--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: ACL; Type: SCHEMA; Schema: -; Owner: w4
--

CREATE SCHEMA "ACL";


ALTER SCHEMA "ACL" OWNER TO w4;

--
-- Name: Accounting; Type: SCHEMA; Schema: -; Owner: w4
--

CREATE SCHEMA "Accounting";


ALTER SCHEMA "Accounting" OWNER TO w4;

--
-- Name: ext; Type: SCHEMA; Schema: -; Owner: w4
--

CREATE SCHEMA ext;


ALTER SCHEMA ext OWNER TO w4;

--
-- Name: ftp; Type: SCHEMA; Schema: -; Owner: w4admin
--

CREATE SCHEMA ftp;


ALTER SCHEMA ftp OWNER TO w4admin;

--
-- Name: reporting; Type: SCHEMA; Schema: -; Owner: w4
--

CREATE SCHEMA reporting;


ALTER SCHEMA reporting OWNER TO w4;

--
-- Name: topology; Type: SCHEMA; Schema: -; Owner: w4
--

CREATE SCHEMA topology;


ALTER SCHEMA topology OWNER TO w4;

--
-- Name: w4_application_functions; Type: SCHEMA; Schema: -; Owner: w4
--

CREATE SCHEMA w4_application_functions;


ALTER SCHEMA w4_application_functions OWNER TO w4;

--
-- Name: w4_automatic_functions; Type: SCHEMA; Schema: -; Owner: w4
--

CREATE SCHEMA w4_automatic_functions;


ALTER SCHEMA w4_automatic_functions OWNER TO w4;

--
-- Name: w4api; Type: SCHEMA; Schema: -; Owner: w4
--

CREATE SCHEMA w4api;


ALTER SCHEMA w4api OWNER TO w4;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

--
-- Name: accounting_export_detail; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE accounting_export_detail AS (
	offer text,
	items numeric,
	transaction_type text,
	amount numeric,
	extended numeric,
	total_items numeric,
	agent_earnings numeric,
	paid_in numeric,
	net numeric
);


ALTER TYPE public.accounting_export_detail OWNER TO w4;

--
-- Name: accounting_export_summary; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE accounting_export_summary AS (
	company_name text,
	company_id bigint,
	contact_name text,
	items numeric,
	amount numeric,
	paid_in numeric,
	net numeric
);


ALTER TYPE public.accounting_export_summary OWNER TO w4;

--
-- Name: addbandarg; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE addbandarg AS (
	index integer,
	pixeltype text,
	initialvalue double precision,
	nodataval double precision
);


ALTER TYPE public.addbandarg OWNER TO w4;

--
-- Name: TYPE addbandarg; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TYPE addbandarg IS 'postgis raster type: A composite type used as input into the ST_AddBand function defining the attributes and initial value of the new band.';


--
-- Name: adv_sum_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE adv_sum_return AS (
	manager_name character varying,
	status character varying,
	description character varying,
	credit_balance numeric,
	credit_limit numeric,
	send_alert_if_credit_is_used character varying,
	credit_alert_value character varying,
	credit_percent_under numeric,
	credit_percent_over numeric,
	next_payment_due_date character varying,
	payment_terms character varying,
	contact_name character varying,
	phone character varying,
	mobile character varying,
	fax character varying,
	address_1 character varying,
	address_2 character varying,
	city character varying,
	region character varying,
	zip character varying,
	country character varying,
	email character varying,
	url character varying,
	note_login_url character varying,
	note_login_username character varying
);


ALTER TYPE public.adv_sum_return OWNER TO w4;

--
-- Name: advertiser_account_info; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE advertiser_account_info AS (
	tracking_url text,
	tracking_username text,
	notes text,
	url text,
	status text
);


ALTER TYPE public.advertiser_account_info OWNER TO w4;

--
-- Name: advertiser_billing_information; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE advertiser_billing_information AS (
	name text,
	credit_limit numeric,
	credit_limit_per text,
	allow_over_limit boolean,
	payment_terms_id bigint
);


ALTER TYPE public.advertiser_billing_information OWNER TO w4;

--
-- Name: advertiser_payment_terms_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE advertiser_payment_terms_list AS (
	id bigint,
	val text
);


ALTER TYPE public.advertiser_payment_terms_list OWNER TO w4;

--
-- Name: advertiser_status; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE advertiser_status AS ENUM (
    'active',
    'pending',
    'inactive',
    'collections'
);


ALTER TYPE public.advertiser_status OWNER TO w4;

--
-- Name: all_entity_typeahead_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE all_entity_typeahead_return AS (
	id bigint,
	val character varying,
	type character varying
);


ALTER TYPE public.all_entity_typeahead_return OWNER TO w4;

--
-- Name: audit_entry; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE audit_entry AS (
	id bigint,
	entity_id bigint,
	user_id bigint,
	user_ip text,
	message text,
	entity_type text,
	entity_type_id integer,
	currency_id integer
);


ALTER TYPE public.audit_entry OWNER TO w4;

--
-- Name: audit_log_demo_entry; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE audit_log_demo_entry AS (
	id bigint,
	user_id bigint,
	user_name text,
	user_type text,
	user_type_id bigint,
	entity_id bigint,
	entity_type text,
	entity_type_id integer,
	action_type text,
	action_type_id integer,
	parameter text,
	parameter_type_id integer,
	message text,
	message_template text,
	message_template_id integer,
	new_value text
);


ALTER TYPE public.audit_log_demo_entry OWNER TO w4;

--
-- Name: campaign_approve; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE campaign_approve AS (
	campaign_id bigint,
	publisher_id bigint,
	status text
);


ALTER TYPE public.campaign_approve OWNER TO w4;

--
-- Name: campaign_recommendation; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE campaign_recommendation AS (
	publisher_id bigint,
	campaign_id bigint,
	recommended boolean
);


ALTER TYPE public.campaign_recommendation OWNER TO w4;

--
-- Name: campaign_traffic_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE campaign_traffic_list AS (
	campaign_id bigint,
	campaign_name text,
	status text,
	advertiser_id bigint,
	advertiser_name text,
	channel_ids text,
	channel_names text,
	category_ids text,
	category_names text,
	expires bpchar,
	is_new text,
	traffic_search text,
	search_advertiser text,
	cap_amount numeric,
	unique_clicks numeric,
	conversions numeric,
	conversion_percentage numeric,
	epc numeric,
	total_in numeric,
	total_out numeric,
	profit_percentage numeric
);


ALTER TYPE public.campaign_traffic_list OWNER TO w4;

--
-- Name: cmp_sum_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE cmp_sum_return AS (
	description character varying,
	manager_name character varying,
	advertiser_name character varying,
	default_payin numeric,
	pay_in_model_description character varying,
	default_payout numeric,
	payout_model_description character varying,
	advertiser_credit_balance numeric,
	advertiser_credit_limit numeric,
	advertiser_send_alert_if_credit_is_used boolean,
	advertiser_credit_alert_value numeric,
	failure_redirect_type character varying,
	failure_redirect_url character varying,
	failure_redirect_campaign_id bigint,
	failure_redirect_campaign_name bigint,
	start_date character varying,
	expiry_date character varying,
	status character varying,
	access_type character varying,
	categories_json text,
	channels_json text,
	geos_json text,
	cookie_duration_time integer,
	cookie_duration_unit_description integer,
	tracking_type character varying,
	tracking_type_secure character varying
);


ALTER TYPE public.cmp_sum_return OWNER TO w4;

--
-- Name: contact; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE contact AS ENUM (
    'primary',
    'billing',
    'account'
);


ALTER TYPE public.contact OWNER TO w4;

--
-- Name: conversion_approve; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE conversion_approve AS (
	conversion_id bigint,
	approve boolean
);


ALTER TYPE public.conversion_approve OWNER TO w4;

--
-- Name: conversion_manual; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE conversion_manual AS ENUM (
    'create',
    'update'
);


ALTER TYPE public.conversion_manual OWNER TO w4;

--
-- Name: conversion_wait_reasons; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE conversion_wait_reasons AS ENUM (
    'advertiserProvidingPayin'
);


ALTER TYPE public.conversion_wait_reasons OWNER TO w4;

--
-- Name: doy_range; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE doy_range AS (
	min_doy bigint,
	max_doy bigint
);


ALTER TYPE public.doy_range OWNER TO w4;

--
-- Name: gender; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE gender AS ENUM (
    'male',
    'female',
    'other'
);


ALTER TYPE public.gender OWNER TO w4;

--
-- Name: geo_search; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE geo_search AS (
	id bigint,
	country text,
	region text,
	city text
);


ALTER TYPE public.geo_search OWNER TO w4;

--
-- Name: pixel_type; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pixel_type AS ENUM (
    'iframe',
    'javascript',
    'image_pixel',
    'post_back'
);


ALTER TYPE public.pixel_type OWNER TO w4;

--
-- Name: pub_campaign_details; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_campaign_details AS (
	campaign_name character varying,
	campaign_id bigint,
	publisher_payout numeric,
	campaign_pays_on character varying,
	campaign_description text,
	restrictions text,
	expiration_date timestamp with time zone,
	categories_json json,
	channels_json json,
	geos_json json,
	campaign_assets_banners_json json,
	campaign_assets_emails_json json,
	campaign_assets_text_links_json json,
	suppression_list_link character varying
);


ALTER TYPE public.pub_campaign_details OWNER TO w4;

--
-- Name: pub_campaign_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_campaign_list AS (
	campaign_name character varying,
	campaign_id bigint,
	payout numeric,
	pays_on character varying,
	geos_json text,
	categories_json text,
	channels_json text,
	categories_ids text,
	channels_ids text,
	country_ids text,
	expiration_date text,
	campaign_description text,
	approval_status text,
	is_new boolean
);


ALTER TYPE public.pub_campaign_list OWNER TO w4;

--
-- Name: pub_campaign_reports_list_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_campaign_reports_list_return AS (
	campaign_name text,
	campaign_id bigint,
	total_clicks numeric,
	unique_clicks numeric,
	conversions numeric,
	average_payout numeric,
	conversion_rate numeric,
	epc numeric,
	earnings numeric,
	expiration_date timestamp with time zone,
	payout numeric,
	pays_on text,
	geos_json text,
	categories_json text,
	channels_json text,
	campaign_description text,
	is_new boolean
);


ALTER TYPE public.pub_campaign_reports_list_return OWNER TO w4;

--
-- Name: pub_group_members; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_group_members AS (
	pub_id bigint,
	grp_id bigint,
	member boolean
);


ALTER TYPE public.pub_group_members OWNER TO w4;

--
-- Name: pub_ids; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_ids AS (
	pub_id bigint
);


ALTER TYPE public.pub_ids OWNER TO w4;

--
-- Name: pub_login_info; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_login_info AS (
	email character varying,
	username character varying
);


ALTER TYPE public.pub_login_info OWNER TO w4;

--
-- Name: pub_override; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_override AS (
	payin numeric,
	payout numeric,
	landing_page text
);


ALTER TYPE public.pub_override OWNER TO w4;

--
-- Name: pub_reports_browser_report_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_reports_browser_report_return AS (
	browser character varying(255),
	total_clicks numeric,
	unique_clicks numeric,
	total_conversions numeric,
	payout numeric,
	campaign_id bigint
);


ALTER TYPE public.pub_reports_browser_report_return OWNER TO w4;

--
-- Name: pub_reports_clicks_overview_report_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_reports_clicks_overview_report_return AS (
	total_clicks numeric,
	unique_clicks numeric,
	foreign_clicks numeric,
	banned_clicks numeric,
	campaign_id bigint
);


ALTER TYPE public.pub_reports_clicks_overview_report_return OWNER TO w4;

--
-- Name: pub_reports_creative_report_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_reports_creative_report_return AS (
	creative_id bigint,
	creative_name character varying(255),
	creative_description text,
	creative_image_id bigint,
	total_clicks numeric,
	unique_clicks numeric,
	total_conversions numeric,
	payout numeric,
	campaign_id bigint,
	campaign_name character varying(255),
	conversion_pct numeric
);


ALTER TYPE public.pub_reports_creative_report_return OWNER TO w4;

--
-- Name: pub_reports_daily_report_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_reports_daily_report_return AS (
	total_clicks numeric,
	unique_clicks numeric,
	total_conversions numeric,
	payout numeric,
	conversion_rate numeric,
	epc numeric,
	average_payout numeric,
	campaign_id bigint,
	report_date timestamp with time zone
);


ALTER TYPE public.pub_reports_daily_report_return OWNER TO w4;

--
-- Name: pub_reports_geo_report_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_reports_geo_report_return AS (
	geo_location text,
	total_clicks numeric,
	unique_clicks numeric,
	total_conversions numeric,
	payout numeric,
	campaign_id bigint
);


ALTER TYPE public.pub_reports_geo_report_return OWNER TO w4;

--
-- Name: pub_reports_platform_report_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_reports_platform_report_return AS (
	platform character varying(255),
	total_clicks numeric,
	unique_clicks numeric,
	total_conversions numeric,
	payout numeric,
	campaign_id bigint
);


ALTER TYPE public.pub_reports_platform_report_return OWNER TO w4;

--
-- Name: pub_reports_referrer_report_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_reports_referrer_report_return AS (
	referrer character varying(255),
	total_clicks numeric,
	unique_clicks numeric,
	total_conversions numeric,
	payout numeric,
	campaign_id bigint
);


ALTER TYPE public.pub_reports_referrer_report_return OWNER TO w4;

--
-- Name: pub_reports_subids_report_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_reports_subids_report_return AS (
	sub_id_1 text,
	sub_id_2 text,
	sub_id_3 text,
	sub_id_4 text,
	total_clicks numeric,
	unique_clicks numeric,
	total_conversions numeric,
	payout numeric,
	campaign_id bigint
);


ALTER TYPE public.pub_reports_subids_report_return OWNER TO w4;

--
-- Name: pub_sum_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pub_sum_return AS (
	manager_id bigint,
	manager_name character varying,
	status character varying,
	payment_threshold numeric,
	debit_balance numeric,
	payment_schedule character varying,
	payment_to character varying,
	tax_id character varying,
	address_1 character varying,
	address_2 character varying,
	city character varying,
	region character varying,
	postal_code character varying,
	country character varying,
	phone character varying,
	mobile character varying,
	fax character varying,
	email character varying,
	website_url character varying,
	messenger_id character varying,
	messenger_type character varying
);


ALTER TYPE public.pub_sum_return OWNER TO w4;

--
-- Name: publisher_billing_information; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE publisher_billing_information AS (
	taxid text,
	payment_to text,
	payment_method text,
	payment_schedule text,
	payment_threshold numeric
);


ALTER TYPE public.publisher_billing_information OWNER TO w4;

--
-- Name: publisher_payout; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE publisher_payout AS (
	publisher_id bigint,
	min_date timestamp with time zone,
	max_date timestamp with time zone
);


ALTER TYPE public.publisher_payout OWNER TO w4;

--
-- Name: pubs_campaign_details_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_campaign_details_list AS (
	total_clicks numeric,
	unique_clicks numeric,
	conversions numeric,
	average_payout numeric,
	conversion_rate numeric,
	epc numeric,
	earnings numeric,
	time_periods text,
	payout_type bigint,
	payin_type bigint
);


ALTER TYPE public.pubs_campaign_details_list OWNER TO w4;

--
-- Name: pubs_campaign_totals_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_campaign_totals_list AS (
	campaign_name character varying,
	campaign_id bigint,
	total_clicks bigint,
	total_conversions bigint,
	total_earned_revenue numeric
);


ALTER TYPE public.pubs_campaign_totals_list OWNER TO w4;

--
-- Name: pubs_campaign_totals_list_wide; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_campaign_totals_list_wide AS (
	campaign_name character varying,
	campaign_id bigint,
	total_clicks bigint,
	total_conversions bigint,
	total_earned_revenue numeric,
	payout numeric,
	categories_json text,
	channels_json text,
	expiration_date text,
	campaign_description text,
	campaign_restrictions text,
	pays_on text,
	is_new boolean
);


ALTER TYPE public.pubs_campaign_totals_list_wide OWNER TO w4;

--
-- Name: pubs_clicks_conversions_geo_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_clicks_conversions_geo_list AS (
	clicks_per_geo bigint,
	conversion_per_geo bigint,
	geo character varying
);


ALTER TYPE public.pubs_clicks_conversions_geo_list OWNER TO w4;

--
-- Name: pubs_clicks_conversions_totals_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_clicks_conversions_totals_list AS (
	total_clicks bigint,
	total_conversions bigint,
	time_periods json
);


ALTER TYPE public.pubs_clicks_conversions_totals_list OWNER TO w4;

--
-- Name: pubs_conversion_rate; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_conversion_rate AS (
	conversion_rate numeric,
	time_periods json
);


ALTER TYPE public.pubs_conversion_rate OWNER TO w4;

--
-- Name: pubs_earnings_total_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_earnings_total_list AS (
	earnings numeric,
	time_periods json
);


ALTER TYPE public.pubs_earnings_total_list OWNER TO w4;

--
-- Name: pubs_information_pane; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_information_pane AS (
	affiliate_manager_name character varying,
	affiliate_manager_email character varying,
	affiliate_manager_phone character varying,
	affiliate_manager_im character varying,
	affiliate_manager_image_id character varying,
	publisher_earnings_today numeric,
	publisher_earnings_yesterday numeric,
	publisher_earnings_last_7_days numeric,
	publisher_earnings_mtd numeric,
	publisher_earnings_ytd numeric,
	publisher_earnings_all_time numeric,
	mtd_rewards_balance numeric
);


ALTER TYPE public.pubs_information_pane OWNER TO w4;

--
-- Name: pubs_short_campaigns_list; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE pubs_short_campaigns_list AS (
	campaign_name character varying,
	campaign_id bigint,
	publisher_payout numeric,
	pays_on character varying
);


ALTER TYPE public.pubs_short_campaigns_list OWNER TO w4;

--
-- Name: reclassarg; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE reclassarg AS (
	nband integer,
	reclassexpr text,
	pixeltype text,
	nodataval double precision
);


ALTER TYPE public.reclassarg OWNER TO w4;

--
-- Name: TYPE reclassarg; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TYPE reclassarg IS 'postgis raster type: A composite type used as input into the ST_Reclass function defining the behavior of reclassification.';


--
-- Name: short_manager; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE short_manager AS (
	manager_id bigint,
	manager_name character varying
);


ALTER TYPE public.short_manager OWNER TO w4;

--
-- Name: status_batch; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE status_batch AS ENUM (
    'pending',
    'processing',
    'complete',
    'failed'
);


ALTER TYPE public.status_batch OWNER TO w4;

--
-- Name: status_entity; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE status_entity AS ENUM (
    'active',
    'pending',
    'inactive'
);


ALTER TYPE public.status_entity OWNER TO w4;

--
-- Name: status_invoice; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE status_invoice AS ENUM (
    'paid',
    'unpaid'
);


ALTER TYPE public.status_invoice OWNER TO w4;

--
-- Name: status_publisher; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE status_publisher AS ENUM (
    'active',
    'suspended',
    'unconfirmed',
    'banned'
);


ALTER TYPE public.status_publisher OWNER TO w4;

--
-- Name: status_request; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE status_request AS ENUM (
    'pending',
    'accepted',
    'denied'
);


ALTER TYPE public.status_request OWNER TO w4;

--
-- Name: status_rollup; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE status_rollup AS ENUM (
    'pending',
    'processing',
    'complete',
    'failed'
);


ALTER TYPE public.status_rollup OWNER TO w4;

--
-- Name: suppression; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE suppression AS ENUM (
    'internal',
    'optizmo',
    'unsubcentral'
);


ALTER TYPE public.suppression OWNER TO w4;

--
-- Name: suppression_format; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE suppression_format AS ENUM (
    'plain',
    'md5'
);


ALTER TYPE public.suppression_format OWNER TO w4;

--
-- Name: suppression_scope; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE suppression_scope AS ENUM (
    'email',
    'domain'
);


ALTER TYPE public.suppression_scope OWNER TO w4;

--
-- Name: typeahead_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE typeahead_return AS (
	id bigint,
	val character varying
);


ALTER TYPE public.typeahead_return OWNER TO w4;

--
-- Name: unionarg; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE unionarg AS (
	nband integer,
	uniontype text
);


ALTER TYPE public.unionarg OWNER TO w4;

--
-- Name: TYPE unionarg; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TYPE unionarg IS 'postgis raster type: A composite type used as input into the ST_Union function defining the bands to be processed and behavior of the UNION operation.';


--
-- Name: upload; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE upload AS (
	id bigint,
	publisher_id bigint,
	file_id text,
	file_name text,
	extension text,
	comments text,
	date_uploaded timestamp with time zone
);


ALTER TYPE public.upload OWNER TO w4;

--
-- Name: user_agent_ids; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE user_agent_ids AS (
	platform_id bigint,
	browser_id bigint,
	features bigint[]
);


ALTER TYPE public.user_agent_ids OWNER TO w4;

--
-- Name: user_return; Type: TYPE; Schema: public; Owner: w4
--

CREATE TYPE user_return AS (
	id bigint,
	email character varying,
	password character varying,
	parent_id bigint,
	manager_id bigint,
	active character varying,
	access character varying,
	ip_address inet,
	last_login timestamp with time zone,
	login_name character varying,
	primary_contact_id bigint,
	billing_contact_id bigint,
	account_contact_id bigint,
	first_name character varying,
	last_name character varying,
	image_id character varying,
	messenger_id character varying,
	messenger_type character varying,
	language character varying,
	country character varying,
	phone character varying,
	manager_first_name character varying,
	manager_last_name character varying
);


ALTER TYPE public.user_return OWNER TO w4;

SET search_path = topology, pg_catalog;

--
-- Name: getfaceedges_returntype; Type: TYPE; Schema: topology; Owner: w4
--

CREATE TYPE getfaceedges_returntype AS (
	sequence integer,
	edge integer
);


ALTER TYPE topology.getfaceedges_returntype OWNER TO w4;

--
-- Name: TYPE getfaceedges_returntype; Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON TYPE getfaceedges_returntype IS 'postgis type: A composite type that consists of a sequence number and edge number. This is the return type for ST_GetFaceEdges';


--
-- Name: topoelement; Type: DOMAIN; Schema: topology; Owner: w4
--

CREATE DOMAIN topoelement AS integer[]
	CONSTRAINT dimensions CHECK (((array_upper(VALUE, 2) IS NULL) AND (array_upper(VALUE, 1) = 2)))
	CONSTRAINT lower_dimension CHECK ((array_lower(VALUE, 1) = 1))
	CONSTRAINT type_range CHECK (((VALUE)[2] > 0));


ALTER DOMAIN topology.topoelement OWNER TO w4;

--
-- Name: DOMAIN topoelement; Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON DOMAIN topoelement IS 'postgis domain: An array of 2 integers generally used to identify a TopoGeometry component.';


--
-- Name: topoelementarray; Type: DOMAIN; Schema: topology; Owner: w4
--

CREATE DOMAIN topoelementarray AS integer[]
	CONSTRAINT dimensions CHECK ((((array_upper(VALUE, 2) IS NOT NULL) AND (array_upper(VALUE, 2) = 2)) AND (array_upper(VALUE, 3) IS NULL)));


ALTER DOMAIN topology.topoelementarray OWNER TO w4;

--
-- Name: DOMAIN topoelementarray; Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON DOMAIN topoelementarray IS 'postgis domain: An array of TopoElement objects';


--
-- Name: topogeometry; Type: TYPE; Schema: topology; Owner: w4
--

CREATE TYPE topogeometry AS (
	topology_id integer,
	layer_id integer,
	id integer,
	type integer
);


ALTER TYPE topology.topogeometry OWNER TO w4;

--
-- Name: TYPE topogeometry; Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON TYPE topogeometry IS 'postgis type: A composite type representing a topologically defined geometry';


--
-- Name: validatetopology_returntype; Type: TYPE; Schema: topology; Owner: w4
--

CREATE TYPE validatetopology_returntype AS (
	error character varying,
	id1 integer,
	id2 integer
);


ALTER TYPE topology.validatetopology_returntype OWNER TO w4;

--
-- Name: TYPE validatetopology_returntype; Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON TYPE validatetopology_returntype IS 'postgis type: A composite type that consists of an error message and id1 and id2 to denote location of error. This is the return type for ValidateTopology';


SET search_path = "ACL", pg_catalog;

--
-- Name: check_controller_access(text, text, text); Type: FUNCTION; Schema: ACL; Owner: w4
--

CREATE FUNCTION check_controller_access(arg_group_name text, arg_controller_name text, arg_action_name text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        PERFORM acgp.id
            FROM "ACL".controller_group_privileges acgp
            LEFT JOIN "ACL".groups ag ON (acgp.group_id = ag.id)
            LEFT JOIN "ACL".controller_resources acr ON (acgp.resource_id = acr.id)
            WHERE ag.name = arg_group_name AND acr.name = arg_controller_name AND (acr.action = arg_action_name OR acr.action = '*');
        IF FOUND THEN
            RETURN TRUE;
        END IF;
        RETURN FALSE;
    END;
$$;


ALTER FUNCTION "ACL".check_controller_access(arg_group_name text, arg_controller_name text, arg_action_name text) OWNER TO w4;

SET search_path = ftp, pg_catalog;

--
-- Name: ftp_user_create(bigint, text, text, text); Type: FUNCTION; Schema: ftp; Owner: w4
--

CREATE FUNCTION ftp_user_create(arg_advertiser_id bigint, arg_password text, arg_salt text, arg_ftp_folder text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_username text := 'a' || arg_advertiser_id::text;
        var_folder text := arg_ftp_folder || '/' || var_username;
    BEGIN
        var_username = 'a' || arg_advertiser_id::text;

        PERFORM * FROM advertisers WHERE id = arg_advertiser_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No advertiser found with the id: %', arg_advertiser_id;
        END IF;
        
        PERFORM * FROM ftp.user WHERE username = var_username;
        IF (FOUND) THEN
            RAISE EXCEPTION 'Ftp user account already exists for this advertiser.';
        END IF;

        INSERT INTO ftp.user
            (username, password, advertiser_id, folder)
            VALUES (var_username, arg_password, arg_advertiser_id, var_folder);

        INSERT INTO ftp.user_salt (username, salt) VALUES (var_username, arg_salt);

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION ftp.ftp_user_create(arg_advertiser_id bigint, arg_password text, arg_salt text, arg_ftp_folder text) OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: addauth(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION addauth(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
	lockid alias for $1;
	okay boolean;
	myrec record;
BEGIN
	-- check to see if table exists
	--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)
	okay := 'f';
	FOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP
		okay := 't';
	END LOOP; 
	IF (okay <> 't') THEN 
		CREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);
			-- this will only work from pgsql7.4 up
			-- ON COMMIT DELETE ROWS;
	END IF;

	--  INSERT INTO mylock VALUES ( $1)
--	EXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||
--		quote_literal(getTransactionID()) || ',' ||
--		quote_literal(lockid) ||')';

	INSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);

	RETURN true::boolean;
END;
$_$;


ALTER FUNCTION public.addauth(text) OWNER TO w4;

--
-- Name: FUNCTION addauth(text); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION addauth(text) IS 'args: auth_token - Add an authorization token to be used in current transaction.';


--
-- Name: checkauth(text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION checkauth(text, text) RETURNS integer
    LANGUAGE sql
    AS $_$ SELECT CheckAuth('', $1, $2) $_$;


ALTER FUNCTION public.checkauth(text, text) OWNER TO w4;

--
-- Name: FUNCTION checkauth(text, text); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION checkauth(text, text) IS 'args: a_table_name, a_key_column_name - Creates trigger on a table to prevent/allow updates and deletes of rows based on authorization token.';


--
-- Name: checkauth(text, text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION checkauth(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
DECLARE
	schema text;
BEGIN
	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	if ( $1 != '' ) THEN
		schema = $1;
	ELSE
		SELECT current_schema() into schema;
	END IF;

	-- TODO: check for an already existing trigger ?

	EXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON ' 
		|| quote_ident(schema) || '.' || quote_ident($2)
		||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('
		|| quote_literal($3) || ')';

	RETURN 0;
END;
$_$;


ALTER FUNCTION public.checkauth(text, text, text) OWNER TO w4;

--
-- Name: FUNCTION checkauth(text, text, text); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION checkauth(text, text, text) IS 'args: a_schema_name, a_table_name, a_key_column_name - Creates trigger on a table to prevent/allow updates and deletes of rows based on authorization token.';


--
-- Name: clean_all_clicks_and_converisons_out(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION clean_all_clicks_and_converisons_out() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	BEGIN
		TRUNCATE engine_clicks_staging;
		TRUNCATE engine_conversions_staging;
		INSERT INTO engine_clicks_staging (SELECT * FROM engine_clicks);
		INSERT INTO engine_conversions_staging (SELECT * FROM engine_conversions);
		TRUNCATE engine_clicks;
		TRUNCATE engine_conversions;
		TRUNCATE reports_clicks_rollup_daily;
		TRUNCATE reports_conversions_rollup_daily;
		TRUNCATE reports_clicks_rollup_hourly;
		TRUNCATE reports_conversions_rollup_hourly;
		TRUNCATE reports_clicks_geo_rollup_daily;
		TRUNCATE reports_conversions_geo_rollup_daily;
		TRUNCATE reports_clicks_wide_rollup_daily;
		TRUNCATE reports_conversions_wide_rollup_daily;
		TRUNCATE reports_clicks_subid_rollup_daily;
		TRUNCATE reports_conversions_subid_rollup_daily;
		TRUNCATE reports_clicks_geo_rollup_hourly;
		TRUNCATE reports_clicks_geo_rollup_monthly;
		TRUNCATE reports_clicks_geo_rollup_yearly;
		TRUNCATE reports_clicks_rollup_monthly;
		TRUNCATE reports_clicks_rollup_yearly;
		TRUNCATE reports_clicks_subid_rollup_hourly;
		TRUNCATE reports_clicks_subid_rollup_monthly;
		TRUNCATE reports_clicks_subid_rollup_yearly;
		TRUNCATE reports_clicks_ua_rollup_daily;
		TRUNCATE reports_clicks_ua_rollup_hourly;
		TRUNCATE reports_clicks_ua_rollup_monthly;
		TRUNCATE reports_clicks_ua_rollup_yearly;
		TRUNCATE reports_clicks_wide_rollup_hourly;
		TRUNCATE reports_clicks_wide_rollup_monthly;
		TRUNCATE reports_clicks_wide_rollup_yearly;
		TRUNCATE reports_conversions_geo_rollup_hourly;
		TRUNCATE reports_conversions_geo_rollup_monthly;
		TRUNCATE reports_conversions_geo_rollup_yearly;
		TRUNCATE reports_conversions_rollup_monthly;
		TRUNCATE reports_conversions_rollup_yearly;
		TRUNCATE reports_conversions_subid_rollup_hourly;
		TRUNCATE reports_conversions_subid_rollup_monthly;
		TRUNCATE reports_conversions_subid_rollup_yearly;
		TRUNCATE reports_conversions_ua_rollup_daily;
		TRUNCATE reports_conversions_ua_rollup_hourly;
		TRUNCATE reports_conversions_ua_rollup_monthly;
		TRUNCATE reports_conversions_ua_rollup_yearly;
		TRUNCATE reports_conversions_wide_rollup_hourly;
		TRUNCATE reports_conversions_wide_rollup_monthly;
		TRUNCATE reports_conversions_wide_rollup_yearly;
		PERFORM * FROM  "Accounting".clear_accounting_data();
		RETURN TRUE;
	END;
$$;


ALTER FUNCTION public.clean_all_clicks_and_converisons_out() OWNER TO w4;

--
-- Name: create_campaign(character varying, bigint, timestamp with time zone, timestamp with time zone, bigint, character varying, text, text, bigint, integer, bigint, boolean, text, text, character varying, numeric, integer, bigint, numeric, integer, bigint, character varying, character varying); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION create_campaign(arg_name character varying, arg_advertiser_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_access_type_id bigint, arg_status character varying, arg_channels_json text, arg_categories_json text, arg_cookie_duration bigint, arg_cookie_duration_type_id integer, arg_tracking_type_id bigint, arg_tracking_type_secure boolean, arg_description_html text, arg_restriction_html text, arg_default_redirect_url character varying, arg_default_payin numeric, arg_payin_type_id integer, arg_payin_model_id bigint, arg_default_payout numeric, arg_payout_type_id integer, arg_payout_model_id bigint, arg_currency_iso_code character varying DEFAULT 'USD'::character varying, arg_currency_display_name character varying DEFAULT 'United States Dollars'::character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        track_type_sec_enum VARCHAR;
        track_type_text VARCHAR;
        ret_val BIGINT;
        split_categories TEXT[];
        split_channels TEXT[];
        x TEXT;
        currency_id bigint;
    BEGIN
        ret_val:=nextval('campaigns_id_seq');
        SELECT INTO track_type_text tracking_type_name FROM campaign_tracking_type_lookup WHERE id=arg_tracking_type_id;
        track_type_sec_enum:='no';
        IF arg_tracking_type_secure THEN
            track_type_sec_enum:='yes';
        END IF;
        SELECT id FROM currency_lookup WHERE iso = arg_currency_iso_code INTO currency_id;
        INSERT INTO campaigns("id","name","user_id","advertiser_id","description","restrictions","default_redirect_url","start_date","expiry_date","access_type","status","cookie_duration_time","cookie_duration_unit","tracking_type_id","tracking_type","tracking_secure","default_payin","default_payout","payout_type","payout_model_id","payin_type","payin_model_id","currency_id") VALUES (ret_val,arg_name,0,arg_advertiser_id,arg_description_html,arg_restriction_html,arg_default_redirect_url,arg_start_date,arg_end_date,arg_access_type_id,arg_status,arg_cookie_duration,arg_cookie_duration_type_id,arg_tracking_type_id,track_type_text,track_type_sec_enum,arg_default_payin,arg_default_payout,arg_payout_type_id,arg_payout_model_id,arg_payin_type_id,arg_payin_model_id,currency_id);
        split_channels:=string_to_array(replace(replace(replace(arg_channels_json,'"',''),']',''),'[',''),',');
        split_categories:=string_to_array(replace(replace(replace(arg_categories_json,'"',''),']',''),'[',''),',');
        -- Write out the channels
        FOREACH x IN ARRAY split_channels LOOP
            INSERT INTO campaign_channels (campaign_id,channel_id) VALUES (ret_val,x::INTEGER);
        END LOOP;
        -- Write out the categories
        FOREACH x IN ARRAY split_categories LOOP
            INSERT INTO campaign_categories (campaign_id,category_id) VALUES (ret_val,x::INTEGER);
        END LOOP;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION public.create_campaign(arg_name character varying, arg_advertiser_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_access_type_id bigint, arg_status character varying, arg_channels_json text, arg_categories_json text, arg_cookie_duration bigint, arg_cookie_duration_type_id integer, arg_tracking_type_id bigint, arg_tracking_type_secure boolean, arg_description_html text, arg_restriction_html text, arg_default_redirect_url character varying, arg_default_payin numeric, arg_payin_type_id integer, arg_payin_model_id bigint, arg_default_payout numeric, arg_payout_type_id integer, arg_payout_model_id bigint, arg_currency_iso_code character varying, arg_currency_display_name character varying) OWNER TO w4;

--
-- Name: delete_publisher_override(bigint); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION delete_publisher_override(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        ret_val=TRUE;
        DELETE FROM publisher_overrides WHERE id=arg_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION public.delete_publisher_override(arg_id bigint) OWNER TO w4;

--
-- Name: disablelongtransactions(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION disablelongtransactions() RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;

BEGIN

	--
	-- Drop all triggers applied by CheckAuth()
	--
	FOR rec IN
		SELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p
		WHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid
	LOOP
		EXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||
			' ON ' || quote_ident(rec.relname);
	END LOOP;

	--
	-- Drop the authorization_table table
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP
		DROP TABLE authorization_table;
	END LOOP;

	--
	-- Drop the authorized_tables view
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP
		DROP VIEW authorized_tables;
	END LOOP;

	RETURN 'Long transactions support disabled';
END;
$$;


ALTER FUNCTION public.disablelongtransactions() OWNER TO w4;

--
-- Name: FUNCTION disablelongtransactions(); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION disablelongtransactions() IS 'Disable long transaction support. This function removes the long transaction support metadata tables, and drops all triggers attached to lock-checked tables.';


--
-- Name: enablelongtransactions(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION enablelongtransactions() RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	"query" text;
	exists bool;
	rec RECORD;

BEGIN

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists
	THEN
		"query" = 'CREATE TABLE authorization_table (
			toid oid, -- table oid
			rid text, -- row id
			expires timestamp,
			authid text
		)';
		EXECUTE "query";
	END IF;

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists THEN
		"query" = 'CREATE VIEW authorized_tables AS ' ||
			'SELECT ' ||
			'n.nspname as schema, ' ||
			'c.relname as table, trim(' ||
			quote_literal(chr(92) || '000') ||
			' from t.tgargs) as id_column ' ||
			'FROM pg_trigger t, pg_class c, pg_proc p ' ||
			', pg_namespace n ' ||
			'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||
			' AND c.relnamespace = n.oid' ||
			' AND t.tgfoid = p.oid and t.tgrelid = c.oid';
		EXECUTE "query";
	END IF;

	RETURN 'Long transactions support enabled';
END;
$$;


ALTER FUNCTION public.enablelongtransactions() OWNER TO w4;

--
-- Name: FUNCTION enablelongtransactions(); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION enablelongtransactions() IS 'Enable long transaction support. This function creates the required metadata tables, needs to be called once before using the other functions in this section. Calling it twice is harmless.';


--
-- Name: engine_clicks_part_trig_func(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION engine_clicks_part_trig_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
        BEGIN 
        IF TG_OP = 'INSERT' THEN 
            IF NEW.created_date >= '2013-12-17 00:00:00-08' AND NEW.created_date < '2013-12-18 00:00:00-08' THEN 
                INSERT INTO public.engine_clicks_p2013_12_17 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-16 00:00:00-08' AND NEW.created_date < '2013-12-17 00:00:00-08' THEN 
                    INSERT INTO public.engine_clicks_p2013_12_16 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-18 00:00:00-08' AND NEW.created_date < '2013-12-19 00:00:00-08' THEN 
                INSERT INTO public.engine_clicks_p2013_12_18 VALUES (NEW.*);
                ELSIF NEW.created_date >= '2013-12-15 00:00:00-08' AND NEW.created_date < '2013-12-16 00:00:00-08' THEN 
                    INSERT INTO public.engine_clicks_p2013_12_15 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-19 00:00:00-08' AND NEW.created_date < '2013-12-20 00:00:00-08' THEN 
                INSERT INTO public.engine_clicks_p2013_12_19 VALUES (NEW.*);
                ELSIF NEW.created_date >= '2013-12-14 00:00:00-08' AND NEW.created_date < '2013-12-15 00:00:00-08' THEN 
                    INSERT INTO public.engine_clicks_p2013_12_14 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-20 00:00:00-08' AND NEW.created_date < '2013-12-21 00:00:00-08' THEN 
                INSERT INTO public.engine_clicks_p2013_12_20 VALUES (NEW.*);
                ELSIF NEW.created_date >= '2013-12-13 00:00:00-08' AND NEW.created_date < '2013-12-14 00:00:00-08' THEN 
                    INSERT INTO public.engine_clicks_p2013_12_13 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-21 00:00:00-08' AND NEW.created_date < '2013-12-22 00:00:00-08' THEN 
                INSERT INTO public.engine_clicks_p2013_12_21 VALUES (NEW.*); 
            ELSE 
                RETURN NEW; 
            END IF; 
        END IF; 
        RETURN NULL; 
        END $$;


ALTER FUNCTION public.engine_clicks_part_trig_func() OWNER TO w4;

--
-- Name: engine_conversions_part_trig_func(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION engine_conversions_part_trig_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
        BEGIN 
        IF TG_OP = 'INSERT' THEN 
            IF NEW.created_date >= '2013-12-17 00:00:00-08' AND NEW.created_date < '2013-12-18 00:00:00-08' THEN 
                INSERT INTO public.engine_conversions_p2013_12_17 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-16 00:00:00-08' AND NEW.created_date < '2013-12-17 00:00:00-08' THEN 
                    INSERT INTO public.engine_conversions_p2013_12_16 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-18 00:00:00-08' AND NEW.created_date < '2013-12-19 00:00:00-08' THEN 
                INSERT INTO public.engine_conversions_p2013_12_18 VALUES (NEW.*);
                ELSIF NEW.created_date >= '2013-12-15 00:00:00-08' AND NEW.created_date < '2013-12-16 00:00:00-08' THEN 
                    INSERT INTO public.engine_conversions_p2013_12_15 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-19 00:00:00-08' AND NEW.created_date < '2013-12-20 00:00:00-08' THEN 
                INSERT INTO public.engine_conversions_p2013_12_19 VALUES (NEW.*);
                ELSIF NEW.created_date >= '2013-12-14 00:00:00-08' AND NEW.created_date < '2013-12-15 00:00:00-08' THEN 
                    INSERT INTO public.engine_conversions_p2013_12_14 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-20 00:00:00-08' AND NEW.created_date < '2013-12-21 00:00:00-08' THEN 
                INSERT INTO public.engine_conversions_p2013_12_20 VALUES (NEW.*);
                ELSIF NEW.created_date >= '2013-12-13 00:00:00-08' AND NEW.created_date < '2013-12-14 00:00:00-08' THEN 
                    INSERT INTO public.engine_conversions_p2013_12_13 VALUES (NEW.*); 
                ELSIF NEW.created_date >= '2013-12-21 00:00:00-08' AND NEW.created_date < '2013-12-22 00:00:00-08' THEN 
                INSERT INTO public.engine_conversions_p2013_12_21 VALUES (NEW.*); 
            ELSE 
                RETURN NEW; 
            END IF; 
        END IF; 
        RETURN NULL; 
        END $$;


ALTER FUNCTION public.engine_conversions_part_trig_func() OWNER TO w4;

--
-- Name: get_advertiser_account_contact(bigint); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION get_advertiser_account_contact(arg_advertiser_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		retval json;
	BEGIN
		SELECT INTO retval row_to_json
		(
			ROW
			(
				ct.id, 
				ct.first_name, 
				ct.last_name, 
				COALESCE(ct.address_1,ad.address_1), 
				COALESCE(ct.address_2,ad.address_2), 
				COALESCE(NULLIF(ct.country_id,0),(SELECT id FROM geo_typeahead_countries WHERE country=ad.country)),
				COALESCE
				(
					NULLIF(ct.region_id,0),
					(
						SELECT id 
						FROM geo_typeahead_region 
						WHERE ascii_name=ad."state" AND admin1_code=
						(
							SELECT iso FROM geo_typeahead_countries WHERE country=ad.country
						)
					)
				), 
				COALESCE
				(
					NULLIF(ct.city_id,0),
					(
						SELECT id FROM geo_typeahead_cities WHERE place_name_ascii=ad.city AND country_code=
						(
							SELECT iso FROM geo_typeahead_countries WHERE country=ad.country
						)
					)
				), 
				ct.country_name,
				ct.region_name,
				COALESCE(ct.city_name,ad.city), 
				COALESCE(ct.postal_code,ad.zip), 
				COALESCE(ct.messenger_name,ad.messenger_id), 
				ct.messenger_type, 
				COALESCE(ct.primary_phone,ad.phone), 
				COALESCE(ct.secondary_phone,ad.mobile), 
				COALESCE(ct.fax,ad.fax), 
				COALESCE(ct.email_address,ad.email)
			)::vw_contacts
		)
		FROM advertisers ad 
		LEFT JOIN vw_contacts ct ON ct.id = ad.account_contact_id
		WHERE ad.id = arg_advertiser_id;
		
		RETURN retval;
	END;
$$;


ALTER FUNCTION public.get_advertiser_account_contact(arg_advertiser_id bigint) OWNER TO w4;

--
-- Name: get_advertiser_billing_information(bigint); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION get_advertiser_billing_information(arg_advertiser_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
    BEGIN
    
	SELECT INTO retval
		row_to_json
		(
			ROW
			(
                                "name",
				credit_limit,
                                credit_limit_per,
                                CASE WHEN allow_over_limit = 'yes' THEN true ELSE false END,
                                payment_terms_id
			)::advertiser_billing_information
		)
	FROM advertisers 
	WHERE id = arg_advertiser_id;
	
        RETURN retval;
    END;
$$;


ALTER FUNCTION public.get_advertiser_billing_information(arg_advertiser_id bigint) OWNER TO w4;

--
-- Name: get_proj4_from_srid(integer); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;


ALTER FUNCTION public.get_proj4_from_srid(integer) OWNER TO w4;

--
-- Name: lockrow(text, text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION lockrow(text, text, text) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow(current_schema(), $1, $2, $3, now()::timestamp+'1:00'); $_$;


ALTER FUNCTION public.lockrow(text, text, text) OWNER TO w4;

--
-- Name: FUNCTION lockrow(text, text, text); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION lockrow(text, text, text) IS 'args: a_table_name, a_row_key, an_auth_token - Set lock/authorization for specific row in table';


--
-- Name: lockrow(text, text, text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION lockrow(text, text, text, text) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow($1, $2, $3, $4, now()::timestamp+'1:00'); $_$;


ALTER FUNCTION public.lockrow(text, text, text, text) OWNER TO w4;

--
-- Name: lockrow(text, text, text, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION lockrow(text, text, text, timestamp without time zone) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT LockRow(current_schema(), $1, $2, $3, $4); $_$;


ALTER FUNCTION public.lockrow(text, text, text, timestamp without time zone) OWNER TO w4;

--
-- Name: FUNCTION lockrow(text, text, text, timestamp without time zone); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION lockrow(text, text, text, timestamp without time zone) IS 'args: a_table_name, a_row_key, an_auth_token, expire_dt - Set lock/authorization for specific row in table';


--
-- Name: lockrow(text, text, text, text, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION lockrow(text, text, text, text, timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	myschema alias for $1;
	mytable alias for $2;
	myrid   alias for $3;
	authid alias for $4;
	expires alias for $5;
	ret int;
	mytoid oid;
	myrec RECORD;
	
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table WHERE expires < now()'; 

	SELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n
		WHERE c.relname = mytable
		AND c.relnamespace = n.oid
		AND n.nspname = myschema;

	-- RAISE NOTICE 'toid: %', mytoid;

	FOR myrec IN SELECT * FROM authorization_table WHERE 
		toid = mytoid AND rid = myrid
	LOOP
		IF myrec.authid != authid THEN
			RETURN 0;
		ELSE
			RETURN 1;
		END IF;
	END LOOP;

	EXECUTE 'INSERT INTO authorization_table VALUES ('||
		quote_literal(mytoid::text)||','||quote_literal(myrid)||
		','||quote_literal(expires::text)||
		','||quote_literal(authid) ||')';

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$_$;


ALTER FUNCTION public.lockrow(text, text, text, text, timestamp without time zone) OWNER TO w4;

--
-- Name: FUNCTION lockrow(text, text, text, text, timestamp without time zone); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION lockrow(text, text, text, text, timestamp without time zone) IS 'args: a_schema_name, a_table_name, a_row_key, an_auth_token, expire_dt - Set lock/authorization for specific row in table';


--
-- Name: longtransactionsenabled(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;


ALTER FUNCTION public.longtransactionsenabled() OWNER TO w4;

--
-- Name: make_doy(anynonarray); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION make_doy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		doy INTEGER;
	BEGIN
		SELECT INTO doy CAST(to_char(dt::TIMESTAMP,'YYYYmmdd'::TEXT) as INTEGER);
		RETURN doy;
	END
$$;


ALTER FUNCTION public.make_doy(dt anynonarray) OWNER TO w4;

--
-- Name: make_hoy(anynonarray); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION make_hoy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		hoy INTEGER;
	BEGIN
		SELECT INTO hoy CAST(to_char(dt::TIMESTAMP,'YYYYmmddHH24'::TEXT) as INTEGER);
		RETURN hoy;
	END
$$;


ALTER FUNCTION public.make_hoy(dt anynonarray) OWNER TO w4;

--
-- Name: make_moy(anynonarray); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION make_moy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		moy INTEGER;
	BEGIN
		SELECT INTO moy CAST(to_char(dt::TIMESTAMP,'YYYYmm'::TEXT) as INTEGER);
		RETURN moy;
	END
$$;


ALTER FUNCTION public.make_moy(dt anynonarray) OWNER TO w4;

--
-- Name: make_qoy(anynonarray); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION make_qoy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		qoy INTEGER;
	BEGIN
		SELECT INTO qoy CAST(to_char(dt::TIMESTAMP,'YYYYQ'::TEXT) as INTEGER);
		RETURN qoy;
	END
$$;


ALTER FUNCTION public.make_qoy(dt anynonarray) OWNER TO w4;

--
-- Name: make_woy(anynonarray); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION make_woy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		woy INTEGER;
	BEGIN
		SELECT INTO woy CAST(to_char(dt::TIMESTAMP,'YYYYWW'::TEXT) as INTEGER);
		RETURN woy;
	END
$$;


ALTER FUNCTION public.make_woy(dt anynonarray) OWNER TO w4;

--
-- Name: make_y(anynonarray); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION make_y(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		y INTEGER;
	BEGIN
		SELECT INTO y CAST(to_char(dt::TIMESTAMP,'YYYY'::TEXT) as INTEGER);
		RETURN y;
	END
$$;


ALTER FUNCTION public.make_y(dt anynonarray) OWNER TO w4;

--
-- Name: parse_flat_json(anyelement); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION parse_flat_json(json_json anyelement) RETURNS anyarray
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
    BEGIN
        RETURN string_to_array(replace(replace(replace(json_json::TEXT,'"',''),']',''),'[',''),',');
    END;
$$;


ALTER FUNCTION public.parse_flat_json(json_json anyelement) OWNER TO w4;

--
-- Name: populate_geometry_columns(boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION populate_geometry_columns(use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	inserted    integer;
	oldcount    integer;
	probed      integer;
	stale       integer;
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;

BEGIN
	SELECT count(*) INTO oldcount FROM geometry_columns;
	inserted := 0;

	-- Count the number of geometry columns in all tables and views
	SELECT count(DISTINCT c.oid) INTO probed
	FROM pg_class c,
		 pg_attribute a,
		 pg_type t,
		 pg_namespace n
	WHERE (c.relkind = 'r' OR c.relkind = 'v')
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns' ;

	-- Iterate through all non-dropped geometry columns
	RAISE DEBUG 'Processing Tables.....';

	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns' 
	LOOP

		inserted := inserted + populate_geometry_columns(gcs.oid, use_typmod);
	END LOOP;

	IF oldcount > inserted THEN
	    stale = oldcount-inserted;
	ELSE
	    stale = 0;
	END IF;

	RETURN 'probed:' ||probed|| ' inserted:'||inserted;
END

$$;


ALTER FUNCTION public.populate_geometry_columns(use_typmod boolean) OWNER TO w4;

--
-- Name: FUNCTION populate_geometry_columns(use_typmod boolean); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION populate_geometry_columns(use_typmod boolean) IS 'args: use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints This ensures they will be registered correctly in geometry_columns view. By default will convert all geometry columns with no type modifier to ones with type modifiers. To get old behavior set use_typmod=false';


--
-- Name: populate_geometry_columns(oid, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION populate_geometry_columns(tbl_oid oid, use_typmod boolean DEFAULT true) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	gcs         RECORD;
	gc          RECORD;
	gc_old      RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;
	inserted    integer;
	constraint_successful boolean := false;

BEGIN
	inserted := 0;

	-- Iterate through all geometry columns in this table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP

        RAISE DEBUG 'Processing column %.%.%', gcs.nspname, gcs.relname, gcs.attname;
    
        gc_is_valid := true;
        -- Find the srid, coord_dimension, and type of current geometry
        -- in geometry_columns -- which is now a view
        
        SELECT type, srid, coord_dimension INTO gc_old 
            FROM geometry_columns 
            WHERE f_table_schema = gcs.nspname AND f_table_name = gcs.relname AND f_geometry_column = gcs.attname; 
            
        IF upper(gc_old.type) = 'GEOMETRY' THEN
        -- This is an unconstrained geometry we need to do something
        -- We need to figure out what to set the type by inspecting the data
            EXECUTE 'SELECT st_srid(' || quote_ident(gcs.attname) || ') As srid, GeometryType(' || quote_ident(gcs.attname) || ') As type, ST_NDims(' || quote_ident(gcs.attname) || ') As dims ' ||
                     ' FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || 
                     ' WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1;'
                INTO gc;
            IF gc IS NULL THEN -- there is no data so we can not determine geometry type
            	RAISE WARNING 'No data in table %.%, so no information to determine geometry type and srid', gcs.nspname, gcs.relname;
            	RETURN 0;
            END IF;
            gsrid := gc.srid; gtype := gc.type; gndims := gc.dims;
            	
            IF use_typmod THEN
                BEGIN
                    EXECUTE 'ALTER TABLE ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || ' ALTER COLUMN ' || quote_ident(gcs.attname) || 
                        ' TYPE geometry(' || postgis_type_name(gtype, gndims, true) || ', ' || gsrid::text  || ') ';
                    inserted := inserted + 1;
                EXCEPTION
                        WHEN invalid_parameter_value OR feature_not_supported THEN
                        RAISE WARNING 'Could not convert ''%'' in ''%.%'' to use typmod with srid %, type %: %', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), gsrid, postgis_type_name(gtype, gndims, true), SQLERRM;
                            gc_is_valid := false;
                END;
                
            ELSE
                -- Try to apply srid check to column
            	constraint_successful = false;
                IF (gsrid > 0 AND postgis_constraint_srid(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
                    BEGIN
                        EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || 
                                 ' ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) || 
                                 ' CHECK (st_srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';
                        constraint_successful := true;
                    EXCEPTION
                        WHEN check_violation THEN
                            RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;
                            gc_is_valid := false;
                    END;
                END IF;
                
                -- Try to apply ndims check to column
                IF (gndims IS NOT NULL AND postgis_constraint_dims(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
                    BEGIN
                        EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
                                 ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '
                                 CHECK (st_ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';
                        constraint_successful := true;
                    EXCEPTION
                        WHEN check_violation THEN
                            RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;
                            gc_is_valid := false;
                    END;
                END IF;
    
                -- Try to apply geometrytype check to column
                IF (gtype IS NOT NULL AND postgis_constraint_type(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
                    BEGIN
                        EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
                        ADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '
                        CHECK ((geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ') OR (' || quote_ident(gcs.attname) || ' IS NULL))';
                        constraint_successful := true;
                    EXCEPTION
                        WHEN check_violation THEN
                            -- No geometry check can be applied. This column contains a number of geometry types.
                            RAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);
                    END;
                END IF;
                 --only count if we were successful in applying at least one constraint
                IF constraint_successful THEN
                	inserted := inserted + 1;
                END IF;
            END IF;	        
	    END IF;

	END LOOP;

	RETURN inserted;
END

$$;


ALTER FUNCTION public.populate_geometry_columns(tbl_oid oid, use_typmod boolean) OWNER TO w4;

--
-- Name: FUNCTION populate_geometry_columns(tbl_oid oid, use_typmod boolean); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION populate_geometry_columns(tbl_oid oid, use_typmod boolean) IS 'args: relation_oid, use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints This ensures they will be registered correctly in geometry_columns view. By default will convert all geometry columns with no type modifier to ones with type modifiers. To get old behavior set use_typmod=false';


--
-- Name: postgis_constraint_dims(text, text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
SELECT  replace(split_part(s.consrc, ' = ', 2), ')', '')::integer
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%ndims(% = %';
$_$;


ALTER FUNCTION public.postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) OWNER TO w4;

--
-- Name: postgis_constraint_srid(text, text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')::integer
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%srid(% = %';
$_$;


ALTER FUNCTION public.postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) OWNER TO w4;

--
-- Name: postgis_constraint_type(text, text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) RETURNS character varying
    LANGUAGE sql STABLE STRICT
    AS $_$
SELECT  replace(split_part(s.consrc, '''', 2), ')', '')::varchar		
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%geometrytype(% = %';
$_$;


ALTER FUNCTION public.postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) OWNER TO w4;

--
-- Name: postgis_full_version(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	svnver text;
	projver text;
	geosver text;
	sfcgalver text;
	cgalver text;
	gdalver text;
	libxmlver text;
	dbproc text;
	relproc text;
	fullver text;
	rast_lib_ver text;
	rast_scr_ver text;
	topo_scr_ver text;
	json_lib_ver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libjson_version() INTO json_lib_ver;
	BEGIN
		SELECT postgis_gdal_version() INTO gdalver;
	EXCEPTION
		WHEN undefined_function THEN
			gdalver := NULL;
			RAISE NOTICE 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';
	END;
	BEGIN
		SELECT postgis_sfcgal_version() INTO sfcgalver;
	EXCEPTION
		WHEN undefined_function THEN
			sfcgalver := NULL;
	END;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;
	select postgis_svn_version() INTO svnver;
	BEGIN
		SELECT postgis_topology_scripts_installed() INTO topo_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			topo_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_scripts_installed() INTO rast_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_lib_version() INTO rast_lib_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_lib_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	fullver = 'POSTGIS="' || libver;

	IF  svnver IS NOT NULL THEN
		fullver = fullver || ' r' || svnver;
	END IF;

	fullver = fullver || '"';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS="' || geosver || '"';
	END IF;

	IF  sfcgalver IS NOT NULL THEN
		fullver = fullver || ' SFCGAL="' || sfcgalver || '"';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ="' || projver || '"';
	END IF;

	IF  gdalver IS NOT NULL THEN
		fullver = fullver || ' GDAL="' || gdalver || '"';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML="' || libxmlver || '"';
	END IF;

	IF json_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBJSON="' || json_lib_ver || '"';
	END IF;

	-- fullver = fullver || ' DBPROC="' || dbproc || '"';
	-- fullver = fullver || ' RELPROC="' || relproc || '"';

	IF dbproc != relproc THEN
		fullver = fullver || ' (core procs from "' || dbproc || '" need upgrade)';
	END IF;

	IF topo_scr_ver IS NOT NULL THEN
		fullver = fullver || ' TOPOLOGY';
		IF topo_scr_ver != relproc THEN
			fullver = fullver || ' (topology procs from "' || topo_scr_ver || '" need upgrade)';
		END IF;
	END IF;

	IF rast_lib_ver IS NOT NULL THEN
		fullver = fullver || ' RASTER';
		IF rast_lib_ver != relproc THEN
			fullver = fullver || ' (raster lib from "' || rast_lib_ver || '" need upgrade)';
		END IF;
	END IF;

	IF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN
		fullver = fullver || ' (raster procs from "' || rast_scr_ver || '" need upgrade)';
	END IF;

	RETURN fullver;
END
$$;


ALTER FUNCTION public.postgis_full_version() OWNER TO w4;

--
-- Name: FUNCTION postgis_full_version(); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION postgis_full_version() IS 'Reports full postgis version and build configuration infos.';


--
-- Name: postgis_raster_scripts_installed(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_raster_scripts_installed() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$ SELECT '2.1.0'::text || ' r' || 11822::text AS version $$;


ALTER FUNCTION public.postgis_raster_scripts_installed() OWNER TO w4;

--
-- Name: postgis_scripts_build_date(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_scripts_build_date() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$SELECT '2013-10-08 13:28:11'::text AS version$$;


ALTER FUNCTION public.postgis_scripts_build_date() OWNER TO w4;

--
-- Name: FUNCTION postgis_scripts_build_date(); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION postgis_scripts_build_date() IS 'Returns build date of the PostGIS scripts.';


--
-- Name: postgis_scripts_installed(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_scripts_installed() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$ SELECT '2.1.0'::text || ' r' || 11822::text AS version $$;


ALTER FUNCTION public.postgis_scripts_installed() OWNER TO w4;

--
-- Name: FUNCTION postgis_scripts_installed(); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION postgis_scripts_installed() IS 'Returns version of the postgis scripts installed in this database.';


--
-- Name: postgis_topology_scripts_installed(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_topology_scripts_installed() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$ SELECT '2.1.0'::text || ' r' || 11822::text AS version $$;


ALTER FUNCTION public.postgis_topology_scripts_installed() OWNER TO w4;

--
-- Name: postgis_type_name(character varying, integer, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean DEFAULT true) RETURNS character varying
    LANGUAGE sql IMMUTABLE STRICT COST 200
    AS $_$
 SELECT CASE WHEN $3 THEN new_name ELSE old_name END As geomname
 	FROM 
 	( VALUES
 		 ('GEOMETRY', 'Geometry', 2) ,
 		 	('GEOMETRY', 'GeometryZ', 3) ,
 		 	('GEOMETRY', 'GeometryZM', 4) ,
			('GEOMETRYCOLLECTION', 'GeometryCollection', 2) ,
			('GEOMETRYCOLLECTION', 'GeometryCollectionZ', 3) ,
			('GEOMETRYCOLLECTIONM', 'GeometryCollectionM', 3) ,
			('GEOMETRYCOLLECTION', 'GeometryCollectionZM', 4) ,
			
			('POINT', 'Point',2) ,
			('POINTM','PointM',3) ,
			('POINT', 'PointZ',3) ,
			('POINT', 'PointZM',4) ,
			
			('MULTIPOINT','MultiPoint',2) ,
			('MULTIPOINT','MultiPointZ',3) ,
			('MULTIPOINTM','MultiPointM',3) ,
			('MULTIPOINT','MultiPointZM',4) ,
			
			('POLYGON', 'Polygon',2) ,
			('POLYGON', 'PolygonZ',3) ,
			('POLYGONM', 'PolygonM',3) ,
			('POLYGON', 'PolygonZM',4) ,
			
			('MULTIPOLYGON', 'MultiPolygon',2) ,
			('MULTIPOLYGON', 'MultiPolygonZ',3) ,
			('MULTIPOLYGONM', 'MultiPolygonM',3) ,
			('MULTIPOLYGON', 'MultiPolygonZM',4) ,
			
			('MULTILINESTRING', 'MultiLineString',2) ,
			('MULTILINESTRING', 'MultiLineStringZ',3) ,
			('MULTILINESTRINGM', 'MultiLineStringM',3) ,
			('MULTILINESTRING', 'MultiLineStringZM',4) ,
			
			('LINESTRING', 'LineString',2) ,
			('LINESTRING', 'LineStringZ',3) ,
			('LINESTRINGM', 'LineStringM',3) ,
			('LINESTRING', 'LineStringZM',4) ,
			
			('CIRCULARSTRING', 'CircularString',2) ,
			('CIRCULARSTRING', 'CircularStringZ',3) ,
			('CIRCULARSTRINGM', 'CircularStringM',3) ,
			('CIRCULARSTRING', 'CircularStringZM',4) ,
			
			('COMPOUNDCURVE', 'CompoundCurve',2) ,
			('COMPOUNDCURVE', 'CompoundCurveZ',3) ,
			('COMPOUNDCURVEM', 'CompoundCurveM',3) ,
			('COMPOUNDCURVE', 'CompoundCurveZM',4) ,
			
			('CURVEPOLYGON', 'CurvePolygon',2) ,
			('CURVEPOLYGON', 'CurvePolygonZ',3) ,
			('CURVEPOLYGONM', 'CurvePolygonM',3) ,
			('CURVEPOLYGON', 'CurvePolygonZM',4) ,
			
			('MULTICURVE', 'MultiCurve',2 ) ,
			('MULTICURVE', 'MultiCurveZ',3 ) ,
			('MULTICURVEM', 'MultiCurveM',3 ) ,
			('MULTICURVE', 'MultiCurveZM',4 ) ,
			
			('MULTISURFACE', 'MultiSurface', 2) ,
			('MULTISURFACE', 'MultiSurfaceZ', 3) ,
			('MULTISURFACEM', 'MultiSurfaceM', 3) ,
			('MULTISURFACE', 'MultiSurfaceZM', 4) ,
			
			('POLYHEDRALSURFACE', 'PolyhedralSurface',2) ,
			('POLYHEDRALSURFACE', 'PolyhedralSurfaceZ',3) ,
			('POLYHEDRALSURFACEM', 'PolyhedralSurfaceM',3) ,
			('POLYHEDRALSURFACE', 'PolyhedralSurfaceZM',4) ,
			
			('TRIANGLE', 'Triangle',2) ,
			('TRIANGLE', 'TriangleZ',3) ,
			('TRIANGLEM', 'TriangleM',3) ,
			('TRIANGLE', 'TriangleZM',4) ,

			('TIN', 'Tin', 2),
			('TIN', 'TinZ', 3),
			('TIN', 'TinM', 3),
			('TIN', 'TinZM', 4) )
			 As g(old_name, new_name, coord_dimension)
		WHERE (upper(old_name) = upper($1) OR upper(new_name) = upper($1))
			AND coord_dimension = $2;
$_$;


ALTER FUNCTION public.postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean) OWNER TO w4;

--
-- Name: replace_remote_null_id(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION replace_remote_null_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        seq_name VARCHAR;
    BEGIN
        IF (NEW.id IS NULL) THEN
            seq_name := format('%s_id_seq',TG_TABLE_NAME);
            NEW.id := nextval(seq_name::regclass);
        END IF;   
        RETURN NEW;        
    END
$$;


ALTER FUNCTION public.replace_remote_null_id() OWNER TO w4;

--
-- Name: search_advertisers(character varying, bigint); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION search_advertisers(arg_search character varying, arg_limit_number bigint) RETURNS SETOF typeahead_return
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val typeahead_return;
        ctr BIGINT;
        ids BIGINT[];
        qry TEXT;
    BEGIN
        ids:=array_append(ids,-1::BIGINT);
        ctr:=0;

        -- Look for an EXACT match
        FOR ret_val IN ( SELECT "id", "name" FROM advertisers WHERE "name" ILIKE arg_search OR "id"::VARCHAR = arg_search ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        
        -- Look for stuff that starts with
        FOR ret_val IN ( SELECT "id", "name" FROM advertisers WHERE ( NOT id = ANY( ids ) ) AND "name" ILIKE arg_search || '%' OR "id"::VARCHAR ILIKE arg_search || '%' ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;

        -- Look for stuff that ends with
        FOR ret_val IN ( SELECT "id", "name" FROM advertisers WHERE ( NOT id = ANY( ids ) ) AND "name" ILIKE '%' || arg_search OR "id"::VARCHAR ILIKE '%' || arg_search ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        
        -- Look for stuff that contains
        FOR ret_val IN ( SELECT "id", "name" FROM advertisers WHERE ( NOT id = ANY( ids ) ) AND "name" ILIKE '%' || arg_search || '%' OR "id"::VARCHAR ILIKE '%' || arg_search || '%' ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        RETURN;
    END;
$$;


ALTER FUNCTION public.search_advertisers(arg_search character varying, arg_limit_number bigint) OWNER TO w4;

--
-- Name: search_all_entities(character varying, bigint); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION search_all_entities(arg_search character varying, arg_limit_number bigint) RETURNS SETOF all_entity_typeahead_return
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
    BEGIN        
        RETURN	QUERY SELECT *, 'Advertiser'::VARCHAR AS "type" FROM search_advertisers( arg_search, arg_limit_number / 3 ) 
		UNION SELECT *, 'Campaign'::VARCHAR   AS "type" FROM search_campaigns( arg_search, arg_limit_number / 3 )
		UNION SELECT *, 'Publisher'::VARCHAR  AS "type" FROM search_publishers( arg_search, arg_limit_number / 3 ); --  ORDER BY 3;
        END;
$$;


ALTER FUNCTION public.search_all_entities(arg_search character varying, arg_limit_number bigint) OWNER TO w4;

--
-- Name: search_campaigns(character varying, bigint); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION search_campaigns(arg_search character varying, arg_limit_number bigint) RETURNS SETOF typeahead_return
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val typeahead_return;
        ctr BIGINT;
        ids BIGINT[];
        qry TEXT;
    BEGIN
        ids:=array_append(ids,-1::BIGINT);
        ctr:=0;

        -- Look for an EXACT match
        FOR ret_val IN ( SELECT "id", "name" FROM campaigns WHERE "name" ILIKE arg_search OR "id"::VARCHAR = arg_search ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        
        -- Look for stuff that starts with
        FOR ret_val IN ( SELECT "id", "name" FROM campaigns WHERE ( NOT id = ANY( ids ) ) AND "name" ILIKE arg_search || '%' OR "id"::VARCHAR ILIKE arg_search || '%' ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;

        -- Look for stuff that ends with
        FOR ret_val IN ( SELECT "id", "name" FROM campaigns WHERE ( NOT id = ANY( ids ) ) AND "name" ILIKE '%' || arg_search OR "id"::VARCHAR ILIKE '%' || arg_search ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        
        -- Look for stuff that contains
        FOR ret_val IN ( SELECT "id", "name" FROM campaigns WHERE ( NOT id = ANY( ids ) ) AND "name" ILIKE '%' || arg_search || '%' OR "id"::VARCHAR ILIKE '%' || arg_search || '%' ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        RETURN;
    END;
$$;


ALTER FUNCTION public.search_campaigns(arg_search character varying, arg_limit_number bigint) OWNER TO w4;

--
-- Name: search_city(text, bigint, bigint, integer); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION search_city(arg_city_search text, arg_region_id bigint, arg_country_id bigint, arg_limit_number integer) RETURNS TABLE(id bigint, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        wc TEXT;
        countrycode VARCHAR;
        regioncode VARCHAR;
    BEGIN
        arg_city_search:=replace(arg_city_search,' ','%');
        IF arg_region_id <> -1 AND arg_region_id IS NOT NULL THEN
            SELECT INTO regioncode local_name FROM geo_typeahead_region WHERE geo_typeahead_region.id=arg_region_id;
            IF arg_country_id <> -1 AND arg_country_id IS NOT NULL THEN
                SELECT INTO countrycode iso FROM geo_typeahead_countries WHERE geo_typeahead_countries.id=arg_country_id;
                wc:=' AND country_code=' || quote_literal( countrycode ) || ' AND admin1_code=' || quote_literal( regioncode );
            ELSE
                wc:=' AND admin1_code=' || quote_literal( regioncode );
            END IF;
        ELSE
            IF arg_country_id <> -1 AND arg_country_id IS NOT NULL THEN
                SELECT INTO countrycode iso FROM geo_typeahead_countries WHERE geo_typeahead_countries.id=arg_country_id;
                wc:=' AND country_code=' || quote_literal( countrycode );
            ELSE
                wc:='';
            END IF;            
        END IF;
        RAISE INFO 'FUCKING WHERE CLAUSE [%]',wc;
        RETURN QUERY EXECUTE $$SELECT XxX.id::BIGINT, XxX.val::TEXT FROM (SELECT id, place_name_ascii AS val FROM geo_typeahead_cities WHERE search_string ~* '^$$ || arg_city_search || $$%' $$ || wc || $$ UNION SELECT id, place_name_ascii AS val FROM geo_typeahead_cities WHERE search_string ILIKE '%$$ || arg_city_search || $$%' $$ || wc || $$ LIMIT $$ || arg_limit_number || $$)XxX;$$;
    END;
$_$;


ALTER FUNCTION public.search_city(arg_city_search text, arg_region_id bigint, arg_country_id bigint, arg_limit_number integer) OWNER TO w4;

--
-- Name: search_publishers(character varying, bigint); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION search_publishers(arg_search character varying DEFAULT NULL::character varying, arg_limit_number bigint DEFAULT (5)::bigint) RETURNS SETOF typeahead_return
    LANGUAGE plpgsql
    AS $$
begin
	----------------------- this is stupid -____-
	RETURN QUERY SELECT * FROM w4_application_functions.search_publishers ( arg_search := arg_search::text, arg_limit_number := arg_limit_number);
  END;
$$;


ALTER FUNCTION public.search_publishers(arg_search character varying, arg_limit_number bigint) OWNER TO w4;

--
-- Name: set_publisher_contact(bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION set_publisher_contact(arg_publisher_id bigint, arg_contact_id bigint, arg_is_primary boolean DEFAULT false, arg_is_billing boolean DEFAULT false) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ct RECORD;
	BEGIN
        IF arg_is_primary THEN
            SELECT INTO ct
                c.id,
                c.first_name,
                c.last_name,
                c.address_1,
                c.address_2,
                c.country_id,
                c.region_id,
                c.city_id,
                c.city_name,
                c.postal_code,
                c.messenger_name,
                im.description AS messenger_type,
                c.primary_phone,
                c.secondary_phone,
                c.fax,
                c.email_address,
                c.is_primary,
                c.is_billing
            FROM contacts c
            LEFT JOIN im_types im ON ct.messenger_type = im.id
            WHERE id=arg_contact_id;
            UPDATE users SET primary_contact_id=arg_contact_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET first_name=ct.first_name, last_name=ct.last_name, address_1=ct.address_1, address_2=ct.address_2, city=ct.city_name, "state"=(SELECT region FROM geo_typeahead_region WHERE id=ct.region_id), country=(SELECT country FROM geo_typeahead_countries WHERE id=ct.country_id), zip=ct.postal_code, phone=ct.primary_phone, cell=ct.secondary_phone, messenger_id=ct.messenger_name, messenger_type=ct.messenger_type, fax=ct.fax WHERE user_id=arg_publisher_id;
        END IF;
        IF arg_is_billing THEN
            SELECT INTO ct
                c.id,
                c.first_name,
                c.last_name,
                c.address_1,
                c.address_2,
                c.country_id,
                c.region_id,
                c.city_id,
                c.city_name,
                c.postal_code,
                c.messenger_name,
                im.description AS messenger_type,
                c.primary_phone,
                c.secondary_phone,
                c.fax,
                c.email_address,
                c.is_primary,
                c.is_billing
            FROM contacts c
            LEFT JOIN im_types im ON ct.messenger_type = im.id
            WHERE id=arg_contact_id;
            UPDATE users SET billing_contact_id=arg_contact_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET payment_address_1=arg_address_1, payment_address_2=arg_address_2, payment_city=arg_city_name, payment_region=(SELECT region FROM geo_typeahead_region WHERE id=arg_region_id), payment_postal_code=arg_postal_code, payment_country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id) WHERE user_id=arg_publisher_id;
        END IF;        
	    PERFORM * FROM publisher_contact WHERE publisher_id=arg_publisher_id AND contact_id=arg_contact_id;
	    IF NOT FOUND THEN
	        INSERT INTO publisher_contact ("publisher_id","contact_id") VALUES (arg_publisher_id,arg_contact_id);
	    END IF;
	    RETURN arg_contact_id;
	END;
$$;


ALTER FUNCTION public.set_publisher_contact(arg_publisher_id bigint, arg_contact_id bigint, arg_is_primary boolean, arg_is_billing boolean) OWNER TO w4;

--
-- Name: st_approxcount(text, text, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxcount(rastertable text, rastercolumn text, sample_percent double precision) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, 1, TRUE, $3) $_$;


ALTER FUNCTION public.st_approxcount(rastertable text, rastercolumn text, sample_percent double precision) OWNER TO w4;

--
-- Name: st_approxcount(text, text, boolean, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxcount(rastertable text, rastercolumn text, exclude_nodata_value boolean, sample_percent double precision DEFAULT 0.1) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, 1, $3, $4) $_$;


ALTER FUNCTION public.st_approxcount(rastertable text, rastercolumn text, exclude_nodata_value boolean, sample_percent double precision) OWNER TO w4;

--
-- Name: st_approxcount(text, text, integer, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxcount(rastertable text, rastercolumn text, nband integer, sample_percent double precision) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, $3, TRUE, $4) $_$;


ALTER FUNCTION public.st_approxcount(rastertable text, rastercolumn text, nband integer, sample_percent double precision) OWNER TO w4;

--
-- Name: st_approxcount(text, text, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxcount(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, $3, $4, $5) $_$;


ALTER FUNCTION public.st_approxcount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision) OWNER TO w4;

--
-- Name: st_approxhistogram(text, text, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, 1, TRUE, $3, 0, NULL, FALSE) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: st_approxhistogram(text, text, integer, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, $4, 0, NULL, FALSE) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: st_approxhistogram(text, text, integer, double precision, integer, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, $4, $5, NULL, $6) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: st_approxhistogram(text, text, integer, boolean, double precision, integer, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, $4, $5, $6, NULL, $7) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: st_approxhistogram(text, text, integer, double precision, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, bins integer, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, $4, $5, $6, $7) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, sample_percent double precision, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: st_approxhistogram(text, text, integer, boolean, double precision, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxhistogram(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_histogram($1, $2, $3, $4, $5, $6, $7, $8) $_$;


ALTER FUNCTION public.st_approxhistogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE
    AS $_$ SELECT (_st_quantile($1, $2, 1, TRUE, 0.1, ARRAY[$3]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, quantile double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, double precision[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_quantile($1, $2, 1, TRUE, 0.1, $3) $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, boolean, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, exclude_nodata_value boolean, quantile double precision DEFAULT NULL::double precision) RETURNS double precision
    LANGUAGE sql STABLE
    AS $_$ SELECT (_st_quantile($1, $2, 1, $3, 0.1, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, exclude_nodata_value boolean, quantile double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, 1, TRUE, $3, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, sample_percent double precision, quantile double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, sample_percent double precision, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_quantile($1, $2, 1, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, nband integer, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, TRUE, $4, ARRAY[$5]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, nband integer, sample_percent double precision, quantile double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, integer, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, nband integer, sample_percent double precision, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_quantile($1, $2, $3, TRUE, $4, $5) $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, nband integer, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, $4, $5, ARRAY[$6]::double precision[])).value $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantile double precision) OWNER TO w4;

--
-- Name: st_approxquantile(text, text, integer, boolean, double precision, double precision[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxquantile(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_quantile($1, $2, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_approxquantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO w4;

--
-- Name: st_approxsummarystats(text, text, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxsummarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, 1, $3, 0.1) $_$;


ALTER FUNCTION public.st_approxsummarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO w4;

--
-- Name: st_approxsummarystats(text, text, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxsummarystats(rastertable text, rastercolumn text, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, 1, TRUE, $3) $_$;


ALTER FUNCTION public.st_approxsummarystats(rastertable text, rastercolumn text, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO w4;

--
-- Name: st_approxsummarystats(text, text, integer, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxsummarystats(rastertable text, rastercolumn text, nband integer, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, $3, TRUE, $4) $_$;


ALTER FUNCTION public.st_approxsummarystats(rastertable text, rastercolumn text, nband integer, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO w4;

--
-- Name: st_approxsummarystats(text, text, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_approxsummarystats(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, $3, $4, $5) $_$;


ALTER FUNCTION public.st_approxsummarystats(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, sample_percent double precision, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO w4;

--
-- Name: st_area(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_area(text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Area($1::geometry);  $_$;


ALTER FUNCTION public.st_area(text) OWNER TO w4;

--
-- Name: st_asewkt(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_asewkt(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsEWKT($1::geometry);  $_$;


ALTER FUNCTION public.st_asewkt(text) OWNER TO w4;

--
-- Name: st_asgeojson(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_asgeojson(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGeoJson(1, $1::geometry,15,0);  $_$;


ALTER FUNCTION public.st_asgeojson(text) OWNER TO w4;

--
-- Name: st_asgml(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_asgml(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsGML(2,$1::geometry,15,0, NULL, NULL);  $_$;


ALTER FUNCTION public.st_asgml(text) OWNER TO w4;

--
-- Name: st_askml(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_askml(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT _ST_AsKML(2, $1::geometry, 15, null);  $_$;


ALTER FUNCTION public.st_askml(text) OWNER TO w4;

--
-- Name: st_assvg(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_assvg(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsSVG($1::geometry,0,15);  $_$;


ALTER FUNCTION public.st_assvg(text) OWNER TO w4;

--
-- Name: st_astext(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_astext(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsText($1::geometry);  $_$;


ALTER FUNCTION public.st_astext(text) OWNER TO w4;

--
-- Name: st_count(text, text, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_count(rastertable text, rastercolumn text, exclude_nodata_value boolean) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, 1, $3, 1) $_$;


ALTER FUNCTION public.st_count(rastertable text, rastercolumn text, exclude_nodata_value boolean) OWNER TO w4;

--
-- Name: FUNCTION st_count(rastertable text, rastercolumn text, exclude_nodata_value boolean); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_count(rastertable text, rastercolumn text, exclude_nodata_value boolean) IS 'args: rastertable, rastercolumn, exclude_nodata_value - Returns the number of pixels in a given band of a raster or raster coverage. If no band is specified defaults to band 1. If exclude_nodata_value is set to true, will only count pixels that are not equal to the nodata value.';


--
-- Name: st_count(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_count(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true) RETURNS bigint
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_count($1, $2, $3, $4, 1) $_$;


ALTER FUNCTION public.st_count(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean) OWNER TO w4;

--
-- Name: FUNCTION st_count(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_count(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean) IS 'args: rastertable, rastercolumn, nband=1, exclude_nodata_value=true - Returns the number of pixels in a given band of a raster or raster coverage. If no band is specified defaults to band 1. If exclude_nodata_value is set to true, will only count pixels that are not equal to the nodata value.';


--
-- Name: st_coveredby(text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_coveredby(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_CoveredBy($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_coveredby(text, text) OWNER TO w4;

--
-- Name: st_covers(text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_covers(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Covers($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_covers(text, text) OWNER TO w4;

--
-- Name: st_distance(text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_distance(text, text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Distance($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_distance(text, text) OWNER TO w4;

--
-- Name: st_distinct4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_distinct4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT COUNT(DISTINCT unnest)::float FROM unnest($1) $_$;


ALTER FUNCTION public.st_distinct4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO w4;

--
-- Name: st_distinct4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_distinct4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT COUNT(DISTINCT unnest)::double precision FROM unnest($1) $_$;


ALTER FUNCTION public.st_distinct4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_dwithin(text, text, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_dwithin(text, text, double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_DWithin($1::geometry, $2::geometry, $3);  $_$;


ALTER FUNCTION public.st_dwithin(text, text, double precision) OWNER TO w4;

--
-- Name: st_histogram(text, text, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, 1, $4, NULL, $5) $_$;


ALTER FUNCTION public.st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) IS 'args: rastertable, rastercolumn, nband, bins, right - Returns a set of record summarizing a raster or raster coverage data distribution separate bin ranges. Number of bins are autocomputed if not specified.';


--
-- Name: st_histogram(text, text, integer, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_histogram($1, $2, $3, TRUE, 1, $4, $5, $6) $_$;


ALTER FUNCTION public.st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) IS 'args: rastertable, rastercolumn, nband=1, bins, width=NULL, right=false - Returns a set of record summarizing a raster or raster coverage data distribution separate bin ranges. Number of bins are autocomputed if not specified.';


--
-- Name: st_histogram(text, text, integer, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_histogram($1, $2, $3, $4, 1, $5, NULL, $6) $_$;


ALTER FUNCTION public.st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) IS 'args: rastertable, rastercolumn, nband, exclude_nodata_value, bins, right - Returns a set of record summarizing a raster or raster coverage data distribution separate bin ranges. Number of bins are autocomputed if not specified.';


--
-- Name: st_histogram(text, text, integer, boolean, integer, double precision[], boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_histogram($1, $2, $3, $4, 1, $5, $6, $7) $_$;


ALTER FUNCTION public.st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) OWNER TO w4;

--
-- Name: FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_histogram(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, bins integer, width double precision[], "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) IS 'args: rastertable, rastercolumn, nband=1, exclude_nodata_value=true, bins=autocomputed, width=NULL, right=false - Returns a set of record summarizing a raster or raster coverage data distribution separate bin ranges. Number of bins are autocomputed if not specified.';


--
-- Name: st_intersects(text, text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_intersects(text, text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT ST_Intersects($1::geometry, $2::geometry);  $_$;


ALTER FUNCTION public.st_intersects(text, text) OWNER TO w4;

--
-- Name: st_invdistweight4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_invdistweight4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		ndims int;

		k double precision DEFAULT 1.;
		_k double precision DEFAULT 1.;
		z double precision[];
		d double precision[];
		_d double precision;
		z0 double precision;

		_z integer;
		x integer;
		y integer;

		cx integer;
		cy integer;
		cv double precision;
		cw double precision DEFAULT NULL;

		w integer;
		h integer;
		max_dx double precision;
		max_dy double precision;
	BEGIN
--		RAISE NOTICE 'value = %', value;
--		RAISE NOTICE 'userargs = %', userargs;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		_z := array_lower(_value, 1);

		-- width and height (0-based)
		h := array_upper(_value, 2) - array_lower(_value, 2);
		w := array_upper(_value, 3) - array_lower(_value, 3);

		-- max distance from center pixel
		max_dx := w / 2;
		max_dy := h / 2;
--		RAISE NOTICE 'max_dx, max_dy = %, %', max_dx, max_dy;

		-- correct width and height (1-based)
		w := w + 1;
		h := h + 1;
--		RAISE NOTICE 'w, h = %, %', w, h;

		-- width and height should be odd numbers
		IF w % 2. != 1 THEN
			RAISE EXCEPTION 'Width of neighborhood array does not permit for a center pixel';
		END IF;
		IF h % 2. != 1 THEN
			RAISE EXCEPTION 'Height of neighborhood array does not permit for a center pixel';
		END IF;

		-- center pixel's coordinates
		cy := max_dy + array_lower(_value, 2);
		cx := max_dx + array_lower(_value, 3);
--		RAISE NOTICE 'cx, cy = %, %', cx, cy;

		-- if userargs provided, only use the first two args
		IF userargs IS NOT NULL AND array_ndims(userargs) = 1 THEN
			-- first arg is power factor
			k := userargs[array_lower(userargs, 1)]::double precision;
			IF k IS NULL THEN
				k := _k;
			ELSEIF k < 0. THEN
				RAISE NOTICE 'Power factor (< 0) must be between 0 and 1.  Defaulting to 0';
				k := 0.;
			ELSEIF k > 1. THEN
				RAISE NOTICE 'Power factor (> 1) must be between 0 and 1.  Defaulting to 1';
				k := 1.;
			END IF;

			-- second arg is what to do if center pixel has a value
			-- this will be a weight to apply for the center pixel
			IF array_length(userargs, 1) > 1 THEN
				cw := abs(userargs[array_lower(userargs, 1) + 1]::double precision);
				IF cw IS NOT NULL THEN
					IF cw < 0. THEN
						RAISE NOTICE 'Weight (< 0) of center pixel value must be between 0 and 1.  Defaulting to 0';
						cw := 0.;
					ELSEIF cw > 1 THEN
						RAISE NOTICE 'Weight (> 1) of center pixel value must be between 0 and 1.  Defaulting to 1';
						cw := 1.;
					END IF;
				END IF;
			END IF;
		END IF;
--		RAISE NOTICE 'k = %', k;
		k = abs(k) * -1;

		-- center pixel value
		cv := _value[_z][cy][cx];

		-- check to see if center pixel has value
--		RAISE NOTICE 'cw = %', cw;
		IF cw IS NULL AND cv IS NOT NULL THEN
			RETURN cv;
		END IF;

		FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
			FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
--				RAISE NOTICE 'value[%][%][%] = %', _z, y, x, _value[_z][y][x];

				-- skip NODATA values and center pixel
				IF _value[_z][y][x] IS NULL OR (x = cx AND y = cy) THEN
					CONTINUE;
				END IF;

				z := z || _value[_z][y][x];

				-- use pythagorean theorem
				_d := sqrt(power(cx - x, 2) + power(cy - y, 2));
--				RAISE NOTICE 'distance = %', _d;

				d := d || _d;
			END LOOP;
		END LOOP;
--		RAISE NOTICE 'z = %', z;
--		RAISE NOTICE 'd = %', d;

		-- neighborhood is NODATA
		IF z IS NULL OR array_length(z, 1) < 1 THEN
			-- center pixel has value
			IF cv IS NOT NULL THEN
				RETURN cv;
			ELSE
				RETURN NULL;
			END IF;
		END IF;

		z0 := 0;
		_d := 0;
		FOR x IN array_lower(z, 1)..array_upper(z, 1) LOOP
			d[x] := power(d[x], k);
			z[x] := z[x] * d[x];
			_d := _d + d[x];
			z0 := z0 + z[x];
		END LOOP;
		z0 := z0 / _d;
--		RAISE NOTICE 'z0 = %', z0;

		-- apply weight for center pixel if center pixel has value
		IF cv IS NOT NULL THEN
			z0 := (cw * cv) + ((1 - cw) * z0);
--			RAISE NOTICE '*z0 = %', z0;
		END IF;

		RETURN z0;
	END;
	$$;


ALTER FUNCTION public.st_invdistweight4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_length(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_length(text) RETURNS double precision
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_Length($1::geometry);  $_$;


ALTER FUNCTION public.st_length(text) OWNER TO w4;

--
-- Name: st_max4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        max float;
    BEGIN
        _matrix := matrix;
        max := '-Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN max;
    END;
    $$;


ALTER FUNCTION public.st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO w4;

--
-- Name: st_max4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_max4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		max double precision;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		max := '-Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					IF _value[z][y][x] > max THEN
						max := _value[z][y][x];
					END IF;
				END LOOP;
			END LOOP;
		END LOOP;

		IF max = '-Infinity'::double precision THEN
			RETURN NULL;
		END IF;

		RETURN max;
	END;
	$$;


ALTER FUNCTION public.st_max4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_mean4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
        count float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        count := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                        count := count + 1;
                    END IF;
                ELSE
                    count := count + 1;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        IF count = 0 THEN
            RETURN NULL;
        END IF;
        RETURN sum / count;
    END;
    $$;


ALTER FUNCTION public.st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO w4;

--
-- Name: st_mean4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_mean4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		sum double precision;
		count int;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		sum := 0;
		count := 0;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					sum := sum + _value[z][y][x];
					count := count + 1;
				END LOOP;
			END LOOP;
		END LOOP;

		IF count < 1 THEN
			RETURN NULL;
		END IF;

		RETURN sum / count::double precision;
	END;
	$$;


ALTER FUNCTION public.st_mean4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_min4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN min;
    END;
    $$;


ALTER FUNCTION public.st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO w4;

--
-- Name: st_min4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_min4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		min double precision;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		min := 'Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					IF _value[z][y][x] < min THEN
						min := _value[z][y][x];
					END IF;
				END LOOP;
			END LOOP;
		END LOOP;

		IF min = 'Infinity'::double precision THEN
			RETURN NULL;
		END IF;

		RETURN min;
	END;
	$$;


ALTER FUNCTION public.st_min4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_mindist4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_mindist4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		ndims int;

		d double precision DEFAULT NULL;
		_d double precision;

		z integer;
		x integer;
		y integer;

		cx integer;
		cy integer;
		cv double precision;

		w integer;
		h integer;
		max_dx double precision;
		max_dy double precision;
	BEGIN

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
		END IF;
		z := array_lower(_value, 1);

		-- width and height (0-based)
		h := array_upper(_value, 2) - array_lower(_value, 2);
		w := array_upper(_value, 3) - array_lower(_value, 3);

		-- max distance from center pixel
		max_dx := w / 2;
		max_dy := h / 2;

		-- correct width and height (1-based)
		w := w + 1;
		h := h + 1;

		-- width and height should be odd numbers
		IF w % 2. != 1 THEN
			RAISE EXCEPTION 'Width of neighborhood array does not permit for a center pixel';
		END IF;
		IF h % 2. != 1 THEN
			RAISE EXCEPTION 'Height of neighborhood array does not permit for a center pixel';
		END IF;

		-- center pixel's coordinates
		cy := max_dy + array_lower(_value, 2);
		cx := max_dx + array_lower(_value, 3);

		-- center pixel value
		cv := _value[z][cy][cx];

		-- check to see if center pixel has value
		IF cv IS NOT NULL THEN
			RETURN 0.;
		END IF;

		FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
			FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP

				-- skip NODATA values and center pixel
				IF _value[z][y][x] IS NULL OR (x = cx AND y = cy) THEN
					CONTINUE;
				END IF;

				-- use pythagorean theorem
				_d := sqrt(power(cx - x, 2) + power(cy - y, 2));
--				RAISE NOTICE 'distance = %', _d;

				IF d IS NULL OR _d < d THEN
					d := _d;
				END IF;
			END LOOP;
		END LOOP;
--		RAISE NOTICE 'd = %', d;

		RETURN d;
	END;
	$$;


ALTER FUNCTION public.st_mindist4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_quantile(text, text, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, 1, TRUE, 1, ARRAY[$3]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, quantile double precision) OWNER TO w4;

--
-- Name: st_quantile(text, text, double precision[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_quantile($1, $2, 1, TRUE, 1, $3) $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO w4;

--
-- Name: st_quantile(text, text, boolean, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, exclude_nodata_value boolean, quantile double precision DEFAULT NULL::double precision) RETURNS double precision
    LANGUAGE sql STABLE
    AS $_$ SELECT (_st_quantile($1, $2, 1, $3, 1, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, exclude_nodata_value boolean, quantile double precision) OWNER TO w4;

--
-- Name: st_quantile(text, text, integer, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, TRUE, 1, ARRAY[$4]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, nband integer, quantile double precision) OWNER TO w4;

--
-- Name: st_quantile(text, text, integer, double precision[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_quantile($1, $2, $3, TRUE, 1, $4) $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO w4;

--
-- Name: FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision) IS 'args: rastertable, rastercolumn, nband, quantiles - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';


--
-- Name: st_quantile(text, text, integer, boolean, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, quantile double precision) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_quantile($1, $2, $3, $4, 1, ARRAY[$5]::double precision[])).value $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, quantile double precision) OWNER TO w4;

--
-- Name: st_quantile(text, text, integer, boolean, double precision[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT _st_quantile($1, $2, $3, $4, 1, $5) $_$;


ALTER FUNCTION public.st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, quantiles double precision[], OUT quantile double precision, OUT value double precision) OWNER TO w4;

--
-- Name: FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, quantiles double precision[], OUT quantile double precision, OUT value double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_quantile(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, quantiles double precision[], OUT quantile double precision, OUT value double precision) IS 'args: rastertable, rastercolumn, nband=1, exclude_nodata_value=true, quantiles=NULL - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';


--
-- Name: st_range4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
        max float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        max := '-Infinity'::float;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
                END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
        END IF;
        RETURN max - min;
    END;
    $$;


ALTER FUNCTION public.st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO w4;

--
-- Name: st_range4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_range4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		min double precision;
		max double precision;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		min := 'Infinity'::double precision;
		max := '-Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					IF _value[z][y][x] < min THEN
						min := _value[z][y][x];
					END IF;
					IF _value[z][y][x] > max THEN
						max := _value[z][y][x];
					END IF;
				END LOOP;
			END LOOP;
		END LOOP;

		IF max = '-Infinity'::double precision OR min = 'Infinity'::double precision THEN
			RETURN NULL;
		END IF;

		RETURN max - min;
	END;
	$$;


ALTER FUNCTION public.st_range4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_samealignment(double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_samealignment(ulx1 double precision, uly1 double precision, scalex1 double precision, scaley1 double precision, skewx1 double precision, skewy1 double precision, ulx2 double precision, uly2 double precision, scalex2 double precision, scaley2 double precision, skewx2 double precision, skewy2 double precision) RETURNS boolean
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT st_samealignment(st_makeemptyraster(1, 1, $1, $2, $3, $4, $5, $6), st_makeemptyraster(1, 1, $7, $8, $9, $10, $11, $12)) $_$;


ALTER FUNCTION public.st_samealignment(ulx1 double precision, uly1 double precision, scalex1 double precision, scaley1 double precision, skewx1 double precision, skewy1 double precision, ulx2 double precision, uly2 double precision, scalex2 double precision, scaley2 double precision, skewx2 double precision, skewy2 double precision) OWNER TO w4;

--
-- Name: FUNCTION st_samealignment(ulx1 double precision, uly1 double precision, scalex1 double precision, scaley1 double precision, skewx1 double precision, skewy1 double precision, ulx2 double precision, uly2 double precision, scalex2 double precision, scaley2 double precision, skewx2 double precision, skewy2 double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_samealignment(ulx1 double precision, uly1 double precision, scalex1 double precision, scaley1 double precision, skewx1 double precision, skewy1 double precision, ulx2 double precision, uly2 double precision, scalex2 double precision, scaley2 double precision, skewx2 double precision, skewy2 double precision) IS 'args: ulx1, uly1, scalex1, scaley1, skewx1, skewy1, ulx2, uly2, scalex2, scaley2, skewx2, skewy2 - Returns true if rasters have same skew, scale, spatial ref and false if they dont with notice detailing issue.';


--
-- Name: st_stddev4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_stddev4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT stddev(unnest) FROM unnest($1) $_$;


ALTER FUNCTION public.st_stddev4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO w4;

--
-- Name: st_stddev4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_stddev4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$ SELECT stddev(unnest) FROM unnest($1) $_$;


ALTER FUNCTION public.st_stddev4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_sum4ma(double precision[], text, text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        RETURN sum;
    END;
    $$;


ALTER FUNCTION public.st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) OWNER TO w4;

--
-- Name: st_sum4ma(double precision[], integer[], text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_sum4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	DECLARE
		_value double precision[][][];
		sum double precision;
		x int;
		y int;
		z int;
		ndims int;
	BEGIN
		sum := 0;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := _st_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
		ELSE
			_value := value;
		END IF;

		-- raster
		FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
						ELSE
							CONTINUE;
						END IF;
					END IF;

					sum := sum + _value[z][y][x];
				END LOOP;
			END LOOP;
		END LOOP;

		RETURN sum;
	END;
	$$;


ALTER FUNCTION public.st_sum4ma(value double precision[], pos integer[], VARIADIC userargs text[]) OWNER TO w4;

--
-- Name: st_summarystats(text, text, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_summarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, 1, $3, 1) $_$;


ALTER FUNCTION public.st_summarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO w4;

--
-- Name: FUNCTION st_summarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_summarystats(rastertable text, rastercolumn text, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) IS 'args: rastertable, rastercolumn, exclude_nodata_value - Returns record consisting of count, sum, mean, stddev, min, max for a given raster band of a raster or raster coverage. Band 1 is assumed is no band is specified.';


--
-- Name: st_summarystats(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_summarystats(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) RETURNS record
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT _st_summarystats($1, $2, $3, $4, 1) $_$;


ALTER FUNCTION public.st_summarystats(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) OWNER TO w4;

--
-- Name: FUNCTION st_summarystats(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_summarystats(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, OUT count bigint, OUT sum double precision, OUT mean double precision, OUT stddev double precision, OUT min double precision, OUT max double precision) IS 'args: rastertable, rastercolumn, nband=1, exclude_nodata_value=true - Returns record consisting of count, sum, mean, stddev, min, max for a given raster band of a raster or raster coverage. Band 1 is assumed is no band is specified.';


--
-- Name: st_valuecount(text, text, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, 1, TRUE, ARRAY[$3]::double precision[], $4)).count $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision) OWNER TO w4;

--
-- Name: FUNCTION st_valuecount(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_valuecount(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision) IS 'args: rastertable, rastercolumn, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';


--
-- Name: st_valuecount(text, text, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, $2, 1, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO w4;

--
-- Name: FUNCTION st_valuecount(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_valuecount(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) IS 'args: rastertable, rastercolumn, searchvalues, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';


--
-- Name: st_valuecount(text, text, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, TRUE, ARRAY[$4]::double precision[], $5)).count $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision) OWNER TO w4;

--
-- Name: FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision) IS 'args: rastertable, rastercolumn, nband, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';


--
-- Name: st_valuecount(text, text, integer, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, $2, $3, TRUE, $4, $5) $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO w4;

--
-- Name: FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) IS 'args: rastertable, rastercolumn, nband, searchvalues, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';


--
-- Name: st_valuecount(text, text, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, $4, ARRAY[$5]::double precision[], $6)).count $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision) OWNER TO w4;

--
-- Name: FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision) IS 'args: rastertable, rastercolumn, nband, exclude_nodata_value, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';


--
-- Name: st_valuecount(text, text, integer, boolean, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, count FROM _st_valuecount($1, $2, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) OWNER TO w4;

--
-- Name: FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT count integer) IS 'args: rastertable, rastercolumn, nband=1, exclude_nodata_value=true, searchvalues=NULL, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';


--
-- Name: st_valuepercent(text, text, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, 1, TRUE, ARRAY[$3]::double precision[], $4)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision) OWNER TO w4;

--
-- Name: st_valuepercent(text, text, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, $2, 1, TRUE, $3, $4) $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO w4;

--
-- Name: st_valuepercent(text, text, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, TRUE, ARRAY[$4]::double precision[], $5)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision) OWNER TO w4;

--
-- Name: st_valuepercent(text, text, integer, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, $2, $3, TRUE, $4, $5) $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO w4;

--
-- Name: st_valuepercent(text, text, integer, boolean, double precision, double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) RETURNS double precision
    LANGUAGE sql STABLE STRICT
    AS $_$ SELECT (_st_valuecount($1, $2, $3, $4, ARRAY[$5]::double precision[], $6)).percent $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision) OWNER TO w4;

--
-- Name: st_valuepercent(text, text, integer, boolean, double precision[], double precision); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION st_valuepercent(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) RETURNS SETOF record
    LANGUAGE sql STABLE
    AS $_$ SELECT value, percent FROM _st_valuecount($1, $2, $3, $4, $5, $6) $_$;


ALTER FUNCTION public.st_valuepercent(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalues double precision[], roundto double precision, OUT value double precision, OUT percent double precision) OWNER TO w4;

--
-- Name: testing(status_entity); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION testing(foo status_entity) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
	DECLARE
	BEGIN
		RETURN 0;
	END;
$$;


ALTER FUNCTION public.testing(foo status_entity) OWNER TO w4;

--
-- Name: tryexec(text[]); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION tryexec(arg_commands text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
	DECLARE
		var_command text;
		var_failed text[] DEFAULT '{}';
	BEGIN

		WHILE array_length( arg_commands, 1 ) > 0 LOOP

			var_failed := '{}';

			FOREACH var_command IN ARRAY arg_commands LOOP

				BEGIN
				
					EXECUTE var_command;
					-- RAISE INFO '~~success: %', var_command;
					
				EXCEPTION WHEN others THEN

					-- RAISE INFO '~~possible dependency: %', var_command;
					var_failed := array_append( var_failed, var_command );
				END;

			END LOOP;

			IF array_length( arg_commands, 1 ) = array_length( var_failed, 1 ) THEN

				RAISE INFO '~~Unable to resolve dependency orderings~~ %', array_length( arg_commands, 1 );
				EXECUTE arg_commands[2];
				RAISE EXCEPTION '~~Unable to resolve dependency orderings~~ %', arg_commands;
				RETURN;

			END IF;

			arg_commands := var_failed;

		END LOOP;
		
	END;
$$;


ALTER FUNCTION public.tryexec(arg_commands text[]) OWNER TO w4;

--
-- Name: unlockrows(text); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION unlockrows(text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	ret int;
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table where authid = ' ||
		quote_literal($1);

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;
$_$;


ALTER FUNCTION public.unlockrows(text) OWNER TO w4;

--
-- Name: FUNCTION unlockrows(text); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION unlockrows(text) IS 'args: auth_token - Remove all locks held by specified authorization id. Returns the number of locks released.';


--
-- Name: updategeometrysrid(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('','',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.updategeometrysrid(character varying, character varying, integer) OWNER TO w4;

--
-- Name: FUNCTION updategeometrysrid(character varying, character varying, integer); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION updategeometrysrid(character varying, character varying, integer) IS 'args: table_name, column_name, srid - Updates the SRID of all features in a geometry column, geometry_columns metadata and srid. If it was enforced with constraints, the constraints will be updated with new srid constraint. If the old was enforced by type definition, the type definition will be changed.';


--
-- Name: updategeometrysrid(character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION updategeometrysrid(character varying, character varying, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT UpdateGeometrySRID('',$1,$2,$3,$4) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.updategeometrysrid(character varying, character varying, character varying, integer) OWNER TO w4;

--
-- Name: FUNCTION updategeometrysrid(character varying, character varying, character varying, integer); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION updategeometrysrid(character varying, character varying, character varying, integer) IS 'args: schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, geometry_columns metadata and srid. If it was enforced with constraints, the constraints will be updated with new srid constraint. If the old was enforced by type definition, the type definition will be changed.';


--
-- Name: updategeometrysrid(character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	myrec RECORD;
	okay boolean;
	cname varchar;
	real_schema name;
	unknown_srid integer;
	new_srid integer := new_srid_in;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <> true ) THEN
			RAISE EXCEPTION 'Invalid schema name';
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT INTO real_schema current_schema()::text;
	END IF;

	-- Ensure that column_name is in geometry_columns
	okay = false;
	FOR myrec IN SELECT type, coord_dimension FROM geometry_columns WHERE f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (NOT okay) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Ensure that new_srid is valid
	IF ( new_srid > 0 ) THEN
		IF ( SELECT count(*) = 0 from spatial_ref_sys where srid = new_srid ) THEN
			RAISE EXCEPTION 'invalid SRID: % not found in spatial_ref_sys', new_srid;
			RETURN false;
		END IF;
	ELSE
		unknown_srid := ST_SRID('POINT EMPTY'::geometry);
		IF ( new_srid != unknown_srid ) THEN
			new_srid := unknown_srid;
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;

	IF postgis_constraint_srid(schema_name, table_name, column_name) IS NOT NULL THEN 
	-- srid was enforced with constraints before, keep it that way.
        -- Make up constraint name
        cname = 'enforce_srid_'  || column_name;
    
        -- Drop enforce_srid constraint
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' DROP constraint ' || quote_ident(cname);
    
        -- Update geometries SRID
        EXECUTE 'UPDATE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' SET ' || quote_ident(column_name) ||
            ' = ST_SetSRID(' || quote_ident(column_name) ||
            ', ' || new_srid::text || ')';
            
        -- Reset enforce_srid constraint
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
            '.' || quote_ident(table_name) ||
            ' ADD constraint ' || quote_ident(cname) ||
            ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')';
    ELSE 
        -- We will use typmod to enforce if no srid constraints
        -- We are using postgis_type_name to lookup the new name 
        -- (in case Paul changes his mind and flips geometry_columns to return old upper case name) 
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' || quote_ident(table_name) || 
        ' ALTER COLUMN ' || quote_ident(column_name) || ' TYPE  geometry(' || postgis_type_name(myrec.type, myrec.coord_dimension, true) || ', ' || new_srid::text || ') USING ST_SetSRID(' || quote_ident(column_name) || ',' || new_srid::text || ');' ;
    END IF;

	RETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;

END;
$$;


ALTER FUNCTION public.updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) OWNER TO w4;

--
-- Name: FUNCTION updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) IS 'args: catalog_name, schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, geometry_columns metadata and srid. If it was enforced with constraints, the constraints will be updated with new srid constraint. If the old was enforced by type definition, the type definition will be changed.';


--
-- Name: updaterastersrid(name, name, integer); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION updaterastersrid(table_name name, column_name name, new_srid integer) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _UpdateRasterSRID('', $1, $2, $3) $_$;


ALTER FUNCTION public.updaterastersrid(table_name name, column_name name, new_srid integer) OWNER TO w4;

--
-- Name: FUNCTION updaterastersrid(table_name name, column_name name, new_srid integer); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION updaterastersrid(table_name name, column_name name, new_srid integer) IS 'args: table_name, column_name, new_srid - Change the SRID of all rasters in the user-specified column and table.';


--
-- Name: updaterastersrid(name, name, name, integer); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) RETURNS boolean
    LANGUAGE sql STRICT
    AS $_$ SELECT _UpdateRasterSRID($1, $2, $3, $4) $_$;


ALTER FUNCTION public.updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) OWNER TO w4;

--
-- Name: FUNCTION updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer); Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON FUNCTION updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) IS 'args: schema_name, table_name, column_name, new_srid - Change the SRID of all rasters in the user-specified column and table.';


--
-- Name: version_campaign_record(); Type: FUNCTION; Schema: public; Owner: w4
--

CREATE FUNCTION version_campaign_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        new_version_number BIGINT;
        new_version_row public.campaign_versions;
    BEGIN
        -- Determine if insert or update
        IF (TG_OP = 'UPDATE') THEN
            -- Get the new version info if this is an update
            SELECT INTO new_version_number COALESCE(MAX(version_id)+1,1) FROM campaign_versions WHERE id = NEW.id;
        ELSEIF (TG_OP = 'INSERT') THEN
            -- Just do a raw insert with version number of 1 and canon date of 0 TIMESTAMPTZ
            new_version_number=1;
        END IF;   
        new_version_row = ROW(
            NEW.id, -- campaign_id
            new_version_number, -- version_id
            NEW.advertiser_id,
            NEW.user_id,
            NEW.name,
            NEW.description,
            NEW.restrictions,
            NEW.default_redirect_url,
            NEW.screenshot_id,
            NEW.landing_pages,
            NEW.failure_redirect_type,
            NEW.failure_redirect_url,
            NEW.failure_redirect_campaign_id,
            NEW.unsubscription_url,
            NEW.unsubscription_screenshot_id,
            NEW.default_payout,
            NEW.payout_type,
            NEW.payout_model_id,
            NEW.default_payin,
            NEW.payin_type,
            NEW.payin_model_id,
            NEW.start_date,
            NEW.is_expiration,
            NEW.expiry_date,
            NEW.geotargeting_postal_code_directive,
            NEW.outgeo_redirect_type,
            NEW.outgeo_redirect_url,
            NEW.outgeo_redirect_campaign_id,
            NEW.outgeo_redirect_screenshot_id,
            NEW.cookie_duration_time,
            NEW.cookie_duration_unit,
            NEW.access_type,
            NEW.status,
            NEW.epc,
            NEW.tracking_type,
            NEW.tracking_secure,
            NEW.new_until,
            NEW.do_redirect_mobile,
            NEW.mobile_redirect_url,
            NEW.mobile_screenshot_id,
            transaction_timestamp(), -- version_start_date
            NEW.currency_id
        );
        -- Save the versioned record
        INSERT INTO campaign_versions VALUES (new_version_row.*);
        -- Be a good little trigger and return the NEW record
        RETURN NEW;        
    END
$$;


ALTER FUNCTION public.version_campaign_record() OWNER TO w4;

SET search_path = topology, pg_catalog;

--
-- Name: _asgmlface(text, integer, regclass, text, integer, integer, text, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION _asgmlface(toponame text, face_id integer, visitedtable regclass, nsprefix_in text, prec integer, options integer, idprefix text, gmlver integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  visited bool;
  nsprefix text;
  gml text;
  rec RECORD;
  rec2 RECORD;
  bounds geometry;
BEGIN

  nsprefix := 'gml:';
  IF nsprefix_in IS NOT NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  gml := '<' || nsprefix || 'Face ' || nsprefix
    || 'id="' || idprefix || 'F' || face_id || '">';

  -- Construct the face geometry, then for each polygon:
  FOR rec IN SELECT (ST_DumpRings((ST_Dump(ST_ForceRHR(
    topology.ST_GetFaceGeometry(toponame, face_id)))).geom)).geom
  LOOP

      -- Contents of a directed face are the list of edges
      -- that cover the specific ring
      bounds = ST_Boundary(rec.geom);

      FOR rec2 IN EXECUTE
        'SELECT e.*, ST_LineLocatePoint('
        || quote_literal(bounds::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
        || ', ST_LineLocatePoint('
        || quote_literal(bounds::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
        || quote_ident(toponame)
        || '.edge e WHERE ( e.left_face = ' || face_id
        || ' OR e.right_face = ' || face_id
        || ') AND ST_Covers('
        || quote_literal(bounds::text)
        || ', e.geom) ORDER BY pos'
      LOOP

        gml = gml || '<' || nsprefix || 'directedEdge';

        -- if this edge goes in same direction to the
        --       ring bounds, make it with negative orientation
        IF rec2.pos2 > rec2.pos THEN -- edge goes in same direction
          gml = gml || ' orientation="-"';
        END IF;

        -- Do visited bookkeeping if visitedTable was given
        IF visitedTable IS NOT NULL THEN

          EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 2 AND element_id = '
            || rec2.edge_id LIMIT 1 INTO visited;
          IF visited THEN
            -- Use xlink:href if visited
            gml = gml || ' xlink:href="#' || idprefix || 'E'
                      || rec2.edge_id || '" />';
            CONTINUE;
          ELSE
            -- Mark as visited otherwise
            EXECUTE 'INSERT INTO ' || visitedTable::text
              || '(element_type, element_id) VALUES (2, '
              || rec2.edge_id || ')';
          END IF;

        END IF;

        gml = gml || '>';

        gml = gml || topology._AsGMLEdge(rec2.edge_id, rec2.start_node,
                                        rec2.end_node, rec2.geom,
                                        visitedTable, nsprefix_in,
                                        prec, options, idprefix, gmlver);
        gml = gml || '</' || nsprefix || 'directedEdge>';

      END LOOP;
    END LOOP;

  gml = gml || '</' || nsprefix || 'Face>';

  RETURN gml;
END
$$;


ALTER FUNCTION topology._asgmlface(toponame text, face_id integer, visitedtable regclass, nsprefix_in text, prec integer, options integer, idprefix text, gmlver integer) OWNER TO w4;

--
-- Name: _st_addfacesplit(character varying, integer, integer, boolean); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION _st_addfacesplit(atopology character varying, anedge integer, oface integer, mbr_only boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  fan RECORD;
  newface INTEGER;
  sql TEXT;
  isccw BOOLEAN;
  ishole BOOLEAN;

BEGIN

  IF oface = 0 AND mbr_only THEN
    RETURN NULL;
  END IF;

  SELECT null::int[] as newring_edges,
         null::geometry as shell
  INTO fan;

  SELECT array_agg(edge)
  FROM topology.getringedges(atopology, anedge)
  INTO STRICT fan.newring_edges;


  -- You can't get to the other side of an edge forming a ring 
  IF fan.newring_edges @> ARRAY[-anedge] THEN
    RETURN 0;
  END IF;


  sql := 'WITH ids as ( select row_number() over () as seq, edge from unnest('
    || quote_literal(fan.newring_edges::text)
    || '::int[] ) u(edge) ), edges AS ( select CASE WHEN i.edge < 0 THEN ST_Reverse(e.geom) ELSE e.geom END as g FROM ids i left join '
    || quote_ident(atopology) || '.edge_data e ON(e.edge_id = abs(i.edge)) ORDER BY seq) SELECT ST_MakePolygon(ST_MakeLine(g.g)) FROM edges g;';
  EXECUTE sql INTO fan.shell;


  isccw := NOT ST_OrderingEquals(fan.shell, ST_ForceRHR(fan.shell));


  IF oface = 0 THEN
    IF NOT isccw THEN
      RETURN NULL;
    END IF;
  END IF;

  IF mbr_only AND oface != 0 THEN
    -- Update old face mbr (nothing to do if we're opening an hole)
    IF isccw THEN -- {
      sql := 'UPDATE '
        || quote_ident(atopology) || '.face SET mbr = '
        || quote_literal(ST_Envelope(fan.shell)::text)
        || '::geometry WHERE face_id = ' || oface;
    	EXECUTE sql;
    END IF; -- }
    RETURN NULL;
  END IF;

  IF oface != 0 AND NOT isccw THEN -- {
    -- Face created an hole in an outer face
    sql := 'INSERT INTO '
      || quote_ident(atopology) || '.face(mbr) SELECT mbr FROM '
      || quote_ident(atopology)
      || '.face WHERE face_id = ' || oface
      || ' RETURNING face_id';
  ELSE
    sql := 'INSERT INTO '
      || quote_ident(atopology) || '.face(mbr) VALUES ('
      || quote_literal(ST_Envelope(fan.shell)::text)
      || '::geometry) RETURNING face_id';
  END IF; -- }

  -- Insert new face
  EXECUTE sql INTO STRICT newface;

  -- Update forward edges
  sql := 'UPDATE '
    || quote_ident(atopology) || '.edge_data SET left_face = ' || newface
    || ' WHERE left_face = ' || oface || ' AND edge_id = ANY ('
    || quote_literal(array( select +(x) from unnest(fan.newring_edges) u(x) )::text)
    || ')';
  EXECUTE sql;

  -- Update backward edges
  sql := 'UPDATE '
    || quote_ident(atopology) || '.edge_data SET right_face = ' || newface
    || ' WHERE right_face = ' || oface || ' AND edge_id = ANY ('
    || quote_literal(array( select -(x) from unnest(fan.newring_edges) u(x) )::text)
    || ')';
  EXECUTE sql;

  IF oface != 0 AND NOT isccw THEN -- {
    -- face shrinked, must update all non-contained edges and nodes
    ishole := true;
  ELSE
    ishole := false;
  END IF; -- }

  -- Update edges bounding the old face
  sql := 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET left_face = CASE WHEN left_face = '
    || oface || ' THEN ' || newface
    || ' ELSE left_face END, right_face = CASE WHEN right_face = '
    || oface || ' THEN ' || newface
    || ' ELSE right_face END WHERE ( left_face = ' || oface
    || ' OR right_face = ' || oface
    || ') AND NOT edge_id = ANY ('
    || quote_literal( array(
        select abs(x) from unnest(fan.newring_edges) u(x)
       )::text )
    || ') AND ';
  IF ishole THEN sql := sql || 'NOT '; END IF;
  sql := sql || 'ST_Contains(' || quote_literal(fan.shell::text)
    -- We only need to check a single point, but must not be an endpoint
    || '::geometry, ST_LineInterpolatePoint(geom, 0.2))';
  EXECUTE sql;

  -- Update isolated nodes in new new face 
  sql := 'UPDATE '
    || quote_ident(atopology) || '.node SET containing_face = ' || newface
    || ' WHERE containing_face = ' || oface 
    || ' AND ';
  IF ishole THEN sql := sql || 'NOT '; END IF;
  sql := sql || 'ST_Contains(' || quote_literal(fan.shell::text) || '::geometry, geom)';
  EXECUTE sql;

  RETURN newface;

END
$$;


ALTER FUNCTION topology._st_addfacesplit(atopology character varying, anedge integer, oface integer, mbr_only boolean) OWNER TO w4;

--
-- Name: _st_adjacentedges(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION _st_adjacentedges(atopology character varying, anode integer, anedge integer) RETURNS integer[]
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  ret integer[];
BEGIN
  WITH edgestar AS (
    SELECT *, count(*) over () AS cnt
    FROM GetNodeEdges(atopology, anode)
  )
  SELECT ARRAY[ (
      SELECT p.edge AS prev FROM edgestar p
      WHERE p.sequence = CASE WHEN m.sequence-1 < 1 THEN cnt
                         ELSE m.sequence-1 END
    ), (
      SELECT p.edge AS prev FROM edgestar p WHERE p.sequence = ((m.sequence)%cnt)+1
    ) ]
  FROM edgestar m
  WHERE edge = anedge
  INTO ret;

  RETURN ret;
END
$$;


ALTER FUNCTION topology._st_adjacentedges(atopology character varying, anode integer, anedge integer) OWNER TO w4;

--
-- Name: _st_remedgecheck(character varying, integer, integer, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION _st_remedgecheck(tname character varying, tid integer, eid integer, lf integer, rf integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  sql text;
  fidary int[];
  rec RECORD;
BEGIN
  -- Check that no TopoGeometry references the edge being removed
  sql := 'SELECT r.topogeo_id, r.layer_id'
      || ', l.schema_name, l.table_name, l.feature_column '
      || 'FROM topology.layer l INNER JOIN '
      || quote_ident(tname)
      || '.relation r ON (l.layer_id = r.layer_id) '
      || 'WHERE l.level = 0 AND l.feature_type = 2 '
      || ' AND l.topology_id = ' || tid
      || ' AND abs(r.element_id) = ' || eid ;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented dropping edge %',
            rec.topogeo_id, rec.layer_id,
            rec.schema_name, rec.table_name, rec.feature_column,
            eid;
  END LOOP;

  IF lf != rf THEN -- {

    RAISE NOTICE 'Deletion of edge % joins faces % and %',
                    eid, lf, rf;

    -- check if any topo_geom is defined only by one of the
    -- joined faces. In such case there would be no way to adapt
    -- the definition in case of healing, so we'd have to bail out
    -- 
    fidary = ARRAY[lf, rf];
    sql := 'SELECT t.* from ('
      || 'SELECT r.topogeo_id, r.layer_id'
      || ', l.schema_name, l.table_name, l.feature_column'
      || ', array_agg(r.element_id) as elems '
      || 'FROM topology.layer l INNER JOIN '
      || quote_ident(tname)
      || '.relation r ON (l.layer_id = r.layer_id) '
      || 'WHERE l.level = 0 AND l.feature_type = 3 '
      || ' AND l.topology_id = ' || tid
      || ' AND r.element_id = ANY (' || quote_literal(fidary)
      || ') group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
      || ' l.feature_column ) t';

    -- No surface can be defined by universal face 
    IF lf != 0 AND rf != 0 THEN -- {
      sql := sql || ' WHERE NOT t.elems @> ' || quote_literal(fidary);
    END IF; -- }


    FOR rec IN EXECUTE sql LOOP
      RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing faces % and %',
            rec.topogeo_id, rec.layer_id,
            rec.schema_name, rec.table_name, rec.feature_column,
            rf, lf;
    END LOOP;

  END IF; -- } two faces healed...
END
$$;


ALTER FUNCTION topology._st_remedgecheck(tname character varying, tid integer, eid integer, lf integer, rf integer) OWNER TO w4;

--
-- Name: addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying) RETURNS integer
    LANGUAGE sql
    AS $_$
  SELECT topology.AddTopoGeometryColumn($1, $2, $3, $4, $5, NULL);
$_$;


ALTER FUNCTION topology.addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying) OWNER TO w4;

--
-- Name: FUNCTION addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying) IS 'args: topology_name, schema_name, table_name, column_name, feature_type - Adds a topogeometry column to an existing table, registers this new column as a layer in topology.layer and returns the new layer_id.';


--
-- Name: addtopogeometrycolumn(character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION addtopogeometrycolumn(toponame character varying, schema character varying, tbl character varying, col character varying, ltype character varying, child integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  intltype integer;
  newlevel integer;
  topoid integer;
  rec RECORD;
  newlayer_id integer;
  query text;
BEGIN

        -- Get topology id
        SELECT id FROM topology.topology into topoid
                WHERE name = toponame;

  IF topoid IS NULL THEN
    RAISE EXCEPTION 'Topology % does not exist', toponame;
  END IF;

  IF ltype ILIKE '%POINT%' OR ltype ILIKE 'PUNTAL' THEN
    intltype = 1;
  ELSIF ltype ILIKE '%LINE%' OR ltype ILIKE 'LINEAL' THEN
    intltype = 2;
  ELSIF ltype ILIKE '%POLYGON%' OR ltype ILIKE 'AREAL' THEN
    intltype = 3;
  ELSIF ltype ILIKE '%COLLECTION%' OR ltype ILIKE 'GEOMETRY' THEN
    intltype = 4;
  ELSE
    RAISE EXCEPTION 'Layer type must be one of POINT,LINE,POLYGON,COLLECTION';
  END IF;

  --
  -- Add new TopoGeometry column in schema.table
  --
  EXECUTE 'ALTER TABLE ' || quote_ident(schema)
    || '.' || quote_ident(tbl) 
    || ' ADD COLUMN ' || quote_ident(col)
    || ' topology.TopoGeometry;';


  --
  -- See if child id exists and extract its level
  --
  IF child IS NOT NULL THEN
    SELECT level + 1 FROM topology.layer
      WHERE layer_id = child
      INTO newlevel;
    IF newlevel IS NULL THEN
      RAISE EXCEPTION 'Child layer % does not exist in topology "%"', child, toponame;
    END IF;
  END IF;

  --
  -- Get new layer id from sequence
  --
  EXECUTE 'SELECT nextval(' ||
    quote_literal(
      quote_ident(toponame) || '.layer_id_seq'
    ) || ')' INTO STRICT newlayer_id;

  EXECUTE 'INSERT INTO ' 
    || 'topology.layer(topology_id, '
    || 'layer_id, level, child_id, schema_name, '
    || 'table_name, feature_column, feature_type) '
    || 'VALUES ('
    || topoid || ','
    || newlayer_id || ',' || COALESCE(newlevel, 0) || ','
    || COALESCE(child::text, 'NULL') || ','
    || quote_literal(schema) || ','
    || quote_literal(tbl) || ','
    || quote_literal(col) || ','
    || intltype || ');';


  --
  -- Create a sequence for TopoGeometries in this new layer
  --
  EXECUTE 'CREATE SEQUENCE ' || quote_ident(toponame)
    || '.topogeo_s_' || newlayer_id;

  --
  -- Add constraints on TopoGeom column
  --
  EXECUTE 'ALTER TABLE ' || quote_ident(schema)
    || '.' || quote_ident(tbl) 
    || ' ADD CONSTRAINT "check_topogeom_' || col || '" CHECK ('
    || 'topology_id(' || quote_ident(col) || ') = ' || topoid
    || ' AND '
    || 'layer_id(' || quote_ident(col) || ') = ' || newlayer_id
    || ' AND '
    || 'type(' || quote_ident(col) || ') = ' || intltype
    || ');';

  --
  -- Add dependency of the feature column on the topology schema
  --
  query = 'INSERT INTO pg_catalog.pg_depend SELECT '
    || 'fcat.oid, fobj.oid, fsub.attnum, tcat.oid, '
    || 'tobj.oid, 0, ''n'' '
    || 'FROM pg_class fcat, pg_namespace fnsp, '
    || ' pg_class fobj, pg_attribute fsub, '
    || ' pg_class tcat, pg_namespace tobj '
    || ' WHERE fcat.relname = ''pg_class'' '
    || ' AND fnsp.nspname = ' || quote_literal(schema)
    || ' AND fobj.relnamespace = fnsp.oid '
    || ' AND fobj.relname = ' || quote_literal(tbl)
    || ' AND fsub.attrelid = fobj.oid '
    || ' AND fsub.attname = ' || quote_literal(col)
    || ' AND tcat.relname = ''pg_namespace'' '
    || ' AND tobj.nspname = ' || quote_literal(toponame);

--
-- The only reason to add this dependency is to avoid
-- simple drop of a feature column. Still, drop cascade
-- will remove both the feature column and the sequence
-- corrupting the topology anyway ...
--

  RETURN newlayer_id;
END;
$$;


ALTER FUNCTION topology.addtopogeometrycolumn(toponame character varying, schema character varying, tbl character varying, col character varying, ltype character varying, child integer) OWNER TO w4;

--
-- Name: FUNCTION addtopogeometrycolumn(toponame character varying, schema character varying, tbl character varying, col character varying, ltype character varying, child integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION addtopogeometrycolumn(toponame character varying, schema character varying, tbl character varying, col character varying, ltype character varying, child integer) IS 'args: topology_name, schema_name, table_name, column_name, feature_type, child_layer - Adds a topogeometry column to an existing table, registers this new column as a layer in topology.layer and returns the new layer_id.';


--
-- Name: addtosearchpath(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION addtosearchpath(a_schema_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	var_result text;
	var_cur_search_path text;
BEGIN
	SELECT reset_val INTO var_cur_search_path FROM pg_settings WHERE name = 'search_path';
	IF var_cur_search_path LIKE '%' || quote_ident(a_schema_name) || '%' THEN
		var_result := a_schema_name || ' already in database search_path';
	ELSE
		EXECUTE 'ALTER DATABASE ' || quote_ident(current_database()) || ' SET search_path = ' || var_cur_search_path || ', ' || quote_ident(a_schema_name); 
		var_result := a_schema_name || ' has been added to end of database search_path ';
	END IF;
  
  RETURN var_result;
END
$$;


ALTER FUNCTION topology.addtosearchpath(a_schema_name character varying) OWNER TO w4;

--
-- Name: asgml(topogeometry); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION asgml(tg topogeometry) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
 SELECT topology.AsGML($1, 'gml');
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry) OWNER TO w4;

--
-- Name: FUNCTION asgml(tg topogeometry); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION asgml(tg topogeometry) IS 'args: tg - Returns the GML representation of a topogeometry.';


--
-- Name: asgml(topogeometry, text); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
 SELECT topology.AsGML($1, $2, 15, 1, NULL);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix text) OWNER TO w4;

--
-- Name: FUNCTION asgml(tg topogeometry, nsprefix text); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION asgml(tg topogeometry, nsprefix text) IS 'args: tg, nsprefix_in - Returns the GML representation of a topogeometry.';


--
-- Name: asgml(topogeometry, regclass); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION asgml(tg topogeometry, visitedtable regclass) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT topology.AsGML($1, 'gml', 15, 1, $2);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, visitedtable regclass) OWNER TO w4;

--
-- Name: FUNCTION asgml(tg topogeometry, visitedtable regclass); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION asgml(tg topogeometry, visitedtable regclass) IS 'args: tg, visitedTable - Returns the GML representation of a topogeometry.';


--
-- Name: asgml(topogeometry, regclass, text); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION asgml(tg topogeometry, visitedtable regclass, nsprefix text) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT topology.AsGML($1, $3, 15, 1, $2);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, visitedtable regclass, nsprefix text) OWNER TO w4;

--
-- Name: FUNCTION asgml(tg topogeometry, visitedtable regclass, nsprefix text); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION asgml(tg topogeometry, visitedtable regclass, nsprefix text) IS 'args: tg, visitedTable, nsprefix - Returns the GML representation of a topogeometry.';


--
-- Name: asgml(topogeometry, text, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, opts integer) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
 SELECT topology.AsGML($1, $2, $3, $4, NULL);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix text, prec integer, opts integer) OWNER TO w4;

--
-- Name: FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, opts integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, opts integer) IS 'args: tg, nsprefix_in, precision, options - Returns the GML representation of a topogeometry.';


--
-- Name: asgml(topogeometry, text, integer, integer, regclass); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, options integer, vis regclass) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT topology.AsGML($1, $2, $3, $4, $5, '');
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix text, prec integer, options integer, vis regclass) OWNER TO w4;

--
-- Name: FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, options integer, vis regclass); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, options integer, vis regclass) IS 'args: tg, nsprefix_in, precision, options, visitedTable - Returns the GML representation of a topogeometry.';


--
-- Name: asgml(topogeometry, text, integer, integer, regclass, text); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, options integer, visitedtable regclass, idprefix text) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT topology.AsGML($1, $2, $3, $4, $5, $6, 3);
$_$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix text, prec integer, options integer, visitedtable regclass, idprefix text) OWNER TO w4;

--
-- Name: FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, options integer, visitedtable regclass, idprefix text); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION asgml(tg topogeometry, nsprefix text, prec integer, options integer, visitedtable regclass, idprefix text) IS 'args: tg, nsprefix_in, precision, options, visitedTable, idprefix - Returns the GML representation of a topogeometry.';


--
-- Name: asgml(topogeometry, text, integer, integer, regclass, text, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION asgml(tg topogeometry, nsprefix_in text, precision_in integer, options_in integer, visitedtable regclass, idprefix text, gmlver integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  nsprefix text;
  precision int;
  options int;
  visited bool;
  toponame text;
  gml text;
  sql text;
  rec RECORD;
  rec2 RECORD;
BEGIN

  nsprefix := 'gml:';
  IF nsprefix_in IS NOT NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  precision := 15;
  IF precision_in IS NOT NULL THEN
    precision = precision_in;
  END IF;

  options := 1;
  IF options_in IS NOT NULL THEN
    options = options_in;
  END IF;

  -- Get topology name (for subsequent queries)
  SELECT name FROM topology.topology into toponame
              WHERE id = tg.topology_id;

  -- Puntual TopoGeometry
  IF tg.type = 1 THEN
    gml = '<' || nsprefix || 'TopoPoint>';
    -- For each defining node, print a directedNode
    FOR rec IN  EXECUTE 'SELECT r.element_id, n.geom from '
      || quote_ident(toponame) || '.relation r LEFT JOIN '
      || quote_ident(toponame) || '.node n ON (r.element_id = n.node_id)'
      || ' WHERE r.layer_id = ' || tg.layer_id
      || ' AND r.topogeo_id = ' || tg.id
    LOOP
      gml = gml || '<' || nsprefix || 'directedNode';
      -- Do visited bookkeeping if visitedTable was given
      IF visitedTable IS NOT NULL THEN
        EXECUTE 'SELECT true FROM '
                || visitedTable::text
                || ' WHERE element_type = 1 AND element_id = '
                || rec.element_id LIMIT 1 INTO visited;
        IF visited IS NOT NULL THEN
          gml = gml || ' xlink:href="#' || idprefix || 'N' || rec.element_id || '" />';
          CONTINUE;
        ELSE
          -- Mark as visited 
          EXECUTE 'INSERT INTO ' || visitedTable::text
            || '(element_type, element_id) VALUES (1, '
            || rec.element_id || ')';
        END IF;
      END IF;
      gml = gml || '>';
      gml = gml || topology._AsGMLNode(rec.element_id, rec.geom, nsprefix_in, precision, options, idprefix, gmlver);
      gml = gml || '</' || nsprefix || 'directedNode>';
    END LOOP;
    gml = gml || '</' || nsprefix || 'TopoPoint>';
    RETURN gml;

  ELSIF tg.type = 2 THEN -- lineal
    gml = '<' || nsprefix || 'TopoCurve>';

    FOR rec IN SELECT (ST_Dump(topology.Geometry(tg))).geom
    LOOP
      FOR rec2 IN EXECUTE
        'SELECT e.*, ST_LineLocatePoint('
        || quote_literal(rec.geom::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
        || ', ST_LineLocatePoint('
        || quote_literal(rec.geom::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
        || quote_ident(toponame)
        || '.edge e WHERE ST_Covers('
        || quote_literal(rec.geom::text)
        || ', e.geom) ORDER BY pos'
        -- TODO: add relation to the conditional, to reduce load ?
      LOOP

        gml = gml || '<' || nsprefix || 'directedEdge';

        -- if this edge goes in opposite direction to the
        --       line, make it with negative orientation
        IF rec2.pos2 < rec2.pos THEN -- edge goes in opposite direction
          gml = gml || ' orientation="-"';
        END IF;

        -- Do visited bookkeeping if visitedTable was given
        IF visitedTable IS NOT NULL THEN

          EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 2 AND element_id = '
            || rec2.edge_id LIMIT 1 INTO visited;
          IF visited THEN
            -- Use xlink:href if visited
            gml = gml || ' xlink:href="#' || idprefix || 'E' || rec2.edge_id || '" />';
            CONTINUE;
          ELSE
            -- Mark as visited otherwise
            EXECUTE 'INSERT INTO ' || visitedTable::text
              || '(element_type, element_id) VALUES (2, '
              || rec2.edge_id || ')';
          END IF;

        END IF;


        gml = gml || '>';

        gml = gml || topology._AsGMLEdge(rec2.edge_id,
                                        rec2.start_node,
                                        rec2.end_node, rec2.geom,
                                        visitedTable,
                                        nsprefix_in, precision,
                                        options, idprefix, gmlver);


        gml = gml || '</' || nsprefix || 'directedEdge>';
      END LOOP;
    END LOOP;

    gml = gml || '</' || nsprefix || 'TopoCurve>';
    return gml;

  ELSIF tg.type = 3 THEN -- areal
    gml = '<' || nsprefix || 'TopoSurface>';

    -- For each defining face, print a directedFace
    FOR rec IN  EXECUTE 'SELECT f.face_id from '
      || quote_ident(toponame) || '.relation r LEFT JOIN '
      || quote_ident(toponame) || '.face f ON (r.element_id = f.face_id)'
      || ' WHERE r.layer_id = ' || tg.layer_id
      || ' AND r.topogeo_id = ' || tg.id
    LOOP
      gml = gml || '<' || nsprefix || 'directedFace';
      -- Do visited bookkeeping if visitedTable was given
      IF visitedTable IS NOT NULL THEN
        EXECUTE 'SELECT true FROM '
                || visitedTable::text
                || ' WHERE element_type = 3 AND element_id = '
                || rec.face_id LIMIT 1 INTO visited;
        IF visited IS NOT NULL THEN
          gml = gml || ' xlink:href="#' || idprefix || 'F' || rec.face_id || '" />';
          CONTINUE;
        ELSE
          -- Mark as visited 
          EXECUTE 'INSERT INTO ' || visitedTable::text
            || '(element_type, element_id) VALUES (3, '
            || rec.face_id || ')';
        END IF;
      END IF;
      gml = gml || '>';
      gml = gml || topology._AsGMLFace(toponame, rec.face_id, visitedTable,
                                       nsprefix_in, precision,
                                       options, idprefix, gmlver);
      gml = gml || '</' || nsprefix || 'directedFace>';
    END LOOP;
    gml = gml || '</' || nsprefix || 'TopoSurface>';
    RETURN gml;

  ELSIF tg.type = 4 THEN -- collection
    RAISE EXCEPTION 'Collection TopoGeometries are not supported by AsGML';

  END IF;
	

  RETURN gml;
	
END
$$;


ALTER FUNCTION topology.asgml(tg topogeometry, nsprefix_in text, precision_in integer, options_in integer, visitedtable regclass, idprefix text, gmlver integer) OWNER TO w4;

--
-- Name: FUNCTION asgml(tg topogeometry, nsprefix_in text, precision_in integer, options_in integer, visitedtable regclass, idprefix text, gmlver integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION asgml(tg topogeometry, nsprefix_in text, precision_in integer, options_in integer, visitedtable regclass, idprefix text, gmlver integer) IS 'args: tg, nsprefix_in, precision, options, visitedTable, idprefix, gmlversion - Returns the GML representation of a topogeometry.';


--
-- Name: astopojson(topogeometry, regclass); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION astopojson(tg topogeometry, edgemaptable regclass) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  toponame text;
  json text;
  sql text;
  bounds GEOMETRY;
  rec RECORD;
  rec2 RECORD;
  side int;
  arcid int;
  arcs int[];
  ringtxt TEXT[];
  comptxt TEXT[];
  edges_found BOOLEAN;
  old_search_path TEXT;
  all_faces int[];
  faces int[];
  visited_face int;
  shell_faces int[];
  visited_edges int[];
  looking_for_holes BOOLEAN;
BEGIN

  IF tg IS NULL THEN
    RETURN NULL;
  END IF;

  -- Get topology name (for subsequent queries)
  SELECT name FROM topology.topology into toponame
              WHERE id = tg.topology_id;

  -- Puntual TopoGeometry
  IF tg.type = 1 THEN
    -- TODO: implement scale ?
    --json := ST_AsGeoJSON(topology.Geometry(tg));
    --return json;
    RAISE EXCEPTION 'TopoJSON export does not support puntual objects';
  ELSIF tg.type = 2 THEN -- lineal

    FOR rec IN SELECT (ST_Dump(topology.Geometry(tg))).geom
    LOOP -- {

      sql := 'SELECT e.*, ST_LineLocatePoint('
            || quote_literal(rec.geom::text)
            || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
            || ', ST_LineLocatePoint('
            || quote_literal(rec.geom::text)
            || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
            || quote_ident(toponame)
            || '.edge e WHERE ST_Covers('
            || quote_literal(rec.geom::text)
            || ', e.geom) ORDER BY pos';
            -- TODO: add relation to the conditional, to reduce load ?
      FOR rec2 IN EXECUTE sql
      LOOP -- {

        IF edgeMapTable IS NOT NULL THEN
          sql := 'SELECT arc_id-1 FROM ' || edgeMapTable::text || ' WHERE edge_id = ' || rec2.edge_id;
          EXECUTE sql INTO arcid;
          IF arcid IS NULL THEN
            EXECUTE 'INSERT INTO ' || edgeMapTable::text
              || '(edge_id) VALUES (' || rec2.edge_id || ') RETURNING arc_id-1'
            INTO arcid;
          END IF;
        ELSE
          arcid := rec2.edge_id;
        END IF;

        -- edge goes in opposite direction
        IF rec2.pos2 < rec2.pos THEN
          arcid := -(arcid+1);
        END IF;

        arcs := arcs || arcid;

      END LOOP; -- }

      comptxt := comptxt || ( '[' || array_to_string(arcs, ',') || ']' );
      arcs := NULL;

    END LOOP; -- }

    json := '{ "type": "MultiLineString", "arcs": [' || array_to_string(comptxt,',') || ']}';

    return json;

  ELSIF tg.type = 3 THEN -- areal

    json := '{ "type": "MultiPolygon", "arcs": [';

    EXECUTE 'SHOW search_path' INTO old_search_path;
    EXECUTE 'SET search_path TO ' || quote_ident(toponame) || ',' || old_search_path;

    SELECT array_agg(id) as f
    FROM ( SELECT (GetTopoGeomElements(tg))[1] as id ) as f
    INTO all_faces;


    visited_edges := ARRAY[]::int[];
    faces := all_faces;
    looking_for_holes := false;
    shell_faces := ARRAY[]::int[];

    LOOP -- {

      arcs := NULL;
      edges_found := false;


      FOR rec in -- {
WITH RECURSIVE
_edges AS (
  SELECT e.*, 
         e.left_face = ANY ( faces ) as lf,
         e.right_face = ANY ( faces ) as rf
  FROM edge e
  WHERE ( e.left_face = ANY ( faces ) OR
          e.right_face = ANY ( faces ) )
),
_leftmost_non_dangling_edge AS (
  SELECT * FROM _edges e
    WHERE ( e.lf or e.rf ) AND ( e.lf != e.rf )
          AND NOT e.edge_id = ANY ( visited_edges )
      -- TODO: and not in visited ?
  ORDER BY geom LIMIT 1
),
_edgepath AS (
  SELECT
    CASE
      WHEN e.lf THEN lme.edge_id
      ELSE -lme.edge_id
    END as signed_edge_id,
    false as back,

    e.lf = e.rf as dangling,
    e.left_face, e.right_face,
    e.lf, e.rf,
    e.next_right_edge, e.next_left_edge

  FROM _edges e, _leftmost_non_dangling_edge lme
  WHERE e.edge_id = abs(lme.edge_id)
    UNION
  SELECT
    CASE
      WHEN p.dangling AND NOT p.back THEN -p.signed_edge_id
      WHEN p.signed_edge_id < 0 THEN p.next_right_edge
      ELSE p.next_left_edge
    END, -- signed_edge_id
    CASE
      WHEN p.dangling AND NOT p.back THEN true
      ELSE false
    END, -- back

    e.lf = e.rf, -- dangling
    e.left_face, e.right_face,
    e.lf, e.rf,
    e.next_right_edge, e.next_left_edge

  FROM _edges e, _edgepath p
  WHERE
    e.edge_id = CASE
      WHEN p.dangling AND NOT p.back THEN abs(p.signed_edge_id)
      WHEN p.signed_edge_id < 0 THEN abs(p.next_right_edge)
      ELSE abs(p.next_left_edge)
    END
)
SELECT abs(signed_edge_id) as edge_id, signed_edge_id, dangling,
        lf, rf, left_face, right_face
FROM _edgepath
      LOOP  -- }{



        IF rec.left_face = ANY (all_faces) AND NOT rec.left_face = ANY (shell_faces) THEN
          shell_faces := shell_faces || rec.left_face;
        END IF;

        IF rec.right_face = ANY (all_faces) AND NOT rec.right_face = ANY (shell_faces) THEN
          shell_faces := shell_faces || rec.right_face;
        END IF;

        visited_edges := visited_edges || rec.edge_id;

        edges_found := true;

        -- TODO: drop ?
        IF rec.dangling THEN
          CONTINUE;
        END IF;

        IF rec.left_face = ANY (all_faces) AND rec.right_face = ANY (all_faces) THEN
          CONTINUE;
        END IF;

        IF edgeMapTable IS NOT NULL THEN
          sql := 'SELECT arc_id-1 FROM ' || edgeMapTable::text || ' WHERE edge_id = ' || rec.edge_id;
          EXECUTE sql INTO arcid;
          IF arcid IS NULL THEN
            EXECUTE 'INSERT INTO ' || edgeMapTable::text
              || '(edge_id) VALUES (' || rec.edge_id || ') RETURNING arc_id-1'
            INTO arcid;
          END IF;
        ELSE
          arcid := rec.edge_id-1;
        END IF;

        -- Swap sign, use two's complement for negative edges
        IF rec.signed_edge_id >= 0 THEN
          arcid := - ( arcid + 1 );
        END IF;


        arcs := arcid || arcs;

      END LOOP; -- }


      IF NOT edges_found THEN
        IF looking_for_holes THEN
          looking_for_holes := false;
          comptxt := comptxt || ( '[' || array_to_string(ringtxt, ',') || ']' );
          ringtxt := NULL;
          faces := all_faces;
          shell_faces := ARRAY[]::int[];
        ELSE
          EXIT; -- end of loop
        END IF;
      ELSE
        faces := shell_faces;
        IF arcs IS NOT NULL THEN
          ringtxt := ringtxt || ( '[' || array_to_string(arcs,',') || ']' );
        END IF;
        looking_for_holes := true;
      END IF;

    END LOOP; -- }

    json := json || array_to_string(comptxt, ',') || ']}';

    EXECUTE 'SET search_path TO ' || old_search_path;


  ELSIF tg.type = 4 THEN -- collection
    RAISE EXCEPTION 'Collection TopoGeometries are not supported by AsTopoJSON';

  END IF;
	
  RETURN json;
	
END
$$;


ALTER FUNCTION topology.astopojson(tg topogeometry, edgemaptable regclass) OWNER TO w4;

--
-- Name: FUNCTION astopojson(tg topogeometry, edgemaptable regclass); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION astopojson(tg topogeometry, edgemaptable regclass) IS 'args: tg, edgeMapTable - Returns the TopoJSON representation of a topogeometry.';


--
-- Name: cleartopogeom(topogeometry); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION cleartopogeom(tg topogeometry) RETURNS topogeometry
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  topology_info RECORD;
  sql TEXT;
BEGIN

  -- Get topology information
  SELECT id, name FROM topology.topology
    INTO topology_info
    WHERE id = topology_id(tg);
  IF NOT FOUND THEN
      RAISE EXCEPTION 'No topology with id "%" in topology.topology', topology_id(tg);
  END IF;

  -- Clear the TopoGeometry contents
  sql := 'DELETE FROM ' || quote_ident(topology_info.name)
        || '.relation WHERE layer_id = '
        || layer_id(tg)
        || ' AND topogeo_id = '
        || id(tg);
  EXECUTE sql;


  RETURN tg;

END
$$;


ALTER FUNCTION topology.cleartopogeom(tg topogeometry) OWNER TO w4;

--
-- Name: FUNCTION cleartopogeom(tg topogeometry); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION cleartopogeom(tg topogeometry) IS 'args: topogeom - Clears the content of a topo geometry';


--
-- Name: copytopology(character varying, character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION copytopology(atopology character varying, newtopo character varying) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  rec RECORD;
  rec2 RECORD;
  oldtopo_id integer;
  newtopo_id integer;
  n int4;
  ret text;
BEGIN

  SELECT * FROM topology.topology where name = atopology
  INTO strict rec;
  oldtopo_id = rec.id;
  -- TODO: more gracefully handle unexistent topology

  SELECT topology.CreateTopology(newtopo, rec.SRID, rec.precision, rec.hasZ)
  INTO strict newtopo_id;

  -- Copy faces
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.face SELECT * FROM ' || quote_ident(atopology)
    || '.face WHERE face_id != 0';
  -- Update faces sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.face_face_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.face_face_id_seq))';

  -- Copy nodes
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.node SELECT * FROM ' || quote_ident(atopology)
    || '.node';
  -- Update node sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.node_node_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.node_node_id_seq))';

  -- Copy edges
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.edge_data SELECT * FROM ' || quote_ident(atopology)
    || '.edge_data';
  -- Update edge sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.edge_data_edge_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.edge_data_edge_id_seq))';

  -- Copy layers and their TopoGeometry sequences 
  FOR rec IN SELECT * FROM topology.layer WHERE topology_id = oldtopo_id
  LOOP
    INSERT INTO topology.layer (topology_id, layer_id, feature_type,
      level, child_id, schema_name, table_name, feature_column) 
      VALUES (newtopo_id, rec.layer_id, rec.feature_type,
              rec.level, rec.child_id, newtopo,
              'LAYER' ||  rec.layer_id, '');
    -- Create layer's TopoGeometry sequences
    EXECUTE 'SELECT last_value FROM ' 
      || quote_ident(atopology) || '.topogeo_s_' || rec.layer_id 
      INTO STRICT n;
    EXECUTE 'CREATE SEQUENCE ' || quote_ident(newtopo)
      || '.topogeo_s_' || rec.layer_id;
    EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.topogeo_s_' || rec.layer_id
      ) || ', ' || n || ')';
  END LOOP;

  -- Copy TopoGeometry definitions
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.relation SELECT * FROM ' || quote_ident(atopology)
    || '.relation';

  RETURN newtopo_id;
END
$$;


ALTER FUNCTION topology.copytopology(atopology character varying, newtopo character varying) OWNER TO w4;

--
-- Name: FUNCTION copytopology(atopology character varying, newtopo character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION copytopology(atopology character varying, newtopo character varying) IS 'args: existing_topology_name, new_name - Makes a copy of a topology structure (nodes, edges, faces, layers and TopoGeometries).';


--
-- Name: createtopogeom(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION createtopogeom(toponame character varying, tg_type integer, layer_id integer) RETURNS topogeometry
    LANGUAGE sql STRICT
    AS $_$
  SELECT topology.CreateTopoGeom($1,$2,$3,'{{0,0}}');
$_$;


ALTER FUNCTION topology.createtopogeom(toponame character varying, tg_type integer, layer_id integer) OWNER TO w4;

--
-- Name: FUNCTION createtopogeom(toponame character varying, tg_type integer, layer_id integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION createtopogeom(toponame character varying, tg_type integer, layer_id integer) IS 'args: toponame, tg_type, layer_id - Creates a new topo geometry object from topo element array - tg_type: 1:[multi]point, 2:[multi]line, 3:[multi]poly, 4:collection';


--
-- Name: createtopogeom(character varying, integer, integer, topoelementarray); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION createtopogeom(toponame character varying, tg_type integer, layer_id integer, tg_objs topoelementarray) RETURNS topogeometry
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  i integer;
  dims varchar;
  outerdims varchar;
  innerdims varchar;
  obj_type integer;
  obj_id integer;
  ret topology.TopoGeometry;
  rec RECORD;
  layertype integer;
  layerlevel integer;
  layerchild integer;
BEGIN

  IF tg_type < 1 OR tg_type > 4 THEN
    RAISE EXCEPTION 'Invalid TopoGeometry type % (must be in the range 1..4)', tg_type;
  END IF;

  -- Get topology id into return TopoGeometry
  SELECT id FROM topology.topology into ret.topology_id
    WHERE name = toponame;

  --
  -- Get layer info
  --
  layertype := NULL;
  FOR rec IN EXECUTE 'SELECT * FROM topology.layer'
    || ' WHERE topology_id = ' || ret.topology_id
    || ' AND layer_id = ' || layer_id
  LOOP
    layertype = rec.feature_type;
    layerlevel = rec.level;
    layerchild = rec.child_id;
  END LOOP;

  -- Check for existence of given layer id
  IF layertype IS NULL THEN
    RAISE EXCEPTION 'No layer with id % is registered with topology %', layer_id, toponame;
  END IF;

  -- Verify compatibility between layer geometry type and
  -- TopoGeom requested geometry type
  IF layertype != 4 and layertype != tg_type THEN
    RAISE EXCEPTION 'A Layer of type % cannot contain a TopoGeometry of type %', layertype, tg_type;
  END IF;

  -- Set layer id and type in return object
  ret.layer_id = layer_id;
  ret.type = tg_type;

  --
  -- Get new TopoGeo id from sequence
  --
  FOR rec IN EXECUTE 'SELECT nextval(' ||
    quote_literal(
      quote_ident(toponame) || '.topogeo_s_' || layer_id
    ) || ')'
  LOOP
    ret.id = rec.nextval;
  END LOOP;

  -- Loop over outer dimension
  i = array_lower(tg_objs, 1);
  LOOP
    obj_id = tg_objs[i][1];
    obj_type = tg_objs[i][2];

    -- Elements of type 0 represent emptiness, just skip them
    IF obj_type = 0 THEN
      IF obj_id != 0 THEN
        RAISE EXCEPTION 'Malformed empty topo element {0,%} -- id must be 0 as well', obj_id;
      END IF;
    ELSE
      IF layerlevel = 0 THEN -- array specifies lower-level objects
        IF tg_type != 4 and tg_type != obj_type THEN
          RAISE EXCEPTION 'A TopoGeometry of type % cannot contain topology elements of type %', tg_type, obj_type;
        END IF;
      ELSE -- array specifies lower-level topogeometries
        IF obj_type != layerchild THEN
          RAISE EXCEPTION 'TopoGeom element layer do not match TopoGeom child layer';
        END IF;
        -- TODO: verify that the referred TopoGeometry really
        -- exists in the relation table ?
      END IF;

      --RAISE NOTICE 'obj:% type:% id:%', i, obj_type, obj_id;

      --
      -- Insert record into the Relation table
      --
      EXECUTE 'INSERT INTO '||quote_ident(toponame)
        || '.relation(topogeo_id, layer_id, '
        || 'element_id,element_type) '
        || ' VALUES ('||ret.id
        ||','||ret.layer_id
        || ',' || obj_id || ',' || obj_type || ');';
    END IF;

    i = i+1;
    IF i > array_upper(tg_objs, 1) THEN
      EXIT;
    END IF;
  END LOOP;

  RETURN ret;

END
$$;


ALTER FUNCTION topology.createtopogeom(toponame character varying, tg_type integer, layer_id integer, tg_objs topoelementarray) OWNER TO w4;

--
-- Name: FUNCTION createtopogeom(toponame character varying, tg_type integer, layer_id integer, tg_objs topoelementarray); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION createtopogeom(toponame character varying, tg_type integer, layer_id integer, tg_objs topoelementarray) IS 'args: toponame, tg_type, layer_id, tg_objs - Creates a new topo geometry object from topo element array - tg_type: 1:[multi]point, 2:[multi]line, 3:[multi]poly, 4:collection';


--
-- Name: createtopology(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION createtopology(character varying) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT topology.CreateTopology($1, ST_SRID('POINT EMPTY'::geometry), 0); $_$;


ALTER FUNCTION topology.createtopology(character varying) OWNER TO w4;

--
-- Name: FUNCTION createtopology(character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION createtopology(character varying) IS 'args: topology_schema_name - Creates a new topology schema and registers this new schema in the topology.topology table.';


--
-- Name: createtopology(character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION createtopology(character varying, integer) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT topology.CreateTopology($1, $2, 0); $_$;


ALTER FUNCTION topology.createtopology(character varying, integer) OWNER TO w4;

--
-- Name: FUNCTION createtopology(character varying, integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION createtopology(character varying, integer) IS 'args: topology_schema_name, srid - Creates a new topology schema and registers this new schema in the topology.topology table.';


--
-- Name: createtopology(character varying, integer, double precision); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION createtopology(toponame character varying, srid integer, prec double precision) RETURNS integer
    LANGUAGE sql STRICT
    AS $_$ SELECT topology.CreateTopology($1, $2, $3, false);$_$;


ALTER FUNCTION topology.createtopology(toponame character varying, srid integer, prec double precision) OWNER TO w4;

--
-- Name: FUNCTION createtopology(toponame character varying, srid integer, prec double precision); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION createtopology(toponame character varying, srid integer, prec double precision) IS 'args: topology_schema_name, srid, tolerance - Creates a new topology schema and registers this new schema in the topology.topology table.';


--
-- Name: createtopology(character varying, integer, double precision, boolean); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION createtopology(atopology character varying, srid integer, prec double precision, hasz boolean) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  rec RECORD;
  topology_id integer;
  ndims integer;
BEGIN

--  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
--  LOOP
--    RAISE EXCEPTION 'SQL/MM Spatial exception - schema already exists';
--  END LOOP;

  ndims = 2;
  IF hasZ THEN ndims = 3; END IF;

  ------ Fetch next id for the new topology
  FOR rec IN SELECT nextval('topology.topology_id_seq')
  LOOP
    topology_id = rec.nextval;
  END LOOP;


  EXECUTE 'CREATE SCHEMA ' || quote_ident(atopology);

  -------------{ face CREATION
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.face ('
  || 'face_id SERIAL,'
  || ' CONSTRAINT face_primary_key PRIMARY KEY(face_id)'
  || ');';

  -- Add mbr column to the face table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''face'',''mbr'','||quote_literal(srid)
  ||',''POLYGON'',2)'; -- 2d only mbr is good enough

  -------------} END OF face CREATION


  --------------{ node CREATION

  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.node ('
  || 'node_id SERIAL,'
  --|| 'geom GEOMETRY,'
  || 'containing_face INTEGER,'

  || 'CONSTRAINT node_primary_key PRIMARY KEY(node_id),'

  --|| 'CONSTRAINT node_geometry_type CHECK '
  --|| '( GeometryType(geom) = ''POINT'' ),'

  || 'CONSTRAINT face_exists FOREIGN KEY(containing_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id)'

  || ');';

  -- Add geometry column to the node table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''node'',''geom'','||quote_literal(srid)
  ||',''POINT'',' || ndims || ')';

  --------------} END OF node CREATION

  --------------{ edge CREATION

  -- edge_data table
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.edge_data ('
  || 'edge_id SERIAL NOT NULL PRIMARY KEY,'
  || 'start_node INTEGER NOT NULL,'
  || 'end_node INTEGER NOT NULL,'
  || 'next_left_edge INTEGER NOT NULL,'
  || 'abs_next_left_edge INTEGER NOT NULL,'
  || 'next_right_edge INTEGER NOT NULL,'
  || 'abs_next_right_edge INTEGER NOT NULL,'
  || 'left_face INTEGER NOT NULL,'
  || 'right_face INTEGER NOT NULL,'
  --|| 'geom GEOMETRY NOT NULL,'

  --|| 'CONSTRAINT edge_geometry_type CHECK '
  --|| '( GeometryType(geom) = ''LINESTRING'' ),'

  || 'CONSTRAINT start_node_exists FOREIGN KEY(start_node)'
  || ' REFERENCES ' || quote_ident(atopology) || '.node(node_id),'

  || 'CONSTRAINT end_node_exists FOREIGN KEY(end_node) '
  || ' REFERENCES ' || quote_ident(atopology) || '.node(node_id),'

  || 'CONSTRAINT left_face_exists FOREIGN KEY(left_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id),'

  || 'CONSTRAINT right_face_exists FOREIGN KEY(right_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id),'

  || 'CONSTRAINT next_left_edge_exists FOREIGN KEY(abs_next_left_edge)'
  || ' REFERENCES ' || quote_ident(atopology)
  || '.edge_data(edge_id)'
  || ' DEFERRABLE INITIALLY DEFERRED,'

  || 'CONSTRAINT next_right_edge_exists '
  || 'FOREIGN KEY(abs_next_right_edge)'
  || ' REFERENCES ' || quote_ident(atopology)
  || '.edge_data(edge_id) '
  || ' DEFERRABLE INITIALLY DEFERRED'
  || ');';

  -- Add geometry column to the edge_data table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''edge_data'',''geom'','||quote_literal(srid)
  ||',''LINESTRING'',' || ndims || ')';


  -- edge standard view (select rule)
  EXECUTE 'CREATE VIEW ' || quote_ident(atopology)
    || '.edge AS SELECT '
    || ' edge_id, start_node, end_node, next_left_edge, '
    || ' next_right_edge, '
    || ' left_face, right_face, geom FROM '
    || quote_ident(atopology) || '.edge_data';

  -- edge standard view description
  EXECUTE 'COMMENT ON VIEW ' || quote_ident(atopology)
    || '.edge IS '
    || '''Contains edge topology primitives''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.edge_id IS '
    || '''Unique identifier of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.start_node IS '
    || '''Unique identifier of the node at the start of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.end_node IS '
    || '''Unique identifier of the node at the end of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.next_left_edge IS '
    || '''Unique identifier of the next edge of the face on the left (when looking in the direction from START_NODE to END_NODE), moving counterclockwise around the face boundary''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.next_right_edge IS '
    || '''Unique identifier of the next edge of the face on the right (when looking in the direction from START_NODE to END_NODE), moving counterclockwise around the face boundary''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.left_face IS '
    || '''Unique identifier of the face on the left side of the edge when looking in the direction from START_NODE to END_NODE''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.right_face IS '
    || '''Unique identifier of the face on the right side of the edge when looking in the direction from START_NODE to END_NODE''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.geom IS '
    || '''The geometry of the edge''';

  -- edge standard view (insert rule)
  EXECUTE 'CREATE RULE edge_insert_rule AS ON INSERT '
          || 'TO ' || quote_ident(atopology)
    || '.edge DO INSTEAD '
                || ' INSERT into ' || quote_ident(atopology)
    || '.edge_data '
                || ' VALUES (NEW.edge_id, NEW.start_node, NEW.end_node, '
    || ' NEW.next_left_edge, abs(NEW.next_left_edge), '
    || ' NEW.next_right_edge, abs(NEW.next_right_edge), '
    || ' NEW.left_face, NEW.right_face, NEW.geom);';

  --------------} END OF edge CREATION

  --------------{ layer sequence 
  EXECUTE 'CREATE SEQUENCE '
    || quote_ident(atopology) || '.layer_id_seq;';
  --------------} layer sequence

  --------------{ relation CREATION
  --
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.relation ('
  || ' topogeo_id integer NOT NULL, '
  || ' layer_id integer NOT NULL, ' 
  || ' element_id integer NOT NULL, '
  || ' element_type integer NOT NULL, '
  || ' UNIQUE(layer_id,topogeo_id,element_id,element_type));';

  EXECUTE 
  'CREATE TRIGGER relation_integrity_checks '
  ||'BEFORE UPDATE OR INSERT ON '
  || quote_ident(atopology) || '.relation FOR EACH ROW '
  || ' EXECUTE PROCEDURE topology.RelationTrigger('
  ||topology_id||','||quote_literal(atopology)||')';
  --------------} END OF relation CREATION

  
  ------- Default (world) face
  EXECUTE 'INSERT INTO ' || quote_ident(atopology) || '.face(face_id) VALUES(0);';

  ------- GiST index on face
  EXECUTE 'CREATE INDEX face_gist ON '
    || quote_ident(atopology)
    || '.face using gist (mbr);';

  ------- GiST index on node
  EXECUTE 'CREATE INDEX node_gist ON '
    || quote_ident(atopology)
    || '.node using gist (geom);';

  ------- GiST index on edge
  EXECUTE 'CREATE INDEX edge_gist ON '
    || quote_ident(atopology)
    || '.edge_data using gist (geom);';

  ------- Indexes on left_face and right_face of edge_data
  ------- NOTE: these indexes speed up GetFaceGeometry (and thus
  -------       TopoGeometry::Geometry) by a factor of 10 !
  -------       See http://trac.osgeo.org/postgis/ticket/806
  EXECUTE 'CREATE INDEX edge_left_face_idx ON '
    || quote_ident(atopology)
    || '.edge_data (left_face);';
  EXECUTE 'CREATE INDEX edge_right_face_idx ON '
    || quote_ident(atopology)
    || '.edge_data (right_face);';

  ------- Indexes on start_node and end_node of edge_data
  ------- NOTE: this indexes speed up node deletion
  -------       by a factor of 1000 !
  -------       See http://trac.osgeo.org/postgis/ticket/2082
  EXECUTE 'CREATE INDEX edge_start_node_idx ON '
    || quote_ident(atopology)
    || '.edge_data (start_node);';
  EXECUTE 'CREATE INDEX edge_end_node_idx ON '
    || quote_ident(atopology)
    || '.edge_data (end_node);';

  -- TODO: consider also adding an index on node.containing_face 

  ------- Add record to the "topology" metadata table
  EXECUTE 'INSERT INTO topology.topology '
    || '(id, name, srid, precision, hasZ) VALUES ('
    || quote_literal(topology_id) || ','
    || quote_literal(atopology) || ','
    || quote_literal(srid) || ',' || quote_literal(prec)
    || ',' || hasZ
    || ')';

  RETURN topology_id;
END
$$;


ALTER FUNCTION topology.createtopology(atopology character varying, srid integer, prec double precision, hasz boolean) OWNER TO w4;

--
-- Name: FUNCTION createtopology(atopology character varying, srid integer, prec double precision, hasz boolean); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION createtopology(atopology character varying, srid integer, prec double precision, hasz boolean) IS 'args: topology_schema_name, srid, tolerance, hasz - Creates a new topology schema and registers this new schema in the topology.topology table.';


--
-- Name: droptopogeometrycolumn(character varying, character varying, character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION droptopogeometrycolumn(schema character varying, tbl character varying, col character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  lyrinfo RECORD;
  ok BOOL;
  result text;
BEGIN

        -- Get layer and topology info
  ok = false;
  FOR rec IN EXECUTE 'SELECT t.name as toponame, l.* FROM '
    || 'topology.topology t, topology.layer l '
    || ' WHERE l.topology_id = t.id'
    || ' AND l.schema_name = ' || quote_literal(schema)
    || ' AND l.table_name = ' || quote_literal(tbl)
    || ' AND l.feature_column = ' || quote_literal(col)
  LOOP
    ok = true;
    lyrinfo = rec;
  END LOOP;

  -- Layer not found
  IF NOT ok THEN
    RAISE EXCEPTION 'No layer registered on %.%.%',
      schema,tbl,col;
  END IF;
    
  -- Clean up the topology schema
  FOR rec IN SELECT * FROM pg_namespace
    WHERE text(nspname) = lyrinfo.toponame
  LOOP
    -- Cleanup the relation table
    EXECUTE 'DELETE FROM ' || quote_ident(lyrinfo.toponame)
      || '.relation '
      || ' WHERE '
      || 'layer_id = ' || lyrinfo.layer_id;

    -- Drop the sequence for topogeoms in this layer
    EXECUTE 'DROP SEQUENCE ' || quote_ident(lyrinfo.toponame)
      || '.topogeo_s_' || lyrinfo.layer_id;

  END LOOP;

  ok = false;
  FOR rec IN SELECT * FROM pg_namespace n, pg_class c, pg_attribute a
    WHERE text(n.nspname) = schema
    AND c.relnamespace = n.oid
    AND text(c.relname) = tbl
    AND a.attrelid = c.oid
    AND text(a.attname) = col
  LOOP
    ok = true;
    EXIT;
  END LOOP;


  IF ok THEN
    -- Set feature column to NULL to bypass referential integrity
    -- checks
    EXECUTE 'UPDATE ' || quote_ident(schema) || '.'
      || quote_ident(tbl)
      || ' SET ' || quote_ident(col)
      || ' = NULL';
  END IF;

  -- Delete the layer record
  EXECUTE 'DELETE FROM topology.layer '
    || ' WHERE topology_id = ' || lyrinfo.topology_id
    || ' AND layer_id = ' || lyrinfo.layer_id;

  IF ok THEN
    -- Drop the layer column
    EXECUTE 'ALTER TABLE ' || quote_ident(schema) || '.'
      || quote_ident(tbl)
      || ' DROP ' || quote_ident(col)
      || ' cascade';
  END IF;

  result = 'Layer ' || lyrinfo.layer_id || ' ('
    || schema || '.' || tbl || '.' || col
    || ') dropped';

  RETURN result;
END;
$$;


ALTER FUNCTION topology.droptopogeometrycolumn(schema character varying, tbl character varying, col character varying) OWNER TO w4;

--
-- Name: FUNCTION droptopogeometrycolumn(schema character varying, tbl character varying, col character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION droptopogeometrycolumn(schema character varying, tbl character varying, col character varying) IS 'args: schema_name, table_name, column_name - Drops the topogeometry column from the table named table_name in schema schema_name and unregisters the columns from topology.layer table.';


--
-- Name: droptopology(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION droptopology(atopology character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  topoid integer;
  rec RECORD;
BEGIN

  -- Get topology id
        SELECT id FROM topology.topology into topoid
                WHERE name = atopology;


  IF topoid IS NOT NULL THEN

    RAISE NOTICE 'Dropping all layers from topology % (%)',
      atopology, topoid;

    -- Drop all layers in the topology
    FOR rec IN EXECUTE 'SELECT * FROM topology.layer WHERE '
      || ' topology_id = ' || topoid
    LOOP

      EXECUTE 'SELECT topology.DropTopoGeometryColumn('
        || quote_literal(rec.schema_name)
        || ','
        || quote_literal(rec.table_name)
        || ','
        || quote_literal(rec.feature_column)
        || ')';
    END LOOP;

    -- Delete record from topology.topology
    EXECUTE 'DELETE FROM topology.topology WHERE id = '
      || topoid;

  END IF;


  -- Drop the schema (if it exists)
  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
  LOOP
    EXECUTE 'DROP SCHEMA '||quote_ident(atopology)||' CASCADE';
  END LOOP;

  RETURN 'Topology ' || quote_literal(atopology) || ' dropped';
END
$$;


ALTER FUNCTION topology.droptopology(atopology character varying) OWNER TO w4;

--
-- Name: FUNCTION droptopology(atopology character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION droptopology(atopology character varying) IS 'args: topology_schema_name - Use with caution: Drops a topology schema and deletes its reference from topology.topology table and references to tables in that schema from the geometry_columns table.';


--
-- Name: equals(topogeometry, topogeometry); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION equals(tg1 topogeometry, tg2 topogeometry) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  rec RECORD;
  toponame varchar;
  query text;
BEGIN

  IF tg1.topology_id != tg2.topology_id THEN
    -- TODO: revert to ::geometry instead ?
    RAISE EXCEPTION 'Cannot compare TopoGeometries from different topologies';
  END IF;

  -- Not the same type, not equal
  IF tg1.type != tg2.type THEN
    RETURN FALSE;
  END IF;

  -- Geometry collection are not currently supported
  IF tg2.type = 4 THEN
    RAISE EXCEPTION 'GeometryCollection are not supported by equals()';
  END IF;

        -- Get topology name
        SELECT name FROM topology.topology into toponame
                WHERE id = tg1.topology_id;

  -- Two geometries are equal if they are composed by 
  -- the same TopoElements
  FOR rec IN EXECUTE 'SELECT * FROM '
    || ' topology.GetTopoGeomElements('
    || quote_literal(toponame) || ', '
    || tg1.layer_id || ',' || tg1.id || ') '
    || ' EXCEPT SELECT * FROM '
    || ' topology.GetTopogeomElements('
    || quote_literal(toponame) || ', '
    || tg2.layer_id || ',' || tg2.id || ');'
  LOOP
    RETURN FALSE;
  END LOOP;

  FOR rec IN EXECUTE 'SELECT * FROM '
    || ' topology.GetTopoGeomElements('
    || quote_literal(toponame) || ', '
    || tg2.layer_id || ',' || tg2.id || ')'
    || ' EXCEPT SELECT * FROM '
    || ' topology.GetTopogeomElements('
    || quote_literal(toponame) || ', '
    || tg1.layer_id || ',' || tg1.id || '); '
  LOOP
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END
$$;


ALTER FUNCTION topology.equals(tg1 topogeometry, tg2 topogeometry) OWNER TO w4;

--
-- Name: geometrytype(topogeometry); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION geometrytype(tg topogeometry) RETURNS text
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT CASE
		WHEN type($1) = 1 THEN 'MULTIPOINT'
		WHEN type($1) = 2 THEN 'MULTILINESTRING'
		WHEN type($1) = 3 THEN 'MULTIPOLYGON'
		WHEN type($1) = 4 THEN 'GEOMETRYCOLLECTION'
		ELSE 'UNEXPECTED'
		END;
$_$;


ALTER FUNCTION topology.geometrytype(tg topogeometry) OWNER TO w4;

--
-- Name: getnodeedges(character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION getnodeedges(atopology character varying, anode integer) RETURNS SETOF getfaceedges_returntype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  curedge int;
  nextedge int;
  rec RECORD;
  retrec topology.GetFaceEdges_ReturnType;
  n int;
  sql text;
BEGIN

  n := 0;
  sql :=
    'WITH incident_edges AS ( SELECT edge_id, start_node, end_node, ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anode
    || ' or end_node = ' || anode
    || ') SELECT edge_id, ST_Azimuth(ST_StartPoint(geom), ST_PointN(geom, 2)) as az FROM  incident_edges WHERE start_node = ' || anode
    || ' UNION ALL SELECT -edge_id, ST_Azimuth(ST_EndPoint(geom), ST_PointN(geom, ST_NumPoints(geom)-1)) FROM incident_edges WHERE end_node = ' || anode
    || ' ORDER BY az';

  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    n := n + 1;
    retrec.sequence := n;
    retrec.edge := rec.edge_id;
    RETURN NEXT retrec;
  END LOOP; -- incident edges }

END
$$;


ALTER FUNCTION topology.getnodeedges(atopology character varying, anode integer) OWNER TO w4;

--
-- Name: FUNCTION getnodeedges(atopology character varying, anode integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION getnodeedges(atopology character varying, anode integer) IS 'args: atopology, anode - Returns an ordered set of edges incident to the given node.';


--
-- Name: getringedges(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION getringedges(atopology character varying, anedge integer, maxedges integer DEFAULT NULL::integer) RETURNS SETOF getfaceedges_returntype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  rec RECORD;
  retrec topology.GetFaceEdges_ReturnType;
  n int;
  sql text;
BEGIN
  sql := 'WITH RECURSIVE edgering AS ( SELECT '
    || anedge
    || ' as signed_edge_id, edge_id, next_left_edge, next_right_edge FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE edge_id = '
    || abs(anedge)
    || ' UNION '
    || ' SELECT CASE WHEN p.signed_edge_id < 0 THEN p.next_right_edge '
    || ' ELSE p.next_left_edge END, e.edge_id, e.next_left_edge, e.next_right_edge '
    || ' FROM ' || quote_ident(atopology)
    || '.edge_data e, edgering p WHERE e.edge_id = CASE WHEN p.signed_edge_id < 0 '
    || 'THEN abs(p.next_right_edge) ELSE abs(p.next_left_edge) END ) SELECT * FROM edgering';

  n := 1;
  FOR rec IN EXECUTE sql
  LOOP
    retrec.sequence := n;
    retrec.edge := rec.signed_edge_id;
    RETURN NEXT retrec;

    n := n + 1;

    IF n > maxedges THEN
      RAISE EXCEPTION 'Max traversing limit hit: %', maxedges;
    END IF;
  END LOOP;

END
$$;


ALTER FUNCTION topology.getringedges(atopology character varying, anedge integer, maxedges integer) OWNER TO w4;

--
-- Name: FUNCTION getringedges(atopology character varying, anedge integer, maxedges integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION getringedges(atopology character varying, anedge integer, maxedges integer) IS 'args: atopology, aring, max_edges=null - Returns an ordered set of edges forming a ring with the given edge .';


--
-- Name: gettopogeomelementarray(topogeometry); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION gettopogeomelementarray(tg topogeometry) RETURNS topoelementarray
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  toponame varchar;
BEGIN
  toponame = topology.GetTopologyName(tg.topology_id);
  RETURN topology.GetTopoGeomElementArray(toponame, tg.layer_id, tg.id);
END;
$$;


ALTER FUNCTION topology.gettopogeomelementarray(tg topogeometry) OWNER TO w4;

--
-- Name: FUNCTION gettopogeomelementarray(tg topogeometry); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION gettopogeomelementarray(tg topogeometry) IS 'args: tg - Returns a topoelementarray (an array of topoelements) containing the topological elements and type of the given TopoGeometry (primitive elements)';


--
-- Name: gettopogeomelementarray(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION gettopogeomelementarray(toponame character varying, layer_id integer, tgid integer) RETURNS topoelementarray
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  rec RECORD;
  tg_objs varchar := '{';
  i integer;
  query text;
BEGIN

  query = 'SELECT * FROM topology.GetTopoGeomElements('
    || quote_literal(toponame) || ','
    || quote_literal(layer_id) || ','
    || quote_literal(tgid)
    || ') as obj ORDER BY obj';


  -- TODO: why not using array_agg here ?

  i = 1;
  FOR rec IN EXECUTE query
  LOOP
    IF i > 1 THEN
      tg_objs = tg_objs || ',';
    END IF;
    tg_objs = tg_objs || '{'
      || rec.obj[1] || ',' || rec.obj[2]
      || '}';
    i = i+1;
  END LOOP;

  tg_objs = tg_objs || '}';

  RETURN tg_objs;
END;
$$;


ALTER FUNCTION topology.gettopogeomelementarray(toponame character varying, layer_id integer, tgid integer) OWNER TO w4;

--
-- Name: FUNCTION gettopogeomelementarray(toponame character varying, layer_id integer, tgid integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION gettopogeomelementarray(toponame character varying, layer_id integer, tgid integer) IS 'args: toponame, layer_id, tg_id - Returns a topoelementarray (an array of topoelements) containing the topological elements and type of the given TopoGeometry (primitive elements)';


--
-- Name: gettopogeomelements(topogeometry); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION gettopogeomelements(tg topogeometry) RETURNS SETOF topoelement
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  toponame varchar;
  rec RECORD;
BEGIN
  toponame = topology.GetTopologyName(tg.topology_id);
  FOR rec IN SELECT * FROM topology.GetTopoGeomElements(toponame,
    tg.layer_id,tg.id) as ret
  LOOP
    RETURN NEXT rec.ret;
  END LOOP;
  RETURN;
END;
$$;


ALTER FUNCTION topology.gettopogeomelements(tg topogeometry) OWNER TO w4;

--
-- Name: FUNCTION gettopogeomelements(tg topogeometry); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION gettopogeomelements(tg topogeometry) IS 'args: tg - Returns a set of topoelement objects containing the topological element_id,element_type of the given TopoGeometry (primitive elements)';


--
-- Name: gettopogeomelements(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION gettopogeomelements(toponame character varying, layerid integer, tgid integer) RETURNS SETOF topoelement
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  ret topology.TopoElement;
  rec RECORD;
  rec2 RECORD;
  query text;
  query2 text;
  lyr RECORD;
  ok bool;
BEGIN

  -- Get layer info
  ok = false;
  FOR rec IN EXECUTE 'SELECT * FROM '
    || ' topology.layer '
    || ' WHERE layer_id = ' || layerid
  LOOP
    lyr = rec;
    ok = true;
  END LOOP;

  IF NOT ok THEN
    RAISE EXCEPTION 'Layer % does not exist', layerid;
  END IF;


  query = 'SELECT abs(element_id) as element_id, element_type FROM '
    || quote_ident(toponame) || '.relation WHERE '
    || ' layer_id = ' || layerid
    || ' AND topogeo_id = ' || quote_literal(tgid)
    || ' ORDER BY element_type, element_id';

  --RAISE NOTICE 'Query: %', query;

  FOR rec IN EXECUTE query
  LOOP
    IF lyr.level > 0 THEN
      query2 = 'SELECT * from topology.GetTopoGeomElements('
        || quote_literal(toponame) || ','
        || rec.element_type
        || ','
        || rec.element_id
        || ') as ret;';
      --RAISE NOTICE 'Query2: %', query2;
      FOR rec2 IN EXECUTE query2
      LOOP
        RETURN NEXT rec2.ret;
      END LOOP;
    ELSE
      ret = '{' || rec.element_id || ',' || rec.element_type || '}';
      RETURN NEXT ret;
    END IF;
  
  END LOOP;

  RETURN;
END;
$$;


ALTER FUNCTION topology.gettopogeomelements(toponame character varying, layerid integer, tgid integer) OWNER TO w4;

--
-- Name: FUNCTION gettopogeomelements(toponame character varying, layerid integer, tgid integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION gettopogeomelements(toponame character varying, layerid integer, tgid integer) IS 'args: toponame, layer_id, tg_id - Returns a set of topoelement objects containing the topological element_id,element_type of the given TopoGeometry (primitive elements)';


--
-- Name: gettopologyid(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION gettopologyid(toponame character varying) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  ret integer;
BEGIN
        SELECT id FROM topology.topology into ret
                WHERE name = toponame;
  RETURN ret;
END
$$;


ALTER FUNCTION topology.gettopologyid(toponame character varying) OWNER TO w4;

--
-- Name: FUNCTION gettopologyid(toponame character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION gettopologyid(toponame character varying) IS 'args: toponame - Returns the SRID of a topology in the topology.topology table given the name of the topology.';


--
-- Name: gettopologyname(integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION gettopologyname(topoid integer) RETURNS character varying
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  ret varchar;
BEGIN
        SELECT name FROM topology.topology into ret
                WHERE id = topoid;
  RETURN ret;
END
$$;


ALTER FUNCTION topology.gettopologyname(topoid integer) OWNER TO w4;

--
-- Name: FUNCTION gettopologyname(topoid integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION gettopologyname(topoid integer) IS 'args: topology_id - Returns the name of a topology (schema) given the id of the topology.';


--
-- Name: gettopologysrid(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION gettopologysrid(toponame character varying) RETURNS integer
    LANGUAGE sql STABLE STRICT
    AS $_$
  SELECT SRID FROM topology.topology WHERE name = $1;
$_$;


ALTER FUNCTION topology.gettopologysrid(toponame character varying) OWNER TO w4;

--
-- Name: intersects(topogeometry, topogeometry); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION intersects(tg1 topogeometry, tg2 topogeometry) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  tgbuf topology.TopoGeometry;
  rec RECORD;
  toponame varchar;
  query text;
BEGIN
  IF tg1.topology_id != tg2.topology_id THEN
    -- TODO: revert to ::geometry instead ?
    RAISE EXCEPTION 'Cannot compute intersection between TopoGeometries from different topologies';
  END IF;

  -- Order TopoGeometries so that tg1 has less-or-same
  -- dimensionality of tg1 (point,line,polygon,collection)
  IF tg1.type > tg2.type THEN
    tgbuf := tg2;
    tg2 := tg1;
    tg1 := tgbuf;
  END IF;

  --RAISE NOTICE 'tg1.id:% tg2.id:%', tg1.id, tg2.id;
  -- Geometry collection are not currently supported
  IF tg2.type = 4 THEN
    RAISE EXCEPTION 'GeometryCollection are not supported by intersects()';
  END IF;

        -- Get topology name
        SELECT name FROM topology.topology into toponame
                WHERE id = tg1.topology_id;

  -- Hierarchical TopoGeometries are not currently supported
  query = 'SELECT level FROM topology.layer'
    || ' WHERE '
    || ' topology_id = ' || tg1.topology_id
    || ' AND '
    || '( layer_id = ' || tg1.layer_id
    || ' OR layer_id = ' || tg2.layer_id
    || ' ) '
    || ' AND level > 0 ';

  --RAISE NOTICE '%', query;

  FOR rec IN EXECUTE query
  LOOP
    -- TODO: revert to ::geometry instead ?
    RAISE EXCEPTION 'Hierarchical TopoGeometries are not currently supported by intersects()';
  END LOOP;

  IF tg1.type = 1 THEN -- [multi]point


    IF tg2.type = 1 THEN -- point/point
  ---------------------------------------------------------
  -- 
  --  Two [multi]point features intersect if they share
  --  any Node 
  --
  --
  --
      query =
        'SELECT a.topogeo_id FROM '
        || quote_ident(toponame) ||
        '.relation a, '
        || quote_ident(toponame) ||
        '.relation b '
        || 'WHERE a.layer_id = ' || tg1.layer_id
        || ' AND b.layer_id = ' || tg2.layer_id
        || ' AND a.topogeo_id = ' || tg1.id
        || ' AND b.topogeo_id = ' || tg2.id
        || ' AND a.element_id = b.element_id '
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- they share an element
      END LOOP;
      RETURN FALSE; -- no elements shared
  --
  ---------------------------------------------------------
      

    ELSIF tg2.type = 2 THEN -- point/line
  ---------------------------------------------------------
  -- 
  --  A [multi]point intersects a [multi]line if they share
  --  any Node. 
  --
  --
  --
      query =
        'SELECT a.topogeo_id FROM '
        || quote_ident(toponame) ||
        '.relation a, '
        || quote_ident(toponame) ||
        '.relation b, '
        || quote_ident(toponame) ||
        '.edge_data e '
        || 'WHERE a.layer_id = ' || tg1.layer_id
        || ' AND b.layer_id = ' || tg2.layer_id
        || ' AND a.topogeo_id = ' || tg1.id
        || ' AND b.topogeo_id = ' || tg2.id
        || ' AND abs(b.element_id) = e.edge_id '
        || ' AND ( '
          || ' e.start_node = a.element_id '
          || ' OR '
          || ' e.end_node = a.element_id '
        || ' )'
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- they share an element
      END LOOP;
      RETURN FALSE; -- no elements shared
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 3 THEN -- point/polygon
  ---------------------------------------------------------
  -- 
  --  A [multi]point intersects a [multi]polygon if any
  --  Node of the point is contained in any face of the
  --  polygon OR ( is end_node or start_node of any edge
  --  of any polygon face ).
  --
  --  We assume the Node-in-Face check is faster becasue
  --  there will be less Faces then Edges in any polygon.
  --
  --
  --
  --
      -- Check if any node is contained in a face
      query =
        'SELECT n.node_id as id FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.node n '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id
        || ' AND n.node_id = r1.element_id '
        || ' AND r2.element_id = n.containing_face '
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        --RAISE NOTICE 'Node % in polygon face', rec.id;
        RETURN TRUE; -- one (or more) nodes are
                     -- contained in a polygon face
      END LOOP;

      -- Check if any node is start or end of any polygon
      -- face edge
      query =
        'SELECT n.node_id as nid, e.edge_id as eid '
        || ' FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.edge_data e, '
        || quote_ident(toponame) ||
        '.node n '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id
        || ' AND n.node_id = r1.element_id '
        || ' AND ( '
        || ' e.left_face = r2.element_id '
        || ' OR '
        || ' e.right_face = r2.element_id '
        || ' ) '
        || ' AND ( '
        || ' e.start_node = r1.element_id '
        || ' OR '
        || ' e.end_node = r1.element_id '
        || ' ) '
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        --RAISE NOTICE 'Node % on edge % bound', rec.nid, rec.eid;
        RETURN TRUE; -- one node is start or end
                     -- of a face edge
      END LOOP;

      RETURN FALSE; -- no intersection
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 4 THEN -- point/collection
      RAISE EXCEPTION 'Intersection point/collection not implemented yet';

    ELSE
      RAISE EXCEPTION 'Invalid TopoGeometry type', tg2.type;
    END IF;

  ELSIF tg1.type = 2 THEN -- [multi]line
    IF tg2.type = 2 THEN -- line/line
  ---------------------------------------------------------
  -- 
  --  A [multi]line intersects a [multi]line if they share
  --  any Node. 
  --
  --
  --
      query =
        'SELECT e1.start_node FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.edge_data e1, '
        || quote_ident(toponame) ||
        '.edge_data e2 '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id
        || ' AND abs(r1.element_id) = e1.edge_id '
        || ' AND abs(r2.element_id) = e2.edge_id '
        || ' AND ( '
        || ' e1.start_node = e2.start_node '
        || ' OR '
        || ' e1.start_node = e2.end_node '
        || ' OR '
        || ' e1.end_node = e2.start_node '
        || ' OR '
        || ' e1.end_node = e2.end_node '
        || ' )'
        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- they share an element
      END LOOP;
      RETURN FALSE; -- no elements shared
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 3 THEN -- line/polygon
  ---------------------------------------------------------
  -- 
  -- A [multi]line intersects a [multi]polygon if they share
  -- any Node (touch-only case), or if any line edge has any
  -- polygon face on the left or right (full-containment case
  -- + edge crossing case).
  --
  --
      -- E1 are line edges, E2 are polygon edges
      -- R1 are line relations.
      -- R2 are polygon relations.
      -- R2.element_id are FACE ids
      query =
        'SELECT e1.edge_id'
        || ' FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.edge_data e1, '
        || quote_ident(toponame) ||
        '.edge_data e2 '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id

        -- E1 are line edges
        || ' AND e1.edge_id = abs(r1.element_id) '

        -- E2 are face edges
        || ' AND ( e2.left_face = r2.element_id '
        || '   OR e2.right_face = r2.element_id ) '

        || ' AND ( '

        -- Check if E1 have left-or-right face 
        -- being part of R2.element_id
        || ' e1.left_face = r2.element_id '
        || ' OR '
        || ' e1.right_face = r2.element_id '

        -- Check if E1 share start-or-end node
        -- with any E2.
        || ' OR '
        || ' e1.start_node = e2.start_node '
        || ' OR '
        || ' e1.start_node = e2.end_node '
        || ' OR '
        || ' e1.end_node = e2.start_node '
        || ' OR '
        || ' e1.end_node = e2.end_node '

        || ' ) '

        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- either common node
                     -- or edge-in-face
      END LOOP;

      RETURN FALSE; -- no intersection
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 4 THEN -- line/collection
      RAISE EXCEPTION 'Intersection line/collection not implemented yet', tg1.type, tg2.type;

    ELSE
      RAISE EXCEPTION 'Invalid TopoGeometry type', tg2.type;
    END IF;


  ELSIF tg1.type = 3 THEN -- [multi]polygon

    IF tg2.type = 3 THEN -- polygon/polygon
  ---------------------------------------------------------
  -- 
  -- A [multi]polygon intersects a [multi]polygon if they share
  -- any Node (touch-only case), or if any face edge has any of the
  -- other polygon face on the left or right (full-containment case
  -- + edge crossing case).
  --
  --
      -- E1 are poly1 edges.
      -- E2 are poly2 edges
      -- R1 are poly1 relations.
      -- R2 are poly2 relations.
      -- R1.element_id are poly1 FACE ids
      -- R2.element_id are poly2 FACE ids
      query =
        'SELECT e1.edge_id'
        || ' FROM '
        || quote_ident(toponame) ||
        '.relation r1, '
        || quote_ident(toponame) ||
        '.relation r2, '
        || quote_ident(toponame) ||
        '.edge_data e1, '
        || quote_ident(toponame) ||
        '.edge_data e2 '
        || 'WHERE r1.layer_id = ' || tg1.layer_id
        || ' AND r2.layer_id = ' || tg2.layer_id
        || ' AND r1.topogeo_id = ' || tg1.id
        || ' AND r2.topogeo_id = ' || tg2.id

        -- E1 are poly1 edges
        || ' AND ( e1.left_face = r1.element_id '
        || '   OR e1.right_face = r1.element_id ) '

        -- E2 are poly2 edges
        || ' AND ( e2.left_face = r2.element_id '
        || '   OR e2.right_face = r2.element_id ) '

        || ' AND ( '

        -- Check if any edge from a polygon face
        -- has any of the other polygon face
        -- on the left or right 
        || ' e1.left_face = r2.element_id '
        || ' OR '
        || ' e1.right_face = r2.element_id '
        || ' OR '
        || ' e2.left_face = r1.element_id '
        || ' OR '
        || ' e2.right_face = r1.element_id '

        -- Check if E1 share start-or-end node
        -- with any E2.
        || ' OR '
        || ' e1.start_node = e2.start_node '
        || ' OR '
        || ' e1.start_node = e2.end_node '
        || ' OR '
        || ' e1.end_node = e2.start_node '
        || ' OR '
        || ' e1.end_node = e2.end_node '

        || ' ) '

        || ' LIMIT 1';
      --RAISE NOTICE '%', query;
      FOR rec IN EXECUTE query
      LOOP
        RETURN TRUE; -- either common node
                     -- or edge-in-face
      END LOOP;

      RETURN FALSE; -- no intersection
  --
  ---------------------------------------------------------

    ELSIF tg2.type = 4 THEN -- polygon/collection
      RAISE EXCEPTION 'Intersection poly/collection not implemented yet', tg1.type, tg2.type;

    ELSE
      RAISE EXCEPTION 'Invalid TopoGeometry type', tg2.type;
    END IF;

  ELSIF tg1.type = 4 THEN -- collection
    IF tg2.type = 4 THEN -- collection/collection
      RAISE EXCEPTION 'Intersection collection/collection not implemented yet', tg1.type, tg2.type;
    ELSE
      RAISE EXCEPTION 'Invalid TopoGeometry type', tg2.type;
    END IF;

  ELSE
    RAISE EXCEPTION 'Invalid TopoGeometry type %', tg1.type;
  END IF;
END
$$;


ALTER FUNCTION topology.intersects(tg1 topogeometry, tg2 topogeometry) OWNER TO w4;

--
-- Name: layertrigger(); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION layertrigger() RETURNS trigger
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  rec RECORD;
  ok BOOL;
  toponame varchar;
  query TEXT;
BEGIN

  --RAISE NOTICE 'LayerTrigger called % % at % level', TG_WHEN, TG_OP, TG_LEVEL;


  IF TG_OP = 'INSERT' THEN
    RAISE EXCEPTION 'LayerTrigger not meant to be called on INSERT';
  ELSIF TG_OP = 'UPDATE' THEN
    RAISE EXCEPTION 'The topology.layer table cannot be updated';
  END IF;


  -- Check for existance of any feature column referencing
  -- this layer
  FOR rec IN SELECT * FROM pg_namespace n, pg_class c, pg_attribute a
    WHERE text(n.nspname) = OLD.schema_name
    AND c.relnamespace = n.oid
    AND text(c.relname) = OLD.table_name
    AND a.attrelid = c.oid
    AND text(a.attname) = OLD.feature_column
  LOOP
    query = 'SELECT * '
      || ' FROM ' || quote_ident(OLD.schema_name)
      || '.' || quote_ident(OLD.table_name)
      || ' WHERE layer_id('
      || quote_ident(OLD.feature_column)||') '
      || '=' || OLD.layer_id
      || ' LIMIT 1';
    --RAISE NOTICE '%', query;
    FOR rec IN EXECUTE query
    LOOP
      RAISE NOTICE 'A feature referencing layer % of topology % still exists in %.%.%', OLD.layer_id, OLD.topology_id, OLD.schema_name, OLD.table_name, OLD.feature_column;
      RETURN NULL;
    END LOOP;
  END LOOP;


  -- Get topology name
  SELECT name FROM topology.topology INTO toponame
    WHERE id = OLD.topology_id;

  IF toponame IS NULL THEN
    RAISE NOTICE 'Could not find name of topology with id %',
      OLD.layer_id;
  END IF;

  -- Check if any record in the relation table references this layer
  FOR rec IN SELECT * FROM pg_namespace
    WHERE text(nspname) = toponame
  LOOP
    query = 'SELECT * '
      || ' FROM ' || quote_ident(toponame)
      || '.relation '
      || ' WHERE layer_id = '|| OLD.layer_id
      || ' LIMIT 1';
    --RAISE NOTICE '%', query;
    FOR rec IN EXECUTE query
    LOOP
      RAISE NOTICE 'A record in %.relation still references layer %', toponame, OLD.layer_id;
      RETURN NULL;
    END LOOP;
  END LOOP;

  RETURN OLD;
END;
$$;


ALTER FUNCTION topology.layertrigger() OWNER TO w4;

--
-- Name: polygonize(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION polygonize(toponame character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  sql text;
  rec RECORD;
  faces int;
BEGIN

  sql := 'SELECT (st_dump(st_polygonize(geom))).geom from '
         || quote_ident(toponame) || '.edge_data';

  faces = 0;
  FOR rec in EXECUTE sql LOOP
    BEGIN
      PERFORM topology.AddFace(toponame, rec.geom);
      faces = faces + 1;
    EXCEPTION
      WHEN OTHERS THEN
        RAISE WARNING 'Error registering face % (%)', rec.geom, SQLERRM;
    END;
  END LOOP;
  RETURN faces || ' faces registered';
END
$$;


ALTER FUNCTION topology.polygonize(toponame character varying) OWNER TO w4;

--
-- Name: FUNCTION polygonize(toponame character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION polygonize(toponame character varying) IS 'args: toponame - Find and register all faces defined by topology edges';


--
-- Name: relationtrigger(); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION relationtrigger() RETURNS trigger
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  toponame varchar;
  topoid integer;
  plyr RECORD; -- parent layer
  rec RECORD;
  ok BOOL;

BEGIN
  IF TG_NARGS != 2 THEN
    RAISE EXCEPTION 'RelationTrigger called with wrong number of arguments';
  END IF;

  topoid = TG_ARGV[0];
  toponame = TG_ARGV[1];

  --RAISE NOTICE 'RelationTrigger called % % on %.relation for a %', TG_WHEN, TG_OP, toponame, TG_LEVEL;


  IF TG_OP = 'DELETE' THEN
    RAISE EXCEPTION 'RelationTrigger not meant to be called on DELETE';
  END IF;

  -- Get layer info (and verify it exists)
  ok = false;
  FOR plyr IN EXECUTE 'SELECT * FROM topology.layer '
    || 'WHERE '
    || ' topology_id = ' || topoid
    || ' AND'
    || ' layer_id = ' || NEW.layer_id
  LOOP
    ok = true;
    EXIT;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION 'Layer % does not exist in topology %',
      NEW.layer_id, topoid;
    RETURN NULL;
  END IF;

  IF plyr.level > 0 THEN -- this is hierarchical layer

    -- ElementType must be the layer child id
    IF NEW.element_type != plyr.child_id THEN
      RAISE EXCEPTION 'Type of elements in layer % must be set to its child layer id %', plyr.layer_id, plyr.child_id;
      RETURN NULL;
    END IF;

    -- ElementId must be an existent TopoGeometry in child layer
    ok = false;
    FOR rec IN EXECUTE 'SELECT topogeo_id FROM '
      || quote_ident(toponame) || '.relation '
      || ' WHERE layer_id = ' || plyr.child_id 
      || ' AND topogeo_id = ' || NEW.element_id
    LOOP
      ok = true;
      EXIT;
    END LOOP;
    IF NOT ok THEN
      RAISE EXCEPTION 'TopoGeometry % does not exist in the child layer %', NEW.element_id, plyr.child_id;
      RETURN NULL;
    END IF;

  ELSE -- this is a basic layer

    -- ElementType must be compatible with layer type
    IF plyr.feature_type != 4
      AND plyr.feature_type != NEW.element_type
    THEN
      RAISE EXCEPTION 'Element of type % is not compatible with layer of type %', NEW.element_type, plyr.feature_type;
      RETURN NULL;
    END IF;

    --
    -- Now lets see if the element is consistent, which
    -- is it exists in the topology tables.
    --

    --
    -- Element is a Node
    --
    IF NEW.element_type = 1 
    THEN
      ok = false;
      FOR rec IN EXECUTE 'SELECT node_id FROM '
        || quote_ident(toponame) || '.node '
        || ' WHERE node_id = ' || NEW.element_id
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Node % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;

    --
    -- Element is an Edge
    --
    ELSIF NEW.element_type = 2 
    THEN
      ok = false;
      FOR rec IN EXECUTE 'SELECT edge_id FROM '
        || quote_ident(toponame) || '.edge_data '
        || ' WHERE edge_id = ' || abs(NEW.element_id)
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Edge % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;

    --
    -- Element is a Face
    --
    ELSIF NEW.element_type = 3 
    THEN
      IF NEW.element_id = 0 THEN
        RAISE EXCEPTION 'Face % cannot be associated with any feature', NEW.element_id;
        RETURN NULL;
      END IF;
      ok = false;
      FOR rec IN EXECUTE 'SELECT face_id FROM '
        || quote_ident(toponame) || '.face '
        || ' WHERE face_id = ' || NEW.element_id
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Face % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;
    END IF;

  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION topology.relationtrigger() OWNER TO w4;

--
-- Name: st_geometrytype(topogeometry); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_geometrytype(tg topogeometry) RETURNS text
    LANGUAGE sql STABLE STRICT
    AS $_$
	SELECT CASE
		WHEN type($1) = 1 THEN 'ST_MultiPoint'
		WHEN type($1) = 2 THEN 'ST_MultiLinestring'
		WHEN type($1) = 3 THEN 'ST_MultiPolygon'
		WHEN type($1) = 4 THEN 'ST_GeometryCollection'
		ELSE 'ST_Unexpected'
		END;
$_$;


ALTER FUNCTION topology.st_geometrytype(tg topogeometry) OWNER TO w4;

--
-- Name: st_getfaceedges(character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_getfaceedges(toponame character varying, face_id integer) RETURNS SETOF getfaceedges_returntype
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
  rec RECORD;
  bounds geometry;
  retrec topology.GetFaceEdges_ReturnType;
  n int;
  sql TEXT;
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR face_id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  IF NOT EXISTS(SELECT name FROM topology WHERE name = toponame)  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END IF;

  n := 1;

  -- Construct the face geometry, then for each ring of each polygon:
  sql := 'SELECT (ST_DumpRings((ST_Dump(ST_ForceRHR('
    || 'ST_BuildArea(ST_Collect(geom))))).geom)).geom FROM '
    || quote_ident(toponame) || '.edge_data WHERE left_face = '
    || face_id || ' OR right_face = ' || face_id;
  FOR rec IN EXECUTE sql 
  LOOP -- {

    -- Find the edges constituting its boundary
    bounds = ST_Boundary(rec.geom);


    sql := 'WITH er2 AS ( ' 
      || 'WITH er AS ( SELECT ' 
      || 'min(e.edge_id) over (), count(*) over () as cnt, e.edge_id, '
      || 'ST_LineLocatePoint('
      || quote_literal(bounds::text)
      || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
      || ', ST_LineLocatePoint('
      || quote_literal(bounds::text)
      || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
      || quote_ident(toponame)
      || '.edge e WHERE ( e.left_face = ' || face_id
      || ' OR e.right_face = ' || face_id
      || ') AND ST_Covers('
      || quote_literal(bounds::text)
      || ', e.geom)';
    IF face_id = 0 THEN
      sql := sql || ' ORDER BY POS ASC) ';
    ELSE
      sql := sql || ' ORDER BY POS DESC) ';
    END IF;

    -- Reorder rows so to start with the one with smaller edge_id
    sql := sql || 'SELECT row_number() over () - 1 as rn, * FROM er ) '
               || 'SELECT *, ( rn + cnt - ( select rn FROM er2 WHERE edge_id = min ) ) % cnt AS reord FROM er2 ORDER BY reord';


    --RAISE DEBUG 'SQL: %', sql;

    FOR rec IN EXECUTE sql
    LOOP


      retrec.sequence = n;
      retrec.edge = rec.edge_id;

      IF face_id = 0 THEN
        -- if this edge goes in opposite direction to the
        --       ring bounds, make it with negative orientation
        IF rec.pos2 < rec.pos THEN -- edge goes in opposite direction
          retrec.edge = -retrec.edge;
        END IF;
      ELSE
        -- if this edge goes in same direction to the
        --       ring bounds, make it with negative orientation
        IF rec.pos2 > rec.pos THEN -- edge goes in same direction
          retrec.edge = -retrec.edge;
        END IF;
      END IF;

      RETURN NEXT retrec;

      n = n+1;

    END LOOP;
  END LOOP; -- }

  RETURN;
EXCEPTION
  WHEN INVALID_SCHEMA_NAME THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
END
$$;


ALTER FUNCTION topology.st_getfaceedges(toponame character varying, face_id integer) OWNER TO w4;

--
-- Name: FUNCTION st_getfaceedges(toponame character varying, face_id integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION st_getfaceedges(toponame character varying, face_id integer) IS 'args: atopology, aface - Returns a set of ordered edges that bound aface includes the sequence order.';


--
-- Name: st_inittopogeo(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_inittopogeo(atopology character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
  topology_id numeric;
BEGIN
  IF atopology IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
  LOOP
    RAISE EXCEPTION 'SQL/MM Spatial exception - schema already exists';
  END LOOP;

  FOR rec IN EXECUTE 'SELECT topology.CreateTopology('
    ||quote_literal(atopology)|| ') as id'
  LOOP
    topology_id := rec.id;
  END LOOP;

  RETURN 'Topology-Geometry ' || quote_literal(atopology)
    || ' (id:' || topology_id || ') created.';
END
$$;


ALTER FUNCTION topology.st_inittopogeo(atopology character varying) OWNER TO w4;

--
-- Name: FUNCTION st_inittopogeo(atopology character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION st_inittopogeo(atopology character varying) IS 'args: topology_schema_name - Creates a new topology schema and registers this new schema in the topology.topology table and details summary of process.';


--
-- Name: st_modedgeheal(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_modedgeheal(toponame character varying, e1id integer, e2id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  e1rec RECORD;
  e2rec RECORD;
  rec RECORD;
  connectededges int[];
  commonnode int;
  caseno int;
  topoid int;
  sql text;
  e2sign int;
  eidary int[];
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL OR e2id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- NOT IN THE SPECS: see if the same edge is given twice..
  IF e1id = e2id THEN
    RAISE EXCEPTION 'Cannot heal edge % with itself, try with another', e1id;
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e2id
      INTO STRICT e2rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e2id;
    -- NOTE: checks for INVALID_SCHEMA_NAME or UNDEFINED_TABLE done before
  END;


  -- NOT IN THE SPECS: See if any of the two edges are closed.
  IF e1rec.start_node = e1rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e1id, e2id;
  END IF;
  IF e2rec.start_node = e2rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e2id, e1id;
  END IF;

  -- Find common node

  IF e1rec.end_node = e2rec.start_node THEN
    commonnode = e1rec.end_node;
    caseno = 1;
  ELSIF e1rec.end_node = e2rec.end_node THEN
    commonnode = e1rec.end_node;
    caseno = 2;
  END IF;

  -- Check if any other edge is connected to the common node
  IF commonnode IS NOT NULL THEN
    FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
      || '.edge_data WHERE ( edge_id != ' || e1id
      || ' AND edge_id != ' || e2id || ') AND ( start_node = '
      || commonnode || ' OR end_node = ' || commonnode || ' )'
    LOOP
      commonnode := NULL;
      connectededges = connectededges || rec.edge_id;
    END LOOP;
  END IF;

  IF commonnode IS NULL THEN
    IF e1rec.start_node = e2rec.start_node THEN
      commonnode = e1rec.start_node;
      caseno = 3;
    ELSIF e1rec.start_node = e2rec.end_node THEN
      commonnode = e1rec.start_node;
      caseno = 4;
    END IF;

    -- Check if any other edge is connected to the common node
    IF commonnode IS NOT NULL THEN
      FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
        || '.edge_data WHERE ( edge_id != ' || e1id
        || ' AND edge_id != ' || e2id || ') AND ( start_node = '
        || commonnode || ' OR end_node = ' || commonnode || ' )'
      LOOP
        commonnode := NULL;
        connectededges = connectededges || rec.edge_id;
      END LOOP;
    END IF;
  END IF;

  IF commonnode IS NULL THEN
    IF connectededges IS NOT NULL THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - other edges connected (%)', array_to_string(connectededges, ',');
    ELSE
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-connected edges';
    END IF;
  END IF;

  -- NOT IN THE SPECS:
  -- check if any topo_geom is defined only by one of the
  -- input edges. In such case there would be no way to adapt
  -- the definition in case of healing, so we'd have to bail out
  eidary = ARRAY[e1id, e2id];
  sql := 'SELECT t.* from ('
    || 'SELECT r.topogeo_id, r.layer_id'
    || ', l.schema_name, l.table_name, l.feature_column'
    || ', array_agg(abs(r.element_id)) as elems '
    || 'FROM topology.layer l INNER JOIN '
    || quote_ident(toponame)
    || '.relation r ON (l.layer_id = r.layer_id) '
    || 'WHERE l.level = 0 AND l.feature_type = 2 '
    || ' AND l.topology_id = ' || topoid
    || ' AND abs(r.element_id) IN (' || e1id || ',' || e2id || ') '
    || 'group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
    || ' l.feature_column ) t WHERE NOT t.elems @> '
    || quote_literal(eidary);
  --RAISE DEBUG 'SQL: %', sql;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing edges % and %',
          rec.topogeo_id, rec.layer_id,
          rec.schema_name, rec.table_name, rec.feature_column,
          e1id, e2id;
  END LOOP;

  -- Update data of the first edge {
  rec := e1rec;
  IF caseno = 1 THEN -- e1.end = e2.start
    rec.geom = ST_MakeLine(e1rec.geom, e2rec.geom);
    rec.end_node = e2rec.end_node;
    rec.next_left_edge = e2rec.next_left_edge;
    e2sign = 1;
  ELSIF caseno = 2 THEN -- e1.end = e2.end
    rec.geom = ST_MakeLine(e1rec.geom, st_reverse(e2rec.geom));
    rec.end_node = e2rec.start_node;
    rec.next_left_edge = e2rec.next_right_edge;
    e2sign = -1;
  ELSIF caseno = 3 THEN -- e1.start = e2.start
    rec.geom = ST_MakeLine(st_reverse(e2rec.geom), e1rec.geom);
    rec.start_node = e2rec.end_node;
    rec.next_right_edge = e2rec.next_left_edge;
    e2sign = -1;
  ELSIF caseno = 4 THEN -- e1.start = e2.end
    rec.geom = ST_MakeLine(e2rec.geom, e1rec.geom);
    rec.start_node = e2rec.start_node;
    rec.next_right_edge = e2rec.next_right_edge;
    e2sign = 1;
  END IF;
  EXECUTE 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET geom = ' || quote_literal(rec.geom::text)
    || ', start_node = ' || rec.start_node
    || ', end_node = ' || rec.end_node
    || ', next_left_edge = ' || rec.next_left_edge
    || ', abs_next_left_edge = ' || abs(rec.next_left_edge)
    || ', next_right_edge = ' || rec.next_right_edge
    || ', abs_next_right_edge = ' || abs(rec.next_right_edge)
    || ' WHERE edge_id = ' || e1id;
  -- End of first edge update }

  -- Update next_left_edge/next_right_edge for
  -- any edge having them still pointing at the edge being removed (e2id)
  --
  -- NOTE:
  -- *(next_XXX_edge/e2id) serves the purpose of extracting existing
  -- sign from the value, while *e2sign changes that sign again if we
  -- reverted edge2 direction
  --
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || e1id
    || ', next_left_edge = ' || e2sign*e1id
    || '*(next_left_edge/'
    || e2id || ')  WHERE abs_next_left_edge = ' || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || e1id
    || ', next_right_edge = ' || e2sign*e1id
    || '*(next_right_edge/'
    || e2id || ') WHERE abs_next_right_edge = ' || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  -- Delete the second edge
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e2id;

  -- Delete the common node 
  BEGIN
    EXECUTE 'DELETE FROM ' || quote_ident(toponame)
            || '.node WHERE node_id = ' || commonnode;
    EXCEPTION
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing node table)',
          toponame;
  END;

  --
  -- NOT IN THE SPECS:
  -- Drop composition rows involving second
  -- edge, as the first edge took its space,
  -- and all affected TopoGeom have been previously checked
  -- for being composed by both edges.
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.relation r USING topology.layer l '
    || 'WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  RETURN commonnode;
END
$$;


ALTER FUNCTION topology.st_modedgeheal(toponame character varying, e1id integer, e2id integer) OWNER TO w4;

--
-- Name: FUNCTION st_modedgeheal(toponame character varying, e1id integer, e2id integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION st_modedgeheal(toponame character varying, e1id integer, e2id integer) IS 'args: atopology, anedge, anotheredge - Heal two edges by deleting the node connecting them, modifying the first edgeand deleting the second edge. Returns the id of the deleted node.';


--
-- Name: st_newedgeheal(character varying, integer, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_newedgeheal(toponame character varying, e1id integer, e2id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  e1rec RECORD;
  e2rec RECORD;
  rec RECORD;
  newedgeid int;
  connectededges int[];
  commonnode int;
  caseno int;
  topoid int;
  sql text;
  e2sign int;
  eidary int[];
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL OR e2id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- NOT IN THE SPECS: see if the same edge is given twice..
  IF e1id = e2id THEN
    RAISE EXCEPTION 'Cannot heal edge % with itself, try with another', e1id;
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e2id
      INTO STRICT e2rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e2id;
    -- NOTE: checks for INVALID_SCHEMA_NAME or UNDEFINED_TABLE done before
  END;


  -- NOT IN THE SPECS: See if any of the two edges are closed.
  IF e1rec.start_node = e1rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e1id, e2id;
  END IF;
  IF e2rec.start_node = e2rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e2id, e1id;
  END IF;

  -- Find common node

  IF e1rec.end_node = e2rec.start_node THEN
    commonnode = e1rec.end_node;
    caseno = 1;
  ELSIF e1rec.end_node = e2rec.end_node THEN
    commonnode = e1rec.end_node;
    caseno = 2;
  END IF;

  -- Check if any other edge is connected to the common node
  IF commonnode IS NOT NULL THEN
    FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
      || '.edge_data WHERE ( edge_id != ' || e1id
      || ' AND edge_id != ' || e2id || ') AND ( start_node = '
      || commonnode || ' OR end_node = ' || commonnode || ' )'
    LOOP
      commonnode := NULL;
      connectededges = connectededges || rec.edge_id;
    END LOOP;
  END IF;

  IF commonnode IS NULL THEN
    IF e1rec.start_node = e2rec.start_node THEN
      commonnode = e1rec.start_node;
      caseno = 3;
    ELSIF e1rec.start_node = e2rec.end_node THEN
      commonnode = e1rec.start_node;
      caseno = 4;
    END IF;

    -- Check if any other edge is connected to the common node
    IF commonnode IS NOT NULL THEN
      FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
        || '.edge_data WHERE ( edge_id != ' || e1id
        || ' AND edge_id != ' || e2id || ') AND ( start_node = '
        || commonnode || ' OR end_node = ' || commonnode || ' )'
      LOOP
        commonnode := NULL;
        connectededges = connectededges || rec.edge_id;
      END LOOP;
    END IF;
  END IF;

  IF commonnode IS NULL THEN
    IF connectededges IS NOT NULL THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - other edges connected (%)', array_to_string(connectededges, ',');
    ELSE
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-connected edges';
    END IF;
  END IF;

  -- NOT IN THE SPECS:
  -- check if any topo_geom is defined only by one of the
  -- input edges. In such case there would be no way to adapt
  -- the definition in case of healing, so we'd have to bail out
  eidary = ARRAY[e1id, e2id];
  sql := 'SELECT t.* from ('
    || 'SELECT r.topogeo_id, r.layer_id'
    || ', l.schema_name, l.table_name, l.feature_column'
    || ', array_agg(abs(r.element_id)) as elems '
    || 'FROM topology.layer l INNER JOIN '
    || quote_ident(toponame)
    || '.relation r ON (l.layer_id = r.layer_id) '
    || 'WHERE l.level = 0 AND l.feature_type = 2 '
    || ' AND l.topology_id = ' || topoid
    || ' AND abs(r.element_id) IN (' || e1id || ',' || e2id || ') '
    || 'group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
    || ' l.feature_column ) t WHERE NOT t.elems @> '
    || quote_literal(eidary);
  --RAISE DEBUG 'SQL: %', sql;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing edges % and %',
          rec.topogeo_id, rec.layer_id,
          rec.schema_name, rec.table_name, rec.feature_column,
          e1id, e2id;
  END LOOP;

  -- Create new edge {
  rec := e1rec;
  IF caseno = 1 THEN -- e1.end = e2.start
    rec.geom = ST_MakeLine(e1rec.geom, e2rec.geom);
    rec.end_node = e2rec.end_node;
    rec.next_left_edge = e2rec.next_left_edge;
    e2sign = 1;
  ELSIF caseno = 2 THEN -- e1.end = e2.end
    rec.geom = ST_MakeLine(e1rec.geom, st_reverse(e2rec.geom));
    rec.end_node = e2rec.start_node;
    rec.next_left_edge = e2rec.next_right_edge;
    e2sign = -1;
  ELSIF caseno = 3 THEN -- e1.start = e2.start
    rec.geom = ST_MakeLine(st_reverse(e2rec.geom), e1rec.geom);
    rec.start_node = e2rec.end_node;
    rec.next_right_edge = e2rec.next_left_edge;
    e2sign = -1;
  ELSIF caseno = 4 THEN -- e1.start = e2.end
    rec.geom = ST_MakeLine(e2rec.geom, e1rec.geom);
    rec.start_node = e2rec.start_node;
    rec.next_right_edge = e2rec.next_right_edge;
    e2sign = 1;
  END IF;
  -- }

  -- Insert new edge {
  EXECUTE 'SELECT nextval(' || quote_literal(
      quote_ident(toponame) || '.edge_data_edge_id_seq'
    ) || ')' INTO STRICT newedgeid;
  EXECUTE 'INSERT INTO ' || quote_ident(toponame)
    || '.edge VALUES(' || newedgeid
    || ',' || rec.start_node
    || ',' || rec.end_node
    || ',' || rec.next_left_edge
    || ',' || rec.next_right_edge
    || ',' || rec.left_face
    || ',' || rec.right_face
    || ',' || quote_literal(rec.geom::text)
    || ')';
  -- End of new edge insertion }

  -- Update next_left_edge/next_right_edge for
  -- any edge having them still pointing at the edges being removed
  -- (e2id)
  --
  -- NOTE:
  -- *(next_XXX_edge/e2id) serves the purpose of extracting existing
  -- sign from the value, while *e2sign changes that sign again if we
  -- reverted edge2 direction
  --
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || newedgeid
    || ', next_left_edge = ' || e2sign*newedgeid
    || '*(next_left_edge/'
    || e2id || ')  WHERE abs_next_left_edge = ' || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || newedgeid
    || ', next_right_edge = ' || e2sign*newedgeid
    || '*(next_right_edge/'
    || e2id || ') WHERE abs_next_right_edge = ' || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  -- New edge has the same direction as old edge 1
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || newedgeid
    || ', next_left_edge = ' || newedgeid
    || '*(next_left_edge/'
    || e1id || ')  WHERE abs_next_left_edge = ' || e1id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || newedgeid
    || ', next_right_edge = ' || newedgeid
    || '*(next_right_edge/'
    || e1id || ') WHERE abs_next_right_edge = ' || e1id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  --
  -- NOT IN THE SPECS:
  -- Replace composition rows involving the two
  -- edges as one involving the new edge.
  -- It takes a DELETE and an UPDATE to do all
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.relation r USING topology.layer l '
    || 'WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.relation r '
    || ' SET element_id = ' || newedgeid || '*(element_id/'
    || e1id
    || ') FROM topology.layer l WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e1id
  ;
  EXECUTE sql;


  -- Delete both edges
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e2id;
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;

  -- Delete the common node 
  BEGIN
    EXECUTE 'DELETE FROM ' || quote_ident(toponame)
            || '.node WHERE node_id = ' || commonnode;
    EXCEPTION
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing node table)',
          toponame;
  END;

  RETURN newedgeid;
END
$$;


ALTER FUNCTION topology.st_newedgeheal(toponame character varying, e1id integer, e2id integer) OWNER TO w4;

--
-- Name: FUNCTION st_newedgeheal(toponame character varying, e1id integer, e2id integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION st_newedgeheal(toponame character varying, e1id integer, e2id integer) IS 'args: atopology, anedge, anotheredge - Heal two edges by deleting the node connecting them, deleting both edges,and replacing them with an edge whose direction is the same as the firstedge provided.';


--
-- Name: st_remedgemodface(character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_remedgemodface(toponame character varying, e1id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  e1rec RECORD;
  rec RECORD;
  fidary int[];
  topoid int;
  sql text;
  floodfaceid int;
  elink int;
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  -- NOT IN THE SPECS:
  -- Check that no TopoGeometry references the edge being removed
  PERFORM topology._ST_RemEdgeCheck(toponame, topoid, e1id, e1rec.left_face, e1rec.right_face);

  -- Update next_left_edge and next_right_edge face
  -- for all edges bounding the new face
  RAISE NOTICE 'Updating next_{right,left}_face of ring edges...';

  -- TODO: reduce the following to 2 UPDATE rather than 4

  -- Update next_left_edge of previous edges in left face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge < 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge > 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  -- Update next_right_edge of previous edges in right face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge < 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge > 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  IF e1rec.left_face = e1rec.right_face THEN -- {

    floodfaceid = e1rec.left_face; 

  ELSE -- }{

    IF e1rec.left_face = 0 OR e1rec.right_face = 0 THEN -- {

      --
      -- We won't add any new face, but rather let the universe
      -- flood the removed face.
      --

      floodfaceid = 0;

    ELSE -- }{

      -- we choose right face as the face that will remain
      -- to be symmetric with ST_AddEdgeModFace 
      floodfaceid = e1rec.right_face;

      sql := 'UPDATE '
        || quote_ident(toponame)
        || '.face SET mbr = (SELECT '
        -- minimum bounding rectangle is the union of the old faces mbr
        -- (doing this without GEOS would be faster)
        || 'ST_Envelope(ST_Union(mbr)) FROM '
        || quote_ident(toponame)
        || '.face WHERE face_id IN (' 
        || e1rec.left_face || ',' || e1rec.right_face 
        || ') ) WHERE face_id = ' || floodfaceid ;
      EXECUTE sql;

    END IF; -- }

    -- Update left_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET left_face = ' || floodfaceid 
      || ' WHERE left_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update right_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET right_face = ' || floodfaceid 
      || ' WHERE right_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update containing_face for all nodes still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.node SET containing_face = ' || floodfaceid 
      || ' WHERE containing_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- NOT IN THE SPECS:
    -- Replace composition rows involving the two
    -- faces as one involving the new face.
    -- It takes a single DELETE to do that.
    sql := 'DELETE FROM ' || quote_ident(toponame)
      || '.relation r USING topology.layer l '
      || 'WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND abs(r.element_id) IN ('
      || e1rec.left_face || ',' || e1rec.right_face
      || ') AND abs(r.element_id) != '
      || floodfaceid; -- could be optimized..
    EXECUTE sql;

  END IF; -- } two faces healed...

  -- Delete the edge
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;
  EXECUTE sql;

  -- Check if any of the edge nodes remains isolated, 
  -- set containing_face  = floodfaceid in that case
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.node n SET containing_face = ' || floodfaceid
    || ' WHERE node_id IN ('
    || e1rec.start_node || ','
    || e1rec.end_node || ') AND NOT EXISTS (SELECT edge_id FROM '
    || quote_ident(toponame)
    || '.edge_data WHERE start_node = n.node_id OR end_node = n.node_id)';
  EXECUTE sql;

  IF e1rec.right_face != e1rec.left_face THEN -- {

    -- Delete left face, if not universe and not "flood" face
    IF e1rec.left_face != 0 AND e1rec.left_face != floodfaceid
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.left_face; 
      EXECUTE sql;
    END IF;

    -- Delete right face, if not universe and not "flood" face
    IF e1rec.right_face != 0 AND e1rec.right_face != floodfaceid
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.right_face;
      EXECUTE sql;
    END IF;

  END IF; -- }

  RETURN floodfaceid;
END
$$;


ALTER FUNCTION topology.st_remedgemodface(toponame character varying, e1id integer) OWNER TO w4;

--
-- Name: FUNCTION st_remedgemodface(toponame character varying, e1id integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION st_remedgemodface(toponame character varying, e1id integer) IS 'args: atopology, anedge - Removes an edge and, if the removed edge separated two faces,delete one of the them and modify the other to take the space of both.';


--
-- Name: st_remedgenewface(character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_remedgenewface(toponame character varying, e1id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  e1rec RECORD;
  rec RECORD;
  fidary int[];
  topoid int;
  sql text;
  newfaceid int;
  newfacecreated bool;
  elink int;
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  -- NOT IN THE SPECS:
  -- Check that no TopoGeometry references the edge being removed
  PERFORM topology._ST_RemEdgeCheck(toponame, topoid, e1id, e1rec.left_face, e1rec.right_face);

  -- Update next_left_edge and next_right_edge face
  -- for all edges bounding the new face
  RAISE NOTICE 'Updating next_{right,left}_face of ring edges...';

  -- TODO: reduce the following to 2 UPDATE rather than 4

  -- Update next_left_edge of previous edges in left face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge < 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge > 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  -- Update next_right_edge of previous edges in right face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge < 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge > 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  IF e1rec.left_face = e1rec.right_face THEN -- {

    newfaceid := e1rec.left_face; -- TODO: or what should we return ?
    newfacecreated := false;

  ELSE -- }{

    IF e1rec.left_face = 0 OR e1rec.right_face = 0 THEN -- {

      --
      -- We won't add any new face, but rather let the universe
      -- flood the removed face.
      --

      newfaceid := 0;
      newfacecreated := false;

    ELSE -- }{

      --
      -- Insert the new face 
      --

      sql := 'SELECT nextval(' || quote_literal(
          quote_ident(toponame) || '.face_face_id_seq'
        ) || ')';

      EXECUTE sql INTO STRICT newfaceid;
      newfacecreated := true;

      sql := 'INSERT INTO '
        || quote_ident(toponame)
        || '.face(face_id, mbr) SELECT '
        -- face_id
        || newfaceid  || ', '
        -- minimum bounding rectangle is the union of the old faces mbr
        -- (doing this without GEOS would be faster)
        || 'ST_Envelope(ST_Union(mbr)) FROM '
        || quote_ident(toponame)
        || '.face WHERE face_id IN (' 
        || e1rec.left_face || ',' || e1rec.right_face 
        || ')';
      EXECUTE sql;

    END IF; -- }

    -- Update left_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET left_face = ' || newfaceid 
      || ' WHERE left_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update right_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET right_face = ' || newfaceid 
      || ' WHERE right_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update containing_face for all nodes still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.node SET containing_face = ' || newfaceid 
      || ' WHERE containing_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- NOT IN THE SPECS:
    -- Replace composition rows involving the two
    -- faces as one involving the new face.
    -- It takes a DELETE and an UPDATE to do all
    sql := 'DELETE FROM ' || quote_ident(toponame)
      || '.relation r USING topology.layer l '
      || 'WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
      || e1rec.left_face;
    EXECUTE sql;
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.relation r '
      || ' SET element_id = ' || newfaceid 
      || ' FROM topology.layer l WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND r.element_id = '
      || e1rec.right_face;
    EXECUTE sql;

  END IF; -- } two faces healed...

  -- Delete the edge
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;
  EXECUTE sql;

  -- Check if any of the edge nodes remains isolated, 
  -- set containing_face  = newfaceid in that case
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.node n SET containing_face = ' || newfaceid
    || ' WHERE node_id IN ('
    || e1rec.start_node || ','
    || e1rec.end_node || ') AND NOT EXISTS (SELECT edge_id FROM '
    || quote_ident(toponame)
    || '.edge_data WHERE start_node = n.node_id OR end_node = n.node_id)';
  EXECUTE sql;

  IF e1rec.right_face != e1rec.left_face THEN -- {

    -- Delete left face, if not universe
    IF e1rec.left_face != 0 THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.left_face; 
      EXECUTE sql;
    END IF;

    -- Delete right face, if not universe
    IF e1rec.right_face != 0
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.right_face;
      EXECUTE sql;
    END IF;

  END IF; -- }

  IF newfacecreated THEN
    RETURN newfaceid;
  ELSE
    RETURN NULL; -- -newfaceid;
  END IF;
END
$$;


ALTER FUNCTION topology.st_remedgenewface(toponame character varying, e1id integer) OWNER TO w4;

--
-- Name: FUNCTION st_remedgenewface(toponame character varying, e1id integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION st_remedgenewface(toponame character varying, e1id integer) IS 'args: atopology, anedge - Removes an edge and, if the removed edge separated two faces,delete the original faces and replace them with a new face.';


--
-- Name: st_remisonode(character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_remisonode(character varying, integer) RETURNS text
    LANGUAGE sql
    AS $_$
  SELECT topology.ST_RemoveIsoNode($1, $2)
$_$;


ALTER FUNCTION topology.st_remisonode(character varying, integer) OWNER TO w4;

--
-- Name: st_removeisoedge(character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_removeisoedge(atopology character varying, anedge integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  edge RECORD;
  rec RECORD;
  ok BOOL;
BEGIN

  --
  -- Atopology and anedge are required
  -- 
  IF atopology IS NULL OR anedge IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Check node existance
  -- 
  ok = false;
  FOR edge IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE edge_id =  ' || anedge
  LOOP
    ok = true;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - non-existent edge';
  END IF;

  --
  -- Check node isolation
  -- 
  IF edge.left_face != edge.right_face THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - not isolated edge';
  END IF;

  FOR rec IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' 
    || ' WHERE edge_id !=  ' || anedge
    || ' AND ( start_node = ' || edge.start_node
    || ' OR start_node = ' || edge.end_node
    || ' OR end_node = ' || edge.start_node
    || ' OR end_node = ' || edge.end_node
    || ' ) '
  LOOP
    RAISE EXCEPTION
      'SQL/MM Spatial exception - not isolated edge';
  END LOOP;

  --
  -- Delete the edge
  --
  EXECUTE 'DELETE FROM ' || quote_ident(atopology) || '.edge_data '
    || ' WHERE edge_id = ' || anedge;

  RETURN 'Isolated edge ' || anedge || ' removed';
END
$$;


ALTER FUNCTION topology.st_removeisoedge(atopology character varying, anedge integer) OWNER TO w4;

--
-- Name: st_removeisonode(character varying, integer); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION st_removeisonode(atopology character varying, anode integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec RECORD;
BEGIN

  --
  -- Atopology and apoint are required
  -- 
  IF atopology IS NULL OR anode IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Check node isolation.
  -- 
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE start_node =  ' || anode ||
    ' OR end_node = ' || anode 
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - not isolated node';
  END LOOP;

  EXECUTE 'DELETE FROM ' || quote_ident(atopology) || '.node '
    || ' WHERE node_id = ' || anode;

  RETURN 'Isolated node ' || anode || ' removed';
END
$$;


ALTER FUNCTION topology.st_removeisonode(atopology character varying, anode integer) OWNER TO w4;

--
-- Name: FUNCTION st_removeisonode(atopology character varying, anode integer); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION st_removeisonode(atopology character varying, anode integer) IS 'args: atopology, anode - Removes an isolated node and returns description of action. If the node is not isolated (is start or end of an edge), then an exception is thrown.';


--
-- Name: topoelementarray_append(topoelementarray, topoelement); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION topoelementarray_append(topoelementarray, topoelement) RETURNS topoelementarray
    LANGUAGE sql IMMUTABLE
    AS $_$
	SELECT CASE
		WHEN $1 IS NULL THEN
			topology.TopoElementArray('{' || $2::text || '}')
		ELSE
			topology.TopoElementArray($1::int[][]||$2::int[])
		END;
$_$;


ALTER FUNCTION topology.topoelementarray_append(topoelementarray, topoelement) OWNER TO w4;

--
-- Name: topologysummary(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION topologysummary(atopology character varying) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
  rec RECORD;
  rec2 RECORD;
  var_topology_id integer;
  n int4;
  missing int4;
  sql text;
  ret text;
BEGIN

  ret := 'Topology ' || quote_ident(atopology) ;

  BEGIN
    SELECT * FROM topology.topology WHERE name = atopology INTO STRICT rec;
    -- TODO: catch <no_rows> to give a nice error message
    var_topology_id := rec.id;

    ret := ret || ' (' || rec.id || '), ';
    ret := ret || 'SRID ' || rec.srid || ', '
               || 'precision ' || rec.precision;
    IF rec.hasz THEN ret := ret || ', has Z'; END IF;
    ret := ret || E'\n';
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ret := ret || E' (X)\n';
  END;

  BEGIN

  BEGIN
    EXECUTE 'SELECT count(node_id) FROM ' || quote_ident(atopology)
      || '.node ' INTO STRICT n;
    ret = ret || n || ' nodes, ';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'X nodes, ';
  END;

  BEGIN
    EXECUTE 'SELECT count(edge_id) FROM ' || quote_ident(atopology)
      || '.edge_data ' INTO STRICT n;
    ret = ret || n || ' edges, ';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'X edges, ';
  END;

  BEGIN
    EXECUTE 'SELECT count(face_id) FROM ' || quote_ident(atopology)
      || '.face WHERE face_id != 0' INTO STRICT n;
    ret = ret || n || ' faces, ';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'X faces, ';
  END;

  BEGIN

    EXECUTE 'SELECT count(*) FROM (SELECT DISTINCT layer_id,topogeo_id FROM '
      || quote_ident(atopology) || '.relation ) foo ' INTO STRICT n;
    ret = ret || n || ' topogeoms in ';

    EXECUTE 'SELECT count(*) FROM (SELECT DISTINCT layer_id FROM '
      || quote_ident(atopology) || '.relation ) foo ' INTO STRICT n;
    ret = ret || n || ' layers' || E'\n';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'X topogeoms in X layers' || E'\n';
  END;

  -- print information about registered layers
  FOR rec IN SELECT * FROM topology.layer l
    WHERE l.topology_id = var_topology_id
    ORDER by layer_id
  LOOP -- {
    ret = ret || 'Layer ' || rec.layer_id || ', type ';
    CASE
      WHEN rec.feature_type = 1 THEN
        ret = ret || 'Puntal';
      WHEN rec.feature_type = 2 THEN
        ret = ret || 'Lineal';
      WHEN rec.feature_type = 3 THEN
        ret = ret || 'Polygonal';
      WHEN rec.feature_type = 4 THEN
        ret = ret || 'Mixed';
      ELSE 
        ret = ret || '???';
    END CASE;

    ret = ret || ' (' || rec.feature_type || '), ';

    BEGIN

      EXECUTE 'SELECT count(*) FROM ( SELECT DISTINCT topogeo_id FROM '
        || quote_ident(atopology)
        || '.relation r WHERE r.layer_id = ' || rec.layer_id
        || ' ) foo ' INTO STRICT n;

      ret = ret || n || ' topogeoms' || E'\n';

    EXCEPTION WHEN UNDEFINED_TABLE THEN
      ret = ret || 'X topogeoms' || E'\n';
    END;

      IF rec.level > 0 THEN
        ret = ret || ' Hierarchy level ' || rec.level 
                  || ', child layer ' || rec.child_id || E'\n';
      END IF;

      ret = ret || ' Deploy: ';
      IF rec.feature_column != '' THEN
        ret = ret || quote_ident(rec.schema_name) || '.'
                  || quote_ident(rec.table_name) || '.'
                  || quote_ident(rec.feature_column);

        IF n > 0 THEN
          sql := 'SELECT count(*) FROM ( SELECT topogeo_id FROM '
            || quote_ident(atopology)
            || '.relation r WHERE r.layer_id = ' || rec.layer_id
            || ' EXCEPT SELECT DISTINCT id('
            || quote_ident(rec.feature_column) || ') FROM '
            || quote_ident(rec.schema_name) || '.'
            || quote_ident(rec.table_name) || ') as foo';
          EXECUTE sql INTO STRICT missing;
          IF missing > 0 THEN
            ret = ret || ' (' || missing || ' missing topogeoms)';
          END IF;
        END IF;
        ret = ret || E'\n';

      ELSE
        ret = ret || E'NONE (detached)\n';
      END IF;

  END LOOP; -- }

  -- print information about unregistered layers containing topogeoms
  sql := 'SELECT layer_id FROM '
      || quote_ident(atopology) || '.relation EXCEPT SELECT layer_id'
      || ' FROM topology.layer WHERE topology_id = '
      || var_topology_id || 'ORDER BY layer_id';
  --RAISE DEBUG '%', sql;
  FOR rec IN  EXECUTE sql
  LOOP -- {
    ret = ret || 'Layer ' || rec.layer_id::text || ', UNREGISTERED, ';

    EXECUTE 'SELECT count(*) FROM ( SELECT DISTINCT topogeo_id FROM '
      || quote_ident(atopology)
      || '.relation r WHERE r.layer_id = ' || rec.layer_id
      || ' ) foo ' INTO STRICT n;

    ret = ret || n || ' topogeoms' || E'\n';

  END LOOP; -- }

  EXCEPTION
    WHEN INVALID_SCHEMA_NAME THEN
      ret = ret || E'\n- missing schema - ';
    WHEN OTHERS THEN
      RAISE EXCEPTION 'Got % (%)', SQLERRM, SQLSTATE;
  END;


  RETURN ret;
END
$$;


ALTER FUNCTION topology.topologysummary(atopology character varying) OWNER TO w4;

--
-- Name: FUNCTION topologysummary(atopology character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION topologysummary(atopology character varying) IS 'args: topology_schema_name - Takes a topology name and provides summary totals of types of objects in topology';


--
-- Name: validatetopology(character varying); Type: FUNCTION; Schema: topology; Owner: w4
--

CREATE FUNCTION validatetopology(toponame character varying) RETURNS SETOF validatetopology_returntype
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
  retrec topology.ValidateTopology_ReturnType;
  rec RECORD;
  rec2 RECORD;
  i integer;
  invalid_edges integer[];
  invalid_faces integer[];
  sql text;
BEGIN

  -- Check for coincident nodes
  FOR rec IN EXECUTE 'SELECT a.node_id as id1, b.node_id as id2 FROM '
    || quote_ident(toponame) || '.node a, '
    || quote_ident(toponame) || '.node b '
    || 'WHERE a.node_id < b.node_id '
    || ' AND ST_DWithin(a.geom, b.geom, 0)' -- NOTE: see #1625 and #1789
  LOOP
    retrec.error = 'coincident nodes';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for edge crossed nodes
  -- TODO: do this in the single edge loop
  FOR rec IN EXECUTE 'SELECT n.node_id as id1, e.edge_id as id2 FROM '
    || quote_ident(toponame) || '.node n, '
    || quote_ident(toponame) || '.edge e '
    || 'WHERE e.start_node != n.node_id '
    || 'AND e.end_node != n.node_id '
    || 'AND ST_Within(n.geom, e.geom)'
  LOOP
    retrec.error = 'edge crosses node';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Scan all edges 
  FOR rec IN EXECUTE 'SELECT e.geom, e.edge_id as id1, e.left_face, e.right_face FROM '
    || quote_ident(toponame) || '.edge e ORDER BY edge_id'
  LOOP

    -- Any invalid edge becomes a cancer for higher level complexes
    IF NOT ST_IsValid(rec.geom) THEN

      retrec.error = 'invalid edge';
      retrec.id1 = rec.id1;
      retrec.id2 = NULL;
      RETURN NEXT retrec;
      invalid_edges := array_append(invalid_edges, rec.id1);

      IF invalid_faces IS NULL OR NOT rec.left_face = ANY ( invalid_faces )
      THEN
        invalid_faces := array_append(invalid_faces, rec.left_face);
      END IF;

      IF rec.right_face != rec.left_face AND ( invalid_faces IS NULL OR
            NOT rec.right_face = ANY ( invalid_faces ) )
      THEN
        invalid_faces := array_append(invalid_faces, rec.right_face);
      END IF;

      CONTINUE;

    END IF;

    IF NOT ST_IsSimple(rec.geom) THEN
      retrec.error = 'edge not simple';
      retrec.id1 = rec.id1;
      retrec.id2 = NULL;
      RETURN NEXT retrec;
    END IF;

  END LOOP;

  -- Check for edge crossing
  sql := 'SELECT e1.edge_id as id1, e2.edge_id as id2, '
    || ' e1.geom as g1, e2.geom as g2, '
    || 'ST_Relate(e1.geom, e2.geom) as im FROM '
    || quote_ident(toponame) || '.edge e1, '
    || quote_ident(toponame) || '.edge e2 '
    || 'WHERE e1.edge_id < e2.edge_id '
    || ' AND e1.geom && e2.geom ';
  IF invalid_edges IS NOT NULL THEN
    sql := sql || ' AND NOT e1.edge_id = ANY ('
               || quote_literal(invalid_edges) || ')'
               || ' AND NOT e2.edge_id = ANY ('
               || quote_literal(invalid_edges) || ')';
  END IF;

  FOR rec IN EXECUTE sql
  LOOP
    IF ST_RelateMatch(rec.im, 'FF1F**1*2') THEN
      CONTINUE; -- no interior intersection
    END IF;

    --
    -- Closed lines have no boundary, so endpoint
    -- intersection would be considered interior
    -- See http://trac.osgeo.org/postgis/ticket/770
    -- See also full explanation in topology.AddEdge
    --

    IF ST_RelateMatch(rec.im, 'FF10F01F2') THEN
      -- first line (g1) is open, second (g2) is closed
      -- first boundary has puntual intersection with second interior
      --
      -- compute intersection, check it equals second endpoint
      IF ST_Equals(ST_Intersection(rec.g2, rec.g1),
                   ST_StartPoint(rec.g2))
      THEN
        CONTINUE;
      END IF;
    END IF;

    IF ST_RelateMatch(rec.im, 'F01FFF102') THEN
      -- second line (g2) is open, first (g1) is closed
      -- second boundary has puntual intersection with first interior
      -- 
      -- compute intersection, check it equals first endpoint
      IF ST_Equals(ST_Intersection(rec.g2, rec.g1),
                   ST_StartPoint(rec.g1))
      THEN
        CONTINUE;
      END IF;
    END IF;

    IF ST_RelateMatch(rec.im, '0F1FFF1F2') THEN
      -- both lines are closed (boundary intersects nothing)
      -- they have puntual intersection between interiors
      -- 
      -- compute intersection, check it's a single point
      -- and equals first StartPoint _and_ second StartPoint
      IF ST_Equals(ST_Intersection(rec.g1, rec.g2),
                   ST_StartPoint(rec.g1)) AND
         ST_Equals(ST_StartPoint(rec.g1), ST_StartPoint(rec.g2))
      THEN
        CONTINUE;
      END IF;
    END IF;

    retrec.error = 'edge crosses edge';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for edge start_node geometry mis-match
  -- TODO: move this in the first edge table scan 
  FOR rec IN EXECUTE 'SELECT e.edge_id as id1, n.node_id as id2 FROM '
    || quote_ident(toponame) || '.edge e, '
    || quote_ident(toponame) || '.node n '
    || 'WHERE e.start_node = n.node_id '
    || 'AND NOT ST_Equals(ST_StartPoint(e.geom), n.geom)'
  LOOP
    retrec.error = 'edge start node geometry mis-match';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for edge end_node geometry mis-match
  -- TODO: move this in the first edge table scan 
  FOR rec IN EXECUTE 'SELECT e.edge_id as id1, n.node_id as id2 FROM '
    || quote_ident(toponame) || '.edge e, '
    || quote_ident(toponame) || '.node n '
    || 'WHERE e.end_node = n.node_id '
    || 'AND NOT ST_Equals(ST_EndPoint(e.geom), n.geom)'
  LOOP
    retrec.error = 'edge end node geometry mis-match';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for faces w/out edges
  FOR rec IN EXECUTE 'SELECT face_id as id1 FROM '
    || quote_ident(toponame) || '.face '
    || 'WHERE face_id > 0 EXCEPT ( SELECT left_face FROM '
    || quote_ident(toponame) || '.edge '
    || ' UNION SELECT right_face FROM '
    || quote_ident(toponame) || '.edge '
    || ')'
  LOOP
    retrec.error = 'face without edges';
    retrec.id1 = rec.id1;
    retrec.id2 = NULL;
    RETURN NEXT retrec;
  END LOOP;

  -- Now create a temporary table to construct all face geometries
  -- for checking their consistency

  sql := 'CREATE TEMP TABLE face_check ON COMMIT DROP AS '
    || 'SELECT face_id, topology.ST_GetFaceGeometry('
    || quote_literal(toponame) || ', face_id) as geom, mbr FROM '
    || quote_ident(toponame) || '.face WHERE face_id > 0';
  IF invalid_faces IS NOT NULL THEN
    sql := sql || ' AND NOT face_id = ANY ('
               || quote_literal(invalid_faces) || ')';
  END IF;
  EXECUTE sql;

  -- Build a gist index on geom
  EXECUTE 'CREATE INDEX "face_check_gist" ON '
    || 'face_check USING gist (geom);';

  -- Build a btree index on id
  EXECUTE 'CREATE INDEX "face_check_bt" ON ' 
    || 'face_check (face_id);';

  -- Scan the table looking for NULL geometries
  FOR rec IN EXECUTE
    'SELECT f1.face_id FROM '
    || 'face_check f1 WHERE f1.geom IS NULL'
  LOOP
    -- Face missing !
    retrec.error := 'face has no rings';
    retrec.id1 := rec.face_id;
    retrec.id2 := NULL;
    RETURN NEXT retrec;
  END LOOP;


  -- Scan the table looking for overlap or containment
  -- TODO: also check for MBR consistency
  FOR rec IN EXECUTE
    'SELECT f1.geom, f1.face_id as id1, f2.face_id as id2, '
    || ' ST_Relate(f1.geom, f2.geom) as im'
    || ' FROM '
    || 'face_check f1, '
    || 'face_check f2 '
    || 'WHERE f1.face_id < f2.face_id'
    || ' AND f1.geom && f2.geom'
  LOOP

    -- Face overlap
    IF ST_RelateMatch(rec.im, 'T*T***T**') THEN
    retrec.error = 'face overlaps face';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
    END IF;

    -- Face 1 is within face 2 
    IF ST_RelateMatch(rec.im, 'T*F**F***') THEN
    retrec.error = 'face within face';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
    END IF;

    -- Face 1 contains face 2
    IF ST_RelateMatch(rec.im, 'T*****FF*') THEN
    retrec.error = 'face within face';
    retrec.id1 = rec.id2;
    retrec.id2 = rec.id1;
    RETURN NEXT retrec;
    END IF;

  END LOOP;


  DROP TABLE face_check;

  RETURN;
END
$$;


ALTER FUNCTION topology.validatetopology(toponame character varying) OWNER TO w4;

--
-- Name: FUNCTION validatetopology(toponame character varying); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON FUNCTION validatetopology(toponame character varying) IS 'args: topology_schema_name - Returns a set of validatetopology_returntype objects detailing issues with topology';


SET search_path = w4_application_functions, pg_catalog;

--
-- Name: add_conversion_to_rollups(bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION add_conversion_to_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa numeric, pcpa numeric, ppcpa numeric, icpa numeric, ts timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ahoy BIGINT; aru_hour acct_advertiser_rollup_hour; adoy BIGINT; aru_day acct_advertiser_rollup_day; amoy BIGINT; aru_month acct_advertiser_rollup_month; ay BIGINT; aru_year acct_advertiser_rollup_year; ihoy BIGINT; iru_hour acct_internal_rollup_hour; idoy BIGINT; iru_day acct_internal_rollup_day; imoy BIGINT; iru_month acct_internal_rollup_month; iy BIGINT; iru_year acct_internal_rollup_year; phoy BIGINT; pru_hour acct_publisher_rollup_hour; pdoy BIGINT; pru_day acct_publisher_rollup_day; pmoy BIGINT; pru_month acct_publisher_rollup_month; py BIGINT; pru_year acct_publisher_rollup_year; exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
    BEGIN
        -- Get Rollup Time Boundaries
        ahoy:=make_hoy(ts); adoy:=make_doy(ts); amoy:=make_moy(ts); ay:=make_y(ts); ihoy:=make_hoy(ts); idoy:=make_doy(ts); imoy:=make_moy(ts); iy:=make_y(ts); phoy:=make_hoy(ts); pdoy:=make_doy(ts); pmoy:=make_moy(ts); py:=make_y(ts);
        -- Update Advertiser Rollups
        IF acpa<>0::numeric THEN
            -- Hour
            aru_hour:=lookup_acct_advertiser_rollup_hour(aid,cid,pid,ahoy,acpa);
            IF FOUND THEN
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment+acpa;
                aru_hour.num_conversion:=aru_hour.num_conversion+1;
            ELSE
                aru_hour.a_id:=aid;
                aru_hour.c_id:=cid;
                aru_hour.p_id:=pid;
                aru_hour.cost_per_action:=acpa;
                aru_hour.a_hoy:=ahoy;
                aru_hour.status:=100;
                aru_hour.total_period_adjustment:=acpa;
                aru_hour.num_conversion:=1;
            END IF;
            -- Day
            aru_day:=lookup_acct_advertiser_rollup_day(aid,cid,pid,adoy,acpa);
            IF FOUND THEN
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment+acpa;
                aru_day.num_conversion:=aru_day.num_conversion+1;
            ELSE
                aru_day.a_id:=aid;
                aru_day.c_id:=cid;
                aru_day.p_id:=pid;
                aru_day.cost_per_action:=acpa;
                aru_day.a_doy:=adoy;
                aru_day.status:=100;
                aru_day.total_period_adjustment:=acpa;
                aru_day.num_conversion:=1;
            END IF;
            -- Month
            aru_month:=lookup_acct_advertiser_rollup_month(aid,cid,pid,amoy,acpa);
            IF FOUND THEN
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment+acpa;
                aru_month.num_conversion:=aru_month.num_conversion+1;
            ELSE
                aru_month.a_id:=aid;
                aru_month.c_id:=cid;
                aru_month.p_id:=pid;
                aru_month.cost_per_action:=acpa;
                aru_month.a_moy:=amoy;
                aru_month.status:=100;
                aru_month.total_period_adjustment:=acpa;
                aru_month.num_conversion:=1;
            END IF;
            -- Year
            aru_year:=lookup_acct_advertiser_rollup_year(aid,cid,pid,ay,acpa);
            IF FOUND THEN
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment+acpa;
                aru_year.num_conversion:=aru_year.num_conversion+1;
            ELSE
                aru_year.a_id:=aid;
                aru_year.c_id:=cid;
                aru_year.p_id:=pid;
                aru_year.cost_per_action:=acpa;
                aru_year.a_y:=ay;
                aru_year.status:=100;
                aru_year.total_period_adjustment:=acpa;
                aru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_advertiser_rollup_hour(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
        END IF;
        -- Update Internal Rollups
        IF icpa<>0::numeric THEN
            -- Hour
            iru_hour:=lookup_acct_internal_rollup_hour(aid,cid,pid,ihoy,icpa);
            IF FOUND THEN
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment+icpa;
                iru_hour.num_conversion:=iru_hour.num_conversion+1;
            ELSE
                iru_hour.a_id:=aid;
                iru_hour.c_id:=cid;
                iru_hour.p_id:=pid;
                iru_hour.cost_per_action:=icpa;
                iru_hour.i_hoy:=ihoy;
                iru_hour.status:=100;
                iru_hour.total_period_adjustment:=icpa;
                iru_hour.num_conversion:=1;
            END IF;
            -- Day
            iru_day:=lookup_acct_internal_rollup_day(aid,cid,pid,idoy,icpa);
            IF FOUND THEN
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment+icpa;
                iru_day.num_conversion:=iru_day.num_conversion+1;
            ELSE
                iru_day.a_id:=aid;
                iru_day.c_id:=cid;
                iru_day.p_id:=pid;
                iru_day.cost_per_action:=icpa;
                iru_day.i_doy:=idoy;
                iru_day.status:=100;
                iru_day.total_period_adjustment:=icpa;
                iru_day.num_conversion:=1;
            END IF;
            -- Month
            iru_month:=lookup_acct_internal_rollup_month(aid,cid,pid,imoy,icpa);
            IF FOUND THEN
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment+icpa;
                iru_month.num_conversion:=iru_month.num_conversion+1;
            ELSE
                iru_month.a_id:=aid;
                iru_month.c_id:=cid;
                iru_month.p_id:=pid;
                iru_month.cost_per_action:=icpa;
                iru_month.i_moy:=imoy;
                iru_month.status:=100;
                iru_month.total_period_adjustment:=icpa;
                iru_month.num_conversion:=1;
            END IF;
            -- Year
            iru_year:=lookup_acct_internal_rollup_year(aid,cid,pid,iy,icpa);
            IF FOUND THEN
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment+icpa;
                iru_year.num_conversion:=iru_year.num_conversion+1;
            ELSE
                iru_year.a_id:=aid;
                iru_year.c_id:=cid;
                iru_year.p_id:=pid;
                iru_year.cost_per_action:=icpa;
                iru_year.i_y:=iy;
                iru_year.status:=100;
                iru_year.total_period_adjustment:=icpa;
                iru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_internal_rollup_hour(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
        END IF;
        -- Update Publisher Rollups
        IF pcpa<>0::numeric THEN
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(aid,cid,pid,phoy,pcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+pcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion+1;
            ELSE
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=pid;
                pru_hour.cost_per_action:=pcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=pcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(aid,cid,pid,pdoy,pcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+pcpa;
                pru_day.num_conversion:=pru_day.num_conversion+1;
            ELSE
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=pid;
                pru_day.cost_per_action:=pcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=pcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(aid,cid,pid,pmoy,pcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+pcpa;
                pru_month.num_conversion:=pru_month.num_conversion+1;
            ELSE
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=pid;
                pru_month.cost_per_action:=pcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=pcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(aid,cid,pid,py,pcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+pcpa;
                pru_year.num_conversion:=pru_year.num_conversion+1;
            ELSE
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=pid;
                pru_year.cost_per_action:=pcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=pcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        IF ppcpa<>0::numeric THEN
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(aid,cid,ppid,phoy,ppcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+ppcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion+1;
            ELSE
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=ppid;
                pru_hour.cost_per_action:=pcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=ppcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(aid,cid,ppid,pdoy,ppcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+ppcpa;
                pru_day.num_conversion:=pru_day.num_conversion+1;
            ELSE
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=ppid;
                pru_day.cost_per_action:=pcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=ppcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(aid,cid,ppid,pmoy,ppcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+ppcpa;
                pru_month.num_conversion:=pru_month.num_conversion+1;
            ELSE
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=ppid;
                pru_month.cost_per_action:=ppcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=ppcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(aid,cid,ppid,py,ppcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+ppcpa;
                pru_year.num_conversion:=pru_year.num_conversion+1;
            ELSE
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=ppid;
                pru_year.cost_per_action:=ppcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=ppcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.add_conversion_to_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa numeric, pcpa numeric, ppcpa numeric, icpa numeric, ts timestamp with time zone) OWNER TO w4;

--
-- Name: approve_conversions(text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION approve_conversions(conversion_ids text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        arow INTEGER; ids BIGINT[]; tmpids TEXT[];
    BEGIN
        tmpids=string_to_array(replace(replace(replace(conversion_ids,'"',''),']',''),'[',''),',');
        FOR I IN array_lower(tmpids, 1)..array_upper(tmpids, 1) LOOP
            UPDATE engine_conversions SET status=10 WHERE id=CAST(tmpids[I] as BIGINT);
        END LOOP;
                GET DIAGNOSTICS arow = ROW_COUNT; 
        RETURN arow;
    END
$$;


ALTER FUNCTION w4_application_functions.approve_conversions(conversion_ids text) OWNER TO w4;

--
-- Name: campaign_default_screenshot_get(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION campaign_default_screenshot_get(arg_c_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;

    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    default_redirect_url,
                    restrictions,
                    screenshot_id
                FROM campaigns
                WHERE id = arg_c_id
            ) row
        INTO var_results;

        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4_application_functions.campaign_default_screenshot_get(arg_c_id bigint) OWNER TO w4;

--
-- Name: categories_ids_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION categories_ids_json(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
        r VARCHAR;
        tmp_ary VARCHAR[];
    BEGIN
        tmp_ary:=array_append(tmp_ary,'');
        FOR r IN SELECT category_id::VARCHAR FROM campaign_categories WHERE campaign_id=arg_campaign_id LOOP
            tmp_ary:=array_append(tmp_ary,r::VARCHAR);
        END LOOP;
        ret_val:=array_to_json(tmp_ary);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.categories_ids_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: categories_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION categories_json(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
        r VARCHAR;
        tmp_ary VARCHAR[];
    BEGIN
        tmp_ary:=array_append(tmp_ary,'');
        FOR r IN SELECT cat."name" FROM campaign_categories cc LEFT JOIN categories cat ON cat.id=cc.category_id WHERE cc.campaign_id=arg_campaign_id LOOP
            tmp_ary:=array_append(tmp_ary,r);
        END LOOP;
        ret_val:=array_to_json(tmp_ary);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.categories_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: channels_ids_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION channels_ids_json(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
        r VARCHAR;
        tmp_ary VARCHAR[];
    BEGIN
        tmp_ary:=array_append(tmp_ary,'');
        FOR r IN SELECT channel_id::VARCHAR FROM campaign_channels WHERE campaign_id=arg_campaign_id LOOP
            tmp_ary:=array_append(tmp_ary,r::VARCHAR);
        END LOOP;
        ret_val:=array_to_json(tmp_ary);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.channels_ids_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: channels_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION channels_json(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
        r VARCHAR;
        tmp_ary VARCHAR[];
    BEGIN
        tmp_ary:=array_append(tmp_ary,'');
        FOR r IN SELECT chan."name" FROM campaign_channels cc LEFT JOIN channels chan ON chan.id=cc.channel_id WHERE cc.campaign_id=arg_campaign_id LOOP
            tmp_ary:=array_append(tmp_ary,r);
        END LOOP;
        ret_val:=array_to_json(tmp_ary);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.channels_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: check_campaign_eligible(bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_campaign_eligible(cid bigint, pid bigint, chnl bigint) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        camp campaigns;
        adv advertisers;
        cap campaign_assigned_publishers;
        ccap campaign_caps;
        total_convs BIGINT;
        total_payout NUMERIC;
        int_convs BIGINT;
        int_payout NUMERIC;
    BEGIN
        SELECT INTO camp * FROM campaigns cmp WHERE cmp.id=cid;
        IF camp.status<>'active' THEN -- Failure condition
            RETURN -9; -- Active failure ordinal
        END IF;
        IF camp.start_date > CURRENT_TIMESTAMP THEN -- Failure Condition
            RETURN -10; -- Not started yet ordinal
        END IF;
        IF camp.expiry_date < CURRENT_TIMESTAMP THEN -- Failure Condition
            RETURN -11; -- Campaign ended ordinal
        END IF;
        SELECT INTO adv * FROM advertisers WHERE id=camp.advertiser_id;
        IF adv.status <> 'active' THEN
            RETURN -12; -- Advertiser not active failure ordinal
        END IF;
        IF camp.access_type <> 1 THEN
            SELECT INTO cap * FROM campaign_assigned_publishers WHERE campaign_id=cid AND publisher_id=pid;
            IF camp.access_type=2 THEN
                IF NOT FOUND THEN
                    RETURN -13; -- Private Campaign without access failure ordinal
                ELSE
                    IF cap.status <> 'approved' THEN
                        RETURN -13; -- Private Campaign without access failure ordinal
                    END IF;
                END IF;
            ELSE
                IF NOT FOUND THEN
                    RETURN -14; -- By Approval Campaign without approval failure ordinal
                END IF;
                IF cap.status <> 'approved' THEN
                    RETURN -14; -- By approval Campaign without approval failure ordinal
                END IF;
            END IF;
        END IF;
        FOR ccap IN EXECUTE 'SELECT * FROM campaign_caps cc WHERE cc.campaign_id=' || cid LOOP
            CASE ccap.type 
            WHEN 1 THEN -- Per Publisher
                CASE ccap.period
                    WHEN 1 THEN -- Minute
                        RAISE NOTICE 'Minute duration caps are not supported. Please fix campaign_cap id [%]',ccap.id;
                    WHEN 2 THEN -- Hour
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO total_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy=make_hoy() AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                            ELSE -- Multiple periods
                                SELECT INTO total_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy() AND hoy >= make_hoy( NOW() - (ccap.value::TEXT || ' hour')::INTERVAL ) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO total_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy=make_hoy() AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                            ELSE -- Multiple Periods
                                SELECT INTO total_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy() AND hoy >= make_hoy( NOW() - (ccap.value::TEXT || ' hour')::INTERVAL ) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    WHEN 3 THEN -- Day
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy=make_doy() AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND rch.hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL )::TEXT || '25'::TEXT)::BIGINT  AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL )::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy=make_doy() AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.doy=make_hoy( NOW () - ('1 day')::INTERVAL) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    WHEN 4 THEN -- Week
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('7 day')::INTERVAL) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ((ccap.value*7)::TEXT || ' day')::INTERVAL) AND rch.hoy >= (make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ((ccap.value*7)::TEXT || ' day')::INTERVAL) AND rch.hoy >= (make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('7 day')::INTERVAL) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('7 day')::INTERVAL) AND rch.hoy >= (make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            ELSE -- Multiple Periods
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);                                    
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL ) AND hoy >= (make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    WHEN 5 THEN -- Month
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND make_doy(NOW() - ('1 month')::INTERVAL) AND rch.doy >= rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('1 month')::INTERVAL) AND rch.hoy >= (make_doy( NOW() - ('1 month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL ) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE  rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('1 month')::INTERVAL) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('1 month')::INTERVAL) AND rch.hoy >= make_doy( NOW() - ('1 month')::INTERVAL) || '25'::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL ) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    WHEN 6 THEN -- Year
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('1 year')::INTERVAL) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('1 year')::INTERVAL) AND rch.hoy >= (make_doy( NOW() - ('1 year')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' year')::INTERVAL ) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' year')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE  rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('1 year')::INTERVAL) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('1 year')::INTERVAL) AND rch.hoy >= (make_doy( NOW() - ('1 month')::INTERVAL) || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' year')::INTERVAL ) AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy >= make_hoy( NOW() - (ccap.value::TEXT || ' year')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.publisher_id=pid AND rch.campaign_id=cid GROUP BY rch.publisher_id, rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    END CASE;
            WHEN 2 THEN
                RAISE NOTICE 'Per Channel caps are not supported. Please fix campaign_cap id [%]',ccap.id;
            WHEN 3 THEN
                CASE ccap.period
                    WHEN 1 THEN -- Minute
                        RAISE NOTICE 'Minute duration caps are not supported. Please fix campaign_cap id [%]',ccap.id;
                    WHEN 2 THEN -- Hour
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO total_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy=make_hoy() AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                            ELSE -- Multiple periods
                                SELECT INTO total_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy() AND hoy >= make_hoy( NOW() - (ccap.value::TEXT || ' hour')::INTERVAL ) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO total_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy=make_hoy() AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                            ELSE -- Multiple Periods
                                SELECT INTO total_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy() AND hoy >= make_hoy( NOW() - (ccap.value::TEXT || ' hour')::INTERVAL ) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    WHEN 3 THEN -- Day
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy=make_doy() AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND rch.hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy=make_doy() AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy=make_hoy( NOW () - ('1 day')::INTERVAL) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    WHEN 4 THEN -- Week
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('7 day')::INTERVAL) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ((ccap.value*7)::TEXT || ' day')::INTERVAL) AND rch.hoy >= (make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL) AND rch.doy >= rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ((ccap.value*7)::TEXT || ' day')::INTERVAL) AND rch.hoy >= (make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - '7 days'::INTERVAL) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - '7 days'::INTERVAL) AND rch.hoy >= (make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            ELSE -- Multiple Periods
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);                                    
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL ) AND hoy >= (make_doy(NOW() - ((ccap.value*7)::TEXT || ' day')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    WHEN 5 THEN -- Month
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('1 month')::INTERVAL) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('1 month')::INTERVAL) AND rch.hoy >= (make_doy( NOW() - ('1 month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL ) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE  rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('1 month')::INTERVAL) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('1 month')::INTERVAL) AND rch.hoy >= (make_doy( NOW() - ('1 month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL ) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    WHEN 6 THEN -- Year
                        CASE ccap.unit_type
                        WHEN 'currency' THEN -- Check if it's gone over the money
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE rch.doy <= make_doy() AND doy >= make_doy(NOW() - ('1 year')::INTERVAL) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('1 year')::INTERVAL) AND hoy >= (make_doy( NOW() - ('1 year')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' years')::INTERVAL ) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=COALESCE(int_payout,0);
                                SELECT INTO int_payout COALESCE(SUM(rch.total_pay_in::NUMERIC),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' year')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_payout:=total_payout+COALESCE(int_payout,0);
                            END CASE;
                            IF total_payout >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        ELSE -- Check if it's gone over the number of conversions
                            CASE ccap.value
                            WHEN 1 THEN -- Single period
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE  rch.doy <= make_doy() AND rch.doy >= make_doy(NOW() - ('1 year')::INTERVAL) AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE rch.hoy <= make_hoy( NOW () - ('1 year')::INTERVAL) AND rch.hoy >= (make_doy( NOW() - ('1 month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            ELSE -- Multiple periods
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_daily rch WHERE doy <= make_doy() AND doy >= make_doy( NOW() - (ccap.value::TEXT || ' year')::INTERVAL )  AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=COALESCE(int_convs,0);
                                SELECT INTO int_convs COALESCE(SUM(rch.total_conversions),0) FROM reporting.reports_conversions_rollup_hourly rch WHERE hoy <= make_hoy( NOW() - (ccap.value::TEXT || ' year')::INTERVAL ) AND hoy >= (make_doy( NOW() - (ccap.value::TEXT || ' month')::INTERVAL)::TEXT || '25'::TEXT)::BIGINT AND rch.campaign_id=cid GROUP BY rch.campaign_id;
                                total_convs:=total_convs+COALESCE(int_convs,0);
                            END CASE;
                            IF total_convs >= ccap.units THEN -- Failure condition
                                RETURN -8; -- Cap failure ordinal
                            END IF;
                        END CASE;
                    END CASE;
            END CASE;
        END LOOP;
        RETURN 1;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_campaign_eligible(cid bigint, pid bigint, chnl bigint) OWNER TO w4;

--
-- Name: check_categories(bigint, bigint[]); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_categories(arg_campaign_id bigint, arg_campaigns_array bigint[]) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val INTEGER;
    BEGIN
        SELECT INTO ret_val count(1) FROM campaign_categories WHERE campaign_id=arg_campaign_id AND category_id = ANY (arg_campaigns_array);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_categories(arg_campaign_id bigint, arg_campaigns_array bigint[]) OWNER TO w4;

--
-- Name: check_channels(bigint, bigint[]); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_channels(arg_campaign_id bigint, arg_campaigns_array bigint[]) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val INTEGER;
    BEGIN
        SELECT INTO ret_val count(1) FROM campaign_channels WHERE campaign_id=arg_campaign_id AND channel_id = ANY (arg_campaigns_array);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_channels(arg_campaign_id bigint, arg_campaigns_array bigint[]) OWNER TO w4;

--
-- Name: check_click_duplicate(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_click_duplicate(arg_click_id bigint, arg_campaign_id bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        PERFORM id FROM engine_clicks WHERE id=arg_click_id AND campaign_id=arg_campaign_id;
        IF FOUND THEN
            RETURN FALSE;
        END IF;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_click_duplicate(arg_click_id bigint, arg_campaign_id bigint) OWNER TO w4;

--
-- Name: check_click_duplicate(bigint, bigint, bigint, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_click_duplicate(arg_campaign_id bigint, arg_publisher_id bigint, arg_click_id bigint DEFAULT NULL::bigint, arg_ref_id text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        var_id bigint := null;

    BEGIN
        SELECT id FROM engine_clicks WHERE
            (id = arg_click_id OR (hitpath_ref_id = arg_ref_id AND hitpath_ref_id IS NOT NULL)) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id)
        INTO var_id;
        RETURN var_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_click_duplicate(arg_campaign_id bigint, arg_publisher_id bigint, arg_click_id bigint, arg_ref_id text) OWNER TO w4;

--
-- Name: check_geos(bigint, bigint[]); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_geos(arg_campaign_id bigint, arg_geos_array bigint[]) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val INTEGER;
    BEGIN
        SELECT INTO ret_val count(1) FROM campaign_geotargeting WHERE campaign_id=arg_campaign_id AND id = ANY (arg_geos_array);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_geos(arg_campaign_id bigint, arg_geos_array bigint[]) OWNER TO w4;

--
-- Name: check_geos(bigint, text[]); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_geos(arg_campaign_id bigint, arg_geos_array text[]) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val INTEGER;
        blank_ary TEXT [];
    BEGIN
        IF arg_geos_array = blank_ary THEN
            arg_geos_array = '{US,CA,UK,GB,AU}';
        END IF;
        SELECT INTO ret_val COUNT(country) FROM campaign_geotargeting WHERE campaign_id=arg_campaign_id AND country = ANY (arg_geos_array) GROUP BY country;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_geos(arg_campaign_id bigint, arg_geos_array text[]) OWNER TO w4;

--
-- Name: check_is_adv_contact_billing(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_is_adv_contact_billing(arg_advertiser_id bigint, arg_contact_id bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        SELECT INTO ret_val CASE billing_contact_id WHEN arg_contact_id THEN TRUE ELSE FALSE END FROM advertisers WHERE id=arg_advertiser_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_is_adv_contact_billing(arg_advertiser_id bigint, arg_contact_id bigint) OWNER TO w4;

--
-- Name: check_is_adv_contact_primary(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_is_adv_contact_primary(arg_advertiser_id bigint, arg_contact_id bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        SELECT INTO ret_val CASE primary_contact_id WHEN arg_contact_id THEN TRUE ELSE FALSE END FROM advertisers WHERE id=arg_advertiser_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_is_adv_contact_primary(arg_advertiser_id bigint, arg_contact_id bigint) OWNER TO w4;

--
-- Name: check_is_pub_contact_billing(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_is_pub_contact_billing(arg_publisher_id bigint, arg_contact_id bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        SELECT INTO ret_val CASE billing_contact_id WHEN arg_contact_id THEN TRUE ELSE FALSE END FROM users WHERE id=arg_publisher_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_is_pub_contact_billing(arg_publisher_id bigint, arg_contact_id bigint) OWNER TO w4;

--
-- Name: check_is_pub_contact_primary(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_is_pub_contact_primary(arg_publisher_id bigint, arg_contact_id bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        SELECT INTO ret_val CASE primary_contact_id WHEN arg_contact_id THEN TRUE ELSE FALSE END FROM users WHERE id=arg_publisher_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_is_pub_contact_primary(arg_publisher_id bigint, arg_contact_id bigint) OWNER TO w4;

--
-- Name: check_pays_on(bigint, bigint[]); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_pays_on(arg_campaign_id bigint, arg_pays_on_array bigint[]) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE ret_val INTEGER;
    BEGIN
        SELECT INTO ret_val count(1) FROM campaigns WHERE id=arg_campaign_id AND payout_model_id = ANY( arg_pays_on_array );
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.check_pays_on(arg_campaign_id bigint, arg_pays_on_array bigint[]) OWNER TO w4;

--
-- Name: check_publisher_override(bigint, bigint, bigint, text, text, text, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_publisher_override(cid bigint, pid bigint, tier_id bigint, sid1 text, sid2 text, sid3 text, sid4 text) RETURNS public.pub_override
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret pub_override; tmp RECORD;
    BEGIN
        ret.payin:=0;
        ret.payout:=0;
        ret.landing_page:='';
        SELECT INTO tmp *
        FROM publisher_overrides
        WHERE campaign_id=cid AND publisher_id=pid AND publisher_tier_id=tier_id AND sub_id_1=sid1 AND sub_id_2=sid2 AND sub_id_3=sid3 AND sub_id_4=sid4
        AND effective_date > current_timestamp AND expiration_date < current_timestamp;
        IF FOUND THEN
            ret.payin:=tmp.override_payin;
            ret.payout:=override_payout;
            ret.landing_page:=override_advertiser_landing_page;
        END IF;
        RETURN ret;
    END
$$;


ALTER FUNCTION w4_application_functions.check_publisher_override(cid bigint, pid bigint, tier_id bigint, sid1 text, sid2 text, sid3 text, sid4 text) OWNER TO w4;

--
-- Name: check_user_credential(character varying, character varying, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION check_user_credential(arg_login_name character varying, arg_password character varying, arg_impersonation_id bigint) RETURNS public.user_return
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val user_return;
    BEGIN
        SELECT 
                usr.id
              , COALESCE(cts.email_address,usr.email)
              , usr.password
              , usr.parent_id
              , usr.manager_id
              , usr.active
              , usr.access
              , usr.ip_address
              , usr.last_login
              , usr.login_name
              , usr.primary_contact_id
              , usr.billing_contact_id
              , usr.account_contact_id
              , COALESCE(cts.first_name,usp.first_name)
                      , COALESCE(cts.last_name,usp.last_name)
              , usp.image_id
              , COALESCE(cts.messenger_name,usp.messenger_id) AS messenger_id
              , CASE WHEN (cts.messenger_type > 0) 
                THEN (SELECT description FROM im_types WHERE cts.messenger_type = im_types.id) 
                ELSE (SELECT description FROM im_types WHERE usp.messenger_type = im_types.id)
                END AS messenger_type
              , usp.preferred_language
              , CASE WHEN cts.country_id > 0 THEN (SELECT country FROM geo_typeahead_countries WHERE id=cts.country_id) ELSE usp.country END AS country
              , COALESCE(cts.primary_phone,usp.phone)
              , mup.first_name AS manager_first_name
              , mup.last_name AS manager_last_name
        INTO ret_val
        FROM users usr 
        LEFT JOIN user_profiles usp ON usr.id=usp.user_id 
        LEFT JOIN users mgr ON mgr.id=usr.manager_id
        LEFT JOIN user_profiles mup ON mgr.id=mup.user_id
                LEFT JOIN contacts cts ON usr.primary_contact_id=cts.id
        WHERE
                    usr.login_name ILIKE arg_login_name
                    AND usr.password=arg_password
                    AND ((usr.active='active' OR usr.active='suspended')
            OR (arg_impersonation_id IS NOT NULL and usr.access='publisher'));
        IF NOT FOUND THEN
            PERFORM *
            FROM users usr 
            WHERE usr.login_name ILIKE arg_login_name;
            IF NOT FOUND THEN
                RAISE EXCEPTION 'The login name [%] was not found for any user, administrator, or publisher.',arg_login_name;
            ELSE
                RAISE EXCEPTION 'The password for the login name [%] is incorrect',arg_login_name;
            END IF;
        ELSE
            UPDATE users SET last_login=now() WHERE users.id=ret_val.id;
        END IF;
        RETURN ret_val;
    END;
  $$;


ALTER FUNCTION w4_application_functions.check_user_credential(arg_login_name character varying, arg_password character varying, arg_impersonation_id bigint) OWNER TO w4;

--
-- Name: create_advertiser(text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_advertiser(arg_name text, arg_first_name text, arg_last_name text, arg_primary_phone text, arg_email_address text, arg_url text, arg_ftp_password text, arg_manager_id text, arg_address_1 text, arg_city_name text, arg_region_name text, arg_postal_code text, arg_credit_limit text, arg_country_id text, arg_status text DEFAULT 'active'::text, arg_payment_terms_id text DEFAULT '1'::text, arg_allow_over_limit text DEFAULT 'yes'::text, arg_credit_limit_per text DEFAULT 'day'::text, arg_address_2 text DEFAULT NULL::text, arg_secondary_phone text DEFAULT NULL::text, arg_fax text DEFAULT NULL::text, arg_messenger_name text DEFAULT NULL::text, arg_messenger_type integer DEFAULT NULL::integer) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        next_id bigint;
        acct_contact_id bigint;
        contact_id  bigint;
        var_country_id bigint;
        var_region_id bigint;
        var_city_id bigint;
        var_ftp_username text;
        var_ftp_folder text;

    BEGIN
    /* pull out into create contact sproc?, will get called more, but less redundant */
	SELECT CAST(arg_country_id AS bigint) INTO var_country_id;
        SELECT region_id, city_id FROM w4api.geo_get(var_country_id, arg_region_name, arg_city_name) INTO var_region_id, var_city_id;

        next_id   := nextval( 'advertisers_id_seq' );
        contact_id := create_contact(
					arg_first_name, 
					arg_last_name, 
					arg_address_1, 
					arg_address_2, 
					var_country_id, 
					var_region_id, 
					var_city_id, 
					arg_city_name, 
					arg_postal_code, 
					arg_messenger_name, 
					arg_messenger_type, 
					arg_primary_phone, 
					arg_secondary_phone, 
					arg_fax, 
					arg_email_address
				      );

        INSERT INTO advertiser_contacts
				(advertiser_id, contact_id)
						VALUES (next_id, contact_id);
  
        acct_contact_id := create_contact(
					arg_name, 
					'', 
					arg_address_1, 
					arg_address_2, 
					var_country_id, 
					var_region_id, 
					var_city_id, 
					arg_city_name, 
					arg_postal_code, 
					'', 
					null, 
					'', 
					'', 
					'', 
					''
					 );

        INSERT INTO advertisers
		(
		    "id",
		    "name",
		    "manager_id",
		    "credit_limit",
		    "credit_limit_per",
		    "allow_over_limit",
		    "payment_terms_id",
		    "ftp_password",
		    "status",
		    "billing_contact_id",
		    "primary_contact_id",
		    "account_contact_id",
		    "url"
		) 
		  VALUES 
		  (
		    next_id,
		    arg_name,
		    CAST(arg_manager_id AS bigint),
		    CAST(arg_credit_limit AS double precision),
		    arg_credit_limit_per,
		    arg_allow_over_limit,
		    CAST(arg_payment_terms_id AS smallint),
		    arg_ftp_password,
		    arg_status,
		    contact_id,
		    contact_id,
		    acct_contact_id,
		    arg_url
		  );
   
        var_ftp_username := CONCAT('a', next_id::text);
        var_ftp_folder := CONCAT('/home/', var_ftp_username);
        INSERT INTO ftp.user
            (username, password, advertiser_id, folder, gid)
            VALUES (var_ftp_username, arg_ftp_password, next_id, var_ftp_folder, 1);


	EXECUTE 'SELECT w4api.advertiser_get_list(arg_advertiser_ids:=''['||next_id||']'')' INTO ret_val;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_advertiser(arg_name text, arg_first_name text, arg_last_name text, arg_primary_phone text, arg_email_address text, arg_url text, arg_ftp_password text, arg_manager_id text, arg_address_1 text, arg_city_name text, arg_region_name text, arg_postal_code text, arg_credit_limit text, arg_country_id text, arg_status text, arg_payment_terms_id text, arg_allow_over_limit text, arg_credit_limit_per text, arg_address_2 text, arg_secondary_phone text, arg_fax text, arg_messenger_name text, arg_messenger_type integer) OWNER TO w4;

SET search_path = public, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: contacts; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE contacts (
    id bigint NOT NULL,
    first_name character varying(250) DEFAULT NULL::character varying,
    last_name character varying(250) DEFAULT NULL::character varying,
    address_1 character varying(250) DEFAULT NULL::character varying,
    address_2 character varying(250) DEFAULT NULL::character varying,
    country_id bigint,
    region_id bigint,
    city_id bigint,
    city_name character varying(250) DEFAULT NULL::character varying,
    postal_code character varying(16) DEFAULT NULL::character varying,
    messenger_name character varying(250) DEFAULT NULL::character varying,
    messenger_type bigint,
    primary_phone text DEFAULT NULL::character varying,
    secondary_phone character varying(32) DEFAULT NULL::character varying,
    fax character varying(32) DEFAULT NULL::character varying,
    email_address character varying(250) DEFAULT NULL::character varying,
    is_primary boolean DEFAULT false,
    is_billing boolean DEFAULT false,
    country_name text,
    region_name text
);


ALTER TABLE public.contacts OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: create_advertiser_contact(bigint, character varying, character varying, character varying, character varying, bigint, bigint, bigint, character varying, character varying, character varying, bigint, character varying, character varying, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_advertiser_contact(arg_advertiser_id bigint, arg_first_name character varying DEFAULT NULL::character varying, arg_last_name character varying DEFAULT NULL::character varying, arg_address_1 character varying DEFAULT NULL::character varying, arg_address_2 character varying DEFAULT NULL::character varying, arg_country_id bigint DEFAULT (-1), arg_region_id bigint DEFAULT (-1), arg_city_id bigint DEFAULT (-1), arg_city_name character varying DEFAULT NULL::character varying, arg_postal_code character varying DEFAULT NULL::character varying, arg_messenger_name character varying DEFAULT NULL::character varying, arg_messenger_type bigint DEFAULT NULL::bigint, arg_primary_phone character varying DEFAULT NULL::character varying, arg_secondary_phone character varying DEFAULT NULL::character varying, arg_fax character varying DEFAULT NULL::character varying, arg_email_address character varying DEFAULT NULL::character varying, arg_is_primary boolean DEFAULT false, arg_is_billing boolean DEFAULT false) RETURNS public.contacts
    LANGUAGE plpgsql
    AS $$
	DECLARE
	    ret_id BIGINT;
        ret_rec contacts;
	BEGIN
	    ret_id:=create_contact(arg_first_name,arg_last_name,arg_address_1,arg_address_2,arg_country_id,arg_region_id,arg_city_id,arg_city_name,arg_postal_code,arg_messenger_name,arg_messenger_type, arg_primary_phone, arg_secondary_phone, arg_fax, arg_email_address); 
        PERFORM * FROM advertiser_contacts WHERE advertiser_id=arg_advertiser_id AND contact_id=ret_id;
	    IF NOT FOUND THEN
	        INSERT INTO advertiser_contacts ("advertiser_id","contact_id") VALUES (arg_advertiser_id,ret_id);
	    END IF;
	    IF arg_is_primary THEN
            UPDATE advertisers SET primary_contact_id=ret_id, contact_name=arg_first_name || ' ' || arg_last_name, phone=arg_primary_phone, mobile=arg_secondary_phone, email=arg_email_address, messenger_id=arg_messenger_name || ' ' || arg_messenger_type::text, fax=arg_fax, address_1=arg_address_1, address_2=arg_address_2, city=arg_city_name, "state"=(SELECT ascii_name FROM geo_typeahead_region WHERE id=arg_region_id), country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id), zip=arg_postal_code  WHERE id=arg_advertiser_id;
	    END IF;
	    IF arg_is_billing THEN
            UPDATE advertisers SET billing_contact_id=ret_id, billing_first_name=arg_first_name, billing_last_name=arg_last_name, billing_address_1=arg_address_1, billing_address_2=arg_address_2, billing_city=arg_city_name, billing_region_id=arg_region_id, billing_country_id=arg_country_id WHERE id=arg_advertiser_id;
	    END IF;
        SELECT INTO ret_rec * FROM contacts WHERE id=ret_id;
	    IF arg_is_primary THEN
            ret_rec.is_primary:=TRUE;
        ELSE
            ret_rec.is_primary:=FALSE;
        END IF;
        IF arg_is_billing THEN
            ret_rec.is_billing:=TRUE;
        ELSE
            ret_rec.is_primary:=FALSE;
        END IF;
	    RETURN ret_rec;
	END;
$$;


ALTER FUNCTION w4_application_functions.create_advertiser_contact(arg_advertiser_id bigint, arg_first_name character varying, arg_last_name character varying, arg_address_1 character varying, arg_address_2 character varying, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_city_name character varying, arg_postal_code character varying, arg_messenger_name character varying, arg_messenger_type bigint, arg_primary_phone character varying, arg_secondary_phone character varying, arg_fax character varying, arg_email_address character varying, arg_is_primary boolean, arg_is_billing boolean) OWNER TO w4;

--
-- Name: create_campaign(character varying, bigint, timestamp with time zone, timestamp with time zone, bigint, character varying, text, text, bigint, integer, bigint, boolean, text, text, character varying, numeric, integer, bigint, numeric, integer, bigint, bigint, boolean, public.suppression, text, text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_campaign(arg_name character varying, arg_advertiser_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_access_type_id bigint, arg_status character varying, arg_channels_json text, arg_categories_json text, arg_cookie_duration bigint, arg_cookie_duration_type_id integer, arg_tracking_type_id bigint, arg_tracking_type_secure boolean, arg_description_html text, arg_restriction_html text, arg_default_redirect_url character varying, arg_default_payin numeric, arg_payin_type_id integer, arg_payin_model_id bigint, arg_default_payout numeric, arg_payout_type_id integer, arg_payout_model_id bigint, arg_currency_id bigint, arg_allow_postback_payin boolean, arg_suppression_type public.suppression DEFAULT NULL::public.suppression, arg_suppression_id text DEFAULT NULL::text, arg_suppression_external_name text DEFAULT NULL::text, arg_manager_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        split_categories TEXT[];
        split_channels TEXT[];
        x TEXT;
        var_campaign_id bigint;
        var_suppression_result json;
        var_suppression_id bigint;
        var_suppression_internal_id bigint := NULL;
        var_suppression_external_id text := NULL;
        var_tracking_type_name TEXT;
        var_screenshot_id bigint := NULL;

    BEGIN

	----- check that dates are valid
        IF (arg_start_date > arg_end_date) THEN
            RAISE EXCEPTION 'Campaign expires on % before it begins on %.', arg_end_date, arg_start_date;
        END IF;

	----- tracking type check
        SELECT INTO var_tracking_type_name tracking_type_name FROM campaign_tracking_type_lookup WHERE id=arg_tracking_type_id;

        ----- screenshots
         IF (arg_default_redirect_url IS NOT NULL) THEN
        SELECT w4api.screenshot_create(arg_default_redirect_url) INTO var_screenshot_id;
         END IF;
        
        INSERT INTO campaigns
            (
                "name",
                "user_id",
                "advertiser_id",
                "description",
                "restrictions",
                "default_redirect_url",
                "screenshot_id",
                "start_date",
                "expiry_date",
                "access_type",
                "status",
                "cookie_duration_time",
                "cookie_duration_unit",
                "tracking_type_id",
                "tracking_type",
                "tracking_secure",
                "default_payin",
                "default_payout",
                "payout_type",
                "payout_model_id",
                "payin_type",
                "payin_model_id",
                "currency_id",
                "allow_postback_payin"
            )
            VALUES (
                arg_name,
                arg_manager_id,
                arg_advertiser_id,
                arg_description_html,
                arg_restriction_html,
                arg_default_redirect_url,
                var_screenshot_id::CHARACTER VARYING,
                arg_start_date,
                arg_end_date,
                arg_access_type_id,
                arg_status,
                arg_cookie_duration,
                arg_cookie_duration_type_id,
                arg_tracking_type_id,
                var_tracking_type_name,
                arg_tracking_type_secure,
                arg_default_payin,
                arg_default_payout,
                arg_payout_type_id,
                arg_payout_model_id,
                arg_payin_type_id,
                arg_payin_model_id,
                arg_currency_id,
                arg_allow_postback_payin
            ) RETURNING id INTO var_campaign_id;

	----- supression updates
        IF ((arg_suppression_type IS NOT NULL) AND (arg_suppression_id IS NOT NULL)) THEN
            IF (arg_suppression_type = 'internal') THEN
                var_suppression_internal_id = arg_suppression_id;
            ELSE
                var_suppression_external_id = arg_suppression_id;
            END IF;
            var_suppression_result := w4api.campaign_suppression_lists_create(var_campaign_id, arg_suppression_type,arg_manager_id, 'active'::status_entity, var_suppression_internal_id, var_suppression_external_id, arg_suppression_external_name);
        END IF;
        
	---- insert channels and categories
        split_channels:=string_to_array(replace(replace(replace(arg_channels_json,'"',''),']',''),'[',''),',');
        split_categories:=string_to_array(replace(replace(replace(arg_categories_json,'"',''),']',''),'[',''),',');

        FOREACH x IN ARRAY split_channels LOOP
            INSERT INTO campaign_channels (campaign_id,channel_id) VALUES (var_campaign_id,x::INTEGER);
        END LOOP;

        FOREACH x IN ARRAY split_categories LOOP
            INSERT INTO campaign_categories (campaign_id,category_id) VALUES (var_campaign_id,x::INTEGER);
        END LOOP;
        ---- return json with new campaign data
        EXECUTE 'SELECT w4api.campaign_get(arg_campaign_ids:=''['||var_campaign_id||']'')' INTO ret_val;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_campaign(arg_name character varying, arg_advertiser_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_access_type_id bigint, arg_status character varying, arg_channels_json text, arg_categories_json text, arg_cookie_duration bigint, arg_cookie_duration_type_id integer, arg_tracking_type_id bigint, arg_tracking_type_secure boolean, arg_description_html text, arg_restriction_html text, arg_default_redirect_url character varying, arg_default_payin numeric, arg_payin_type_id integer, arg_payin_model_id bigint, arg_default_payout numeric, arg_payout_type_id integer, arg_payout_model_id bigint, arg_currency_id bigint, arg_allow_postback_payin boolean, arg_suppression_type public.suppression, arg_suppression_id text, arg_suppression_external_name text, arg_manager_id bigint) OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: categories; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE categories (
    id bigint NOT NULL,
    parent_id bigint,
    name character varying(255) NOT NULL,
    description text,
    CONSTRAINT categories_parent_id_check CHECK ((parent_id >= 0))
);


ALTER TABLE public.categories OWNER TO w4;

--
-- Name: vw_category; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_category AS
 SELECT cat.id,
    cat.name,
    cat.description,
    cat.parent_id,
    pcat.name AS parent_name
   FROM (categories cat
   LEFT JOIN categories pcat ON ((cat.parent_id = pcat.id)));


ALTER TABLE public.vw_category OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: create_category(character varying, text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_category(arg_name character varying, arg_description text, arg_parent_id bigint DEFAULT 0) RETURNS public.vw_category
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val vw_category;
        idx BIGINT;
        check_val BIGINT;
        chk_val BIGINT;
        cat_depth INTEGER;
        max_depth INTEGER;
    BEGIN
        max_depth:=2; -- Allow for a depth of 2 per Jason
        IF arg_parent_id > 0 THEN
            -- Check parent_id to ensure that it won't cause recursion
            cat_depth:=0;
            chk_val:=arg_parent_id;
            LOOP
                cat_depth:=cat_depth+1;
                SELECT INTO check_val parent_id FROM categories WHERE id=chk_val;
                IF check_val > 0 THEN
                    chk_val:=check_val;
                ELSE
                    -- It's OK to insert, it's not past the recursion limit
                    idx:=nextval('categories_id_seq');
                    INSERT INTO categories("id","parent_id","name","description") VALUES (idx,arg_parent_id,arg_name,arg_description);    
                    SELECT INTO ret_val * FROM vw_category WHERE id=idx;
                    RETURN ret_val;
                END IF;
                IF cat_depth > max_depth THEN
                    -- It's NOT OK to insert this, it's past the recursion limit
                    RAISE WARNING 'You can not assign a category to a category that is % deep',max_depth;
                    RETURN ret_val;
                END IF;
            END LOOP;
        ELSE
            -- Top level Category
            idx:=nextval('categories_id_seq');
            INSERT INTO categories("id","parent_id","name","description") VALUES (idx,0,arg_name,arg_description);
            SELECT INTO ret_val * FROM vw_category WHERE id=idx;
            RETURN ret_val;
        END IF;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_category(arg_name character varying, arg_description text, arg_parent_id bigint) OWNER TO w4;

--
-- Name: create_cmpl_downloaded(bigint, bigint, character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_cmpl_downloaded(arg_campaign_id bigint, arg_publisher_id bigint, arg_sha1_hash character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val bigint;
        rows_mod integer;
    BEGIN
        IF arg_campaign_id IS NULL OR arg_sha1_hash IS NULL THEN
            RAISE EXCEPTION 'Missing one or more required params.';
        END IF;

        ret_val:=nextval('public.cmpl_downloaded_id_seq');
        INSERT INTO cmpl_downloaded (id, campaign_id, publisher_id, downloaded_ts, sha1_hash) VALUES
            (ret_val, arg_campaign_id, arg_publisher_id, CURRENT_TIMESTAMP, arg_sha1_hash);
        GET DIAGNOSTICS rows_mod = ROW_COUNT;
        IF rows_mod < 1 THEN
            RAISE EXCEPTION  'General insert failure.';
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_cmpl_downloaded(arg_campaign_id bigint, arg_publisher_id bigint, arg_sha1_hash character varying) OWNER TO w4;

--
-- Name: create_contact(character varying, character varying, character varying, character varying, bigint, bigint, bigint, character varying, character varying, character varying, bigint, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_contact(arg_first_name character varying, arg_last_name character varying, arg_address_1 character varying, arg_address_2 character varying, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_city_name character varying, arg_postal_code character varying, arg_messenger_name character varying, arg_messenger_type bigint, arg_primary_phone character varying, arg_secondary_phone character varying, arg_fax character varying, arg_email_address character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
	DECLARE
		ret_id BIGINT;
	BEGIN
		ret_id:=nextval('contacts_id_seq');
		INSERT INTO contacts VALUES (ret_id,arg_first_name,arg_last_name,arg_address_1,arg_address_2,arg_country_id,arg_region_id,arg_city_id,arg_city_name,arg_postal_code,arg_messenger_name,arg_messenger_type,arg_primary_phone,arg_secondary_phone,arg_fax,arg_email_address); 
		RETURN ret_id;
	END;
$$;


ALTER FUNCTION w4_application_functions.create_contact(arg_first_name character varying, arg_last_name character varying, arg_address_1 character varying, arg_address_2 character varying, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_city_name character varying, arg_postal_code character varying, arg_messenger_name character varying, arg_messenger_type bigint, arg_primary_phone character varying, arg_secondary_phone character varying, arg_fax character varying, arg_email_address character varying) OWNER TO w4;

--
-- Name: create_file(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_file(arg_user_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val bigint;
        rows_mod integer;
        status status_entity;
    BEGIN
        status = 'pending';
        IF arg_user_id IS NULL THEN
            RAISE EXCEPTION 'Missing one or more required params.';
        END IF;

        ret_val:=nextval('public.files_id_seq');
        INSERT INTO files (id, status, user_id, last_modified) VALUES
            (ret_val, status, arg_user_id, CURRENT_TIMESTAMP);
        GET DIAGNOSTICS rows_mod = ROW_COUNT;
        IF rows_mod < 1 THEN
            RAISE EXCEPTION  'General insert failure.';
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_file(arg_user_id bigint) OWNER TO w4;

--
-- Name: create_manual_conversions(integer, bigint, bigint, timestamp with time zone, numeric, numeric); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_manual_conversions(arg_conversion_quantity integer, arg_publisher_id bigint, arg_campaign_id bigint, arg_conversion_date timestamp with time zone, arg_pay_in_amount numeric, arg_pay_out_amount numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        store_count INTEGER;
        ret_val BIGINT;
    BEGIN
        store_count:=0;
        IF arg_conversion_quantity > 0 THEN
            LOOP
                store_count:=store_count+1;
                ret_val:=nextval('public.engine_conversions_id_seq');
                INSERT INTO engine_conversions (id, click_id, payin, payout, parent_payout, campaign_id, publisher_id, parent_publisher_id, referral_url, creative_id, ip_address, continent, country, region, region_name, city, postal_code, latitude, longitude, metro_code, area_code, browser_id, platform_id, status, channel, modified_date, created_date) VALUES
                    (ret_val,0, arg_pay_in_amount::money, arg_pay_out_amount::money, 0::money, arg_campaign_id, arg_publisher_id, 0, '', 0, '127.0.0.1', 'NA', 'US', 'CA', 'California', 'Santa Monica', '90405', 34.0194, -118.4903, 0, 310, 0, 0, 1, 0,arg_conversion_date,arg_conversion_date);
                RAISE INFO 'Stored count = [%]',store_count;
                EXIT WHEN store_count = arg_conversion_quantity;
            END LOOP;
            RETURN TRUE;
        ELSE
            RAISE WARNING 'Can not create less than 1 manual conversion';
        END IF;
        RETURN FALSE;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_manual_conversions(arg_conversion_quantity integer, arg_publisher_id bigint, arg_campaign_id bigint, arg_conversion_date timestamp with time zone, arg_pay_in_amount numeric, arg_pay_out_amount numeric) OWNER TO w4;

--
-- Name: create_or_update_users(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_or_update_users() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    BEGIN
        -- Determine if insert or update
        IF (TG_OP = 'UPDATE') THEN
            -- Get the new modified date for the update
            IF NEW.modified IS NULL THEN
                NEW.modified:=transaction_timestamp();
            END IF;
        ELSEIF (TG_OP = 'INSERT') THEN
            IF NEW.created IS NULL THEN
                NEW.created:=transaction_timestamp();
            END IF;
            IF NEW.modified IS NULL THEN
                NEW.modified:=transaction_timestamp();
            END IF;
            IF NEW.uuid IS NULL OR NEW.uuid='' THEN
                SELECT INTO NEW.uuid uuid FROM w4_application_functions.uuid();
            END IF;
            IF NEW.login_name IS NULL THEN
		NEW.login_name=NEW.email;
	    END IF;
        END IF;
        -- Be a good little trigger and return the NEW record
        RETURN NEW;        
    END
$$;


ALTER FUNCTION w4_application_functions.create_or_update_users() OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: campaign_piggyback_pixels; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_piggyback_pixels (
    id bigint NOT NULL,
    campaign_id integer NOT NULL,
    publisher_id bigint NOT NULL,
    code text NOT NULL,
    type integer NOT NULL,
    status status_entity NOT NULL,
    user_id bigint NOT NULL,
    last_updated timestamp with time zone,
    created timestamp with time zone,
    CONSTRAINT campaign_piggyback_pixels_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT campaign_piggyback_pixels_publisher_id_check CHECK ((publisher_id >= 0))
);


ALTER TABLE public.campaign_piggyback_pixels OWNER TO w4;

--
-- Name: campaign_tracking_type_lookup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_tracking_type_lookup (
    id bigint NOT NULL,
    tracking_type_name character varying(128)
);


ALTER TABLE public.campaign_tracking_type_lookup OWNER TO w4;

--
-- Name: campaigns; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaigns (
    id bigint NOT NULL,
    advertiser_id bigint,
    user_id integer,
    name character varying(255) NOT NULL,
    description text NOT NULL,
    restrictions text,
    default_redirect_url character varying(2083) NOT NULL,
    screenshot_id character varying(24) DEFAULT NULL::character varying,
    landing_pages text,
    failure_redirect_type smallint DEFAULT (1)::smallint NOT NULL,
    failure_redirect_url character varying(1024) DEFAULT NULL::character varying,
    failure_redirect_campaign_id bigint,
    unsubscription_url character varying(2083) DEFAULT NULL::character varying,
    unsubscription_screenshot_id character varying(24) DEFAULT NULL::character varying,
    default_payout numeric NOT NULL,
    payout_type smallint DEFAULT (1)::smallint,
    payout_model_id integer NOT NULL,
    default_payin numeric NOT NULL,
    payin_type smallint DEFAULT (1)::smallint,
    payin_model_id integer NOT NULL,
    start_date timestamp with time zone NOT NULL,
    is_expiration smallint DEFAULT (0)::smallint NOT NULL,
    expiry_date timestamp with time zone,
    geotargeting_postal_code_directive character varying,
    outgeo_redirect_type smallint DEFAULT (1)::smallint NOT NULL,
    outgeo_redirect_url character varying(1024) DEFAULT NULL::character varying,
    outgeo_redirect_campaign_id bigint,
    outgeo_redirect_screenshot_id character varying(24) DEFAULT NULL::character varying,
    cookie_duration_time smallint NOT NULL,
    cookie_duration_unit smallint NOT NULL,
    access_type smallint DEFAULT (1)::smallint NOT NULL,
    status character varying,
    epc numeric,
    tracking_type character varying,
    tracking_secure character varying DEFAULT 'no'::character varying,
    new_until date,
    do_redirect_mobile smallint DEFAULT (0)::smallint,
    mobile_redirect_url character varying(2048) DEFAULT NULL::character varying,
    mobile_screenshot_id character varying(24) DEFAULT NULL::character varying,
    tracking_type_id bigint,
    currency_id bigint,
    allow_postback_payin boolean,
    suppression_id bigint,
    CONSTRAINT campaigns_access_type_check CHECK ((access_type >= 0)),
    CONSTRAINT campaigns_advertiser_id_check CHECK ((advertiser_id >= 0)),
    CONSTRAINT campaigns_cookie_duration_time_check CHECK ((cookie_duration_time >= 0)),
    CONSTRAINT campaigns_cookie_duration_unit_check CHECK ((cookie_duration_unit >= 0)),
    CONSTRAINT campaigns_default_payin_check CHECK ((default_payin >= (0)::numeric)),
    CONSTRAINT campaigns_default_payout_check CHECK ((default_payout >= (0)::numeric)),
    CONSTRAINT campaigns_epc_check CHECK ((epc >= (0)::numeric)),
    CONSTRAINT campaigns_failure_redirect_campaign_id_check CHECK ((failure_redirect_campaign_id >= 0)),
    CONSTRAINT campaigns_failure_redirect_type_check CHECK ((failure_redirect_type >= 0)),
    CONSTRAINT campaigns_geotargeting_postal_code_directive_check CHECK (((geotargeting_postal_code_directive)::text = ANY (ARRAY[('deny'::character varying)::text, ('allow'::character varying)::text]))),
    CONSTRAINT campaigns_is_expiration_check CHECK ((is_expiration >= 0)),
    CONSTRAINT campaigns_outgeo_redirect_campaign_id_check CHECK ((outgeo_redirect_campaign_id >= 0)),
    CONSTRAINT campaigns_outgeo_redirect_type_check CHECK ((outgeo_redirect_type >= 0)),
    CONSTRAINT campaigns_payin_model_id_check CHECK ((payin_model_id >= 0)),
    CONSTRAINT campaigns_payin_type_check CHECK ((payin_type >= 0)),
    CONSTRAINT campaigns_payout_model_id_check CHECK ((payout_model_id >= 0)),
    CONSTRAINT campaigns_payout_type_check CHECK ((payout_type >= 0)),
    CONSTRAINT campaigns_status_check CHECK (((status)::text = ANY (ARRAY[('active'::character varying)::text, ('paused'::character varying)::text, ('disabled'::character varying)::text]))),
    CONSTRAINT campaigns_user_id_check CHECK ((user_id >= 0))
);


ALTER TABLE public.campaigns OWNER TO w4;

--
-- Name: COLUMN campaigns.failure_redirect_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaigns.failure_redirect_type IS '1 - Url, 2 - Campaign';


--
-- Name: COLUMN campaigns.payout_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaigns.payout_type IS '1 - Flat Rate, 2 - Percentage';


--
-- Name: COLUMN campaigns.payin_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaigns.payin_type IS '1 - Flat Rate, 2 - Percentage';


--
-- Name: COLUMN campaigns.outgeo_redirect_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaigns.outgeo_redirect_type IS '1 - Url, 2 - Campaign';


--
-- Name: COLUMN campaigns.cookie_duration_unit; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaigns.cookie_duration_unit IS '1 - Seconds, 2 - Minutes, 3 - Hours, 4 - Days, 5 - Weeks, 6 - Months, 7 - Years';


--
-- Name: COLUMN campaigns.access_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaigns.access_type IS '1 - Public, 2 - Private, 3 - By Approval';


--
-- Name: user_profiles; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_profiles (
    id bigint NOT NULL,
    user_uuid character(36) DEFAULT NULL::bpchar,
    first_name character varying(255) DEFAULT NULL::character varying,
    last_name character varying(255) DEFAULT NULL::character varying,
    address_1 character varying(255) DEFAULT NULL::character varying,
    address_2 character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    state character(250) DEFAULT NULL::bpchar,
    zip character varying(10) DEFAULT NULL::character varying,
    country character(250) DEFAULT NULL::bpchar,
    created timestamp with time zone,
    modified timestamp with time zone,
    image_id character varying(255) DEFAULT NULL::character varying,
    phone text DEFAULT NULL::character varying,
    cell character varying(30) DEFAULT NULL::character varying,
    messenger_id character varying(255) DEFAULT NULL::character varying,
    messenger_type bigint,
    skype character varying(255) DEFAULT NULL::character varying,
    preferred_language character varying(32) DEFAULT NULL::character varying,
    contact_email character varying(255) DEFAULT NULL::character varying,
    tier_id integer,
    currency character varying(16) DEFAULT NULL::character varying,
    region character varying(32) DEFAULT NULL::character varying,
    fax character varying(32) DEFAULT NULL::character varying,
    company_name character varying(255) DEFAULT NULL::character varying,
    company_position character varying(255) DEFAULT NULL::character varying,
    payment_address_1 character varying(255) DEFAULT NULL::character varying,
    payment_address_2 character varying(255) DEFAULT NULL::character varying,
    payment_city character varying(255) DEFAULT NULL::character varying,
    payment_region character varying(255) DEFAULT NULL::character varying,
    payment_postal_code character varying(10) DEFAULT NULL::character varying,
    payment_country character(250) DEFAULT NULL::bpchar,
    payment_to character varying,
    payment_by smallint,
    payment_schedule character varying,
    payment_threshold numeric(18,4) DEFAULT NULL::numeric,
    tax_id character varying(32) DEFAULT NULL::character varying,
    website_url character varying(255) DEFAULT NULL::character varying,
    website_category character varying(255) DEFAULT NULL::character varying,
    website_marketing character varying(255) DEFAULT NULL::character varying,
    is_network_account smallint,
    is_require_renewed_terms smallint,
    has_uploaded_w9_file smallint,
    approver_id bigint,
    approve_date timestamp with time zone,
    registration_comment text,
    register_ip_address inet,
    register_date timestamp with time zone,
    payment_bank_routing_number character varying(30) DEFAULT NULL::character varying,
    payment_bank_account_number character varying(40) DEFAULT NULL::character varying,
    user_id bigint DEFAULT 1306 NOT NULL,
    notes text DEFAULT ''::text NOT NULL,
    CONSTRAINT user_profiles_is_network_account_check CHECK ((is_network_account >= 0)),
    CONSTRAINT user_profiles_payment_schedule_check CHECK (((payment_schedule)::text = ANY (ARRAY[('monthly'::character varying)::text, ('weekly'::character varying)::text, ('semi-monthly'::character varying)::text, ('bi-weekly'::character varying)::text, NULL::text]))),
    CONSTRAINT user_profiles_payment_to_check CHECK (((payment_to)::text = ANY (ARRAY[('company'::character varying)::text, ('person'::character varying)::text])))
);


ALTER TABLE public.user_profiles OWNER TO w4;

--
-- Name: users; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE users (
    uuid character(36) NOT NULL,
    id bigint NOT NULL,
    email character varying(255) DEFAULT NULL::character varying,
    password character(40) DEFAULT NULL::bpchar,
    parent_id bigint,
    manager_id bigint,
    active character varying DEFAULT 'unconfirmed'::character varying,
    access character varying,
    ip_address inet,
    last_login timestamp with time zone,
    created timestamp with time zone,
    modified timestamp with time zone,
    login_name character varying NOT NULL,
    primary_contact_id bigint,
    billing_contact_id bigint,
    account_contact_id bigint,
    contact_id bigint,
    referrer_id bigint,
    CONSTRAINT users_access_check CHECK (((access)::text = ANY (ARRAY[('admin'::character varying)::text, ('publisher'::character varying)::text, ('advertiser'::character varying)::text, ('root'::character varying)::text, ('accountant'::character varying)::text]))),
    CONSTRAINT users_active_check CHECK (((active)::text = ANY (ARRAY[('active'::character varying)::text, ('suspended'::character varying)::text, ('unconfirmed'::character varying)::text, ('banned'::character varying)::text, ('collections'::character varying)::text])))
);


ALTER TABLE public.users OWNER TO w4;

--
-- Name: vw_piggyback_pixel; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_piggyback_pixel AS
 SELECT cpp.id,
    cpp.campaign_id,
    cpp.publisher_id,
    cpp.code,
    cpp.type,
    cpp.status,
    cpp.user_id,
    cpp.last_updated,
    cpp.type AS tracking_type_id,
    c.name AS campaign_name,
    pp.company_name AS publisher_name,
    up.first_name AS user_first_name,
    up.last_name AS user_last_name,
    tt.tracking_type_name,
    concat(up.first_name, ' ', up.last_name) AS user_name,
    c.currency_id
   FROM ((((((campaign_piggyback_pixels cpp
   RIGHT JOIN campaigns c ON ((cpp.campaign_id = c.id)))
   LEFT JOIN users u ON ((cpp.user_id = u.id)))
   LEFT JOIN users p ON (((cpp.publisher_id = p.id) AND ((p.access)::text = 'publisher'::text))))
   LEFT JOIN user_profiles pp ON ((p.id = pp.user_id)))
   LEFT JOIN user_profiles up ON ((u.id = up.user_id)))
   LEFT JOIN campaign_tracking_type_lookup tt ON ((cpp.type = tt.id)))
  WHERE (cpp.status = 'active'::status_entity);


ALTER TABLE public.vw_piggyback_pixel OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: create_piggyback_pixel(bigint, bigint, character varying, integer, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_piggyback_pixel(arg_campaign_id bigint, arg_publisher_id bigint, arg_code character varying, arg_tracking_type_id integer, arg_user_id bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS public.vw_piggyback_pixel
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val vw_piggyback_pixel;
        ret_id  bigint;
        rows_mod integer;
        status status_entity;
        tmp_id BIGINT;
    BEGIN
        status = 'active';
        IF arg_campaign_id < 1 OR arg_publisher_id < 1 OR arg_tracking_type_id < 1 THEN
            RAISE EXCEPTION 'Missing one or more required params.';
        END IF;

        PERFORM * FROM campaign_tracking_type_lookup WHERE id=arg_tracking_type_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Tracking type id not found.';
        END IF;

        PERFORM * FROM campaign_piggyback_pixels cpp WHERE campaign_id = arg_campaign_id AND publisher_id = arg_publisher_id AND cpp.status = 'active';
        IF (FOUND) THEN
            RAISE EXCEPTION 'Cannot have more than one pixel per campaign / publisher combo.';
        END IF;

        INSERT INTO campaign_piggyback_pixels (campaign_id, publisher_id, code, type, status, user_id, last_updated, created) VALUES
            (arg_campaign_id, arg_publisher_id, arg_code, arg_tracking_type_id, status, arg_user_id, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
            RETURNING id
            INTO ret_id;
        GET DIAGNOSTICS rows_mod = ROW_COUNT;
        IF rows_mod < 1 THEN
            RAISE EXCEPTION 'General insert failure.';
        END IF;

        SELECT INTO ret_val * FROM vw_piggyback_pixel WHERE id=ret_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_piggyback_pixel(arg_campaign_id bigint, arg_publisher_id bigint, arg_code character varying, arg_tracking_type_id integer, arg_user_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: create_publisher(text, text, text, text, text, text, bigint, text, text, text, text, bigint, text, text, text, text, text, text, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_publisher(arg_login_name text, arg_name text, arg_first_name text, arg_last_name text, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_name text, arg_city_name text, arg_postal_code text, arg_messenger_name text, arg_messenger_type bigint, arg_primary_phone text, arg_secondary_phone text, arg_fax text, arg_url text, arg_tax_id text, arg_email_address text, arg_password text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        next_id bigint;
        
        primary_contact_id bigint;
        billing_contact_id bigint;
        account_contact_id bigint;
        
        var_city_id    bigint;
        var_region_id  bigint;
        var_country_name text;
        
        vuuid text;
    BEGIN
        next_id := nextval( 'users_id_seq' );
        vuuid := uuid();
        
	-- NOTE: this arrangement creates the publisher with a NULL primary_contact_id prior to filling it out
	-- via create_publisher_contact. The code from the function can be inlined here to order the operations
	-- here more correctly

	PERFORM login_name FROM users WHERE login_name ILIKE arg_login_name;
	IF FOUND THEN
            RAISE EXCEPTION 'The login name [%] is in use by another user', arg_login_name;
	END IF;

        SELECT country_name, region_id, city_id FROM geo_get(arg_country_id, arg_region_name, arg_city_name) INTO var_country_name, var_region_id, var_city_id;
        
        billing_contact_id := create_contact( arg_name, '', arg_address_1, arg_address_2, arg_country_id, var_region_id, var_city_id, arg_city_name, arg_postal_code, '', null, '', '', '', '' );
        account_contact_id := create_contact( arg_name, '', arg_address_1, arg_address_2, arg_country_id, var_region_id, var_city_id, arg_city_name, arg_postal_code, '', null, '', '', '', '' );

        INSERT INTO users
            (id, login_name, email, password, uuid, active, access, primary_contact_id, billing_contact_id, account_contact_id)
            VALUES (next_id,arg_login_name,arg_email_address,arg_password, vuuid, 'unconfirmed', 'publisher', NULL::bigint, billing_contact_id, account_contact_id);
        
        INSERT INTO user_profiles
            (user_uuid, user_id, company_name, tax_id, website_url, first_name, last_name, address_1, address_2, city, state, region, zip, country, payment_address_1, payment_address_2,
                payment_city, payment_region, payment_postal_code, payment_country, created, modified, phone, cell, messenger_id, messenger_type, fax, contact_email)
            VALUES (vuuid, next_id, arg_name, arg_tax_id, arg_url, arg_first_name, arg_last_name, arg_address_1, arg_address_2, arg_city_name, arg_region_name, arg_region_name,
                arg_postal_code, var_country_name, arg_address_1, arg_address_2, arg_city_name, arg_region_name, arg_postal_code, var_country_name, now(), now(), arg_primary_phone,
                arg_secondary_phone, arg_messenger_name, arg_messenger_type, arg_fax, arg_email_address);

        primary_contact_id := id FROM create_publisher_contact(next_id, arg_first_name, arg_last_name, '', '', arg_country_id, var_region_id, var_city_id, '', '', arg_messenger_name, arg_messenger_type, arg_primary_phone, arg_secondary_phone, arg_fax, arg_email_address, true, false );

	EXECUTE 'SELECT w4api.publisher_get_list(arg_publisher_ids:=''['||next_id||']'')' INTO ret_val;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_publisher(arg_login_name text, arg_name text, arg_first_name text, arg_last_name text, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_name text, arg_city_name text, arg_postal_code text, arg_messenger_name text, arg_messenger_type bigint, arg_primary_phone text, arg_secondary_phone text, arg_fax text, arg_url text, arg_tax_id text, arg_email_address text, arg_password text) OWNER TO w4;

--
-- Name: create_publisher_ban(bigint, bigint, bigint, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_publisher_ban(arg_publisher_id bigint, arg_advertiser_id bigint, arg_campaign_id bigint, arg_sub_id_1 character varying, arg_sub_id_2 character varying, arg_sub_id_3 character varying, arg_sub_id_4 character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val bigint;
	rows_mod integer;
        status status_entity;
    BEGIN
        IF arg_publisher_id < 1 OR arg_advertiser_id < 1 THEN
            RETURN -2; --Missing one or more required params
        END IF;

        status := 'active';
        ret_val:=nextval('public.advertiser_banned_publishers_id_seq');
        BEGIN
        INSERT INTO advertiser_banned_publishers (id, advertiser_id, publisher_id, campaign_id, sub_id_1, sub_id_2, sub_id_3, sub_id_4, status) VALUES
            (ret_val, arg_advertiser_id, arg_publisher_id, arg_campaign_id, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, status);
        GET DIAGNOSTICS rows_mod = ROW_COUNT;
        IF rows_mod < 1 THEN
            RETURN -3;  --General insert failure
        END IF;
        EXCEPTION WHEN unique_violation THEN
            RETURN -4; --Duplicate ban for publisher and advertiser
        END;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_publisher_ban(arg_publisher_id bigint, arg_advertiser_id bigint, arg_campaign_id bigint, arg_sub_id_1 character varying, arg_sub_id_2 character varying, arg_sub_id_3 character varying, arg_sub_id_4 character varying) OWNER TO w4;

--
-- Name: create_publisher_contact(bigint, character varying, character varying, character varying, character varying, bigint, bigint, bigint, character varying, character varying, character varying, bigint, character varying, character varying, character varying, character varying, boolean, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_publisher_contact(arg_publisher_id bigint, arg_first_name character varying DEFAULT NULL::character varying, arg_last_name character varying DEFAULT NULL::character varying, arg_address_1 character varying DEFAULT NULL::character varying, arg_address_2 character varying DEFAULT NULL::character varying, arg_country_id bigint DEFAULT (-1), arg_region_id bigint DEFAULT (-1), arg_city_id bigint DEFAULT (-1), arg_city_name character varying DEFAULT NULL::character varying, arg_postal_code character varying DEFAULT NULL::character varying, arg_messenger_name character varying DEFAULT NULL::character varying, arg_messenger_type bigint DEFAULT NULL::bigint, arg_primary_phone character varying DEFAULT NULL::character varying, arg_secondary_phone character varying DEFAULT NULL::character varying, arg_fax character varying DEFAULT NULL::character varying, arg_email_address character varying DEFAULT NULL::character varying, arg_is_primary boolean DEFAULT false, arg_is_billing boolean DEFAULT false, arg_is_account boolean DEFAULT false) RETURNS public.contacts
    LANGUAGE plpgsql
    AS $$
	DECLARE
	    ret_id BIGINT;
        ret_rec contacts;
	BEGIN
        ret_id:=w4_application_functions.create_contact(arg_first_name,arg_last_name,arg_address_1,arg_address_2,arg_country_id,arg_region_id,arg_city_id,arg_city_name,arg_postal_code,arg_messenger_name,arg_messenger_type, arg_primary_phone, arg_secondary_phone, arg_fax, arg_email_address); 
        PERFORM * FROM publisher_contact WHERE publisher_id=arg_publisher_id AND contact_id=ret_id;
	    IF NOT FOUND THEN
	        INSERT INTO publisher_contact ("publisher_id","contact_id") VALUES (arg_publisher_id,ret_id);
	    END IF;
        IF arg_is_primary THEN
            UPDATE users SET primary_contact_id=ret_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET first_name=arg_first_name, last_name=arg_last_name, address_1=arg_address_1, address_2=arg_address_2, city=arg_city_name, "state"=(SELECT region FROM geo_typeahead_region WHERE id=arg_region_id), country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id), zip=arg_postal_code, phone=arg_primary_phone, cell=arg_secondary_phone, messenger_id=arg_messenger_name, messenger_type=arg_messenger_type, fax=arg_fax WHERE user_id=arg_publisher_id;
        END IF;
        IF arg_is_billing THEN
            UPDATE users SET billing_contact_id=ret_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET payment_address_1=arg_address_1, payment_address_2=arg_address_2, payment_city=arg_city_name, payment_region=(SELECT region FROM geo_typeahead_region WHERE id=arg_region_id), payment_postal_code=arg_postal_code, payment_country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id) WHERE user_id=arg_publisher_id;
        END IF; 
        IF arg_is_account THEN
            UPDATE users SET account_contact_id=ret_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET address_1=arg_address_1, address_2=arg_address_2, city=arg_city_name, state=(SELECT region FROM geo_typeahead_region WHERE id=arg_region_id), 
            zip=arg_postal_code, 
            country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id) WHERE user_id=arg_publisher_id;
        END IF; 
	    SELECT INTO ret_rec * FROM contacts WHERE id=ret_id;
	    IF arg_is_primary THEN
            ret_rec.is_primary:=TRUE;
        ELSE
            ret_rec.is_primary:=FALSE;
        END IF;
        IF arg_is_billing THEN
            ret_rec.is_billing:=TRUE;
        ELSE
            ret_rec.is_primary:=FALSE;
        END IF;
	    RETURN ret_rec;
	END;
$$;


ALTER FUNCTION w4_application_functions.create_publisher_contact(arg_publisher_id bigint, arg_first_name character varying, arg_last_name character varying, arg_address_1 character varying, arg_address_2 character varying, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_city_name character varying, arg_postal_code character varying, arg_messenger_name character varying, arg_messenger_type bigint, arg_primary_phone character varying, arg_secondary_phone character varying, arg_fax character varying, arg_email_address character varying, arg_is_primary boolean, arg_is_billing boolean, arg_is_account boolean) OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: publisher_overrides; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_overrides (
    id bigint NOT NULL,
    override_payout double precision,
    override_payin double precision,
    effective_date timestamp with time zone,
    expiration_date timestamp with time zone,
    override_advertiser_landing_page character varying(256) DEFAULT NULL::character varying,
    campaign_id integer NOT NULL,
    publisher_id integer,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    publisher_tier_id integer
);


ALTER TABLE public.publisher_overrides OWNER TO w4;

--
-- Name: vw_publisher_override; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_override AS
 SELECT po.id,
    po.publisher_id,
    COALESCE(up.company_name, (concat(up.first_name, ' ', up.last_name))::character varying) AS publisher_name,
    po.campaign_id,
    c.name AS campaign_name,
    po.override_payout AS payout,
    c.default_payout,
    po.override_payin AS payin,
    c.default_payin,
    (to_json(ARRAY[COALESCE(po.sub_id_1, ''::text), COALESCE(po.sub_id_2, ''::text), COALESCE(po.sub_id_3, ''::text), COALESCE(po.sub_id_4, ''::text)]))::text AS subids_json,
    po.override_advertiser_landing_page AS landing_page,
    to_char(po.effective_date, 'mm/dd/YYYY'::text) AS start_date,
    to_char(po.expiration_date, 'mm/dd/YYYY'::text) AS end_date
   FROM (((publisher_overrides po
   LEFT JOIN users u ON ((po.publisher_id = u.id)))
   LEFT JOIN user_profiles up ON ((u.id = up.user_id)))
   LEFT JOIN campaigns c ON ((po.campaign_id = c.id)))
  WHERE (c.name IS NOT NULL);


ALTER TABLE public.vw_publisher_override OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: create_publisher_override(bigint, bigint, numeric, numeric, json, text, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_publisher_override(arg_publisher_id bigint, arg_campaign_id bigint, arg_payout numeric, arg_payin numeric, arg_subids_json json, arg_landing_page text, arg_start_date timestamp with time zone DEFAULT now(), arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_tier bigint DEFAULT 0) RETURNS public.vw_publisher_override
    LANGUAGE plpgsql
    AS $$
    DECLARE
        idx BIGINT;
        ret_val vw_publisher_override;
        sub_ids VARCHAR[];
    BEGIN
        IF make_doy(arg_start_date) = make_doy(now()) THEN
            arg_start_date:=now();
        END IF;
        idx=nextval('publisher_overrides_id_seq');
sub_ids=parse_flat_json(arg_subids_json::TEXT);
        INSERT INTO publisher_overrides 
            (id, override_payout, override_payin, effective_date, expiration_date, override_advertiser_landing_page, campaign_id, publisher_id, sub_id_1, sub_id_2, sub_id_3,sub_id_4, publisher_tier_id)
        VALUES (idx,arg_payout,arg_payin,arg_start_date,arg_end_date,arg_landing_page,arg_campaign_id,arg_publisher_id,sub_ids[1],sub_ids[2],sub_ids[3],sub_ids[4],arg_publisher_tier);
        SELECT INTO ret_val * FROM vw_publisher_override WHERE id=idx;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.create_publisher_override(arg_publisher_id bigint, arg_campaign_id bigint, arg_payout numeric, arg_payin numeric, arg_subids_json json, arg_landing_page text, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_publisher_tier bigint) OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: vw_user; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_user AS
 SELECT u.id,
    u.email AS email_address,
    u.login_name,
    up.first_name,
    up.last_name,
    (((up.first_name)::text || ' '::text) || (up.last_name)::text) AS full_name,
    u.manager_id,
    upm.first_name AS manager_first_name,
    upm.last_name AS manager_last_name,
    (((upm.first_name)::text || ' '::text) || (upm.last_name)::text) AS manager_full_name,
    up.image_id,
    up.messenger_type,
    up.messenger_id AS messenger_name,
    up.phone AS primary_phone
   FROM ((users u
   LEFT JOIN user_profiles up ON ((u.id = up.user_id)))
   LEFT JOIN user_profiles upm ON ((u.manager_id = upm.user_id)))
  WHERE (((u.access)::text = 'admin'::text) AND ((u.active)::text <> 'banned'::text))
  ORDER BY concat(up.first_name, ' ', up.last_name);


ALTER TABLE public.vw_user OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: create_user(character varying, character varying, character varying, character varying, character varying, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION create_user(arg_login_name character varying, arg_email_address character varying, arg_password character varying, arg_first_name character varying, arg_last_name character varying, arg_image_id bigint, arg_manager_id bigint DEFAULT 0) RETURNS public.vw_user
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val vw_user;
        udv VARCHAR;
        uds VARCHAR;
        upd BOOLEAN;
        usr_uuid VARCHAR;
        usr_id BIGINT;
        usr_prof_id BIGINT;
        var_image_id text := arg_image_id::text;

    BEGIN
        usr_uuid=uuid();
        upd=FALSE;
        IF arg_login_name <> '' AND arg_login_name IS NOT NULL THEN
            PERFORM * FROM users WHERE login_name ILIKE arg_login_name;
            IF FOUND THEN
                RAISE EXCEPTION $$The login_name [%] is already in use$$,arg_login_name;
            END IF;
        END IF;
        IF arg_login_name = '' OR arg_login_name IS NULL THEN
            RAISE EXCEPTION $$The login_name must not be blank$$;
        END IF;
        usr_id=nextval('users_id_seq');
        IF arg_password = '' THEN
            RAISE EXCEPTION $$Password must not be blank$$;
        END IF;
        INSERT INTO users VALUES (usr_uuid,usr_id,COALESCE(arg_email_address,''),arg_password,DEFAULT,COALESCE(arg_manager_id,-1),DEFAULT,'admin',DEFAULT,DEFAULT,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP,COALESCE(arg_login_name,''),0,0,0);
        usr_prof_id:=nextval('user_profiles_id_seq');
        INSERT INTO user_profiles VALUES(usr_prof_id,usr_uuid,COALESCE(arg_first_name,''),COALESCE(arg_last_name,''),DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP,COALESCE(var_image_id,''),DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,0,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,0,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,0,0,0,0,DEFAULT,DEFAULT,DEFAULT,CURRENT_TIMESTAMP,DEFAULT,DEFAULT,usr_id);
        SELECT 
		      *
		INTO ret_val
		FROM vw_user
	    WHERE id=usr_id;
        RETURN ret_val;
    END;
$_$;


ALTER FUNCTION w4_application_functions.create_user(arg_login_name character varying, arg_email_address character varying, arg_password character varying, arg_first_name character varying, arg_last_name character varying, arg_image_id bigint, arg_manager_id bigint) OWNER TO w4;

--
-- Name: decline_conversions(text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION decline_conversions(conversion_ids text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        arow INTEGER;
    BEGIN
        UPDATE engine_conversions SET status=50 WHERE id IN (conversion_ids);
        GET DIAGNOSTICS arow = ROW_COUNT; 
        RETURN arow;
    END
$$;


ALTER FUNCTION w4_application_functions.decline_conversions(conversion_ids text) OWNER TO w4;

--
-- Name: delete_advertiser_contact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_advertiser_contact(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        adv_id BIGINT;
    BEGIN
        adv_id:=0;
        SELECT INTO adv_id id FROM advertisers WHERE primary_contact_id=arg_id LIMIT 1;
        IF adv_id > 0 THEN
            RAISE EXCEPTION 'Can not delete primary contact from advertiser [%]',adv_id;
            RETURN FALSE;
        END IF;
        adv_id:=0;
        SELECT INTO adv_id id FROM advertisers WHERE billing_contact_id=arg_id LIMIT 1;
        IF adv_id > 0 THEN
            RAISE EXCEPTION 'Can not delete billing contact from advertiser [%]',adv_id;
            RETURN FALSE;
        END IF;
        DELETE FROM advertiser_contacts WHERE contact_id=arg_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.delete_advertiser_contact(arg_id bigint) OWNER TO w4;

--
-- Name: delete_advertiser_contact(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_advertiser_contact(arg_id bigint, arg_advertiser_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        adv advertisers;
    BEGIN
        SELECT INTO adv * FROM advertisers WHERE id=arg_advertiser_id;
        IF arg_id=adv.primary_contact_id THEN
            RAISE WARNING 'Can not delete primary contact from advertiser [%]',arg_advertiser_id;
            RETURN FALSE;
        END IF;
        IF arg_id=adv.billing_contact_id THEN
            RAISE WARNING 'Can not delete billing contact from advertiser [%]',arg_advertiser_id;
            RETURN FALSE;
        END IF;
        IF arg_id=adv.account_contact_id THEN
            RAISE WARNING 'Can not delete account contact from advertiser [%]',arg_advertiser_id;
            RETURN FALSE;
        END IF;
        DELETE FROM advertiser_contacts WHERE contact_id=arg_id AND advertiser_id=arg_advertiser_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.delete_advertiser_contact(arg_id bigint, arg_advertiser_id bigint) OWNER TO w4;

--
-- Name: delete_contact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_contact(arg_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        DELETE FROM advertiser_contacts WHERE contact_id=arg_id;
        DELETE FROM publisher_contact WHERE contact_id=arg_id;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.delete_contact(arg_id bigint) OWNER TO w4;

--
-- Name: FUNCTION delete_contact(arg_id bigint); Type: COMMENT; Schema: w4_application_functions; Owner: w4
--

COMMENT ON FUNCTION delete_contact(arg_id bigint) IS 'Disassociates this contact from all other entities';


SET search_path = public, pg_catalog;

--
-- Name: engine_conversions; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions (
    id bigint NOT NULL,
    click_id bigint,
    payin money,
    payout money,
    parent_payout money,
    campaign_id bigint DEFAULT 0,
    publisher_id bigint DEFAULT 0,
    parent_publisher_id bigint DEFAULT 0,
    referral_url text,
    creative_id integer DEFAULT 0,
    ip_address inet,
    continent character(2) DEFAULT NULL::bpchar,
    country character varying(255) DEFAULT NULL::character varying,
    region character varying(2) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT 1,
    channel bigint,
    modified_date timestamp with time zone,
    created_date timestamp with time zone NOT NULL,
    advertiser_refid text
);


ALTER TABLE public.engine_conversions OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: delete_conversion(public.engine_conversions); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_conversion(old_cnv public.engine_conversions) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        acl acct_conversion_ledger; ail acct_internal_ledger; aal acct_advertiser_ledger; apl acct_publisher_ledger; appl acct_publisher_ledger;
        acpa numeric; icpa numeric; pcpa numeric; ppcpa numeric; clickid BIGINT; astatus INTEGER; pstatus INTEGER; ppstatus INTEGER;
        trans RECORD; stats RECORD; old_cnv_advertiser_id BIGINT;
        exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
    BEGIN
        SELECT INTO old_cnv_advertiser_id (SELECT c.advertiser_id FROM campaigns c WHERE c.id=old_cnv.campaign_id);
        -- Calculate the required CPA info for adjusting ledgers
        acpa:=old_cnv.payin; 
        pcpa:=COALESCE(old_cnv.parent_payout-old_cnv.payout,old_cnv.payout);
        ppcpa:=CASE WHEN old_cnv.parent_payout > 0::numeric THEN old_cnv.parent_payout ELSE 0::numeric END; 
        icpa:=old_cnv.payin-old_cnv.payout;
        /* Click ID is DEPRECATED - This is now using the conversion's own ID. PLEASE HEED THIS COMMENT! */
        -- Identify the conversion using click_id::BIGINT
        clickid:=old_cnv.id::BIGINT;
        -- Set the status
        SELECT INTO stats id, advertiser_invoice_status, publisher_invoice_status, parent_publisher_invoice_status FROM acct_conversion_ledger WHERE conversion_id=clickid;
        -- Remove from ALL Ledgers
        astatus:=stats.advertiser_invoice_status;
        pstatus:=stats.publisher_invoice_status;
        ppstatus:=stats.parent_publisher_invoice_status;
        acl:=get_acct_conversion_ledger_by_clickid(clickid);
        aal:=get_acct_advertiser_ledger_by_clickid(clickid);
        ail:=get_acct_internal_ledger_by_clickid(clickid);
        apl:=get_acct_publisher_ledger_by_clickid(clickid);
        appl:=get_acct_publisher_ledger(apl.id);
        DELETE FROM acct_conversion_ledger_memo WHERE acl_id=acl.id;
        DELETE FROM acct_internal_ledger_memo WHERE ail_id=ail.id;
        DELETE FROM acct_advertiser_ledger_memo WHERE aal_id=aal.id;
        DELETE FROM acct_publisher_ledger_memo WHERE apl_id=apl.id;
        DELETE FROM acct_conversion_ledger WHERE id=acl.id;
        DELETE FROM acct_internal_ledger WHERE id=ail.id;
        DELETE FROM acct_advertiser_ledger WHERE id=aal.id;
        DELETE FROM acct_publisher_ledger WHERE id=apl.id;
        IF appl.id = 0 OR appl.id IS NULL THEN
        ELSE
            DELETE FROM acct_publisher_ledger_memo WHERE apl_id=appl.id;
            DELETE FROM acct_publisher_ledger WHERE id=appl.id;
        END IF;
        -- Check to see if it was active in the deltas
        CASE old_cnv.status WHEN 1, 10, 20, 30, 31, 32, 33, 40 THEN
            -- Fix ALL the aggregates in it's time range with deltas
            PERFORM remove_conversion_from_rollups(old_cnv_advertiser_id,old_cnv.campaign_id,old_cnv.publisher_id,old_cnv.parent_publisher_id,acpa,pca,ppcpa,icpa,old_cnv.created_date,astatus,pstatus,ppstatus,clickid);
            -- Check to see if there are transaction records for adjustments
            FOR trans IN SELECT id,conversion_id::BIGINT,advertiser_id,campaign_id,publisher_id,credit_amt,debit_amt,transaction_type,created_date FROM acct_transaction_ledger WHERE conversion_id=clickid OR internal_ledger_id=ail.id LOOP
                acpa:=0; icpa:=0; pcpa:=0;
                CASE trans.status WHEN 1, 10, 20, 30, 31, 32, 33, 40 THEN
                    CASE trans.transaction_type WHEN 110 THEN -- acpa, icpa are set
                        acpa:=trans.debit_amt;
                        icpa:=trans.debit_amt;
                    WHEN 510 THEN -- pcpa, icpa are set
                        icpa:=trans.credit_amt;
                        pcpa:=trans.credit_amt;
                    WHEN 1100 THEN -- apca, icpa, and pcpa are set
                        acpa:=trans.debit_amt;
                        icpa:=trans.debit_amt-trans.credit_amt;
                        pcpa:=trans.credit_amt;
                    END CASE;
                    PERFORM remove_conversion_from_rollups(trans.advertiser_id,trans.campaign_id,trans.publisher_id,0,acpa,pcpa,0,icpa,trans.created_date,astatus,pstatus,0,clickid);
                END CASE;
                CASE trans.transaction_type WHEN 110, 510, 1100 THEN
                    DELETE FROM acct_transaction_ledger_memo WHERE atl_id=trans.id;
                    DELETE FROM acct_transaction_ledger WHERE id=trans.id;
                ELSE
                    PERFORM log_potential_data_anomaly('accounting rollup trigger calls','delete_conversion','( transaction_id:' || atlid::TEXT || ',click_id::BIGINT:' || clickid::TEXT || ',internal_ledger_id:' || ailid::TEXT || ',transaction_type:' || trans.transaction_type || ')','Transaction Ledger Entry of wrong type. Expecting transaction type of 110, 510, or 1100 (Out of period conversion transaction adjustments) [' || trans.transaction_type || '] given.','Unsure how transaction type [' || trans.transaction_type || '] modifies accounting conversion rollups','CRIT');
                END CASE;
            END LOOP;
        END CASE;
        RETURN TRUE;
        /*
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
        */
     END;
$$;


ALTER FUNCTION w4_application_functions.delete_conversion(old_cnv public.engine_conversions) OWNER TO w4;

--
-- Name: delete_file(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_file(arg_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        status_local status_entity;
        rows_mod integer;
    BEGIN
        status_local = 'inactive';
        UPDATE files SET "status"=status_local WHERE id=arg_id; 
        GET DIAGNOSTICS rows_mod = ROW_COUNT;
        IF rows_mod < 1 THEN
            RAISE EXCEPTION 'General delete failure.';
        END IF;
        RETURN arg_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.delete_file(arg_id bigint) OWNER TO w4;

--
-- Name: delete_piggyback_pixel(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_piggyback_pixel(arg_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        status_local status_entity;
        rows_mod integer;
    BEGIN
        status_local = 'inactive';
        UPDATE campaign_piggyback_pixels SET "status"=status_local WHERE id=arg_id; 
        GET DIAGNOSTICS rows_mod = ROW_COUNT;
        IF rows_mod < 1 THEN
            RAISE EXCEPTION 'General delete failure.';
        END IF;
        RETURN arg_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.delete_piggyback_pixel(arg_id bigint) OWNER TO w4;

--
-- Name: delete_publisher_contact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_publisher_contact(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        pub_id BIGINT;
    BEGIN
        pub_id:=0;
        SELECT INTO pub_id id FROM users WHERE primary_contact_id=arg_id LIMIT 1;
        IF pub_id > 0 THEN
            RAISE EXCEPTION 'Can not delete primary contact from publisher [%]',pub_id;
            RETURN FALSE;
        END IF;
        pub_id:=0;
        SELECT INTO pub_id id FROM users WHERE billing_contact_id=arg_id LIMIT 1;
        IF pub_id > 0 THEN
            RAISE EXCEPTION 'Can not delete billing contact from publisher [%]',pub_id;
            RETURN FALSE;
        END IF;
        DELETE FROM publisher_contact WHERE contact_id=arg_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.delete_publisher_contact(arg_id bigint) OWNER TO w4;

--
-- Name: delete_publisher_contact(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_publisher_contact(arg_id bigint, arg_publisher_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        pub users;
    BEGIN
        SELECT INTO pub * FROM users WHERE id=arg_publisher_id;
        IF arg_id=pub.primary_contact_id THEN
            RAISE WARNING 'Can not delete primary contact from publisher [%]',arg_publisher_id;
            RETURN FALSE;
        END IF;
        IF arg_id=pub.billing_contact_id THEN
            RAISE WARNING 'Can not delete billing contact from publisher [%]',arg_publisher_id;
            RETURN FALSE;
        END IF;
        IF arg_id=pub.account_contact_id THEN
            RAISE WARNING 'Can not delete account contact from publisher [%]',arg_publisher_id;
            RETURN FALSE;
        END IF;
        DELETE FROM publisher_contact WHERE contact_id=arg_id AND publisher_id=arg_publisher_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.delete_publisher_contact(arg_id bigint, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: delete_user(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION delete_user(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
    BEGIN
        UPDATE users SET active='banned' WHERE id=arg_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.delete_user(arg_id bigint) OWNER TO w4;

--
-- Name: deletecontact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION deletecontact(contactid bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
    BEGIN
        DELETE FROM advertiser_contacts WHERE contact_id=contactid;
        DELETE FROM publisher_contact WHERE contact_id=contactid;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.deletecontact(contactid bigint) OWNER TO w4;

--
-- Name: FUNCTION deletecontact(contactid bigint); Type: COMMENT; Schema: w4_application_functions; Owner: w4
--

COMMENT ON FUNCTION deletecontact(contactid bigint) IS 'Disassociates this contact from all other entities';


--
-- Name: engine_dupe_click(bigint, bigint, bigint, bigint, integer, bigint, integer, inet, character varying, character varying, character varying, character varying, character varying, character varying, double precision, double precision, integer, integer, integer, integer, bigint, text, text, text, text, character varying, text, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION engine_dupe_click(clkclick_id bigint, clkcampaign_id bigint, clkpublisher_id bigint, clkparent_publisher_id bigint, clkredirect_url_id integer, clkconsumer_id bigint, clkcreative_id integer, clkip_address inet, clkcontinent character varying, clkcountry character varying, clkregion character varying, clkregion_name character varying, clkcity character varying, clkpostal_code character varying, clklatitude double precision, clklongitude double precision, clkmetro_code integer, clkarea_code integer, clkbrowser_id integer, clkplatform_id integer, clkchannel bigint, clksub_id_1 text, clksub_id_2 text, clksub_id_3 text, clksub_id_4 text, clkbase_uri character varying, clkreferral_url text, clkref_id text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_click_id bigint;
        var_created_date timestamp with time zone := CURRENT_TIMESTAMP;

    BEGIN
        INSERT INTO engine_clicks_dupes
            (click_id, campaign_id, publisher_id, parent_publisher_id, redirect_url_id, consumer_id, creative_id, ip_address, continent, country, region, region_name, city, postal_code,
                latitude, longitude, metro_code, area_code, browser_id, platform_id, channel, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, referral_url, created_date,
                status, hitpath_ref_id)
            VALUES (clkclick_id, clkcampaign_id, clkpublisher_id, clkparent_publisher_id, clkredirect_url_id, clkconsumer_id, clkcreative_id, clkip_address, clkcontinent, clkcountry,
                 clkregion, clkregion_name, clkcity, clkpostal_code, clklatitude, clklongitude, clkmetro_code, clkarea_code, clkbrowser_id, clkplatform_id, clkchannel, clksub_id_1,
                 clksub_id_2, clksub_id_3, clksub_id_4, clkbase_uri, clkreferral_url, var_created_date, 0, clkref_id)
            RETURNING id
            INTO var_click_id;
        RETURN ('{"click_id": ' || var_click_id || ', "created_date": "' || var_created_date || '"}')::json;
    END;
$$;


ALTER FUNCTION w4_application_functions.engine_dupe_click(clkclick_id bigint, clkcampaign_id bigint, clkpublisher_id bigint, clkparent_publisher_id bigint, clkredirect_url_id integer, clkconsumer_id bigint, clkcreative_id integer, clkip_address inet, clkcontinent character varying, clkcountry character varying, clkregion character varying, clkregion_name character varying, clkcity character varying, clkpostal_code character varying, clklatitude double precision, clklongitude double precision, clkmetro_code integer, clkarea_code integer, clkbrowser_id integer, clkplatform_id integer, clkchannel bigint, clksub_id_1 text, clksub_id_2 text, clksub_id_3 text, clksub_id_4 text, clkbase_uri character varying, clkreferral_url text, clkref_id text) OWNER TO w4;

--
-- Name: engine_store_click(bigint, bigint, bigint, integer, bigint, integer, inet, character varying, character varying, character varying, character varying, character varying, character varying, double precision, double precision, integer, integer, integer, integer, bigint, text, text, text, text, character varying, text, text, bigint, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION engine_store_click(clkcampaign_id bigint, clkpublisher_id bigint, clkparent_publisher_id bigint, clkredirect_url_id integer, clkconsumer_id bigint, clkcreative_id integer, clkip_address inet, clkcontinent character varying, clkcountry character varying, clkregion character varying, clkregion_name character varying, clkcity character varying, clkpostal_code character varying, clklatitude double precision, clklongitude double precision, clkmetro_code integer, clkarea_code integer, clkbrowser_id integer, clkplatform_id integer, clkchannel bigint, clksub_id_1 text, clksub_id_2 text, clksub_id_3 text, clksub_id_4 text, clkbase_uri character varying, clkreferral_url text, clkref_id text, clkadvertiser_id bigint, clkencrypted_id text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_click_id bigint;
        var_created_date timestamp with time zone := CURRENT_TIMESTAMP;

    BEGIN
        var_click_id := nextval('engine_clicks_id_seq');
        INSERT INTO engine_clicks
            (id, campaign_id, publisher_id, parent_publisher_id, redirect_url_id, consumer_id, creative_id, ip_address, continent, country, region, region_name, city, postal_code,
                latitude, longitude, metro_code, area_code, browser_id, platform_id, channel, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, referral_url, nb_dupes, created_date,
                status, hitpath_ref_id)
            VALUES (var_click_id, clkcampaign_id, clkpublisher_id, clkparent_publisher_id, clkredirect_url_id, clkconsumer_id, clkcreative_id, clkip_address, clkcontinent, clkcountry,
                 clkregion, clkregion_name, clkcity, clkpostal_code, clklatitude, clklongitude, clkmetro_code, clkarea_code, clkbrowser_id, clkplatform_id, clkchannel, clksub_id_1,
                 clksub_id_2, clksub_id_3, clksub_id_4, clkbase_uri, clkreferral_url, 0, var_created_date, 0, clkref_id);

        INSERT INTO reports_clicks
            (id, encrypted_id, campaign_id, advertiser_id, publisher_id, parent_publisher_id, redirect_url_id, creative_id, ip_address, country, region_name, city, postal_code,
                latitude, longitude, metro_code, area_code, browser_id, platform_id, channel, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, referral_url, created_date,
                hoy)
            VALUES (var_click_id, clkencrypted_id, clkcampaign_id, clkadvertiser_id, clkpublisher_id, clkparent_publisher_id, clkredirect_url_id, clkcreative_id, clkip_address, clkcountry,
                 clkregion_name, clkcity, clkpostal_code, clklatitude, clklongitude, clkmetro_code, clkarea_code, clkbrowser_id, clkplatform_id, clkchannel, clksub_id_1,
                 clksub_id_2, clksub_id_3, clksub_id_4, clkbase_uri, clkreferral_url, var_created_date, make_hoy(var_created_date));

        RETURN ('{"click_id": ' || var_click_id || ', "created_date": "' || var_created_date || '"}')::json;
    END;
$$;


ALTER FUNCTION w4_application_functions.engine_store_click(clkcampaign_id bigint, clkpublisher_id bigint, clkparent_publisher_id bigint, clkredirect_url_id integer, clkconsumer_id bigint, clkcreative_id integer, clkip_address inet, clkcontinent character varying, clkcountry character varying, clkregion character varying, clkregion_name character varying, clkcity character varying, clkpostal_code character varying, clklatitude double precision, clklongitude double precision, clkmetro_code integer, clkarea_code integer, clkbrowser_id integer, clkplatform_id integer, clkchannel bigint, clksub_id_1 text, clksub_id_2 text, clksub_id_3 text, clksub_id_4 text, clkbase_uri character varying, clkreferral_url text, clkref_id text, clkadvertiser_id bigint, clkencrypted_id text) OWNER TO w4;

--
-- Name: engine_store_conversion(bigint, money, money, money, bigint, bigint, bigint, text, integer, inet, character varying, character varying, character varying, character varying, character varying, character varying, double precision, double precision, integer, integer, integer, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION engine_store_conversion(convclickid bigint, convpayin money, convpayout money, convparentpayout money, convcampaignid bigint, convpublisherid bigint, convparentpublisherid bigint, convreferralurl text, convcreativeid integer, convipaddress inet, convcontinent character varying, convcountry character varying, convregion character varying, convregionname character varying, convcity character varying, convpostalcode character varying, convlatitude double precision, convlongitude double precision, convmetrocode integer, convareacode integer, convbrowserid integer, convplatformid integer, convchannel integer, arg_date timestamp with time zone DEFAULT now()) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BIGINT;
        rows_mod INTEGER;
        adv advertisers;
        adv_balance NUMERIC;
        camp campaigns;
        ccap campaign_caps;
        clks BIGINT;
        clkscnt BIGINT;

    BEGIN
        ret_val := check_campaign_eligible(convcampaignid, convpublisherid, convcreativeid);
        IF (ret_val < 0) THEN
            RETURN ('{"conversion_id": ' || ret_val || '}')::json;
        END IF;

        IF (convclickid > 1) THEN
            SELECT INTO clkscnt count(*) FROM engine_conversions WHERE click_id = convclickid;
            IF (clkscnt > 0) THEN
                RETURN ('{"conversion_id": -5}')::json;
            END IF;
	END IF;

        SELECT INTO adv * FROM advertisers av WHERE av.id = (SELECT advertiser_id FROM campaigns cmp WHERE cmp.id = convcampaignid);
        SELECT INTO adv_balance SUM(total_credit_used) FROM vw_adv_cpg_balances WHERE advertiser_id = adv.id GROUP BY advertiser_id;
        IF (adv.credit_limit::numeric > 0.01) THEN
            IF ((convpayin::numeric + adv_balance::numeric) > adv.credit_limit::numeric) AND adv.allow_over_limit = 'no' THEN
                RETURN ('{"conversion_id": -6}')::json;
            END IF;
        END IF;

        ret_val:=nextval('public.engine_conversions_id_seq');
        INSERT INTO engine_conversions
            (id, click_id, payin, payout, parent_payout, campaign_id, publisher_id, parent_publisher_id, referral_url, creative_id, ip_address, continent, country,
                region, region_name, city, postal_code, latitude, longitude, metro_code, area_code, browser_id, platform_id, status, channel, modified_date, created_date)
            VALUES (ret_val,convclickid, convpayin, convpayout, convparentpayout, convcampaignid, convpublisherid, convparentpublisherid, convreferralurl, convcreativeid,
                convipaddress, convcontinent, convcountry, convregion, convregionname, convcity, convpostalcode, convlatitude, convlongitude, convmetrocode, convareacode,
                convbrowserid, convplatformid, 1, convchannel,arg_date,arg_date);
        RETURN ('{"conversion_id": ' || ret_val || ', "created_date": "' || arg_date || '"}')::json;
    END;
$$;


ALTER FUNCTION w4_application_functions.engine_store_conversion(convclickid bigint, convpayin money, convpayout money, convparentpayout money, convcampaignid bigint, convpublisherid bigint, convparentpublisherid bigint, convreferralurl text, convcreativeid integer, convipaddress inet, convcontinent character varying, convcountry character varying, convregion character varying, convregionname character varying, convcity character varying, convpostalcode character varying, convlatitude double precision, convlongitude double precision, convmetrocode integer, convareacode integer, convbrowserid integer, convplatformid integer, convchannel integer, arg_date timestamp with time zone) OWNER TO w4;

--
-- Name: engine_store_conversion(bigint, money, money, money, bigint, bigint, bigint, text, integer, inet, character varying, character varying, character varying, character varying, character varying, character varying, double precision, double precision, integer, integer, integer, integer, integer, text, timestamp with time zone); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION engine_store_conversion(convclickid bigint, convpayin money, convpayout money, convparentpayout money, convcampaignid bigint, convpublisherid bigint, convparentpublisherid bigint, convreferralurl text, convcreativeid integer, convipaddress inet, convcontinent character varying, convcountry character varying, convregion character varying, convregionname character varying, convcity character varying, convpostalcode character varying, convlatitude double precision, convlongitude double precision, convmetrocode integer, convareacode integer, convbrowserid integer, convplatformid integer, convchannel integer, convrefid text, arg_date timestamp with time zone DEFAULT now()) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BIGINT;
        rows_mod INTEGER;
        camp campaigns;
        ccap campaign_caps;
        clks BIGINT;
        clkscnt BIGINT;
        var_advertiser_over_limit boolean;

    BEGIN
        ret_val := check_campaign_eligible(convcampaignid, convpublisherid, convcreativeid);
        IF (ret_val < 0) THEN
            RETURN ('{"conversion_id": ' || ret_val || '}')::json;
        END IF;

        IF (convclickid > 1) THEN
            SELECT INTO clkscnt count(*) FROM engine_conversions WHERE click_id = convclickid;
            IF (clkscnt > 0) THEN
                RETURN ('{"conversion_id": -5}')::json;
            END IF;
END IF;

        var_advertiser_over_limit := conversion_advertiser_cap_get(convcampaignid, convpayin::numeric);
        IF (var_advertiser_over_limit) THEN
            RETURN ('{"conversion_id": -6}')::json;
        END IF;

        ret_val:=nextval('public.engine_conversions_id_seq');
        INSERT INTO engine_conversions
            (id, click_id, payin, payout, parent_payout, campaign_id, publisher_id, parent_publisher_id, referral_url, creative_id, ip_address, continent, country,
                region, region_name, city, postal_code, latitude, longitude, metro_code, area_code, browser_id, platform_id, status, channel, modified_date, created_date, advertiser_refid)
            VALUES (ret_val,convclickid, convpayin, convpayout, convparentpayout, convcampaignid, convpublisherid, convparentpublisherid, convreferralurl, convcreativeid,
                convipaddress, convcontinent, convcountry, convregion, convregionname, convcity, convpostalcode, convlatitude, convlongitude, convmetrocode, convareacode,
                convbrowserid, convplatformid, 1, convchannel,arg_date,arg_date, convrefid);
        RETURN ('{"conversion_id": ' || ret_val || ', "created_date": "' || arg_date || '"}')::json;
    END;
$$;


ALTER FUNCTION w4_application_functions.engine_store_conversion(convclickid bigint, convpayin money, convpayout money, convparentpayout money, convcampaignid bigint, convpublisherid bigint, convparentpublisherid bigint, convreferralurl text, convcreativeid integer, convipaddress inet, convcontinent character varying, convcountry character varying, convregion character varying, convregionname character varying, convcity character varying, convpostalcode character varying, convlatitude double precision, convlongitude double precision, convmetrocode integer, convareacode integer, convbrowserid integer, convplatformid integer, convchannel integer, convrefid text, arg_date timestamp with time zone) OWNER TO w4;

--
-- Name: generate_interval_series(timestamp with time zone, timestamp with time zone, interval); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION generate_interval_series(arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval) RETURNS character varying[]
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        freq_value DOUBLE PRECISION;
        ret_val VARCHAR[][];
        tmp_val VARCHAR; 
        prev_val VARCHAR;
        tmp_ary VARCHAR[];
   BEGIN
        IF (arg_start_date = arg_end_date) THEN
            arg_end_date:=arg_end_date + interval '23 hour 59 minute 59 second';
        END IF;
        ret_val:=ARRAY[ARRAY[''::VARCHAR,''::VARCHAR]];
        freq_value:=extract(YEAR FROM arg_frequency::INTERVAL);
        IF freq_value > 0.0 THEN
            prev_val:=make_y(arg_start_date)::VARCHAR;
            FOR tmp_val IN EXECUTE $fetch_sql$SELECT generate_series('$fetch_sql$ || arg_start_date || $fetch_sql$'::TIMESTAMPTZ,'$fetch_sql$ || arg_end_date || $fetch_sql$'::TIMESTAMPTZ,'$fetch_sql$ || arg_frequency || $fetch_sql$'::INTERVAL)$fetch_sql$ LOOP
                tmp_ary:=ARRAY[prev_val::VARCHAR,make_y(tmp_val::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
                prev_val:=make_y(tmp_val::TIMESTAMPTZ + INTERVAL '1 year');
            END LOOP;
            IF prev_val::BIGINT <= make_y(arg_end_date) THEN
                tmp_ary:=ARRAY[prev_val::VARCHAR,make_y(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
                IF tmp_ary <> ARRAY[make_y(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_y(arg_end_date::TIMESTAMPTZ)::VARCHAR] THEN
                    tmp_ary:=ARRAY[make_y(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_y(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                    ret_val:=ret_val || tmp_ary;
                END IF;
                prev_val:=make_y(arg_end_date::TIMESTAMPTZ + INTERVAL '5 year')::VARCHAR;
            END IF;
            IF prev_val::BIGINT <= make_y(arg_end_date + INTERVAL '1 year') AND freq_value > 1 THEN
                tmp_ary:=ARRAY[make_y(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_y(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
            END IF;
            RETURN ret_val[2:array_length(ret_val,1)];
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency::INTERVAL);
        IF freq_value > 0.0 THEN
            prev_val:=make_moy(arg_start_date)::VARCHAR;
            FOR tmp_val IN EXECUTE $fetch_sql$SELECT generate_series('$fetch_sql$ || arg_start_date || $fetch_sql$'::TIMESTAMPTZ,'$fetch_sql$ || arg_end_date || $fetch_sql$'::TIMESTAMPTZ,'$fetch_sql$ || arg_frequency || $fetch_sql$'::INTERVAL)$fetch_sql$ LOOP
                tmp_ary:=ARRAY[prev_val::VARCHAR,make_moy(tmp_val::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
                prev_val:=make_moy(tmp_val::TIMESTAMPTZ + INTERVAL '1 month');
            END LOOP;
            IF prev_val::BIGINT <= make_moy(arg_end_date) THEN
                tmp_ary:=ARRAY[prev_val::VARCHAR,make_moy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
                prev_val:=make_moy(tmp_val::TIMESTAMPTZ + INTERVAL '1 month');
                IF tmp_ary <> ARRAY[make_moy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_moy(arg_end_date::TIMESTAMPTZ)::VARCHAR] THEN
                    tmp_ary:=ARRAY[make_moy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_moy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                    ret_val:=ret_val || tmp_ary;
                END IF;
                prev_val:=make_moy(arg_end_date::TIMESTAMPTZ + INTERVAL '1 year')::VARCHAR;
            END IF;
            IF prev_val::BIGINT <= make_moy(arg_end_date + INTERVAL '1 month') AND freq_value > 1 THEN
                tmp_ary:=ARRAY[make_moy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_moy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
            END IF;
            RETURN ret_val[2:array_length(ret_val,1)];
        END IF;
        freq_value:=extract(DAY FROM arg_frequency::INTERVAL);
        IF freq_value > 0.0 THEN
            prev_val:=make_doy(arg_start_date)::VARCHAR;
            FOR tmp_val IN EXECUTE $fetch_sql$SELECT generate_series('$fetch_sql$ || arg_start_date || $fetch_sql$'::TIMESTAMPTZ,'$fetch_sql$ || arg_end_date || $fetch_sql$'::TIMESTAMPTZ,'$fetch_sql$ || arg_frequency || $fetch_sql$'::INTERVAL)$fetch_sql$ LOOP
                tmp_ary:=ARRAY[prev_val::VARCHAR,make_doy(tmp_val::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
                prev_val:=make_doy(tmp_val::TIMESTAMPTZ + INTERVAL '1 day');
            END LOOP;
            IF prev_val::BIGINT <= make_doy(arg_end_date) THEN
                tmp_ary:=ARRAY[prev_val::VARCHAR,make_doy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
                prev_val:=make_doy(tmp_val::TIMESTAMPTZ + INTERVAL '1 day');
                IF tmp_ary <> ARRAY[make_doy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_doy(arg_end_date::TIMESTAMPTZ)::VARCHAR] THEN
                    tmp_ary:=ARRAY[make_doy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_doy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                    ret_val:=ret_val || tmp_ary;
                END IF;
                prev_val:=make_doy(arg_end_date::TIMESTAMPTZ + INTERVAL '1 year')::VARCHAR;
            END IF;
            IF prev_val::BIGINT <= make_doy(arg_end_date + INTERVAL '1 day') AND freq_value > 1 THEN
                tmp_ary:=ARRAY[make_doy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_doy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
            END IF;
            RETURN ret_val[2:array_length(ret_val,1)];
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency::INTERVAL);
        IF freq_value > 0.0 THEN
            prev_val:=make_hoy(arg_start_date)::VARCHAR;
            FOR tmp_val IN EXECUTE $fetch_sql$SELECT generate_series('$fetch_sql$ || arg_start_date || $fetch_sql$'::TIMESTAMPTZ,'$fetch_sql$ || arg_end_date || $fetch_sql$'::TIMESTAMPTZ,'$fetch_sql$ || arg_frequency || $fetch_sql$'::INTERVAL)$fetch_sql$ LOOP
                tmp_ary:=ARRAY[prev_val::VARCHAR,make_hoy(tmp_val::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
                prev_val:=make_hoy(tmp_val::TIMESTAMPTZ + INTERVAL '1 hour');
            END LOOP;
            IF prev_val::BIGINT <= make_hoy(arg_end_date) THEN
                tmp_ary:=ARRAY[prev_val::VARCHAR,make_hoy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
                IF tmp_ary <> ARRAY[make_hoy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_hoy(arg_end_date::TIMESTAMPTZ)::VARCHAR] THEN
                    tmp_ary:=ARRAY[make_hoy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_hoy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                    ret_val:=ret_val || tmp_ary;
                END IF;
                prev_val:=make_hoy(arg_end_date::TIMESTAMPTZ + INTERVAL '1 year')::VARCHAR;
            END IF;
            IF prev_val::BIGINT <= make_hoy(arg_end_date + INTERVAL '1 hour') AND freq_value > 1 THEN
                tmp_ary:=ARRAY[make_hoy(arg_end_date::TIMESTAMPTZ)::VARCHAR,make_hoy(arg_end_date::TIMESTAMPTZ)::VARCHAR];
                ret_val:=ret_val || tmp_ary;
            END IF;
            RETURN ret_val[2:array_length(ret_val,1)];
        END IF;
        RAISE EXCEPTION 'Interval type submitted not supported at this time. Currently supported intervals are integral values of YEAR, MONTH, DAY, and HOUR. If a fractional interval of any of the supported types is entered, it will be rounded to the nearest integral value. Negative Frequencies have undefined results, so they will never be supported.';
    END;
$_$;


ALTER FUNCTION w4_application_functions.generate_interval_series(arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval) OWNER TO w4;

--
-- Name: geo_named_heatmap(timestamp with time zone, timestamp with time zone, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION geo_named_heatmap(arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_publisher_id bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        var_location_code text;
        var_unique_clicks bigint;
        ret_val text  := 'heatmapData:{'; 
        start_doy INTEGER;
        end_doy INTEGER;
        loc VARCHAR;
        total BIGINT;
    BEGIN
        start_doy=make_doy(arg_start_date);
        end_doy=make_doy(arg_end_date);
   
        FOR var_unique_clicks, var_location_code IN
            SELECT
                unique_clicks,
                location_code
            FROM (
                SELECT
                    COALESCE(SUM(rgd.unique_clicks),0) AS unique_clicks,
                    rgd.country AS location_code
                FROM reports_clicks_geo_country_rollup_hourly rgd
                LEFT JOIN campaigns cmp ON rgd.campaign_id = cmp.id
                WHERE substring(rgd.hoy::text from 1 for 8)::int >= start_doy AND substring(rgd.hoy::text from 1 for 8)::int <= end_doy AND rgd.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id)
                GROUP BY rgd.country
                UNION SELECT
                    COALESCE(SUM(rgd.unique_clicks),0) AS unique_clicks,
                    gtr.admin1_code || '.' || gtr.local_name AS location_code
                FROM reports_clicks_geo_region_rollup_hourly rgd
                LEFT JOIN geo_typeahead_region gtr ON rgd.country=gtr.admin1_code AND rgd.region_name=gtr.ascii_name
                LEFT JOIN campaigns cmp ON rgd.campaign_id = cmp.id
                WHERE substring(rgd.hoy::text from 1 for 8)::int >= start_doy AND substring(rgd.hoy::text from 1 for 8)::int <= end_doy AND rgd.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id)
                GROUP BY gtr.admin1_code, gtr.local_name
            ) country_and_region    
            WHERE unique_clicks > 0 AND location_code IS NOT NULL
            ORDER BY location_code
        LOOP
            
            ret_val := ret_val || '"' || var_location_code || '": ' || var_unique_clicks || ',';
        END LOOP;
        return ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.geo_named_heatmap(arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_publisher_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: geos_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION geos_json(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
        r VARCHAR;
        tmp_ary VARCHAR[];
    BEGIN
        tmp_ary:=array_append(tmp_ary,'');
        FOR r IN SELECT c.country FROM campaign_geotargeting cg LEFT JOIN geo_target_countries c ON cg.country=c.country WHERE cg.campaign_id=arg_campaign_id LOOP
            tmp_ary:=array_append(tmp_ary,r);
        END LOOP;
        ret_val:=array_to_json(tmp_ary);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.geos_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: get_advertiser_account(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_account(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
            DECLARE
                retval json;
            BEGIN
              SELECT row_to_json (row,true)
                FROM (
                         SELECT
                                adv.id,
                                COALESCE(adv.name,'') AS name,
                                adv.status,
                                adv.manager_id,
                                CASE 
                                    WHEN ((acm.first_name NOTNULL) OR (acm.last_name NOTNULL)) THEN CONCAT (acm.first_name, ' ' ,acm.last_name)
                                    ELSE CONCAT (aup.first_name, ' ' ,aup.last_name)
                                END AS manager_name, 
                                COALESCE(adv.note_login_username,'') AS tracking_username,
                                COALESCE(adv.note_login_url,'') AS tracking_url,
                                COALESCE(adv.note_login_password,'') AS tracking_password,
                                COALESCE(adv.description,'') AS notes,
                                COALESCE(adv.url,'') AS url,  
                                COALESCE(ftp.username,'') AS ftp_username,    
                                 array_to_json(enum_range(null::advertiser_status)) AS status_codes,
                                (SELECT w4_application_functions.get_advertiser_account_contact(arg_advertiser_id:=arg_id)) AS contact                                     
                            FROM advertisers adv
                            LEFT JOIN users aum ON (aum.id = adv.manager_id)
                            LEFT JOIN ftp.user ftp ON (ftp.advertiser_id = adv.id)
                            LEFT JOIN contacts acm ON (acm.id = aum.primary_contact_id)
                            LEFT JOIN user_profiles aup ON (aup.user_id = aum.id)
                            WHERE adv.id=arg_id
                        ) row INTO retval;    
          RETURN retval;
            END;
        $$;


ALTER FUNCTION w4_application_functions.get_advertiser_account(arg_id bigint) OWNER TO w4;

--
-- Name: get_advertiser_account_contact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_account_contact(arg_advertiser_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
            DECLARE
                retval json;
                var_city_id bigint;
                var_region_id bigint;
                var_country_id bigint;
            BEGIN
            --- this looks ridiculous because it kind of is ridiculous but... it was doing weird stuff so this is a half assed quick fix
            --- Addresses should be kept consistent, i.e. if account_contacts Address 1 is NOTNULL but address_2 is NULL, it shouldnt return address_2 from the advertisers table
            --- but these should never be blank either, so they fall back to the old coalesce everything method
            --- primary contact added in as buffer before reverting to advertiser table data though,
            --- same thing was done to first_name/last_name combos and message type/message name combinations
                SELECT row_to_json (row,true) FROM(
                    SELECT adv_pc.id,
                    COALESCE(
                                adv_ac.first_name,
                                adv_pc.first_name,
                                substring(adv.contact_name FROM '(.*)\s.*$'),
                                adv.name
                            ) AS first_name,
                    CASE
                        WHEN adv_ac.first_name NOTNULL THEN adv_ac.last_name
                        WHEN adv_pc.first_name NOTNULL THEN adv_pc.last_name
                        WHEN adv.contact_name NOTNULL THEN substring(contact_name FROM '.*\s(.*)$')
                    ELSE
                    ''
                    END AS last_name,    
                    COALESCE(adv_ac.address_1,adv_pc.address_1,adv.address_1) AS address_1, 
                    CASE WHEN(adv_ac.address_1 NOTNULL) THEN adv_ac.address_2
                    WHEN(adv_pc.address_1 NOTNULL) THEN adv_pc.address_2
                    WHEN(adv.address_1 NOTNULL) THEN adv.address_2
                    ELSE
                        ''
                    END AS address_2,
                    CASE WHEN(adv_ac.address_1 NOTNULL) THEN 
			COALESCE((SELECT w4_application_functions.get_city_name(adv_ac.city_id)),adv_ac.city_name)
                    WHEN(adv_pc.address_1 NOTNULL) THEN 
			COALESCE((SELECT w4_application_functions.get_city_name(adv_pc.city_id)),adv_pc.city_name)
                    WHEN(adv.address_1 NOTNULL) THEN adv.city
                    ELSE
                        ''
                    END AS city_name,
                    CASE WHEN(adv_ac.address_1 NOTNULL) THEN 
			COALESCE((SELECT w4_application_functions.get_region_name(adv_ac.region_id)),adv_ac.region_name)
                    WHEN(adv_pc.address_1 NOTNULL) THEN 
			COALESCE((SELECT w4_application_functions.get_region_name(adv_pc.region_id)),adv_pc.region_name)
                    WHEN(adv.address_1 NOTNULL) THEN adv.state
                    ELSE
                        ''
                    END AS region_name,
                    CASE 
                        WHEN(adv_ac.address_1 NOTNULL) THEN 
				COALESCE((SELECT w4_application_functions.get_country_name(adv_ac.country_id)),adv_ac.country_name)
                        WHEN(adv_pc.address_1 NOTNULL) THEN 
				COALESCE((SELECT w4_application_functions.get_country_name(adv_pc.country_id)),adv_pc.country_name)
                        WHEN(adv.address_1 NOTNULL) THEN adv.country
                        ELSE COALESCE((SELECT w4_application_functions.get_country_name(adv_ac.country_id)),(SELECT w4_application_functions.get_country_name(adv_pc.country_id)),adv.country,'') 
                    END AS country_name,
                    CASE 
                        WHEN(adv_ac.address_1 NOTNULL) THEN adv_ac.postal_code
                        WHEN(adv_pc.address_2 NOTNULL) THEN adv_pc.postal_code
                        WHEN(adv.address_1 NOTNULL) THEN adv.zip
                        ELSE '' 
                    END AS postal_code,
                    CASE 
                        WHEN(adv_ac.address_1 NOTNULL) THEN adv_ac.city_id
                        WHEN(adv_pc.address_1 NOTNULL) THEN adv_pc.city_id
                        WHEN(adv.address_1 NOTNULL) THEN (SELECT id FROM geo_typeahead_cities WHERE place_name_ascii=adv.city AND country_code=(SELECT iso FROM geo_typeahead_countries WHERE country=adv.country))
                        ELSE COALESCE(adv_ac.city_id,adv_pc.city_id,(SELECT id FROM geo_typeahead_cities WHERE place_name_ascii=adv.city AND country_code=(SELECT iso FROM geo_typeahead_countries WHERE country=adv.country)),0)
                    END AS city_id,
                    CASE 
                        WHEN(adv_ac.address_1 NOTNULL) THEN adv_ac.region_id
                        WHEN(adv_pc.address_1 NOTNULL) THEN adv_pc.region_id
                        WHEN(adv.address_1 NOTNULL) THEN (SELECT id FROM geo_typeahead_cities WHERE place_name_ascii=adv.country AND country_code=(SELECT iso FROM geo_typeahead_countries WHERE country=adv.country))
                        ELSE COALESCE(adv_ac.region_id, adv_pc.region_id,(SELECT id FROM geo_typeahead_cities WHERE place_name_ascii=adv.state AND country_code=(SELECT iso FROM geo_typeahead_countries WHERE country=adv.country)),0)  
                    END AS region_id,
                    CASE 
                        WHEN(adv_ac.address_1 NOTNULL) THEN adv_ac.country_id
                        WHEN(adv_pc.address_1 NOTNULL) THEN adv_pc.country_id
                        WHEN(adv.address_1 NOTNULL) THEN (SELECT id FROM geo_typeahead_cities WHERE place_name_ascii=adv.city AND country_code=(SELECT iso FROM geo_typeahead_countries WHERE country=adv.country))
                        ELSE 
                        COALESCE(adv_ac.country_id,adv_pc.country_id,(SELECT id FROM geo_typeahead_countries WHERE country=adv.country),0) 
                    END AS country_id,
                    COALESCE(adv_ac.messenger_type,adv_pc.messenger_type,-1) AS messenger_type,
                    CASE 
                        WHEN ((adv_ac.messenger_type > 0)) THEN COALESCE(adv_ac.messenger_name,adv.messenger_id,'')
                        WHEN ((adv_pc.messenger_type > 0)AND (adv_ac.messenger_type ISNULL)) THEN COALESCE(adv_pc.messenger_name,adv.messenger_id,'')
                        ELSE '' 
                    END AS messenger_name, 
                    COALESCE(adv_ac.primary_phone,adv_pc.primary_phone,adv.phone,'') AS primary_phone,
                    COALESCE(adv_ac.secondary_phone,adv_pc.secondary_phone,adv.mobile,'') AS secondary_phone,
                    COALESCE(adv_ac.fax,adv_pc.fax,adv.fax,'') AS fax,
                    COALESCE(adv_ac.email_address,adv_pc.email_address,adv.email,'') AS email_address 
                    FROM advertisers adv
                    LEFT JOIN contacts adv_pc ON adv.account_contact_id = adv_pc.id
                    LEFT JOIN contacts adv_ac ON adv.primary_contact_id = adv_ac.id
                    LEFT JOIN geo_typeahead_countries co ON co.id = adv_pc.country_id
                    LEFT JOIN geo_typeahead_region re ON re.id = adv_pc.region_id
                    LEFT JOIN geo_typeahead_cities ci ON ci.id = adv_pc.city_id
                    LEFT JOIN im_types im ON adv_pc.messenger_type = im.id WHERE adv.id = arg_advertiser_id
                    )row INTO retval;        
                RETURN retval;
            END;
        $_$;


ALTER FUNCTION w4_application_functions.get_advertiser_account_contact(arg_advertiser_id bigint) OWNER TO w4;

--
-- Name: get_advertiser_billing(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_billing(arg_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
        var_name text;
        var_credit_limit numeric;
        var_credit_limit_per text;
        var_allow_over_limit boolean;
        var_payment_terms_id bigint;

    BEGIN

	SELECT
            "name",
            COALESCE(credit_limit, 0),
            COALESCE(credit_limit_per, ''),
            CASE WHEN allow_over_limit = 'yes' THEN true ELSE false END,
            COALESCE(payment_terms_id, 0)
	FROM advertisers 
	WHERE id = arg_id
        INTO var_name, var_credit_limit, var_credit_limit_per, var_allow_over_limit, var_payment_terms_id;
    
	retval := 
	(
		'{' || 
			'"id": ' || arg_id                                   || ',' ||
			'"contact": ' || get_advertiser_billing_contact( arg_id ) || ',' ||
			'"terms": ' || get_advertiser_payment_terms()           || ',' ||
			'"name": ' || to_json(var_name)           || ',' ||
			'"credit_limit": ' || var_credit_limit           || ',' ||
			'"credit_limit_per": ' || to_json(var_credit_limit_per)           || ',' ||
			'"allow_over_limit": ' || to_json(var_allow_over_limit)           || ',' ||
			'"payment_terms_id": ' || var_payment_terms_id           ||
		'}'
	)::json;
	RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_billing(arg_id bigint) OWNER TO w4;

--
-- Name: get_advertiser_billing_contact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_billing_contact(arg_advertiser_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
   DECLARE
                retval json;
                var_city_id bigint;
                var_region_id bigint;
                var_country_id bigint;
            BEGIN
                SELECT row_to_json (row,true) FROM(
                    SELECT adv_bc.id,
                    COALESCE(adv_bc.first_name,adv.billing_first_name ) AS first_name,
                    CASE WHEN adv_bc.first_name NOTNULL THEN adv_bc.last_name WHEN adv.billing_first_name NOTNULL THEN adv.billing_last_name ELSE '' END AS last_name,    
                    COALESCE(adv_bc.address_1,adv.billing_address_1) AS address_1, 
                    CASE WHEN(adv_bc.address_1 NOTNULL) THEN adv_bc.address_2 WHEN(adv.billing_address_1 NOTNULL) THEN adv.billing_address_2 ELSE '' END AS address_2,
                    COALESCE((SELECT w4_application_functions.get_city_name(adv_bc.city_id)),adv_bc.city_name, adv.billing_city,'') AS city_name,
                    COALESCE((SELECT w4_application_functions.get_region_name(adv_bc.region_id)),(SELECT w4_application_functions.get_region_name(adv.billing_region_id)))AS region_name,
                    COALESCE((SELECT w4_application_functions.get_country_name(adv_bc.country_id)), adv_bc.country_name,(SELECT w4_application_functions.get_country_name(adv.billing_country_id))) AS country_name,
                    COALESCE(adv_bc.postal_code,'')AS postal_code,
                    COALESCE(adv_bc.city_id,(SELECT id FROM geo_typeahead_cities WHERE place_name_ascii=adv.billing_city AND country_code=(SELECT iso FROM geo_typeahead_countries WHERE id=adv.billing_country_id)),0)AS city_id,
                    COALESCE(adv_bc.region_id,adv.billing_region_id,0) AS region_id,
                    COALESCE(adv_bc.country_id,billing_country_id,0) AS country_id,
                    COALESCE(adv_bc.messenger_type,-1) AS messenger_type,
                    CASE WHEN(adv_bc.messenger_type > 0) THEN COALESCE(adv_bc.messenger_name,adv.messenger_id,'') ELSE '' END AS messenger_name,                      
                    COALESCE(adv_bc.primary_phone,'') AS primary_phone,
                    COALESCE(adv_bc.secondary_phone,'') AS secondary_phone,
                    COALESCE(adv_bc.fax,'') AS fax,
                    COALESCE(adv_bc.email_address,'') AS email_address 
                    FROM advertisers adv
                    LEFT JOIN contacts adv_bc ON adv.billing_contact_id = adv_bc.id
                    LEFT JOIN im_types im ON adv_bc.messenger_type = im.id 
                    WHERE adv.id = arg_advertiser_id
                    )row INTO retval;        
                RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_billing_contact(arg_advertiser_id bigint) OWNER TO w4;

--
-- Name: get_advertiser_billing_contact_old(bigint, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_billing_contact_old(arg_advertiser_id bigint, arg_person boolean DEFAULT true, arg_address boolean DEFAULT false) RETURNS public.contacts
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        a advertisers;
        ret_rec contacts;
    BEGIN
        SELECT INTO a * FROM advertisers WHERE id=arg_advertiser_id;
        SELECT INTO ret_rec ct.* FROM contacts ct LEFT JOIN advertisers adv ON ct.id=adv.billing_contact_id WHERE adv.id=arg_advertiser_id;
                IF ret_rec.id <> a.billing_contact_id THEN
                    ret_rec.is_billing:=FALSE;
                ELSE
                    ret_rec.is_billing:=TRUE;
                END IF;
                IF ret_rec.id <> a.primary_contact_id THEN
                    ret_rec.is_primary:=FALSE;
                ELSE
                    ret_rec.is_primary:=TRUE;
                END IF;
        RETURN ret_rec;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_billing_contact_old(arg_advertiser_id bigint, arg_person boolean, arg_address boolean) OWNER TO w4;

--
-- Name: get_advertiser_billing_information(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_billing_information(arg_advertiser_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
    BEGIN
    
	SELECT INTO retval
		row_to_json
		(
			ROW
			(
                                "name",
				credit_limit,
                                CASE WHEN allow_over_limit = 'yes' THEN true ELSE false END,
                                payment_terms_id
			)::advertiser_billing_information
		)
	FROM advertisers 
	WHERE id = arg_advertiser_id;
	
        RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_billing_information(arg_advertiser_id bigint) OWNER TO w4;

--
-- Name: get_advertiser_billing_terms(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_billing_terms() RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$

    BEGIN
	RETURN array_to_json( array_agg( ROW( id, "name" )::typeahead_return ) ) FROM advertiser_payment_terms;	
    END;
    
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_billing_terms() OWNER TO w4;

--
-- Name: get_advertiser_contact(bigint, boolean, boolean, text, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_contact(arg_advertiser_id bigint, arg_include_primary boolean DEFAULT true, arg_include_billing boolean DEFAULT true, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT 25, arg_offset bigint DEFAULT 0) RETURNS SETOF public.contacts
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        a advertisers;
        r contacts;
        order_clause text;

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'ct.first_name ASC');

        SELECT INTO a * FROM advertisers WHERE id=arg_advertiser_id;
        IF arg_include_primary THEN
            IF arg_include_billing THEN
                FOR r IN EXECUTE 'SELECT ct.* FROM advertiser_contacts ac LEFT JOIN contacts ct ON ct.id=ac.contact_id WHERE ac.advertiser_id='||arg_advertiser_id::TEXT || ' AND ct.id IS NOT NULL ' || order_clause || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') || ' OFFSET ' || arg_offset LOOP
                IF r.id <> a.billing_contact_id THEN
                    r.is_billing:=FALSE;
                ELSE
                    r.is_billing:=TRUE;
                END IF;
                IF r.id <> a.primary_contact_id THEN
                    r.is_primary:=FALSE;
                ELSE
                    r.is_primary:=TRUE;
                END IF;
			RETURN NEXT r;
                END LOOP;
            ELSE
                FOR r IN EXECUTE 'SELECT ct.* FROM advertiser_contacts ac LEFT JOIN contacts ct ON ct.id=ac.contact_id LEFT JOIN advertisers adv ON ac.advertiser_id=adv.id WHERE ct.id <> adv.billing_contact_id AND adv.id=' || arg_advertiser_id::TEXT || ' AND ct.id IS NOT NULL ' || order_clause || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') || ' OFFSET ' || arg_offset LOOP
                IF r.id <> a.billing_contact_id THEN
                    r.is_billing:=FALSE;
                ELSE
                    r.is_billing:=TRUE;
                END IF;
                IF r.id <> a.primary_contact_id THEN
                    r.is_primary:=FALSE;
                ELSE
                    r.is_primary:=TRUE;
                END IF;
			RETURN NEXT r;
                END LOOP;
            END IF;
        ELSE
            IF arg_include_billing THEN
                FOR r IN EXECUTE 'SELECT ct.* FROM advertiser_contacts ac LEFT JOIN contacts ct ON ct.id=ac.contact_id LEFT JOIN advertisers adv ON ac.advertiser_id=adv.id WHERE ct.id <> adv.primary_contact_id AND adv.id=' || arg_advertiser_id::TEXT || ' AND ct.id IS NOT NULL ' || order_clause || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') || ' OFFSET ' || arg_offset LOOP
                IF r.id <> a.billing_contact_id THEN
                    r.is_billing:=FALSE;
                ELSE
                    r.is_billing:=TRUE;
                END IF;
                IF r.id <> a.primary_contact_id THEN
                    r.is_primary:=FALSE;
                ELSE
                    r.is_primary:=TRUE;
                END IF;
			RETURN NEXT r;
                END LOOP;
            ELSE
                FOR r IN EXECUTE 'SELECT ct.* FROM advertiser_contacts ac LEFT JOIN contacts ct ON ct.id=ac.contact_id LEFT JOIN advertisers adv ON ac.advertiser_id=adv.id WHERE ct.id <> adv.primary_contact_id AND ct.id <> adv.billing_contact_id AND adv.id='||arg_advertiser_id::TEXT || ' AND ct.id IS NOT NULL ' || order_clause || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') || ' OFFSET ' || arg_offset LOOP
                IF r.id <> a.billing_contact_id THEN
                    r.is_billing:=FALSE;
                ELSE
                    r.is_billing:=TRUE;
                END IF;
                IF r.id <> a.primary_contact_id THEN
                    r.is_primary:=FALSE;
                ELSE
                    r.is_primary:=TRUE;
                END IF;
			RETURN NEXT r;
                END LOOP;
            END IF;
        END IF;
        return;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_contact(arg_advertiser_id bigint, arg_include_primary boolean, arg_include_billing boolean, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: get_advertiser_payment_terms(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_payment_terms() RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
    
	RETURN 	to_json
		(
			array_agg
			(
				row_to_json
				(
					ROW
					(
						id,
						"name"
					)::advertiser_payment_terms_list
				)
			)
		)
	FROM advertiser_payment_terms;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_payment_terms() OWNER TO w4;

--
-- Name: get_advertiser_primary_contact(bigint, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_primary_contact(arg_advertiser_id bigint, arg_person boolean DEFAULT true, arg_address boolean DEFAULT false) RETURNS public.contacts
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        a advertisers;
        ret_rec contacts;
    BEGIN
        SELECT INTO a * FROM advertisers WHERE id=arg_advertiser_id;
        SELECT INTO ret_rec ct.* FROM contacts ct LEFT JOIN advertisers adv ON ct.id=adv.primary_contact_id WHERE adv.id=arg_advertiser_id;
                IF ret_rec.id <> a.billing_contact_id THEN
                    ret_rec.is_billing:=FALSE;
                ELSE
                    ret_rec.is_billing:=TRUE;
                END IF;
                IF ret_rec.id <> a.primary_contact_id THEN
                    ret_rec.is_primary:=FALSE;
                ELSE
                    ret_rec.is_primary:=TRUE;
                END IF;
        RETURN ret_rec;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_primary_contact(arg_advertiser_id bigint, arg_person boolean, arg_address boolean) OWNER TO w4;

--
-- Name: get_advertiser_status_codes(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_advertiser_status_codes() RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        status json;
    BEGIN
        SELECT INTO status to_json( ARRAY['active', 'pending', 'inactive', 'collections'] );
        RETURN status;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_advertiser_status_codes() OWNER TO w4;

--
-- Name: get_banners_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_banners_json(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
        rec RECORD;
        r VARCHAR;
        comma_char VARCHAR;
    BEGIN
	comma_char:='';
        ret_val:='{"banners":[';
        FOR rec IN SELECT * FROM creatives c LEFT JOIN creative_emails ce ON c.id=ce.creative_id AND c."type"=1 WHERE c.campaign_id=arg_campaign_id LOOP
            r:=row_to_json(rec);
            ret_val:=ret_val || comma_char || r::VARCHAR;
            comma_char:=',';
        END LOOP;
        ret_val:=ret_val || ']}';
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_banners_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: get_campaign_traffic_list(integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_campaign_traffic_list(arg_advertiser_id integer DEFAULT NULL::integer) RETURNS SETOF public.campaign_traffic_list
    LANGUAGE plpgsql
    AS $$
	DECLARE
		--ret_rec vw_campaigns_traffic_list_view;
		sql_str text;
	BEGIN
		sql_str := 'SELECT '
			|| '	campaign_id'
                        || '	, MAX(campaign_name) AS campaign_name'
                        || '	, MAX(campaign_status) AS status'
                        || '	, MAX(advertiser_id) AS advertiser_id'
                        || '	, MAX(advertiser_name) AS advertiser_name'
                        || '	, MAX(channel_ids) AS channel_ids'
                        || '	, MAX(channels) AS channel_names'
                        || '	, MAX(category_ids) AS category_ids'
                        || '	, MAX(categories) AS category_names'
                        || '	, MAX(expires) AS expires'
                        || '	, MAX(is_new) AS is_new'
                        || '	, CONCAT( MAX(campaign_name), CHR(1), campaign_id ) AS traffic_search'
                        || '	, CONCAT( MAX(advertiser_name), CHR(1), MAX(advertiser_id) ) AS search_advertiser'
                        || '	, SUM( total_in ) / NULLIF(MAX(campaign_cap), 0) AS cap_amount'
                        || '	, SUM( total_clicks ) AS unique_clicks'
                        || '	, SUM( total_conversions ) AS conversions'
                        || '	, SUM( total_conversions ) / NULLIF(SUM(total_clicks), 0) * 100 AS conversion_percentage'
                        || '	, SUM( total_in ) / NULLIF(SUM(total_clicks), 0) AS EPC'
                        || '	, SUM( total_in ) AS total_in'
                        || '	, SUM( total_out ) AS total_out'
                        || '	, 100 - SUM( total_out ) / NULLIF(SUM(total_in), 0) * 100 AS profit_percentage'
			|| ' FROM vw_campaigns_traffic_list_view';
                IF arg_advertiser_id IS NOT NULL THEN
                    sql_str := sql_str || ' WHERE advertiser_id = ' || arg_advertiser_id;
                END IF;
                sql_str := sql_str || ' GROUP BY campaign_id';
                RETURN QUERY EXECUTE sql_str;
	END;
$$;


ALTER FUNCTION w4_application_functions.get_campaign_traffic_list(arg_advertiser_id integer) OWNER TO w4;

--
-- Name: get_category(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_category(arg_id bigint) RETURNS public.categories
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_rec categories;
    BEGIN
        SELECT INTO ret_rec * FROM categories WHERE id=arg_id;
        RETURN ret_rec;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_category(arg_id bigint) OWNER TO w4;

--
-- Name: get_city_id(bigint, bigint, character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_city_id(arg_country_id bigint, arg_region_id bigint, arg_city character varying) RETURNS bigint
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BIGINT;
        countrycode VARCHAR;
        regioncode VARCHAR;
    BEGIN
        SELECT INTO countrycode iso FROM geo_typeahead_countries WHERE id=arg_country_id;
        SELECT INTO regioncode local_name FROM geo_typeahead_region WHERE id=arg_region_id;
        SELECT INTO ret_val id FROM geo_typeahead_cities WHERE admin1_code=regioncode AND country_code=countrycode AND place_name_ascii=arg_city;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_city_id(arg_country_id bigint, arg_region_id bigint, arg_city character varying) OWNER TO w4;

--
-- Name: get_city_name(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_city_name(arg_city_id bigint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
        DECLARE
            ret_val text;
        BEGIN
            SELECT INTO ret_val place_name_ascii FROM geo_typeahead_cities WHERE id=arg_city_id;
            RETURN ret_val;
        END;
    $$;


ALTER FUNCTION w4_application_functions.get_city_name(arg_city_id bigint) OWNER TO w4;

--
-- Name: get_click_conversion_graph(bigint, timestamp with time zone, timestamp with time zone, interval, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_click_conversion_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_frequency interval DEFAULT '1 day'::interval, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pubs_clicks_conversions_totals_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_clicks_conversions_totals_list; -- total_clicks, total_conversions
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN
        arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
    arg_end_date = COALESCE(arg_end_date, NOW());
        -- Get the interval series
        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);
        -- Initialize our data return
        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(ry.unique_clicks),0) AS clicks, COALESCE(SUM(ry.total_conversions),0) AS conversions, array_to_json(r) AS slice FROM reports_yearly ry LEFT JOIN campaigns cmp ON ry.campaign_id = cmp.id WHERE (ry.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND ry.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY ry.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.total_conversions:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rm.unique_clicks),0) AS clicks, COALESCE(SUM(rm.total_conversions),0) AS conversions, array_to_json(r) AS slice FROM reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id WHERE (rm.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rm.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rm.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.total_conversions:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rd.unique_clicks),0) AS clicks, COALESCE(SUM(rd.total_conversions),0) AS conversions, array_to_json(r) AS slice FROM reports_daily rd LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id WHERE (rd.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rd.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rd.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.total_conversions:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rh.unique_clicks),0) AS clicks, COALESCE(SUM(rh.total_conversions),0) AS conversions, array_to_json(r) AS slice FROM reports_hourly rh LEFT JOIN campaigns cmp ON rh.campaign_id = cmp.id WHERE (rh.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rh.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rh.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.total_conversions:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_click_conversion_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval, arg_offset bigint, arg_limit bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_click_conversion_graph(bigint, bigint, timestamp with time zone, timestamp with time zone, interval, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_click_conversion_graph(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_frequency interval DEFAULT '1 day'::interval, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pubs_clicks_conversions_totals_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_clicks_conversions_totals_list; -- total_clicks, total_conversions
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN
    arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
    arg_end_date = COALESCE(arg_end_date, NOW());
        -- Get the interval series
        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);
        -- Initialize our data return
        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(ry.unique_clicks),0) AS clicks, COALESCE(SUM(ry.total_conversions),0) AS conversions, array_to_json(r) AS slice FROM reports_yearly ry LEFT JOIN campaigns cmp ON ry.campaign_id = cmp.id WHERE (ry.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND ry.publisher_id=arg_publisher_id AND ry.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY ry.publisher_id,ry.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.total_conversions:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rm.unique_clicks),0) AS clicks, COALESCE(SUM(rm.total_conversions),0) AS conversions, array_to_json(r) AS slice FROM reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id WHERE (rm.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rm.publisher_id=arg_publisher_id AND rm.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rm.publisher_id,rm.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.total_conversions:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rd.unique_clicks),0) AS clicks, COALESCE(SUM(rd.total_conversions),0) AS conversions, array_to_json(r) AS slice FROM reports_daily rd LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id WHERE (rd.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rd.publisher_id=arg_publisher_id AND rd.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rd.publisher_id,rd.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.total_conversions:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rh.unique_clicks),0) AS clicks, COALESCE(SUM(rh.total_conversions),0) AS conversions, array_to_json(r) AS slice FROM reports_hourly rh LEFT JOIN campaigns cmp ON rh.campaign_id = cmp.id WHERE (rh.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rh.publisher_id=arg_publisher_id AND rh.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rh.publisher_id,rh.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.total_conversions:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_click_conversion_graph(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval, arg_offset bigint, arg_limit bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_conversion_rate_graph(bigint, timestamp with time zone, timestamp with time zone, interval, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_conversion_rate_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_frequency interval DEFAULT '1 day'::interval, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pubs_conversion_rate
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_conversion_rate; -- total_clicks, total_conversions
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN
            arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
		arg_end_date = COALESCE(arg_end_date, NOW());
        -- Get the interval series
        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);
        -- Initialize our data return
        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val (COALESCE(SUM(ry.total_conversions),0)/NULLIF(COALESCE(SUM(ry.unique_clicks),0),0) * 100) AS conversion_rate, array_to_json(r) AS slice FROM reports_yearly ry LEFT JOIN campaigns cmp ON ry.campaign_id = cmp.id WHERE (ry.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND ry.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY ry.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.conversion_rate:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val (COALESCE(SUM(rm.total_conversions),0)/NULLIF(COALESCE(SUM(rm.unique_clicks),0),0) * 100) AS conversion_rate, array_to_json(r) AS slice FROM reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id WHERE (rm.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rm.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rm.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.conversion_rate:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val (COALESCE(SUM(rd.total_conversions),0)/NULLIF(COALESCE(SUM(rd.unique_clicks),0),0) * 100) AS conversion_rate, array_to_json(r) AS slice FROM reports_daily rd LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id WHERE (rd.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rd.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rd.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.conversion_rate:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val (COALESCE(SUM(rh.total_conversions),0)/NULLIF(COALESCE(SUM(rh.unique_clicks),0),0) * 100) AS conversion_rate, array_to_json(r) AS slice FROM reports_hourly rh LEFT JOIN campaigns cmp ON rh.campaign_id = cmp.id WHERE (rh.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rh.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rh.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.conversion_rate:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_conversion_rate_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval, arg_offset bigint, arg_limit bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_conversion_rate_graph(bigint, bigint, timestamp with time zone, timestamp with time zone, interval, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_conversion_rate_graph(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_frequency interval DEFAULT '1 day'::interval, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pubs_conversion_rate
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_conversion_rate; -- total_clicks, total_conversions
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN
            arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
    arg_end_date = COALESCE(arg_end_date, NOW());
        -- Get the interval series
        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);
        -- Initialize our data return
        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val (COALESCE(SUM(ry.total_conversions),0)/NULLIF(COALESCE(SUM(ry.unique_clicks),0),0) * 100) AS conversion_rate, array_to_json(r) AS slice FROM reports_yearly ry LEFT JOIN campaigns cmp ON ry.campaign_id = cmp.id WHERE (ry.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND ry.publisher_id=arg_publisher_id AND ry.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY ry.publisher_id,ry.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.conversion_rate:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val (COALESCE(SUM(rm.total_conversions),0)/NULLIF(COALESCE(SUM(rm.unique_clicks),0),0) * 100) AS conversion_rate, array_to_json(r) AS slice FROM reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id WHERE (rm.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rm.publisher_id=arg_publisher_id AND rm.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rm.publisher_id,rm.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.conversion_rate:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val (COALESCE(SUM(rd.total_conversions),0)/NULLIF(COALESCE(SUM(rd.unique_clicks),0),0) * 100) AS conversion_rate, array_to_json(r) AS slice FROM reports_daily rd LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id WHERE (rd.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rd.publisher_id=arg_publisher_id AND rd.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rd.publisher_id,rd.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.conversion_rate:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val (COALESCE(SUM(rh.total_conversions),0)/NULLIF(COALESCE(SUM(rh.unique_clicks),0),0) * 100) AS conversion_rate, array_to_json(r) AS slice FROM reports_hourly rh LEFT JOIN campaigns cmp ON rh.campaign_id = cmp.id WHERE (rh.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rh.publisher_id=arg_publisher_id AND rh.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rh.publisher_id,rh.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.conversion_rate:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_conversion_rate_graph(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval, arg_offset bigint, arg_limit bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_country_id(character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_country_id(arg_country character varying) RETURNS bigint
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BIGINT;
    BEGIN
        SELECT INTO ret_val id FROM geo_typeahead_countries WHERE country=arg_country;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_country_id(arg_country character varying) OWNER TO w4;

--
-- Name: get_country_name(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_country_name(arg_country_id bigint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
        DECLARE
            ret_val TEXT;
        BEGIN
            SELECT INTO ret_val country FROM geo_typeahead_countries WHERE id=arg_country_id;
            RETURN ret_val;
        END;
    $$;


ALTER FUNCTION w4_application_functions.get_country_name(arg_country_id bigint) OWNER TO w4;

--
-- Name: get_earnings_graph(bigint, timestamp with time zone, timestamp with time zone, interval, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_earnings_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_frequency interval DEFAULT '1 day'::interval, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pubs_earnings_total_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_earnings_total_list;
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN
                arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
    arg_end_date = COALESCE(arg_end_date, NOW());

        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);

        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(ry.total_pay_out),0) AS earnings, array_to_json(r) AS slice FROM reports_yearly ry LEFT JOIN campaigns cmp ON ry.campaign_id = cmp.id WHERE (ry.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND ry.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY ry.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rm.total_pay_out),0) AS earnings, array_to_json(r) AS slice FROM reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id WHERE (rm.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rm.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rm.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rd.total_pay_out),0) AS earnings, array_to_json(r) AS slice FROM reports_daily rd LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id WHERE (rd.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rd.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rd.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rh.total_pay_out),0) AS earnings, array_to_json(r) AS slice FROM reports_hourly rh LEFT JOIN campaigns cmp ON rh.campaign_id = cmp.id WHERE (rh.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rh.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rh.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_earnings_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval, arg_offset bigint, arg_limit bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_earnings_graph(bigint, bigint, timestamp with time zone, timestamp with time zone, interval, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_earnings_graph(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_frequency interval DEFAULT '1 day'::interval, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pubs_earnings_total_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_earnings_total_list;
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN
                arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
    arg_end_date = COALESCE(arg_end_date, NOW());
        -- Get the interval series
        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);
        -- Determine the interval that we're going to be splitting chunks from to decide which tables to hit
        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(ry.total_pay_out),0) AS earnings, array_to_json(r) AS slice FROM reports_yearly ry LEFT JOIN campaigns cmp ON ry.campaign_id = cmp.id WHERE (ry.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND ry.publisher_id=arg_publisher_id AND ry.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY ry.publisher_id,ry.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rm.total_pay_out),0) AS earnings, array_to_json(r) AS slice FROM reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id WHERE (rm.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rm.publisher_id=arg_publisher_id AND rm.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rm.publisher_id,rm.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rd.total_pay_out),0) AS earnings, array_to_json(r) AS slice FROM reports_daily rd LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id WHERE (rd.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rd.publisher_id=arg_publisher_id AND rd.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rd.publisher_id,rd.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rh.total_pay_out),0) AS earnings, array_to_json(r) AS slice FROM reports_hourly rh LEFT JOIN campaigns cmp ON rh.campaign_id = cmp.id WHERE (rh.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rh.publisher_id=arg_publisher_id AND rh.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rh.publisher_id,rh.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_earnings_graph(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval, arg_offset bigint, arg_limit bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_emails_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_emails_json(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
        rec RECORD;
        r VARCHAR;
        comma_char VARCHAR;
    BEGIN
	comma_char:='';
        ret_val:='{"emails":[';
        FOR rec IN SELECT * FROM creatives c LEFT JOIN creative_emails ce ON c.id=ce.creative_id AND c."type"=3 WHERE c.campaign_id=arg_campaign_id LOOP
            r:=row_to_json(rec);
            ret_val:=ret_val || comma_char || r::VARCHAR;
            comma_char:=',';
        END LOOP;
        ret_val:=ret_val || ']}';
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_emails_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: get_engine_audit_entry(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_engine_audit_entry(arg_click_id bigint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val text := '';
    BEGIN
        SELECT INTO ret_val message FROM engine_audit_log WHERE click_id=arg_click_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_engine_audit_entry(arg_click_id bigint) OWNER TO w4;

--
-- Name: get_epc_graph(bigint, timestamp with time zone, timestamp with time zone, interval, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_epc_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_frequency interval DEFAULT '1 day'::interval, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pubs_earnings_total_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_earnings_total_list;
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN
                arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
	arg_end_date = COALESCE(arg_end_date, NOW());
        -- Get the interval series
        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);
        -- Determine the interval that we're going to be splitting chunks from to decide which tables to hit
        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(ry.total_pay_out),0)/NULLIF(COALESCE(SUM(ry.unique_clicks),0),0) AS earnings, array_to_json(r) AS slice FROM reports_yearly ry LEFT JOIN campaigns cmp ON ry.campaign_id = cmp.id WHERE (ry.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND ry.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY ry.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rm.total_pay_out),0)/NULLIF(COALESCE(SUM(rm.unique_clicks),0),0) AS earnings, array_to_json(r) AS slice FROM reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id WHERE (rm.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rm.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rm.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rd.total_pay_out),0)/NULLIF(COALESCE(SUM(rd.unique_clicks),0),0) AS earnings, array_to_json(r) AS slice FROM reports_daily rd LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id WHERE (rd.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rd.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rd.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rh.total_pay_out),0)/NULLIF(COALESCE(SUM(rh.unique_clicks),0),0) AS earnings, array_to_json(r) AS slice FROM reports_hourly rh LEFT JOIN campaigns cmp ON rh.campaign_id = cmp.id WHERE (rh.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rh.publisher_id=arg_publisher_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rh.publisher_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_epc_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval, arg_offset bigint, arg_limit bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_epc_graph(bigint, bigint, timestamp with time zone, timestamp with time zone, interval, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_epc_graph(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_frequency interval DEFAULT '1 day'::interval, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pubs_earnings_total_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_earnings_total_list;
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN
                arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
    arg_end_date = COALESCE(arg_end_date, NOW());
        -- Get the interval series
        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);
        -- Determine the interval that we're going to be splitting chunks from to decide which tables to hit
        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(ry.total_pay_out),0)/NULLIF(COALESCE(SUM(ry.unique_clicks),0),0) AS earnings, array_to_json(r) AS slice FROM reports_yearly ry LEFT JOIN campaigns cmp ON ry.campaign_id = cmp.id WHERE (ry.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND ry.publisher_id=arg_publisher_id AND ry.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY ry.publisher_id,ry.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rm.total_pay_out),0)/NULLIF(COALESCE(SUM(rm.unique_clicks),0),0) AS earnings, array_to_json(r) AS slice FROM reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id  WHERE (rm.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rm.publisher_id=arg_publisher_id AND rm.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rm.publisher_id,rm.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rd.total_pay_out),0)/NULLIF(COALESCE(SUM(rd.unique_clicks),0),0) AS earnings, array_to_json(r) AS slice FROM reports_daily rd LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id WHERE (rd.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rd.publisher_id=arg_publisher_id AND rd.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rd.publisher_id,rd.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rh.total_pay_out),0)/NULLIF(COALESCE(SUM(rh.unique_clicks),0),0) AS earnings, array_to_json(r) AS slice FROM reports_hourly rh LEFT JOIN campaigns cmp ON rh.campaign_id = cmp.id WHERE (rh.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rh.publisher_id=arg_publisher_id AND rh.campaign_id=arg_campaign_id AND (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id) GROUP BY rh.publisher_id,rh.campaign_id;
                IF ret_val IS NOT NULL THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r);
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_epc_graph(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_frequency interval, arg_offset bigint, arg_limit bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_geos_graph(bigint, timestamp with time zone, timestamp with time zone, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_geos_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25) RETURNS SETOF public.pubs_clicks_conversions_geo_list
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val pubs_clicks_conversions_geo_list;
        qry_fetch TEXT;
    BEGIN
                arg_start_date = COALESCE(arg_start_date, NOW() - '7 days'::INTERVAL);
		arg_end_date = COALESCE(arg_end_date, NOW());
        qry_fetch:=$sql$SELECT COALESCE(SUM(total_clicks),0) AS clicks_per_geo, COALESCE(SUM(total_conversions),0) AS clicks_per_geo, country || ' ' || region_name || ' ' || city_name AS geo FROM reports_geo_hourly WHERE (hoy >= make_hoy('$sql$ || arg_start_date || $sql$'::TEXT) AND hoy <= make_hoy('$sql$ || arg_end_date || $sql$'::TEXT)) AND publisher_id=$sql$ || arg_publisher_id || $sql$ GROUP BY publisher_id, country, region_name, city_name$sql$;
        RAISE INFO '%',qry_fetch;
        FOR ret_val IN EXECUTE qry_fetch LOOP
            RETURN NEXT ret_val;
        END LOOP;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_geos_graph(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset bigint, arg_limit bigint) OWNER TO w4;

--
-- Name: get_new_campaigns(bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_new_campaigns(arg_publisher_id bigint, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25) RETURNS SETOF public.pubs_short_campaigns_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val pubs_short_campaigns_list;
    BEGIN
        FOR ret_val IN SELECT cmp."name" AS campaign_name, cmp.id AS campaign_id, COALESCE(po.override_payout, cmp.default_payout)AS publisher_payout, pays_on_friendly_name(cmp.payout_model_id) AS pays_on FROM campaigns cmp LEFT JOIN publisher_overrides po ON po.publisher_id=arg_publisher_id AND po.campaign_id=cmp.id AND (po.effective_date <= now() OR po.effective_date IS NULL) AND (po.expiration_date >= now() OR po.expiration_date IS NULL) WHERE cmp.new_until < now() AND cmp.start_date < now() AND (cmp.expiry_date > now() OR cmp.expiry_date IS NULL) AND (access_type=1 OR access_type=3) ORDER BY cmp.start_date DESC LIMIT arg_limit OFFSET arg_offset LOOP
            RETURN NEXT ret_val;
        END LOOP;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_new_campaigns(arg_publisher_id bigint, arg_offset bigint, arg_limit bigint) OWNER TO w4;

--
-- Name: get_orphaned_contacts(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_orphaned_contacts() RETURNS SETOF public.contacts
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r contacts;
    BEGIN
        FOR r IN EXECUTE 'SELECT * FROM contacts WHERE id NOT IN (SELECT DISTINCT(contact_id) FROM publisher_contact UNION SELECT DISTINCT(contact_id) FROM advertiser_contacts UNION SELECT DISTINCT(primary_contact_id) FROM users UNION SELECT DISTINCT(billing_contact_id) FROM users UNION SELECT DISTINCT(account_contact_id) FROM users UNION SELECT DISTINCT(contact_id) FROM users);' LOOP
            RETURN NEXT r;
        END LOOP; 
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_orphaned_contacts() OWNER TO w4;

--
-- Name: get_payment_to_name(bigint, character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_payment_to_name(arg_publisher_id bigint, payment_to character varying) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val TEXT;
    BEGIN
        ret_val:='Not Set. We can not pay this person if we do not have the appropriate information.';
        IF payment_to='person' THEN
            SELECT INTO ret_val COALESCE(NULLIF(bct.first_name || ' ' || bct.last_name,' '),NULLIF(pct.first_name || ' ' || pct.last_name,' '),NULLIF(up.first_name || ' ' || up.last_name,' '),up.company_name) FROM users u LEFT JOIN user_profiles up ON u.id=up.user_id LEFT JOIN contacts bct ON bct.id=u.billing_contact_id LEFT JOIN contacts pct ON pct.id=u.primary_contact_id WHERE u.id=arg_publisher_id;
        END IF;
        IF payment_to='company' THEN
            SELECT INTO ret_val COALESCE(act.first_name,up.company_name) FROM users u LEFT JOIN user_profiles up ON u.id = up.user_id LEFT JOIN contacts act ON u.account_contact_id=act.id WHERE u.id = arg_publisher_id;
        END IF;        
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_payment_to_name(arg_publisher_id bigint, payment_to character varying) OWNER TO w4;

--
-- Name: get_payment_to_name_options(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_payment_to_name_options(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
    BEGIN

	SELECT INTO retval
		array_to_json
		(
			ARRAY
			[
				COALESCE
				(
					NULLIF( bct.first_name || ' ' || bct.last_name, ' ' ),
					NULLIF( pct.first_name || ' ' || pct.last_name, ' ' ),
					NULLIF( up.first_name  || ' ' || up.last_name,  ' ' ),
					up.company_name
				),
				COALESCE( act.first_name, up.company_name )
			]
		)
	FROM 
		users u 
	LEFT JOIN user_profiles up ON u.id   = up.user_id 
	LEFT JOIN contacts bct     ON bct.id = u.billing_contact_id 
	LEFT JOIN contacts pct     ON pct.id = u.primary_contact_id 
	LEFT JOIN contacts act     ON act.id = u.account_contact_id
	WHERE u.id = arg_publisher_id;

        RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_payment_to_name_options(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
	company_name text;
        retval json;
        var_email text;
        var_login_name text;
        var_parent_id text;
        var_referrer_id text;

    BEGIN
       SELECT COALESCE(email,''), COALESCE(login_name,''), COALESCE(parent_id::text, ''), COALESCE(referrer_id::text, '')  FROM users WHERE id = arg_id INTO var_email, var_login_name, var_parent_id, var_referrer_id;
       
	retval := 
	(
		'{' || 
			'"id": ' || arg_id                                  || ',' ||
			'"name": ' || get_publisher_edit_title( arg_id )      || ',' ||
			'"contact": ' || get_publisher_account_contact( arg_id ) || ',' ||
			'"url": ' || get_publisher_account_url( arg_id )     || ',' ||
			'"manager_id": ' || get_publisher_account_manager( arg_id ) || ',' ||
			'"manager_name":  ' || get_publisher_account_manager_name( arg_id ) || ',' ||
			'"status": ' || get_publisher_account_status( arg_id )  || ',' ||
			'"files": ' || w4_application_functions.get_publisher_account_files( arg_id )   || ',' ||
			'"notes":         ' || get_publisher_account_notes( arg_id )        || ',' ||
			'"managers": ' || get_publisher_account_managers()        || ',' ||
			'"status_codes": ' || get_publisher_status_codes()            || ',' ||
			'"email": ' || to_json(var_email)            || ',' ||
			'"parent_id": ' || to_json(var_parent_id)            || ',' ||
			'"referrer_id": ' || to_json(var_referrer_id)            || ',' ||
			'"username": ' || to_json(var_login_name)            ||
		'}'
	)::json;
	RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account(arg_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account_contact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_contact(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
		retval json;
	BEGIN
		SELECT INTO retval row_to_json
		(
			ROW
			(
				COALESCE(ct.id,u.account_contact_id),
				COALESCE(ct.first_name,up.first_name),
				COALESCE(ct.last_name,up.last_name),
				COALESCE(ct.address_1,up.address_1),
				CASE WHEN(ct.address_1 NOTNULL)THEN
					ct.address_2
					ELSE
					up.address_2
					END,
				COALESCE(NULLIF(ct.country_id,0),(SELECT id FROM geo_typeahead_countries WHERE lower(country)=lower(up.country))), 
				COALESCE(NULLIF(region_id, 0),(SELECT id FROM geo_typeahead_region WHERE lower(ascii_name)=lower(up.state) AND UPPER(admin1_code)=(SELECT UPPER(iso) FROM geo_typeahead_countries WHERE country=up.country LIMIT 1))), 
				COALESCE(NULLIF(ct.city_id,0),(SELECT id FROM geo_typeahead_cities WHERE lower(place_name_ascii)=lower(up.city) AND UPPER(country_code)=(SELECT UPPER(iso) FROM geo_typeahead_countries WHERE lower(country)=lower(up.country)))), 
				COALESCE(ct.country_name,(SELECT country FROM geo_typeahead_countries WHERE id=ct.country_id),up.country),
				COALESCE(ct.region_name,(SELECT ascii_name FROM geo_typeahead_region WHERE id=ct.region_id LIMIT 1),up.state),
				COALESCE(ct.city_name,(SELECT place_name_ascii FROM geo_typeahead_cities WHERE id=ct.city_id),up.city),
				CASE WHEN(ct.address_1 NOTNULL)THEN
					ct.postal_code
					ELSE
					up.zip
					END,
				ct.messenger_name,
				ct.messenger_type,
				ct.primary_phone,
				ct.secondary_phone,
				ct.fax,
				ct.email_address
			)::vw_contacts
		)
		FROM user_profiles up 
		LEFT JOIN users u     ON u.id  = up.user_id 
		LEFT JOIN vw_contacts ct ON ct.id = u.account_contact_id 
		WHERE u.id = arg_publisher_id;

		RETURN retval;
	END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_contact(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account_files(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_files(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
	retval json;
    BEGIN

	SELECT INTO retval
		array_to_json
		(
			array_agg
			( 
				ROW
				(
					id,
					publisher_id,
					file_id,
					file_name, 
					extension, 
					comments, 
					date_uploaded 
				)::upload -- ::publisher_uploads
			)
		)
	FROM ( SELECT uploaded_at AS date_uploaded, pu.* FROM publisher_uploads pu ) sqldumb
	WHERE publisher_id = arg_publisher_id 
	GROUP BY publisher_id;

	IF COUNT( retval ) = 0 THEN
		retval = '[]'::json;
	END IF;
	
	RETURN retval;

    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_files(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account_information(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_information(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        RETURN row_to_json( ROW( email, login_name )::pub_login_info ) FROM users WHERE id = arg_publisher_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_information(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account_manager(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_manager(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        var_retval json;
    BEGIN
        SELECT to_json( COALESCE(manager_id, 0) ) FROM users WHERE id = arg_publisher_id INTO var_retval;
        IF (NOT FOUND) THEN
            var_retval := '';
        END IF;
        RETURN var_retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_manager(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account_manager_name(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_manager_name(arg_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$

	    DECLARE
	    
		retval json;
		
	    BEGIN
	    
		retval := to_json( up.first_name || ' ' || up.last_name ) 
		FROM
			users u 
		INNER JOIN 
			user_profiles up ON u.manager_id = up.user_id 
		WHERE
			u.id = arg_id;

		IF retval IS NULL THEN
			RETURN 'null'::json;
		END IF;
		
		RETURN retval;
		
	    END;
	    
	$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_manager_name(arg_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account_managers(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_managers() RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        RETURN array_to_json( array_agg( ROW( user_id, full_name )::short_manager ) ) FROM vw_user_listing;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_managers() OWNER TO w4;

--
-- Name: get_publisher_account_notes(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_notes(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        RETURN to_json( notes ) AS notes FROM user_profiles WHERE user_id = arg_publisher_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_notes(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account_status(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_status(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        RETURN to_json( active ) AS status FROM users WHERE id = arg_publisher_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_status(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_account_url(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_account_url(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        var_retval json;
    BEGIN
        SELECT to_json( website_url ) FROM user_profiles WHERE user_id = arg_publisher_id INTO var_retval;
        IF (NOT FOUND) THEN
            var_retval := '';
        END IF;
        RETURN var_retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_account_url(arg_publisher_id bigint) OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: message_delivery_setting_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE message_delivery_setting_types (
    id bigint NOT NULL,
    delivery_setting_id bigint,
    delivery_type_id bigint
);


ALTER TABLE public.message_delivery_setting_types OWNER TO w4;

--
-- Name: message_delivery_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE message_delivery_types (
    id bigint NOT NULL,
    delivery_name character varying(32) DEFAULT NULL::character varying,
    delivery_description character varying(250) DEFAULT NULL::character varying
);


ALTER TABLE public.message_delivery_types OWNER TO w4;

--
-- Name: message_status; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE message_status (
    id bigint NOT NULL,
    status_name character varying(32) DEFAULT NULL::character varying,
    status_description character varying(250) DEFAULT NULL::character varying
);


ALTER TABLE public.message_status OWNER TO w4;

--
-- Name: message_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE message_types (
    id bigint NOT NULL,
    type_name character varying(32) DEFAULT NULL::character varying,
    type_description character varying(250) DEFAULT NULL::character varying
);


ALTER TABLE public.message_types OWNER TO w4;

--
-- Name: messages; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE messages (
    id bigint NOT NULL,
    sender_id bigint,
    receiver_id bigint,
    message_type integer,
    message_status integer,
    message_content text,
    message_created_date timestamp with time zone,
    message_last_access_date timestamp with time zone,
    message_delivery_setting integer,
    message_subject text
);


ALTER TABLE public.messages OWNER TO w4;

--
-- Name: vw_publisher_alerts; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_alerts AS
 SELECT msg.id AS alert_id,
    msg.message_content AS alert_content,
    msg.message_created_date AS alert_created_date,
    ms.status_name AS alert_status,
    msg.receiver_id AS publisher_id,
    msg.sender_id,
    concat(sup.first_name, ' ', sup.last_name) AS sender_name
   FROM ((((((messages msg
   LEFT JOIN message_status ms ON ((msg.message_status = ms.id)))
   LEFT JOIN message_types mt ON ((msg.message_type = mt.id)))
   LEFT JOIN message_delivery_setting_types mdst ON ((msg.message_delivery_setting = mdst.delivery_setting_id)))
   LEFT JOIN message_delivery_types mdt ON ((mdst.delivery_type_id = mdt.id)))
   LEFT JOIN users susr ON ((msg.sender_id = susr.id)))
   LEFT JOIN user_profiles sup ON ((susr.uuid = sup.user_uuid)))
  WHERE ((((ms.status_name)::text = ANY (ARRAY[('New'::character varying)::text, ('Displayed'::character varying)::text, ('Read'::character varying)::text])) AND ((mt.type_name)::text = 'publisher_alert'::text)) AND ((mdt.delivery_name)::text = 'publisher_dashboard'::text))
  ORDER BY ms.id;


ALTER TABLE public.vw_publisher_alerts OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: get_publisher_alerts(bigint, boolean, boolean, boolean, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_alerts(arg_publisher_id bigint, arg_get_new boolean DEFAULT true, arg_get_read boolean DEFAULT true, arg_get_archived boolean DEFAULT true, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25) RETURNS SETOF public.vw_publisher_alerts
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val vw_publisher_alerts%ROWTYPE;
        oset BIGINT;
        olim BIGINT;
    BEGIN
        olim:=0;
        oset:=0;
        IF arg_get_new THEN
            FOR ret_val IN EXECUTE $fetch_sql$SELECT * FROM vw_publisher_alerts vpa WHERE alert_status='New' OR alert_status='Displayed' AND publisher_id=$fetch_sql$ || arg_publisher_id || ' ORDER BY 1 DESC;' LOOP
                oset:=oset+1;
                IF olim <= arg_limit AND oset >= arg_offset THEN
                    -- Update the status to reflect that it's been displayed in a list view to the user
                    olim:=olim+1;
                    IF ret_val.alert_status='New' THEN
                        UPDATE messages SET message_status=(SELECT id FROM message_status WHERE status_name='Displayed') WHERE id=ret_val.alert_id;
                    END IF;
                    RETURN NEXT ret_val;
                ELSE
                    RETURN;
                END IF;
            END LOOP;
        END IF;
        IF arg_get_read THEN
            FOR ret_val IN EXECUTE $fetch_sql$SELECT * FROM vw_publisher_alerts vpa WHERE alert_status='Read' AND publisher_id=$fetch_sql$ || arg_publisher_id || ' ORDER BY 1 DESC;' LOOP
                oset:=oset+1;
                IF olim <= arg_limit AND oset >= arg_offset THEN
                    -- Update the status to reflect that it's been displayed in a list view to the user
                    olim:=olim+1;
                    RETURN NEXT ret_val;
                ELSE
                    RETURN;
                END IF;
            END LOOP;
        END IF;
        IF arg_get_archived THEN
            FOR ret_val IN EXECUTE $fetch_sql$SELECT * FROM vw_publisher_alerts vpa WHERE alert_status='Archived' AND publisher_id=$fetch_sql$ || arg_publisher_id || ' ORDER BY 1 DESC;' LOOP
                oset:=oset+1;
                IF olim <= arg_limit AND oset >= arg_offset THEN
                    -- Update the status to reflect that it's been displayed in a list view to the user
                    olim:=olim+1;
                    RETURN NEXT ret_val;
                ELSE
                    RETURN;
                END IF;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_publisher_alerts(arg_publisher_id bigint, arg_get_new boolean, arg_get_read boolean, arg_get_archived boolean, arg_offset bigint, arg_limit bigint) OWNER TO w4;

--
-- Name: get_publisher_billing(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_billing(arg_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
        var_tax_id text;
        var_payment_to text;
        var_payment_by text;
        var_payment_schedule text;
        var_payment_threshold numeric;

    BEGIN

	SELECT
            COALESCE(tax_id, ''),
            COALESCE(payment_to, ''), -- get_payment_to_name( arg_publisher_id, payment_to ),
            COALESCE(payment_by, 0), -- get_publisher_billing_method_name( payment_by ),
            COALESCE(payment_schedule, ''),
            COALESCE(payment_threshold, 0)
	FROM user_profiles 
	WHERE user_id = arg_id
        INTO var_tax_id, var_payment_to, var_payment_by, var_payment_schedule, var_payment_threshold;
    
	retval := 
	(
		'{' || 
			'"id": ' || arg_id                                  || ',' ||
			'"contact": ' || get_publisher_billing_contact( arg_id ) || ',' ||
			'"payment_names": ' || get_publisher_payment_names( arg_id )   || ',' ||
			'"methods": ' || get_publisher_billing_methods()         || ',' ||
			'"schedules": ' || get_publisher_billing_schedules()       || ',' ||
			'"taxid": ' || to_json(var_tax_id)       || ',' ||
			'"payment_to": ' || to_json(var_payment_to)       || ',' ||
			'"payment_method": ' || var_payment_by       || ',' ||
			'"payment_schedule": ' || to_json(var_payment_schedule)       || ',' ||
			'"payment_threshold": ' || var_payment_threshold       ||
		'}'
	)::json;

	RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_billing(arg_id bigint) OWNER TO w4;

--
-- Name: get_publisher_billing_contact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_billing_contact(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
    BEGIN
	SELECT INTO retval
		row_to_json
		(
			ROW
			(
				ct.id,
				ct.first_name,
				ct.last_name,
				COALESCE(ct.address_1,up.payment_address_1),
				CASE WHEN(ct.address_1 NOTNULL)THEN
					ct.address_2
					ELSE
					up.payment_address_2
					END,
				COALESCE(NULLIF(ct.country_id,0),(SELECT id FROM geo_typeahead_countries WHERE lower(country)=lower(up.payment_country))), 
				COALESCE(NULLIF(region_id, 0),(SELECT id FROM geo_typeahead_region WHERE lower(ascii_name)=lower(up.payment_region) AND UPPER(admin1_code)=(SELECT UPPER(iso) FROM geo_typeahead_countries WHERE country=up.payment_country LIMIT 1) LIMIT 1)), 
				COALESCE(NULLIF(ct.city_id,0),(SELECT id FROM geo_typeahead_cities WHERE lower(place_name_ascii)=lower(up.payment_city) AND UPPER(country_code)=(SELECT UPPER(iso) FROM geo_typeahead_countries WHERE lower(country)=lower(up.payment_country)))), 
				COALESCE(ct.country_name,(SELECT country FROM geo_typeahead_countries WHERE id=ct.country_id),up.payment_country),
				COALESCE(ct.region_name,(SELECT ascii_name FROM geo_typeahead_region WHERE id=ct.region_id LIMIT 1),up.payment_region),
				COALESCE(ct.city_name,(SELECT place_name_ascii FROM geo_typeahead_cities WHERE id=ct.city_id),up.payment_city),
				CASE WHEN(ct.address_1 NOTNULL)THEN
					ct.postal_code
					ELSE
					up.payment_postal_code
					END,				
				ct.messenger_name,
				ct.messenger_type,
				ct.primary_phone,
				ct.secondary_phone,
				ct.fax,
				ct.email_address
			)::vw_contacts
		)
	FROM user_profiles up 
	LEFT JOIN users u     ON u.id  = up.user_id 
	LEFT JOIN vw_contacts ct ON ct.id = u.billing_contact_id 
	WHERE u.id = arg_publisher_id;
	
        RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_billing_contact(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_billing_information(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_billing_information(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
    BEGIN
    
	SELECT INTO retval
		row_to_json
		(
			ROW
			(
				tax_id,
				payment_to, -- get_payment_to_name( arg_publisher_id, payment_to ),
				payment_by, -- get_publisher_billing_method_name( payment_by ),
				payment_schedule,
				payment_threshold
			)::publisher_billing_information
		)
	FROM user_profiles 
	WHERE user_id = arg_publisher_id;
	
        RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_billing_information(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_billing_method_id(text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_billing_method_id(arg_name text) RETURNS smallint
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        IF arg_name='Check' THEN
            RETURN 1;
        END IF;
        IF arg_name='Wire' THEN
            RETURN 2;
        END IF;
        IF arg_name='PayPal' THEN
            RETURN 3;
        END IF;
        IF arg_name='ACH' THEN
            RETURN 4;
        END IF;
        RETURN 0;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_billing_method_id(arg_name text) OWNER TO w4;

--
-- Name: get_publisher_billing_method_name(smallint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_billing_method_name(arg_id smallint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val TEXT;
    BEGIN
        CASE arg_id
            WHEN 1 THEN
                ret_val:='Check';
            WHEN 2 THEN
                ret_val:='Wire';
            WHEN 3 THEN
                ret_val:='PayPal';
            WHEN 4 THEN
                ret_val:='ACH';
            ELSE
                ret_val:='Not Set';
        END CASE;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_billing_method_name(arg_id smallint) OWNER TO w4;

--
-- Name: get_publisher_billing_methods(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_billing_methods() RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        RETURN array_to_json( ARRAY['Check', 'Wire', 'PayPal', 'ACH'] );
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_billing_methods() OWNER TO w4;

--
-- Name: get_publisher_billing_schedules(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_billing_schedules() RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        RETURN array_to_json( ARRAY['Weekly', 'Bi-Weekly', 'Semi-Monthly', 'Monthly'] );
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_billing_schedules() OWNER TO w4;

--
-- Name: get_publisher_by_id(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_by_id(arg_id bigint) RETURNS public.users
    LANGUAGE plpgsql
    AS $$
	DECLARE
		return_user users;
	BEGIN
		SELECT *
		INTO return_user
		FROM users usr
		WHERE usr.id=arg_id AND usr.access='publisher';
		IF NOT FOUND THEN
			PERFORM * FROM users WHERE users.id=arg_id AND users.access='admin';
			IF NOT FOUND THEN
				RAISE EXCEPTION 'The user id [%] does not exist for any user, administrator, or publisher.',arg_id;
			ELSE
				RAISE EXCEPTION 'The user id [%] belongs to an administrator, not a publisher.',arg_id;
			END IF;
		END IF;
		RETURN return_user;
	END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_by_id(arg_id bigint) OWNER TO w4;

--
-- Name: get_publisher_contact(bigint, boolean, boolean, text, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_contact(arg_publisher_id bigint, arg_include_primary boolean DEFAULT true, arg_include_billing boolean DEFAULT true, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT 25, arg_offset bigint DEFAULT 0) RETURNS SETOF public.contacts
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        p users;
        r contacts;
        order_clause text;

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'ct.first_name ASC');

        SELECT INTO p * FROM users WHERE id=arg_publisher_id;
        IF arg_include_primary THEN
            IF arg_include_billing THEN
                FOR r IN EXECUTE 'SELECT ct.* FROM publisher_contact pc LEFT JOIN contacts ct ON ct.id=pc.contact_id WHERE pc.publisher_id=' || arg_publisher_id::TEXT || ' ' || order_clause LOOP
                IF r.id <> p.billing_contact_id THEN
                    r.is_billing:=FALSE;
                ELSE
                    r.is_billing:=TRUE;
                END IF;
                IF r.id <> p.primary_contact_id THEN
                    r.is_primary:=FALSE;
                ELSE
                    r.is_primary:=TRUE;
                END IF;
			RETURN NEXT r;
		END LOOP;
            ELSE
                FOR r IN EXECUTE 'SELECT ct.* FROM publisher_contact pc LEFT JOIN contacts ct ON ct.id=pc.contact_id LEFT JOIN users usr ON pc.publisher_id=usr.id WHERE ct.id <> usr.billing_contact_id AND usr.id='||arg_publisher_id::TEXT || ' ' || order_clause LOOP
                IF r.id <> p.billing_contact_id THEN
                    r.is_billing:=FALSE;
                ELSE
                    r.is_billing:=TRUE;
                END IF;
                IF r.id <> p.primary_contact_id THEN
                    r.is_primary:=FALSE;
                ELSE
                    r.is_primary:=TRUE;
                END IF;
			RETURN NEXT r;
                END LOOP;
            END IF;
        ELSE
            IF arg_include_billing THEN
                FOR r IN EXECUTE 'SELECT ct.* FROM publisher_contact pc LEFT JOIN contacts ct ON ct.id=pc.contact_id LEFT JOIN users usr ON pc.publisher_id=usr.id WHERE ct.id <> usr.primary_contact_id AND usr.id='||arg_publisher_id::TEXT || ' ' || order_clause LOOP
                IF r.id <> p.billing_contact_id THEN
                    r.is_billing:=FALSE;
                ELSE
                    r.is_billing:=TRUE;
                END IF;
                IF r.id <> p.primary_contact_id THEN
                    r.is_primary:=FALSE;
                ELSE
                    r.is_primary:=TRUE;
                END IF;
			RETURN NEXT r;
		END LOOP;
            ELSE
                FOR r IN EXECUTE 'SELECT ct.* FROM publisher_contact pc LEFT JOIN contacts ct ON ct.id=pc.contact_id LEFT JOIN users usr ON pc.publisher_id=usr.id WHERE ct.id <> usr.primary_contact_id AND ct.id <> usr.billing_contact_id AND usr.id='||arg_publisher_id::TEXT || ' ' || order_clause LOOP
                IF r.id <> p.billing_contact_id THEN
                    r.is_billing:=FALSE;
                ELSE
                    r.is_billing:=TRUE;
                END IF;
                IF r.id <> p.primary_contact_id THEN
                    r.is_primary:=FALSE;
                ELSE
                    r.is_primary:=TRUE;
                END IF;
			RETURN NEXT r;
		END LOOP;
            END IF;
        END IF;
        return;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_contact(arg_publisher_id bigint, arg_include_primary boolean, arg_include_billing boolean, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: get_publisher_contacts(numeric, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_contacts(arg_publisher_id numeric, arg_include_primary boolean, arg_include_billing boolean) RETURNS SETOF public.contacts
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r contacts;
    BEGIN
        IF arg_include_primary THEN
            IF arg_include_billing THEN
                FOR r IN EXECUTE 'SELECT ct.* FROM publisher_contact pc LEFT JOIN contacts ct ON ct.id=pc.contact_id WHERE pc.publisher_id='||arg_publisher_id::TEXT LOOP
			RETURN NEXT r;
		END LOOP;
            ELSE
                FOR r IN EXECUTE 'SELECT ct.* FROM publisher_contact pc LEFT JOIN contacts ct ON ct.id=pc.contact_id LEFT JOIN users usr ON pc.publisher_id=usr.id WHERE ct.id <> usr.billing_contact_id AND usr.id='||arg_publisher_id::TEXT LOOP
			RETURN NEXT r;
                END LOOP;
            END IF;
        ELSE
            IF arg_include_billing THEN
                FOR r IN EXECUTE 'SELECT ct.* FROM publisher_contact pc LEFT JOIN contacts ct ON ct.id=pc.contact_id LEFT JOIN users usr ON pc.publisher_id=usr.id WHERE ct.id <> usr.primary_contact_id AND usr.id='||arg_publisher_id::TEXT LOOP
			RETURN NEXT r;
		END LOOP;
            ELSE
                FOR r IN EXECUTE 'SELECT ct.* FROM publisher_contact pc LEFT JOIN contacts ct ON ct.id=pc.contact_id LEFT JOIN users usr ON pc.publisher_id=usr.id WHERE ct.id <> usr.primary_contact_id AND ct.id <> usr.billing_contact_id AND usr.id='||arg_publisher_id::TEXT LOOP
			RETURN NEXT r;
		END LOOP;
            END IF;
        END IF;
        return;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_contacts(arg_publisher_id numeric, arg_include_primary boolean, arg_include_billing boolean) OWNER TO w4;

--
-- Name: get_publisher_contacts_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_contacts_json(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        contact json;
    BEGIN
        SELECT INTO contact replace(replace(replace(replace('"contacts":[' || array_agg(row_to_json(ROW(id, first_name, last_name, address_1, address_2, country_id, region_id, city_id, city_name, postal_code, messenger_name, messenger_type, primary_phone, secondary_phone, fax, email_address, check_is_pub_contact_primary(arg_publisher_id,id), check_is_pub_contact_billing(arg_publisher_id,id))::contacts))::TEXT || '}','}","{','},{'),'\"','"'),'{"{','{'),'}"}','}]') FROM contacts WHERE id IN (SELECT contact_id FROM publisher_contact WHERE publisher_id=arg_publisher_id);
        RETURN contact;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_contacts_json(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_dashboard_layout(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_dashboard_layout(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_layout json;
    BEGIN
        ret_layout:='{}';
        SELECT INTO ret_layout settings FROM publisher_interface_settings WHERE publisher_id=arg_publisher_id AND ui_location='Dashboard';
        RETURN ret_layout;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_dashboard_layout(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_edit_screen(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_edit_screen(arg_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val TEXT;
        tt json;
        sb json;
        ct json;
        bi json;
        ai json;
    BEGIN
        tt:=get_publisher_edit_title(arg_id);
        ct:=get_publisher_contacts_json(arg_id);
        bi:=get_publisher_billing(arg_id);
        ai:=get_publisher_account(arg_id);
        ret_val:='{"publisher_edit_screen":{' || '"publisher_edit_title":' || COALESCE(BTRIM(tt::TEXT,'[]'),'""')  || ',' || 
        '"publisher_edit_contacts":' || COALESCE(BTRIM(ct::TEXT,'[]'),'""')  || ','|| 
        '"publisher_edit_billing":' || COALESCE(BTRIM(bi::TEXT,'[]'),'""')  || ',' || 
        '"publisher_edit_account":' || COALESCE(BTRIM(ai::TEXT,'[]'),'""')  || '}}';
        RETURN ret_val; 
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_edit_screen(arg_id bigint) OWNER TO w4;

--
-- Name: get_publisher_edit_sidebar(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_edit_sidebar(arg_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val TEXT;
        am json;
        st json;
        bi json;
        bc json;
        pc json;
        fs json;
        gp json;
    BEGIN
        am:=get_publisher_account_manager(arg_id);
        st:=get_publisher_account_status(arg_id);
        bi:=get_publisher_billing_information(arg_id);
        bc:=get_publisher_billing_contact(arg_id);
        pc:=get_publisher_primary_contact(arg_id);
        fs:=get_publisher_account_files(arg_id);
        gp:=get_publisher_groups_json(arg_id);
        ret_val:='sidebar: {' || COALESCE(BTRIM(am::TEXT,'[]'),'""')  || ',' || COALESCE(BTRIM(st::TEXT,'[]'),'""')  || ',' || COALESCE(BTRIM(bi::TEXT,'[]'),'""')  || ',' || COALESCE(BTRIM(bc::TEXT,'[]'),'""')  || ',' || COALESCE(BTRIM(pc::TEXT,'[]'),'""')  || ',' || COALESCE(BTRIM(fs::TEXT,'[]'),'""') || ',' || COALESCE(BTRIM(gp::TEXT,'[]'),'""')  || '}';
        RETURN ret_val; 
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_edit_sidebar(arg_id bigint) OWNER TO w4;

--
-- Name: get_publisher_edit_title(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_edit_title(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val json;
    BEGIN
        SELECT INTO ret_val to_json( COALESCE( up.company_name, up.first_name || ' ' || up.last_name ) ) FROM user_profiles up WHERE up.user_id = arg_publisher_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Publisher [%]''s profile was NOT FOUND',arg_publisher_id;
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_edit_title(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_groups_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_groups_json(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
    BEGIN
        SELECT INTO retval 
		array_to_json( array_agg( ROW( pg.id, pg."name" )::publisher_groups ) ) 
	FROM publisher_groups_assoc pga 
	LEFT JOIN publisher_groups pg ON pga.group_id = pg.id 
	WHERE pga.publisher_id = arg_publisher_id 
	GROUP BY publisher_id;
	
        RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_groups_json(arg_publisher_id bigint) OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: vw_publisher_messages; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_messages AS
 SELECT msg.id AS message_id,
    msg.message_content,
    msg.message_created_date,
    ms.status_name AS message_status,
    msg.receiver_id AS publisher_id,
    msg.sender_id,
    concat(sup.first_name, ' ', sup.last_name) AS sender_name
   FROM ((((((messages msg
   LEFT JOIN message_status ms ON ((msg.message_status = ms.id)))
   LEFT JOIN message_types mt ON ((msg.message_type = mt.id)))
   LEFT JOIN message_delivery_setting_types mdst ON ((msg.message_delivery_setting = mdst.delivery_setting_id)))
   LEFT JOIN message_delivery_types mdt ON ((mdst.delivery_type_id = mdt.id)))
   LEFT JOIN users susr ON ((msg.sender_id = susr.id)))
   LEFT JOIN user_profiles sup ON ((susr.uuid = sup.user_uuid)))
  WHERE ((((ms.status_name)::text = ANY (ARRAY[('New'::character varying)::text, ('Displayed'::character varying)::text, ('Read'::character varying)::text])) AND ((mt.type_name)::text = 'publisher_message'::text)) AND ((mdt.delivery_name)::text = 'publisher_dashboard'::text))
  ORDER BY ms.id;


ALTER TABLE public.vw_publisher_messages OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: get_publisher_messages(bigint, boolean, boolean, boolean, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_messages(arg_publisher_id bigint, arg_get_new boolean DEFAULT true, arg_get_read boolean DEFAULT true, arg_get_archived boolean DEFAULT true, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25) RETURNS SETOF public.vw_publisher_messages
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val vw_publisher_messages%ROWTYPE;
        oset BIGINT;
        olim BIGINT;
    BEGIN
        olim:=0;
        oset:=0;
        IF arg_get_new THEN
            FOR ret_val IN EXECUTE $fetch_sql$SELECT * FROM vw_publisher_messages vpa WHERE vpa.message_status='New' OR vpa.message_status='Displayed';$fetch_sql$ LOOP
                oset:=oset+1;
                IF olim <= arg_limit AND oset >= arg_offset THEN
                    -- Update the status to reflect that it's been displayed in a list view to the user
                    olim:=olim+1;
                    IF ret_val.message_status='New' THEN
                        UPDATE messages SET message_status=(SELECT id FROM message_status WHERE status_name='Displayed') WHERE id=ret_val.message_id;
                    END IF;
                    RETURN NEXT ret_val;
                ELSE
                    RETURN;
                END IF;
            END LOOP;
        END IF;
        IF arg_get_read THEN
            FOR ret_val IN EXECUTE $fetch_sql$SELECT * FROM vw_publisher_messages vpa WHERE vpa.message_status='Read';$fetch_sql$ LOOP
                oset:=oset+1;
                IF olim <= arg_limit AND oset >= arg_offset THEN
                    -- Update the status to reflect that it's been displayed in a list view to the user
                    olim:=olim+1;
                    RETURN NEXT ret_val;
                ELSE
                    RETURN;
                END IF;
            END LOOP;
        END IF;
        IF arg_get_archived THEN
            FOR ret_val IN EXECUTE $fetch_sql$SELECT * FROM vw_publisher_messages vpa WHERE vpa.message_status='Archived';$fetch_sql$ LOOP
                oset:=oset+1;
                IF olim <= arg_limit AND oset >= arg_offset THEN
                    -- Update the status to reflect that it's been displayed in a list view to the user
                    olim:=olim+1;
                    RETURN NEXT ret_val;
                ELSE
                    RETURN;
                END IF;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_publisher_messages(arg_publisher_id bigint, arg_get_new boolean, arg_get_read boolean, arg_get_archived boolean, arg_offset bigint, arg_limit bigint) OWNER TO w4;

--
-- Name: get_publisher_payment_names(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_payment_names(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        retval json;
    BEGIN
	RETURN	
	(
		'{' ||
			'"company": ' || to_json( get_payment_to_name( arg_publisher_id, 'company' ) ) || ', ' || 
			'"person":  ' || to_json( get_payment_to_name( arg_publisher_id, 'person'  ) ) ||
		'}'
	)::json;
			
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_payment_names(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_primary_contact(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_primary_contact(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        contact json;
    BEGIN
        SELECT INTO contact replace(replace(replace(replace('"primary_contact": {' || array_agg(row_to_json(ROW(ct.id, ct.first_name, ct.last_name, COALESCE(ct.address_1,up.payment_address_1), COALESCE(ct.address_2,up.payment_address_2), COALESCE(NULLIF(ct.country_id,0),(SELECT id FROM geo_typeahead_countries WHERE country=up.payment_country)), COALESCE(NULLIF(region_id,0),(SELECT id FROM geo_typeahead_region WHERE ascii_name=up.payment_region AND admin1_code=(SELECT iso FROM geo_typeahead_countries WHERE country=up.payment_country))), COALESCE(NULLIF(ct.city_id,0),(SELECT id FROM geo_typeahead_cities WHERE place_name_ascii=up.payment_city AND country_code=(SELECT iso FROM geo_typeahead_countries WHERE country=up.payment_country))), COALESCE(ct.city_name,up.payment_city), COALESCE(ct.postal_code,up.payment_postal_code), ct.messenger_name, ct.messenger_type, ct.primary_phone, ct.secondary_phone, ct.fax, ct.email_address, check_is_pub_contact_primary(arg_publisher_id,primary_contact_id), check_is_pub_contact_billing(arg_publisher_id,billing_contact_id))::contacts))::TEXT || '}','}","{','},{'),'\"','"'),'{"{','{'),'}"}','}') FROM user_profiles up LEFT JOIN users u ON u.id=up.user_id LEFT JOIN contacts ct ON ct.id=u.primary_contact_id WHERE u.id=arg_publisher_id;
        RETURN contact;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_primary_contact(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_robert_json_blob_delete_me(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_robert_json_blob_delete_me(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_layout json;
    BEGIN
        ret_layout:='{}';
        SELECT INTO ret_layout settings FROM publisher_interface_settings WHERE publisher_id=arg_publisher_id AND ui_location='TEST';
        RETURN ret_layout;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_robert_json_blob_delete_me(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_publisher_status_codes(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_publisher_status_codes() RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        status json;
    BEGIN
        SELECT INTO status to_json( ARRAY['active', 'banned', 'suspended', 'unconfirmed'] );
        RETURN status;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_publisher_status_codes() OWNER TO w4;

--
-- Name: get_pubs_available_campaigns(bigint, json, json, json, json, bigint, bigint, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_available_campaigns(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint, arg_sort_order text DEFAULT NULL::text) RETURNS SETOF public.pub_campaign_list
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        r		pub_campaign_list;
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];
        sort		text;
        direction	text;
        query		text;

    BEGIN
        channel_ids  := json_array_convert( arg_channel_ids_json  )::bigint[];
        category_ids := json_array_convert( arg_category_ids_json )::bigint[];
        pays_on_ids  := json_array_convert( arg_pays_on_ids_json  )::bigint[];
        geos_ids     := json_array_convert( arg_geos_ids_json  )::text[];
	sort      := COALESCE( arg_sort_order, 'campaign_id DESC' );
	direction := '';
	direction := CASE direction = '' AND sort ~* '\s+ASC$'  WHEN TRUE THEN 'ASC'  ELSE direction END;
	direction := CASE direction = '' AND sort ~* '\s+DESC$' WHEN TRUE THEN 'DESC' ELSE direction END;
	sort      := regexp_replace( sort, '\s+(' || direction || ')$', '', 'i' );
	query := $sql$ SELECT
	cmp."name" AS campaign_name,
	cmp.id AS campaign_id,
	COALESCE( p.override_payout, cmp.default_payout )	AS payout,
	pays_on_friendly_name( cmp.payout_model_id ) AS pays_on,
	geos_json( cmp.id )::text AS geos_json,
	categories_json( cmp.id ) AS categories,
	channels_json( cmp.id ) AS channels,
	categories_ids_json( cmp.id ) AS categories_ids,
	channels_ids_json( cmp.id ) AS channel_ids,
	return_geo_ids_json( cmp.id ) AS country_ids,
	to_char( cmp.expiry_date, 'Month DD, YYYY' ) AS expires,
	cmp.description AS campaign_description,
	CASE cmp.access_type
		WHEN 1 THEN 'public'
		WHEN 2 THEN 'approved'
		WHEN 3 THEN COALESCE(p.status::text,'request')
	END	AS approval_status,
	CASE WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL '1 day' )::timestamptz ) THEN TRUE ELSE FALSE END AS is_new
FROM
	campaigns cmp
LEFT JOIN
(
 SELECT po.*,cap.status, cap.publisher_id AS pub_id, COALESCE(po.campaign_id,cap.campaign_id) AS cid
 FROM publisher_overrides po
 FULL JOIN campaign_assigned_publishers cap
    ON po.publisher_id=cap.publisher_id
    AND po.campaign_id=cap.campaign_id
WHERE (po.effective_date  < NOW() OR po.effective_date IS NULL) AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL) AND (cap.publisher_id=$1 OR po.publisher_id=$1)
) p
    ON p.cid=cmp.id
WHERE
	(((cmp.access_type<>2 AND p.status<>'denied') OR (cmp.access_type<>2 AND p.status IS NULL)) OR (cmp.access_type=2 AND p.status='approved')) AND
	cmp.status = 'active' AND 
			( cmp.expiry_date IS NULL OR cmp.expiry_date > now() ) AND
			( $2 = '{}' OR check_channels( cmp.id,   $2 ) > 0 ) AND
			( $3 = '{}' OR check_categories( cmp.id, $3 ) > 0 ) AND
			( $4 = '{}' OR check_geos( cmp.id,       $4 ) > 0 ) AND
			( $5 = '{}' OR check_pays_on( cmp.id,    $5 ) > 0 )
ORDER BY $sql$ || quote_ident( sort ) || $sql$ $sql$ || direction || $sql$
LIMIT $6
OFFSET $7 $sql$;
raise info 'test: %', query;
	FOR r IN EXECUTE query USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_limit, arg_offset LOOP
            RETURN NEXT r;
        END LOOP;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_available_campaigns(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint, arg_sort_order text) OWNER TO w4;

--
-- Name: get_pubs_available_campaigns_count(bigint, json, json, json, json, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_available_campaigns_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint) RETURNS bigint
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BIGINT;
        channel_ids BIGINT[];
        category_ids BIGINT[];
        pays_on_ids BIGINT[];
        geos_ids BIGINT[];
    BEGIN
        channel_ids := parse_flat_json(arg_channel_ids_json::json);
        category_ids := parse_flat_json(arg_category_ids_json::json);
        pays_on_ids := parse_flat_json(arg_pays_on_ids_json::json);
        geos_ids := parse_flat_json(arg_geos_ids_json::json);
        SELECT INTO ret_val
            COUNT(*)
FROM
	campaigns cmp
LEFT JOIN
(
 SELECT po.*,cap.status, cap.publisher_id AS pub_id, COALESCE(po.campaign_id,cap.campaign_id) AS cid
 FROM publisher_overrides po
 FULL JOIN campaign_assigned_publishers cap
    ON po.publisher_id=cap.publisher_id
    AND po.campaign_id=cap.campaign_id
WHERE (po.effective_date  < NOW() OR po.effective_date IS NULL) AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL) AND (cap.publisher_id=arg_publisher_id OR po.publisher_id=arg_publisher_id)
) p
    ON p.cid=cmp.id
WHERE
	(((cmp.access_type<>2 AND p.status<>'denied') OR (cmp.access_type<>2 AND p.status IS NULL)) OR (cmp.access_type=2 AND p.status='approved')) AND
	cmp.status = 'active'
            AND (check_channels(cmp.id,channel_ids) > 0  OR channel_ids='{}')
            AND (check_categories(cmp.id,category_ids) > 0 OR category_ids='{}')
            AND (check_geos(cmp.id,geos_ids) > 0 OR geos_ids='{}')
            AND (check_pays_on(cmp.id,pays_on_ids) > 0 OR pays_on_ids='{}')
        LIMIT arg_limit
        OFFSET arg_offset;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_pubs_available_campaigns_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint) OWNER TO w4;

--
-- Name: get_pubs_available_campaigns_count(bigint, json, json, json, json, bigint, bigint, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_available_campaigns_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint, arg_is_new boolean) RETURNS bigint
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BIGINT;
        channel_ids BIGINT[];
        category_ids BIGINT[];
        pays_on_ids BIGINT[];
        geos_ids BIGINT[];
    BEGIN
        channel_ids := parse_flat_json(arg_channel_ids_json::json);
        category_ids := parse_flat_json(arg_category_ids_json::json);
        pays_on_ids := parse_flat_json(arg_pays_on_ids_json::json);
        geos_ids := parse_flat_json(arg_geos_ids_json::json);
        SELECT INTO ret_val
            COUNT(*)
FROM
	campaigns cmp
LEFT JOIN
(
 SELECT po.*,cap.status, cap.publisher_id AS pub_id, COALESCE(po.campaign_id,cap.campaign_id) AS cid
 FROM publisher_overrides po
 FULL JOIN campaign_assigned_publishers cap
    ON po.publisher_id=cap.publisher_id
    AND po.campaign_id=cap.campaign_id
WHERE (po.effective_date  < NOW() OR po.effective_date IS NULL) AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL) AND (cap.publisher_id=arg_publisher_id OR po.publisher_id=arg_publisher_id)
) p
    ON p.cid=cmp.id
WHERE
	(((cmp.access_type<>2 AND p.status<>'denied') OR (cmp.access_type<>2 AND p.status IS NULL)) OR (cmp.access_type=2 AND p.status='approved')) AND
	cmp.status = 'active'
            AND (check_channels(cmp.id,channel_ids) > 0  OR channel_ids='{}')
            AND (check_categories(cmp.id,category_ids) > 0 OR category_ids='{}')
            AND (check_geos(cmp.id,geos_ids) > 0 OR geos_ids='{}')
            AND (check_pays_on(cmp.id,pays_on_ids) > 0 OR pays_on_ids='{}')
            AND (cmp.new_until::TIMESTAMPTZ > (now() + INTERVAL '1 day')::TIMESTAMPTZ)
        LIMIT arg_limit
        OFFSET arg_offset;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_pubs_available_campaigns_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint, arg_is_new boolean) OWNER TO w4;

--
-- Name: get_pubs_campaign_details(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_campaign_details(arg_campaign_id bigint, arg_publisher_id bigint) RETURNS public.pub_campaign_details
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val pub_campaign_details;
    BEGIN
        SELECT INTO ret_val
              cmp."name" AS campaign_name
            , cmp.id AS campaign_id
            , COALESCE(po.override_payout, cmp.default_payout)AS publisher_payout
            , pays_on_friendly_name(cmp.payout_model_id) AS campaign_pays_on
            , cmp.description AS campaign_description
            , cmp.restrictions AS campaign_restrictions
            , cmp.expiry_date::TIMESTAMPTZ AS expiration_date
            , categories_json(cmp.id) AS "categories_json"
            , channels_json(cmp.id) AS "channels_json"
            , geos_json(cmp.id) AS "geos_json"
            , get_banners_json(cmp.id) AS campaign_assets_banners_json
            , get_emails_json(cmp.id) AS campaign_assets_emails_json
            , get_text_links_json(cmp.id) AS campaign_assets_text_links_json
            , 'http://w4qa.net/' || md5(now()::TEXT) AS suppression_list_link
        FROM campaigns cmp
        LEFT JOIN publisher_overrides po 
            ON po.publisher_id=arg_publisher_id 
            AND po.campaign_id=cmp.id 
            AND (po.effective_date < now() OR po.effective_date IS NULL)
            AND (po.expiration_date > now() OR po.expiration_date IS NULL) 
        LEFT JOIN campaign_assigned_publishers cap 
            ON cap.campaign_id=cmp.id 
            AND cap.publisher_id=arg_publisher_id 
        WHERE (((cmp.access_type <> 2 OR (cmp.access_type=2 AND cap.status='approved')) AND (cap.status <> 'blocked' AND cap.status <> 'denied')) OR (cap.status IS NULL)) AND cmp.id=arg_campaign_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_pubs_campaign_details(arg_campaign_id bigint, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: get_pubs_new_campaigns(bigint, json, json, json, json, bigint, bigint, text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_new_campaigns(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint, arg_sort_order text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.pub_campaign_list
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        r		pub_campaign_list;
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];
        sort		text;
        direction	text;
        query		text;
        where_clause    text := '';
    BEGIN
        channel_ids  := json_array_convert( arg_channel_ids_json  )::bigint[];
        category_ids := json_array_convert( arg_category_ids_json )::bigint[];
        pays_on_ids  := json_array_convert( arg_pays_on_ids_json  )::bigint[];
        geos_ids     := json_array_convert( arg_geos_ids_json  )::text[];
	sort      := COALESCE( arg_sort_order, 'campaign_id DESC' );
	direction := '';
	direction := CASE direction = '' AND sort ~* '\s+ASC$'  WHEN TRUE THEN 'ASC'  ELSE direction END;
	direction := CASE direction = '' AND sort ~* '\s+DESC$' WHEN TRUE THEN 'DESC' ELSE direction END;
	sort      := regexp_replace( sort, '\s+(' || direction || ')$', '', 'i' );

        IF (arg_currency_id IS NOT NULL) THEN
            where_clause := ' AND cmp.currency_id = ' || arg_currency_id;
        END IF;

	query := 'SELECT
			cmp."name"						AS campaign_name,
			cmp.id							AS campaign_id,
			COALESCE( po.override_payout, cmp.default_payout )	AS payout,
			pays_on_friendly_name( cmp.payout_model_id )		AS pays_on,
			geos_json( cmp.id )::text				AS geos_json,
			categories_json( cmp.id )				AS categories,
			channels_json( cmp.id )					AS channels,
			categories_ids_json( cmp.id )				AS categories_ids,
			channels_ids_json( cmp.id )				AS channel_ids,
			return_geo_ids_json( cmp.id )				AS country_ids,
			to_char( cmp.expiry_date, ''Month DD, YYYY'' )		AS expires,
			cmp.description						AS campaign_description,
			CASE cmp.access_type
				WHEN 1 THEN ''public''
				WHEN 2 THEN ''approved''
				WHEN 3 THEN
					CASE WHEN cap.status IS NULL THEN ''request''
					ELSE cap.status::text
					END
			END							AS approval_status,
			CASE
				WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE
				ELSE FALSE
			END							AS is_new
		FROM
			campaigns cmp
		LEFT JOIN
			publisher_overrides po
			ON po.publisher_id = $1
			AND po.campaign_id = cmp.id
			AND ( po.effective_date  < NOW() OR po.effective_date  IS NULL )
			AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL )
		LEFT JOIN
			campaign_assigned_publishers cap
			ON cap.campaign_id   = cmp.id
			AND cap.publisher_id = $1
		WHERE
			cmp.new_until::timestamptz > NOW() + ''1 day''::interval AND
			(
				cap.status IS NULL OR
				( cmp.access_type <> 2 OR ( cmp.access_type = 2 AND cap.status = ''approved'' ) ) AND
				cap.status <> ''blocked'' AND
				cap.status <> ''denied''
			) AND
			( $2 = ''{}'' OR check_channels( cmp.id,   $2 ) > 0 ) AND
			( $3 = ''{}'' OR check_categories( cmp.id, $3 ) > 0 ) AND
			( $4 = ''{}'' OR check_geos( cmp.id,       $4 ) > 0 ) AND
			( $5 = ''{}'' OR check_pays_on( cmp.id,    $5 ) > 0 )
                        ' || where_clause || '
		ORDER BY ' || quote_ident( sort ) || ' ' || direction || '
		LIMIT $6
		OFFSET $7';
	FOR r IN EXECUTE query USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_limit, arg_offset, arg_currency_id LOOP
            RETURN NEXT r;
        END LOOP;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_new_campaigns(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint, arg_sort_order text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: get_pubs_recommended_campaigns(bigint, json, json, json, json, bigint, bigint, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_recommended_campaigns(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint, arg_sort_order text DEFAULT NULL::text) RETURNS SETOF public.pub_campaign_list
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        r		pub_campaign_list;
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];
        sort		text;
        direction	text;
        query		text;

    BEGIN
        channel_ids  := json_array_convert( arg_channel_ids_json  )::bigint[];
        category_ids := json_array_convert( arg_category_ids_json )::bigint[];
        pays_on_ids  := json_array_convert( arg_pays_on_ids_json  )::bigint[];
        geos_ids     := json_array_convert( arg_geos_ids_json  )::text[];
	sort      := COALESCE( arg_sort_order, 'campaign_id DESC' );
	direction := '';
	direction := CASE direction = '' AND sort ~* '\s+ASC$'  WHEN TRUE THEN 'ASC'  ELSE direction END;
	direction := CASE direction = '' AND sort ~* '\s+DESC$' WHEN TRUE THEN 'DESC' ELSE direction END;
	sort      := regexp_replace( sort, '\s+(' || direction || ')$', '', 'i' );

	query := 'SELECT
			cmp."name"						AS campaign_name,
			cmp.id							AS campaign_id,
			COALESCE( po.override_payout, cmp.default_payout )	AS payout,
			pays_on_friendly_name( cmp.payout_model_id )		AS pays_on,
			geos_json( cmp.id )::text				AS geos_json,
			categories_json( cmp.id )				AS categories,
			channels_json( cmp.id )					AS channels,
			categories_ids_json( cmp.id )				AS categories_ids,
			channels_ids_json( cmp.id )				AS channel_ids,
			return_geo_ids_json( cmp.id )				AS country_ids,
			to_char( cmp.expiry_date, ''Month DD, YYYY'' )		AS expires,
			cmp.description						AS campaign_description,
			CASE cmp.access_type
				WHEN 1 THEN ''public''
				WHEN 2 THEN ''approved''
				WHEN 3 THEN
					CASE WHEN cap.status IS NULL THEN ''request''
					ELSE cap.status::text
					END
			END							AS approval_status,
			CASE
				WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE
				ELSE FALSE
			END							AS is_new
		FROM
			publisher_campaign_recommendations pcr
		RIGHT JOIN
			campaigns cmp
			ON pcr.campaign_id = cmp.id
		LEFT JOIN
			publisher_overrides po
			ON po.publisher_id = $1
			AND po.campaign_id = cmp.id
			AND ( po.effective_date  < NOW() OR po.effective_date  IS NULL )
			AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL )
		LEFT JOIN
			campaign_assigned_publishers cap
			ON cap.campaign_id   = cmp.id
			AND cap.publisher_id = $1
		WHERE
			pcr.publisher_id = $1 AND
			(
				cap.status IS NULL OR
				( cmp.access_type <> 2 OR ( cmp.access_type = 2 AND cap.status = ''approved'' ) ) AND
				cap.status <> ''blocked'' AND
				cap.status <> ''denied''
			) AND
			( $2 = ''{}'' OR check_channels( cmp.id,   $2 ) > 0 ) AND
			( $3 = ''{}'' OR check_categories( cmp.id, $3 ) > 0 ) AND
			( $4 = ''{}'' OR check_geos( cmp.id,       $4 ) > 0 ) AND
			( $5 = ''{}'' OR check_pays_on( cmp.id,    $5 ) > 0 )
		ORDER BY ' || quote_ident( sort ) || ' ' || direction || '
		LIMIT $6
		OFFSET $7';

	FOR r IN EXECUTE query USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_limit, arg_offset LOOP
            RETURN NEXT r;
        END LOOP;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_recommended_campaigns(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_offset bigint, arg_limit bigint, arg_sort_order text) OWNER TO w4;

--
-- Name: get_pubs_report_browser(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_browser(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pub_reports_browser_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val RECORD;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
        order_clause text := '';

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'browser');

        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
            sqry:=$sql$ SELECT b.browser_name AS browser, SUM(rd.total_clicks) AS total_clicks, SUM(rd.unique_clicks) AS unique_clicks, SUM(rd.total_conversions) AS total_conversions, SUM(rd.payout) AS payout, rd.campaign_id FROM vw_pub_campaign_report_details_browser rd LEFT JOIN user_agent_browser_lookup b ON (b.id = rd.browser::bigint) WHERE rd.publisher_id=$sql$ || arg_publisher_id || $sql$ AND rd.doy >=$sql$ || start_doy || $sql$ AND rd.doy <=$sql$ || end_doy || $sql$ GROUP BY rd.campaign_id,b.browser_name $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
            sqry:=$sql$ SELECT b.browser_name AS browser, SUM(rd.total_clicks) AS total_clicks, SUM(rd.unique_clicks) AS unique_clicks, SUM(rd.total_conversions) AS total_conversions, SUM(rd.payout) AS payout, rd.campaign_id FROM vw_pub_campaign_report_details_browser rd LEFT JOIN user_agent_browser_lookup b ON (b.id = rd.browser::bigint) WHERE rd.publisher_id=$sql$ || arg_publisher_id || $sql$ AND rd.doy >=$sql$ || start_doy || $sql$ AND rd.doy <=$sql$ || end_doy || $sql$ AND rd.campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY rd.campaign_id,b.browser_name $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_browser(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_campaign_detail(bigint, bigint, text, interval, timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_campaign_detail(arg_publisher_id bigint, arg_campaign_id bigint, arg_sort_order text DEFAULT NULL::text, arg_frequency interval DEFAULT '1 day'::interval, arg_start_date timestamp with time zone DEFAULT now(), arg_end_date timestamp with time zone DEFAULT now(), arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pubs_campaign_details_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r VARCHAR[];
        ret_val pubs_campaign_details_list;
        freq_value DOUBLE PRECISION;
        freq_series VARCHAR[][];
    BEGIN

        freq_series:=generate_interval_series(arg_start_date::TIMESTAMPTZ,arg_end_date::TIMESTAMPTZ,arg_frequency::INTERVAL);

        freq_value:=extract(YEAR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rpt.total_clicks),0) AS total_clicks, COALESCE(SUM(rpt.unique_clicks),0) AS unique_clicks, COALESCE(SUM(rpt.total_conversions),0) AS conversions, COALESCE(SUM(rpt.total_pay_out)/NULLIF(COALESCE(SUM(rpt.total_conversions),0),0),0) AS average_payout, ROUND(COALESCE(COALESCE(SUM(rpt.total_conversions),0) / NULLIF(COALESCE(SUM(rpt.unique_clicks),0),0), 0)::numeric, 4) AS conversion_rate, COALESCE(COALESCE(SUM(rpt.total_pay_out),0)/NULLIF(COALESCE(SUM(rpt.unique_clicks),0),0), 0) AS epc, COALESCE(SUM(rpt.total_pay_out),0) AS earnings, array_to_json(r)::TEXT AS slice, MAX(cmp.payout_type) AS payout_type, MAX(cmp.payin_type) AS payin_type FROM reports_yearly rpt LEFT JOIN campaigns cmp ON (cmp.id = rpt.campaign_id) WHERE (rpt.y BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rpt.publisher_id=arg_publisher_id AND rpt.campaign_id=arg_campaign_id GROUP BY rpt.publisher_id, rpt.campaign_id ORDER BY COALESCE(arg_sort_order::TEXT,r::TEXT);
                IF FOUND THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.unique_clicks:=0;
                    ret_val.conversions:=0;
                    ret_val.average_payout:=0;
                    ret_val.conversion_rate:=0;
                    ret_val.epc:=0;
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r)::TEXT;
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(MONTH FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rpt.total_clicks),0) AS total_clicks, COALESCE(SUM(rpt.unique_clicks),0) AS unique_clicks, COALESCE(SUM(rpt.total_conversions),0) AS conversions, COALESCE(SUM(rpt.total_pay_out)/NULLIF(COALESCE(SUM(rpt.total_conversions),0),0),0) AS average_payout,ROUND(COALESCE(COALESCE(SUM(rpt.total_conversions),0) / NULLIF(COALESCE(SUM(rpt.unique_clicks),0),0), 0)::numeric, 4) AS conversion_rate, COALESCE(COALESCE(SUM(rpt.total_pay_out),0)/NULLIF(COALESCE(SUM(rpt.unique_clicks),0),0), 0) AS epc, COALESCE(SUM(rpt.total_pay_out),0) AS earnings, array_to_json(r)::TEXT AS slice, MAX(cmp.payout_type) AS payout_type, MAX(cmp.payin_type) AS payin_type FROM reports_monthly rpt LEFT JOIN campaigns cmp ON (cmp.id = rpt.campaign_id) WHERE (rpt.moy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rpt.publisher_id=arg_publisher_id AND rpt.campaign_id=arg_campaign_id GROUP BY rpt.publisher_id, rpt.campaign_id ORDER BY COALESCE(arg_sort_order::TEXT,r::TEXT);
                IF FOUND THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.unique_clicks:=0;
                    ret_val.conversions:=0;
                    ret_val.average_payout:=0;
                    ret_val.conversion_rate:=0;
                    ret_val.epc:=0;
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r)::TEXT;
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(DAY FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rpt.total_clicks),0) AS total_clicks, COALESCE(SUM(rpt.unique_clicks),0) AS unique_clicks, COALESCE(SUM(rpt.total_conversions),0) AS conversions, COALESCE( SUM(rpt.total_pay_out)/NULLIF(COALESCE(SUM(rpt.total_conversions),0),0),0) AS average_payout,ROUND(COALESCE(COALESCE(SUM(rpt.total_conversions),0) / NULLIF(COALESCE(SUM(rpt.unique_clicks),0),0), 0)::numeric, 4) AS conversion_rate, COALESCE(COALESCE(SUM(rpt.total_pay_out),0)/NULLIF(COALESCE(SUM(rpt.unique_clicks),0),0), 0) AS epc, COALESCE(SUM(rpt.total_pay_out),0) AS earnings, array_to_json(r)::TEXT AS slice, MAX(cmp.payout_type) AS payout_type, MAX(cmp.payin_type) AS payin_type FROM reports_daily rpt LEFT JOIN campaigns cmp ON (cmp.id = rpt.campaign_id) WHERE (rpt.doy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rpt.publisher_id=arg_publisher_id AND rpt.campaign_id=arg_campaign_id GROUP BY rpt.publisher_id, rpt.campaign_id ORDER BY COALESCE(arg_sort_order::TEXT,r::TEXT);
                IF FOUND THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.unique_clicks:=0;
                    ret_val.conversions:=0;
                    ret_val.average_payout:=0;
                    ret_val.conversion_rate:=0;
                    ret_val.epc:=0;
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r)::TEXT;
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        freq_value:=extract(HOUR FROM arg_frequency);
        IF freq_value > 0.0 THEN
            FOREACH r SLICE 1 IN ARRAY freq_series LOOP
                SELECT INTO ret_val COALESCE(SUM(rpt.total_clicks),0) AS total_clicks, COALESCE(SUM(rpt.unique_clicks),0) AS unique_clicks, COALESCE(SUM(rpt.total_conversions),0) AS conversions, COALESCE(SUM(rpt.total_pay_out)/NULLIF(COALESCE(SUM(rpt.total_conversions),0),0),0) AS average_payout,ROUND(COALESCE(COALESCE(SUM(rpt.total_conversions),0) / NULLIF(COALESCE(SUM(rpt.unique_clicks),0),0), 0)::numeric, 4) AS conversion_rate, COALESCE(COALESCE(SUM(rpt.total_pay_out),0)/NULLIF(COALESCE(SUM(rpt.unique_clicks),0),0), 0) AS epc, COALESCE(SUM(rpt.total_pay_out),0) AS earnings, array_to_json(r)::TEXT AS slice, MAX(cmp.payout_type) AS payout_type, MAX(cmp.payin_type) AS payin_type FROM reports_hourly rpt LEFT JOIN campaigns cmp ON (cmp.id = rpt.campaign_id) WHERE (rpt.hoy BETWEEN r[1]::BIGINT AND r[2]::BIGINT) AND rpt.publisher_id=arg_publisher_id AND rpt.campaign_id=arg_campaign_id GROUP BY rpt.publisher_id, rpt.campaign_id ORDER BY COALESCE(arg_sort_order::TEXT,r::TEXT);
                IF FOUND THEN
                    RETURN NEXT ret_val;
                ELSE
                    ret_val.total_clicks:=0;
                    ret_val.unique_clicks:=0;
                    ret_val.conversions:=0;
                    ret_val.average_payout:=0;
                    ret_val.conversion_rate:=0;
                    ret_val.epc:=0;
                    ret_val.earnings:=0;
                    ret_val.time_periods:=array_to_json(r)::TEXT;
                    RETURN NEXT ret_val;
                END IF;
            END LOOP;
            RETURN;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_pubs_report_campaign_detail(arg_publisher_id bigint, arg_campaign_id bigint, arg_sort_order text, arg_frequency interval, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_campaign_details(bigint, bigint, text, interval, timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_campaign_details(arg_publisher_id bigint, arg_campaign_id bigint, arg_sort_order text DEFAULT NULL::text, arg_frequency interval DEFAULT '1 day'::interval, arg_start_date timestamp with time zone DEFAULT now(), arg_end_date timestamp with time zone DEFAULT now(), arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pubs_campaign_details_list
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        vdf TEXT;
        sort TEXT;
        direction TEXT;
    BEGIN

	sort      := COALESCE( arg_sort_order, 'time_periods' );

	direction := '';
	direction := CASE direction = '' AND sort ~* '\s+ASC$'  WHEN TRUE THEN 'ASC'  ELSE direction END;
	direction := CASE direction = '' AND sort ~* '\s+DESC$' WHEN TRUE THEN 'DESC' ELSE direction END;
	
	sort      := regexp_replace( sort, '\s+(' || direction || ')$', '', 'i' );
	
        vdf := 'SELECT * FROM get_pubs_report_campaign_detail( $1, $2, COALESCE( $3, NULL ), $4, $5, $6 ) ORDER BY ' || quote_ident( sort ) || ' ' || direction || ' LIMIT $7 OFFSET $8;';
        
        RAISE INFO '[%]',vdf;
        RETURN QUERY EXECUTE vdf USING arg_publisher_id, arg_campaign_id, arg_sort_order, arg_frequency, arg_start_date, arg_end_date, arg_limit, arg_offset;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_campaign_details(arg_publisher_id bigint, arg_campaign_id bigint, arg_sort_order text, arg_frequency interval, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_campaigns_overview(bigint, timestamp with time zone, timestamp with time zone, text, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_campaigns_overview(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_sort_order text, arg_offset integer, arg_limit integer) RETURNS SETOF public.pub_campaign_reports_list_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        r pub_campaign_reports_list_return;
    BEGIN
        FOR r IN execute $sql$   SELECT MAX(campaign_name) AS campaign_name
                        , campaign_id
                        , SUM(total_clicks) AS total_clicks
                        , SUM(unique_clicks) AS unique_clicks
                        , SUM(conversions) AS conversions
                        , AVG(payout) AS average_payout
                        , COALESCE(SUM(conversions)/NULLIF(SUM(unique_clicks),0),0)*100 conversion_rate
                        , COALESCE(SUM(revenue)/NULLIF(SUM(unique_clicks),0),0) epc
                        , SUM(revenue) AS earnings
                        , MAX(expiration_date) AS expiration_date
                        , AVG(payout) AS average_payout
                        , MAX(pays_on) AS pays_on
                        , MAX(geos_json::TEXT) AS geos_json
                        , MAX(categories_json::TEXT) AS categories_json
                        , MAX(channels_json::TEXT) AS channels_json
                        , MAX(campaign_description) AS campaign_description
                        , is_new
                    FROM vw_pubs_campaign_report_list_items 
                    WHERE ( publisher_id = $sql$ || arg_publisher_id || $sql$ ) 
                            AND ( doy BETWEEN $sql$ || make_doy(arg_start_date) || $sql$ AND $sql$ || make_doy(arg_end_date) || $sql$ ) 
                    GROUP BY campaign_id, publisher_id, is_new
                    ORDER BY $sql$ || COALESCE(arg_sort_order,'1') || $sql$
                    LIMIT $sql$ || arg_limit || $sql$
                    OFFSET $sql$ || arg_offset LOOP
            RETURN NEXT r;
        END LOOP;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_campaigns_overview(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_sort_order text, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_click(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_click(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pub_reports_clicks_overview_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val record;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
        order_clause text := '';

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'campaign_id');

        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
	    sqry:=$sql$ SELECT SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(foreign_clicks) AS foreign_clicks, SUM(banned_clicks) AS banned_clicks, campaign_id FROM vw_pub_campaign_report_details_clicks_overview WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ GROUP BY campaign_id $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
	    sqry:=$sql$ SELECT SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(foreign_clicks) AS foreign_clicks, SUM(banned_clicks) AS banned_clicks, campaign_id FROM vw_pub_campaign_report_details_clicks_overview WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ AND campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY campaign_id $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_click(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_clicks_overview(bigint, bigint, timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_clicks_overview(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_offset_number integer DEFAULT 0, arg_limit_number integer DEFAULT 25) RETURNS SETOF public.pub_reports_clicks_overview_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val record;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
    BEGIN
        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
	    sqry:=$sql$ SELECT SUM(total_clicks), SUM(unique_clicks), SUM(foreign_clicks), SUM(banned_clicks), campaign_id FROM vw_pub_campaign_report_details_clicks_overview WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ GROUP BY campaign_id LIMIT $sql$ || arg_limit_number || $sql$ OFFSET $sql$ || arg_offset_number;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
	    sqry:=$sql$ SELECT SUM(total_clicks), SUM(unique_clicks), SUM(foreign_clicks), SUM(banned_clicks), campaign_id FROM vw_pub_campaign_report_details_clicks_overview WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ AND campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY campaign_id LIMIT $sql$ || arg_limit_number || $sql$ OFFSET $sql$ || arg_offset_number;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_clicks_overview(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset_number integer, arg_limit_number integer) OWNER TO w4;

--
-- Name: get_pubs_report_creative(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, integer, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_creative(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_creative_id bigint DEFAULT NULL::bigint, arg_order text DEFAULT NULL::text, arg_offset integer DEFAULT 0, arg_limit bigint DEFAULT NULL::bigint) RETURNS SETOF public.pub_reports_creative_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val RECORD;
        start_doy INTEGER := make_doy(arg_start_date);
        end_doy INTEGER := make_doy(arg_end_date);
        sqry TEXT;
        order_clause text;
        where_clause text := '';

   BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_creative_id::TEXT, 'creative_id = ' || arg_creative_id, where_clause);
        where_clause := where_clause_build(arg_start_date::TEXT, 'doy >= ' || start_doy || '', where_clause);
        where_clause := where_clause_build(arg_end_date::TEXT, 'doy <= ' || end_doy || '', where_clause);
        
        order_clause := order_clause_build(arg_order, 'creative_name DESC');
        sqry:=$sql$
            SELECT
                creative_id,
                creative_name,
                creative_description,
                creative_image_id,
                SUM(total_clicks) AS total_clicks,
                SUM(unique_clicks) AS unique_clicks,
                SUM(total_conversions) AS total_conversions,
                SUM(payout) AS payout,
                campaign_id, 
                campaign_name,
                (SUM(total_conversions) / NULLIF(SUM(total_clicks),0)) AS conversion_pct
            FROM vw_pub_campaign_report_details_creatives
            $sql$ || where_clause || $sql$
            GROUP BY campaign_id, campaign_name, creative_id, creative_name, creative_description, creative_image_id $sql$
            || order_clause || $sql$ LIMIT $sql$ || COALESCE(arg_limit::text, 'ALL') || $sql$ OFFSET $sql$ || arg_offset;
       FOR ret_val IN EXECUTE sqry LOOP
            RETURN NEXT ret_val;
        END LOOP;

        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_creative(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_creative_id bigint, arg_order text, arg_offset integer, arg_limit bigint) OWNER TO w4;

--
-- Name: get_pubs_report_daily(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_daily(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pub_reports_daily_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val RECORD;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
        order_clause text := '';

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'report_date DESC');

        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
            sqry:=$sql$ SELECT SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(total_conversions) AS total_conversions, SUM(payout) AS payout, COALESCE(SUM(total_conversions)/NULLIF(COALESCE(SUM(total_clicks),0),0),0) AS conversion_rate, COALESCE(SUM(payout)/NULLIF(COALESCE(SUM(total_clicks),0),0),0) AS epc, COALESCE(SUM(payout)/NULLIF(COALESCE(SUM(total_conversions),0),0),0) AS average_payout, campaign_id, to_date(doy::TEXT,'YYYYMMDD')::TIMESTAMPTZ AS report_date FROM vw_pub_campaign_report_details_daily WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ GROUP BY campaign_id,doy $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
            sqry:=$sql$ SELECT SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(total_conversions) AS total_conversions, SUM(payout) AS payout, COALESCE(SUM(total_conversions)/NULLIF(COALESCE(SUM(total_clicks),0),0),0) AS conversion_rate, COALESCE(SUM(payout)/NULLIF(COALESCE(SUM(total_clicks),0),0),0) AS epc, COALESCE(SUM(payout)/NULLIF(COALESCE(SUM(total_conversions),0),0),0) AS average_payout, campaign_id, to_date(doy::TEXT,'YYYYMMDD')::TIMESTAMPTZ AS report_date FROM vw_pub_campaign_report_details_daily WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ AND campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY campaign_id,payout,doy $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_daily(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_geo(bigint, bigint, timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_geo(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pub_reports_geo_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val RECORD;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
    BEGIN
        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
            sqry:=$sql$ SELECT geo_location, SUM(total_clicks), SUM(unique_clicks), SUM(total_conversions), SUM(payout), campaign_id FROM vw_pub_campaign_report_details_geos WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ GROUP BY campaign_id,geo_location LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
            sqry:=$sql$ SELECT geo_location, SUM(total_clicks), SUM(unique_clicks), SUM(total_conversions), SUM(payout), campaign_id FROM vw_pub_campaign_report_details_geos WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ AND campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY campaign_id,geo_location LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_geo(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_geo(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_geo(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pub_reports_geo_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val RECORD;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
        order_clause text := '';

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'campaign_id ASC');

        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
            sqry:=$sql$ SELECT geo_location, SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(total_conversions) AS total_conversions, SUM(payout) AS payout, campaign_id FROM vw_pub_campaign_report_details_geos WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ GROUP BY campaign_id,geo_location $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
            sqry:=$sql$ SELECT geo_location, SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(total_conversions) AS total_conversions, SUM(payout) AS payout, campaign_id FROM vw_pub_campaign_report_details_geos WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ AND campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY campaign_id,geo_location $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_geo(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_platform(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_platform(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pub_reports_platform_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val RECORD;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
        order_clause text := '';

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'campaign_id ASC');

        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
            sqry:=$sql$ SELECT p.platform_name AS platform, SUM(rd.total_clicks) AS total_clicks, SUM(rd.unique_clicks) AS unique_clicks, SUM(rd.total_conversions) AS total_conversions, SUM(rd.payout) AS payout, rd.campaign_id FROM vw_pub_campaign_report_details_platform rd LEFT JOIN user_agent_platform_lookup p ON (p.id = rd.platform::bigint) WHERE rd.publisher_id=$sql$ || arg_publisher_id || $sql$ AND rd.doy >=$sql$ || start_doy || $sql$ AND rd.doy <=$sql$ || end_doy || $sql$ GROUP BY rd.campaign_id,p.platform_name $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
            sqry:=$sql$ SELECT p.platform_name AS platform, SUM(rd.total_clicks) AS total_clicks, SUM(rd.unique_clicks) AS unique_clicks, SUM(rd.total_conversions) AS total_conversions, SUM(rd.payout) AS payout, rd.campaign_id FROM vw_pub_campaign_report_details_platform rd LEFT JOIN user_agent_platform_lookup p ON (p.id = rd.platform::bigint) WHERE rd.publisher_id=$sql$ || arg_publisher_id || $sql$ AND rd.doy >=$sql$ || start_doy || $sql$ AND rd.doy <=$sql$ || end_doy || $sql$ AND rd.campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY rd.campaign_id,p.platform_name $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_platform(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_referrer(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_referrer(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pub_reports_referrer_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val RECORD;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
        order_clause text := '';

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'campaign_id ASC');

        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
            sqry:=$sql$ SELECT referrer, SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(total_conversions) AS total_conversions, SUM(payout) AS payout, campaign_id FROM vw_pub_campaign_report_details_referrer WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ GROUP BY campaign_id,referrer $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
            sqry:=$sql$ SELECT referrer, SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(total_conversions) AS total_conversions, SUM(payout) AS payout, campaign_id FROM vw_pub_campaign_report_details_referrer WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ AND campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY campaign_id,referrer $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_referrer(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_pubs_report_subid(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, integer, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_pubs_report_subid(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT 0, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_offset integer DEFAULT 0, arg_limit integer DEFAULT 25) RETURNS SETOF public.pub_reports_subids_report_return
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        ret_val RECORD;
        start_doy INTEGER;
        end_doy INTEGER;
        sqry TEXT;
        order_clause text := '';

    BEGIN
        order_clause := order_clause_build(arg_orderby, 'campaign_id ASC');

        /* TODO: Make this suck less */
        IF arg_start_date IS NULL THEN
            arg_start_date:='1965-01-01 00:00:00'::TIMESTAMPTZ;
        END IF;
        IF arg_end_date IS NULL THEN
            arg_end_date:='9999-12-31 00:00:00'::TIMESTAMPTZ;
        END IF;
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        IF arg_campaign_id=0 THEN
	    sqry:=$sql$ SELECT sub_id_1,sub_id_2,sub_id_3,sub_id_4, SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(total_conversions) AS total_conversions, SUM(payout) AS payout, campaign_id FROM vw_pub_campaign_report_details_subid WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ GROUP BY campaign_id,sub_id_1,sub_id_2,sub_id_3,sub_id_4 $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        ELSE
            sqry:=$sql$ SELECT sub_id_1,sub_id_2,sub_id_3,sub_id_4, SUM(total_clicks) AS total_clicks, SUM(unique_clicks) AS unique_clicks, SUM(total_conversions) AS total_conversions, SUM(payout) AS payout, campaign_id FROM vw_pub_campaign_report_details_subid WHERE publisher_id=$sql$ || arg_publisher_id || $sql$ AND doy >=$sql$ || start_doy || $sql$ AND doy <=$sql$ || end_doy || $sql$ AND campaign_id=$sql$ || arg_campaign_id || $sql$ GROUP BY campaign_id,sub_id_1,sub_id_2,sub_id_3,sub_id_4 $sql$ || order_clause || $sql$ LIMIT $sql$ || arg_limit || $sql$ OFFSET $sql$ || arg_offset;
            FOR ret_val IN EXECUTE sqry LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$_$;


ALTER FUNCTION w4_application_functions.get_pubs_report_subid(arg_publisher_id bigint, arg_campaign_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_offset integer, arg_limit integer) OWNER TO w4;

--
-- Name: get_recommended_campaigns(bigint, timestamp with time zone, timestamp with time zone, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_recommended_campaigns(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset bigint DEFAULT 0, arg_limit bigint DEFAULT 25) RETURNS SETOF public.pubs_short_campaigns_list
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val pubs_short_campaigns_list;
    BEGIN
        FOR ret_val IN SELECT cmp."name" AS campaign_name, cmp.id AS campaign_id, COALESCE(po.override_payout, cmp.default_payout)AS publisher_payout, pays_on_friendly_name(cmp.payout_model_id) AS pays_on FROM publisher_campaign_recommendations pcr LEFT JOIN campaigns cmp ON pcr.campaign_id=cmp.id LEFT JOIN publisher_overrides po ON po.publisher_id=arg_publisher_id AND po.campaign_id=cmp.id AND (po.effective_date <= arg_start_date OR po.effective_date IS NULL) AND (po.expiration_date >= arg_end_date OR po.expiration_date IS NULL) WHERE pcr.publisher_id=arg_publisher_id ORDER BY pcr.created_at LIMIT arg_limit OFFSET arg_offset LOOP
            RETURN NEXT ret_val;
        END LOOP;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_recommended_campaigns(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset bigint, arg_limit bigint) OWNER TO w4;

--
-- Name: get_region_id(bigint, character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_region_id(arg_country_id bigint, arg_region character varying) RETURNS bigint
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BIGINT;
        country_code VARCHAR;
    BEGIN
        SELECT INTO country_code iso FROM geo_typeahead_countries WHERE id=arg_country_id;
        SELECT INTO ret_val id FROM geo_typeahead_region WHERE ascii_name=arg_region;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_region_id(arg_country_id bigint, arg_region character varying) OWNER TO w4;

--
-- Name: get_region_name(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_region_name(arg_region_id bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
        DECLARE
            ret_val text;
        BEGIN
            SELECT INTO ret_val ascii_name FROM geo_typeahead_region WHERE id=arg_region_id;
            RETURN ret_val;
        END;
    $$;


ALTER FUNCTION w4_application_functions.get_region_name(arg_region_id bigint) OWNER TO w4;

--
-- Name: get_sub_ids(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_sub_ids(arg_click_id bigint, OUT arg_sub_id_1 text, OUT arg_sub_id_2 text, OUT arg_sub_id_3 text, OUT arg_sub_id_4 text) RETURNS record
    LANGUAGE sql STABLE
    AS $$
        SELECT sub_id_1, sub_id_2, sub_id_3, sub_id_4 FROM engine_clicks WHERE id=arg_click_id;
$$;


ALTER FUNCTION w4_application_functions.get_sub_ids(arg_click_id bigint, OUT arg_sub_id_1 text, OUT arg_sub_id_2 text, OUT arg_sub_id_3 text, OUT arg_sub_id_4 text) OWNER TO w4;

--
-- Name: get_text_links_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_text_links_json(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
        rec RECORD;
        r VARCHAR;
        comma_char VARCHAR;
    BEGIN
	comma_char:='';
        ret_val:='{"text_links":[';
        FOR rec IN SELECT * FROM creatives c LEFT JOIN creative_emails ce ON c.id=ce.creative_id AND c."type"=2 WHERE c.campaign_id=arg_campaign_id LOOP
            r:=row_to_json(rec);
            ret_val:=ret_val || comma_char || r::VARCHAR;
            comma_char:=',';
        END LOOP;
        ret_val:=ret_val || ']}';
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_text_links_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: get_top_performing_campaigns(bigint, timestamp with time zone, timestamp with time zone, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_top_performing_campaigns(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset bigint, arg_limit bigint) RETURNS SETOF public.pubs_campaign_totals_list_wide
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val pubs_campaign_totals_list_wide;
        start_doy INTEGER;
        end_doy INTEGER;
    BEGIN
        start_doy:=make_doy(arg_start_date);
        end_doy:=make_doy(arg_end_date);
        FOR ret_val IN
            SELECT
                  MAX(cmp."name")::VARCHAR AS campaign_name
                , rd.campaign_id::BIGINT AS campaign_id
                , COALESCE(SUM(rd.total_clicks),0)::BIGINT AS total_clicks
                , COALESCE(SUM(rd.total_conversions),0)::BIGINT AS total_conversions
                , SUM(rd.total_pay_out)::NUMERIC AS total_earned_revenue
                , COALESCE(MAX(po.override_payout)::NUMERIC, MAX(cmp.default_payout)::NUMERIC)::NUMERIC AS payout
                , categories_json(cmp.id)::TEXT AS categories
                , channels_json(cmp.id)::TEXT AS channels
                , to_char(MAX(cmp.expiry_date)::TIMESTAMPTZ,'Month DD, YYYY')::TEXT AS expiration_date
                , MAX(cmp.description)::TEXT AS description
                , MAX(cmp.restrictions)::TEXT AS restrictions
                , pays_on_friendly_name(MAX(cmp.payout_model_id))::TEXT AS pays_on
                , CASE WHEN (cmp.new_until::TIMESTAMPTZ > (now() + INTERVAL '1 day')::TIMESTAMPTZ) THEN TRUE::BOOLEAN ELSE FALSE::BOOLEAN END AS is_new
            FROM reports_daily rd
            LEFT JOIN campaigns cmp
                ON rd.campaign_id=cmp.id
            LEFT JOIN publisher_overrides po
                ON po.publisher_id=arg_publisher_id
                AND po.campaign_id=cmp.id
		AND (po.effective_date < now() OR po.effective_date IS NULL)
		AND (po.expiration_date > now() OR po.expiration_date IS NULL)
            WHERE rd.publisher_id=arg_publisher_id AND (doy BETWEEN start_doy AND end_doy) GROUP BY rd.publisher_id,rd.campaign_id,cmp.id ORDER BY 5 DESC LIMIT arg_limit OFFSET arg_offset LOOP
            RETURN NEXT ret_val;
        END LOOP;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_top_performing_campaigns(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_offset bigint, arg_limit bigint) OWNER TO w4;

--
-- Name: get_unique_geos(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_unique_geos() RETURNS SETOF public.geo_search
    LANGUAGE sql STABLE
    AS $$
        SELECT MAX(id), country, region, city FROM campaign_geotargeting GROUP BY country, region, city;
$$;


ALTER FUNCTION w4_application_functions.get_unique_geos() OWNER TO w4;

--
-- Name: get_user_agent_identification(text, text, text, text, text, text, text, text, text, text, text, text, boolean, boolean, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_user_agent_identification(parent text, platform text, browser text, version text, device_name text, device_maker text, renderingengine_name text, renderingengine_version text, comment text, renderingengine_description text, platformversion text, platform_description text, ismobiledevice boolean, iscrawler boolean, ua_string text) RETURNS public.user_agent_ids
    LANGUAGE plpgsql
    AS $$
    DECLARE
        browser_desc TEXT;
        platform_desc TEXT;
        browser_spl TEXT;
        platform_spl TEXT;
        mobile TEXT;
        crawler TEXT;
        bmobile TEXT;
        bcrawler TEXT;
        browser_id BIGINT;
        platform_id BIGINT;
        feature_ids BIGINT ARRAY;
        return_ids user_agent_ids;
    BEGIN
        mobile:=CASE ismobiledevice WHEN TRUE THEN 'mobile' END;
        crawler:=CASE iscrawler WHEN TRUE THEN 'crawler' END;
        bmobile:=CASE ismobiledevice WHEN TRUE THEN 'YES' ELSE 'NO' END;
        bcrawler:=CASE iscrawler WHEN TRUE THEN 'YES' ELSE 'NO' END;
        platform_spl:='mobile:' || bmobile || ',crawler:' || bcrawler;
        SELECT INTO platform_id id FROM user_agent_platform_lookup WHERE COALESCE(platform_name,'')=COALESCE(platform,'') AND COALESCE(platform_version,'')=COALESCE(platformversion,'') AND COALESCE(platform_special,'')=COALESCE(platform_spl,'');
        IF NOT FOUND THEN
            platform_desc:=replace(platform || ' ' || platformversion  || ' ' || mobile || ' ' || platform_description || ' ' || device_name || ' ' || device_maker,'  ',' ');
            INSERT INTO user_agent_platform_lookup
                (platform_name, platform_version, platform_description, platform_special)
                VALUES (platform,platformversion,platform_desc,platform_spl)
                RETURNING id INTO platform_id; 
        END IF;
        browser_spl:='mobile:' || bmobile || ',crawler:' || bcrawler;
        SELECT INTO browser_id id FROM user_agent_browser_lookup WHERE COALESCE(browser_name,'')=COALESCE(browser,'') AND COALESCE(browser_version,'')=COALESCE(version,'') AND COALESCE(browser_special,'')=COALESCE(browser_spl,'');
        IF NOT FOUND THEN
            browser_desc:=replace(browser || ' '  || version || ' ' || mobile || ' ' || crawler || ' ' || parent || ' ' || renderingengine_name || ' ' || renderingengine_version || ' ' || renderingengine_description || ' ' || comment,'  ',' ');
            INSERT INTO user_agent_browser_lookup
                (browser_name, browser_version, browser_description, browser_special)
                VALUES (browser,version,browser_desc,browser_spl)
                RETURNING id INTO browser_id;
        END IF;
        return_ids.platform_id:=platform_id;
        return_ids.browser_id:=browser_id;
        return_ids.features:=feature_ids;
        RETURN return_ids;
    END
$$;


ALTER FUNCTION w4_application_functions.get_user_agent_identification(parent text, platform text, browser text, version text, device_name text, device_maker text, renderingengine_name text, renderingengine_version text, comment text, renderingengine_description text, platformversion text, platform_description text, ismobiledevice boolean, iscrawler boolean, ua_string text) OWNER TO w4;

--
-- Name: get_user_by_id(integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_user_by_id(arg_id integer) RETURNS public.user_return
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val user_return;
    BEGIN
        SELECT 
              usr.id
            , COALESCE(cts.email_address,usr.email)
            , usr.password
            , usr.parent_id
            , usr.manager_id
            , usr.active
            , usr.access
            , usr.ip_address
            , usr.last_login
            , usr.login_name
            , usr.primary_contact_id
            , usr.billing_contact_id
            , usr.account_contact_id
            , COALESCE(cts.first_name,usp.first_name)
                    , COALESCE(cts.last_name,usp.last_name)
                    , usp.image_id
                    , COALESCE(cts.messenger_name,usp.messenger_id) AS messenger_id
                    , CASE WHEN (cts.messenger_type > 0) 
                    THEN (SELECT description FROM im_types WHERE cts.messenger_type = im_types.id) 
                    ELSE (SELECT description FROM im_types WHERE usp.messenger_type = im_types.id)
            END AS description
                    , usp.preferred_language
                    , CASE WHEN cts.country_id > 0 THEN (SELECT country FROM geo_typeahead_countries WHERE id=cts.country_id) ELSE usp.country END
                    , COALESCE(cts.primary_phone,usp.phone)
                    , mup.first_name AS manager_first_name
                    , mup.last_name AS manager_last_name
        INTO ret_val
        FROM users usr 
        LEFT JOIN user_profiles usp 
                    ON usr.id=usp.user_id 
                LEFT JOIN users mgr
                    ON mgr.id=usr.manager_id
                LEFT JOIN user_profiles mup
                    ON mgr.id=mup.user_id
                LEFT JOIN contacts cts
                    ON usr.primary_contact_id=cts.id
        WHERE usr.id=arg_id;
        IF NOT FOUND THEN
            PERFORM * FROM users WHERE users.id=arg_id;
            IF NOT FOUND THEN
                RAISE EXCEPTION 'The user id [%] does not exist for any user, administrator, or publisher.',arg_id;
            END IF;
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_user_by_id(arg_id integer) OWNER TO w4;

--
-- Name: get_user_groups(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION get_user_groups(arg_id bigint) RETURNS SETOF integer
    LANGUAGE plpgsql STABLE
    AS $$
    BEGIN
        RETURN QUERY SELECT group_id FROM "ACL"."acl_user_groups" WHERE user_id=arg_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.get_user_groups(arg_id bigint) OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: advertisers; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE advertisers (
    id bigint NOT NULL,
    manager_id integer,
    name character varying(128) NOT NULL,
    credit_limit double precision,
    credit_limit_per character varying,
    payment_terms_id integer,
    allow_over_limit character varying NOT NULL,
    send_alert_if_credit_is_used character varying,
    credit_alert_type character varying,
    credit_alert_value numeric(18,2) DEFAULT NULL::numeric,
    next_payment_due_date character varying(36),
    status character varying NOT NULL,
    created timestamp with time zone DEFAULT now() NOT NULL,
    modified timestamp with time zone DEFAULT now() NOT NULL,
    contact_name character varying(128),
    phone character varying(128),
    mobile character varying(128) DEFAULT NULL::character varying,
    email character varying(128),
    address_1 text,
    address_2 text,
    city character varying(128),
    state character varying(128),
    zip character varying(128),
    country character varying(128),
    messenger_id character varying(255) DEFAULT NULL::character varying,
    fax character varying(255) DEFAULT NULL::character varying,
    url character varying(255) DEFAULT NULL::character varying,
    description text,
    send_alert_if_credit_percent_to character varying(1024) DEFAULT NULL::character varying,
    ftp_password character varying(128),
    note_login_url character varying(255) DEFAULT NULL::character varying,
    note_login_username character varying(255) DEFAULT NULL::character varying,
    note_login_password character varying(255) DEFAULT NULL::character varying,
    billing_company character varying(250) DEFAULT NULL::character varying,
    billing_first_name character varying(250) DEFAULT NULL::character varying,
    billing_last_name character varying(250) DEFAULT NULL::character varying,
    billing_address_1 character varying(250) DEFAULT NULL::character varying,
    billing_address_2 character varying(250) DEFAULT NULL::character varying,
    billing_city character varying(250) DEFAULT NULL::character varying,
    billing_region_id integer,
    billing_country_id integer,
    primary_contact_id bigint,
    billing_contact_id bigint,
    account_contact_id bigint,
    CONSTRAINT advertisers_allow_to_go_over_credit_limit_check CHECK (((allow_over_limit)::text = ANY (ARRAY[('yes'::character varying)::text, ('no'::character varying)::text]))),
    CONSTRAINT advertisers_credit_alert_type_check CHECK (((credit_alert_type)::text = ANY (ARRAY[('fixed'::character varying)::text, ('percent'::character varying)::text]))),
    CONSTRAINT advertisers_credit_limit_per_check CHECK (((credit_limit_per)::text = ANY (ARRAY[('day'::character varying)::text, ('week'::character varying)::text, ('month'::character varying)::text, ('year'::character varying)::text]))),
    CONSTRAINT advertisers_manager_id_check CHECK ((manager_id >= 0)),
    CONSTRAINT advertisers_payment_terms_id_check CHECK ((payment_terms_id >= 0)),
    CONSTRAINT advertisers_send_alert_if_credit_is_used_check CHECK (((send_alert_if_credit_is_used)::text = ANY (ARRAY[('yes'::character varying)::text, ('no'::character varying)::text]))),
    CONSTRAINT advertisers_status_check CHECK (((status)::text = ANY (ARRAY[('active'::character varying)::text, ('pending'::character varying)::text, ('inactive'::character varying)::text, ('collections'::character varying)::text])))
);


ALTER TABLE public.advertisers OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: getadvertiser(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION getadvertiser(arg_id bigint) RETURNS public.advertisers
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_adv advertisers;
    BEGIN
        SELECT INTO ret_adv * FROM advertisers WHERE id=arg_id;
        IF NOT FOUND THEN
            RAISE WARNING 'The advertiser with id [%] was not found.',arg_id;
        END IF;
        RETURN ret_adv;
    END;
$$;


ALTER FUNCTION w4_application_functions.getadvertiser(arg_id bigint) OWNER TO w4;

--
-- Name: getcampaigncategory(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION getcampaigncategory(cid bigint) RETURNS public.categories
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_rec categories;
    BEGIN
        SELECT INTO ret_rec * FROM categories WHERE id=cid;
        RETURN ret_rec;
    END;
$$;


ALTER FUNCTION w4_application_functions.getcampaigncategory(cid bigint) OWNER TO w4;

--
-- Name: getorphanedcontacts(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION getorphanedcontacts() RETURNS SETOF public.contacts
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        r contacts;
    BEGIN
        FOR r IN EXECUTE 'SELECT * FROM contacts WHERE id NOT IN (SELECT DISTINCT(contact_id) FROM publisher_contacts UNION SELECT DISTINCT(contact_id) FROM advertiser_contacts);' LOOP
            RETURN NEXT r;        
        END LOOP; 
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.getorphanedcontacts() OWNER TO w4;

--
-- Name: insert_new_conversion(public.engine_conversions); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION insert_new_conversion(new_cnv public.engine_conversions) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        adv_ldgr  acct_advertiser_ledger;
        int_ldgr  acct_internal_ledger;
        pub_ldgr  acct_publisher_ledger;
        ppub_ldgr acct_publisher_ledger;
        cnv_ldgr  acct_conversion_ledger;
        acpa numeric; pcpa numeric; ppcpa numeric; icpa numeric; parentpayout numeric; acl_id BIGINT; new_cnv_advertiser_id BIGINT;
        exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
    BEGIN
        SELECT INTO new_cnv_advertiser_id advertiser_id FROM campaigns WHERE id=new_cnv.campaign_id;
        -- Move it into the Conversion Ledger
        INSERT INTO acct_conversion_ledger VALUES (nextval('acct_conversion_ledger_id_seq'),0,new_cnv.id::BIGINT,70,new_cnv_advertiser_id,new_cnv.campaign_id,
                COALESCE(new_cnv.publisher_id,0),COALESCE(new_cnv.parent_publisher_id,0),
                COALESCE(translate(textin(cash_out(new_cnv.payin)), '$,', '')::numeric,0::numeric)::numeric,COALESCE(translate(textin(cash_out(new_cnv.payout)), '$,', '')::numeric,0::numeric)::numeric,
                COALESCE((SELECT created_date FROM engine_clicks WHERE id=new_cnv.click_id),transaction_timestamp()),
                COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp()),
                make_hoy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_doy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_woy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_moy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_qoy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_y(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_hoy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_doy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_woy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_moy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_qoy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_y(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_hoy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_doy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_woy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_moy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_qoy(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                make_y(COALESCE(new_cnv.created_date::TIMESTAMPTZ,transaction_timestamp())),
                COALESCE(translate(textin(cash_out(new_cnv.payin-new_cnv.payout)), '$,', '')::numeric,0),COALESCE(translate(textin(cash_out(new_cnv.payin)), '$,', '')::numeric / NULLIF(translate(textin(cash_out(new_cnv.payout)), '$,', '')::numeric , 0.00) , 0),
                new_cnv.status,100,100,CASE WHEN new_cnv.parent_payout::NUMERIC <> 0 THEN 100 ELSE 0 END,100);
        SELECT INTO cnv_ldgr * FROM acct_conversion_ledger WHERE id=LASTVAL();
        -- Calculate the required CPA info for adjusting ledgers
        acpa:=COALESCE(translate(textin(cash_out(new_cnv.payin)), '$,', '')::numeric,0::numeric)::numeric; 
        pcpa:=COALESCE(COALESCE(translate(textin(cash_out(new_cnv.parent_payout)), '$,', '')::numeric,0::numeric)::numeric-COALESCE(translate(textin(cash_out(new_cnv.payout)), '$,', '')::numeric,0::numeric)::numeric,COALESCE(translate(textin(cash_out(new_cnv.payout)), '$,', '')::numeric,0::numeric)::numeric);
        ppcpa:=CASE WHEN COALESCE(translate(textin(cash_out(new_cnv.parent_payout)), '$,', '')::numeric,0::numeric)::numeric > 0::numeric THEN COALESCE(translate(textin(cash_out(new_cnv.parent_payout)), '$,', '')::numeric,0::numeric)::numeric ELSE 0::numeric END; 
        icpa:=COALESCE(translate(textin(cash_out(new_cnv.payin)), '$,', '')::numeric,0::numeric)::numeric-COALESCE(translate(textin(cash_out(new_cnv.payout)), '$,', '')::numeric,0::numeric)::numeric;
        -- Advertiser Ledger DEBIT to Internal Ledger CREDIT/DEBIT
        int_ldgr:=get_new_acct_internal_ledger (cnv_ldgr.conversion_id::BIGINT,cnv_ldgr.transaction_type,cnv_ldgr.advertiser_id,
                cnv_ldgr.campaign_id,cnv_ldgr.publisher_id,cnv_ldgr.publisher_pid,cnv_ldgr.conversion_date_time::TIMESTAMPTZ,
                cnv_ldgr.click_date_time::TIMESTAMPTZ,acpa,pcpa+COALESCE(ppcpa,0::numeric),0,cnv_ldgr.status);
        PERFORM get_new_acct_advertiser_ledger (cnv_ldgr.conversion_id::BIGINT,cnv_ldgr.transaction_type,cnv_ldgr.advertiser_id,
                cnv_ldgr.campaign_id,cnv_ldgr.publisher_id,cnv_ldgr.publisher_pid,cnv_ldgr.conversion_date_time,
                cnv_ldgr.click_date_time,0::numeric,acpa,int_ldgr.id,cnv_ldgr.status);
        -- Set internal ledger info for the accounting conversion record
        cnv_ldgr.internal_ledger_id:=int_ldgr.id;
        -- Save the accounting conversion record
        PERFORM set_acct_conversion_ledger(cnv_ldgr);
         -- Check for Parent Publisher ID
        IF new_cnv.parent_publisher_id = 0 OR new_cnv.parent_publisher_id IS NULL THEN
            -- Publisher CREDIT
            PERFORM get_new_acct_publisher_ledger (cnv_ldgr.conversion_id::BIGINT,cnv_ldgr.transaction_type,cnv_ldgr.advertiser_id,
                    cnv_ldgr.campaign_id,cnv_ldgr.publisher_id,cnv_ldgr.publisher_pid,cnv_ldgr.conversion_date_time,
                    cnv_ldgr.click_date_time,cnv_ldgr.pay_out_amt,0::numeric,int_ldgr.id,cnv_ldgr.status); 
        ELSE
            SELECT INTO parentpayout override_payout FROM publisher_overrides WHERE publisher_id=cnv_ldgr.publisher_id AND campaign_id=cnv_ldgr.campaign_id AND cnv_ldgr.conversion_date_time >= effective_date AND cnv_ldgr.conversion_date_time <= expiration_date;
            -- Parent Publisher CREDIT
            PERFORM get_new_acct_publisher_ledger (cnv_ldgr.conversion_id::BIGINT,cnv_ldgr.transaction_type,cnv_ldgr.advertiser_id,
                    cnv_ldgr.campaign_id,cnv_ldgr.publisher_id,NULL,cnv_ldgr.conversion_date_time,
                    cnv_ldgr.click_date_time,ppcpa,0::numeric,int_ldgr.id,cnv_ldgr.status); 
            -- Publisher CREDIT
            PERFORM get_new_acct_publisher_ledger (cnv_ldgr.conversion_id::BIGINT,cnv_ldgr.transaction_type,cnv_ldgr.advertiser_id,
                    cnv_ldgr.campaign_id,cnv_ldgr.publisher_id,cnv_ldgr.publisher_pid,cnv_ldgr.conversion_date_time,
                    cnv_ldgr.click_date_time,pcpa,0::numeric,int_ldgr.id,cnv_ldgr.status);
        END IF;
        -- Add it's values to the rollups
        PERFORM add_conversion_to_rollups(cnv_ldgr.advertiser_id,cnv_ldgr.campaign_id,cnv_ldgr.publisher_id,cnv_ldgr.publisher_pid,acpa,pcpa,ppcpa,icpa,cnv_ldgr.conversion_date_time);
        RETURN TRUE;
        /*
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('insert procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
        */
     END;
$_$;


ALTER FUNCTION w4_application_functions.insert_new_conversion(new_cnv public.engine_conversions) OWNER TO w4;

--
-- Name: invoice_conversions(text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION invoice_conversions(conversion_ids text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        arow INTEGER;
    BEGIN
        UPDATE engine_conversions SET status=32 WHERE id IN (conversion_ids);
        GET DIAGNOSTICS arow = ROW_COUNT; 
        RETURN arow;
    END
$$;


ALTER FUNCTION w4_application_functions.invoice_conversions(conversion_ids text) OWNER TO w4;

--
-- Name: log_potential_data_anomaly(text, text, text, text, text, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION log_potential_data_anomaly(ctype text, cname text, carguments text, cprocess text, cindication text, econfidence text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        INSERT INTO public.data_anomaly_log ("calltype","callname","callarguments","process","indication","errorconfidence","created_timestamp") VALUES (ctype, cname, carguments, cprocess, cindication, econfidence, transaction_timestamp());
        RAISE NOTICE 'Possible Data Anomaly seen in method [%]', cname;
        RAISE NOTICE 'Info provided [%]',ROW(ctype, cname, carguments, cprocess, cindication, econfidence);
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4_application_functions.log_potential_data_anomaly(ctype text, cname text, carguments text, cprocess text, cindication text, econfidence text) OWNER TO w4;

--
-- Name: make_doy(anynonarray); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION make_doy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		doy INTEGER;
	BEGIN
		SELECT INTO doy CAST(to_char(dt::TIMESTAMP,'YYYYmmdd'::TEXT) as INTEGER);
		RETURN doy;
	END
$$;


ALTER FUNCTION w4_application_functions.make_doy(dt anynonarray) OWNER TO w4;

--
-- Name: make_hoy(anynonarray); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION make_hoy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		hoy INTEGER;
	BEGIN
		SELECT INTO hoy CAST(to_char(dt::TIMESTAMP,'YYYYmmddHH24'::TEXT) as INTEGER);
		RETURN hoy;
	END
$$;


ALTER FUNCTION w4_application_functions.make_hoy(dt anynonarray) OWNER TO w4;

--
-- Name: make_moy(anynonarray); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION make_moy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		moy INTEGER;
	BEGIN
		SELECT INTO moy CAST(to_char(dt::TIMESTAMP,'YYYYmm'::TEXT) as INTEGER);
		RETURN moy;
	END
$$;


ALTER FUNCTION w4_application_functions.make_moy(dt anynonarray) OWNER TO w4;

--
-- Name: make_qoy(anynonarray); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION make_qoy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		qoy INTEGER;
	BEGIN
		SELECT INTO qoy CAST(to_char(dt::TIMESTAMP,'YYYYQ'::TEXT) as INTEGER);
		RETURN qoy;
	END
$$;


ALTER FUNCTION w4_application_functions.make_qoy(dt anynonarray) OWNER TO w4;

--
-- Name: make_woy(anynonarray); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION make_woy(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		woy INTEGER;
	BEGIN
		SELECT INTO woy CAST(to_char(dt::TIMESTAMP,'YYYYWW'::TEXT) as INTEGER);
		RETURN woy;
	END
$$;


ALTER FUNCTION w4_application_functions.make_woy(dt anynonarray) OWNER TO w4;

--
-- Name: make_y(anynonarray); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION make_y(dt anynonarray DEFAULT now()) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
		y INTEGER;
	BEGIN
		SELECT INTO y CAST(to_char(dt::TIMESTAMP,'YYYY'::TEXT) as INTEGER);
		RETURN y;
	END
$$;


ALTER FUNCTION w4_application_functions.make_y(dt anynonarray) OWNER TO w4;

--
-- Name: pay_conversions(text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION pay_conversions(conversion_ids text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        arow INTEGER;
    BEGIN
        UPDATE engine_conversions SET status=40 WHERE id IN (conversion_ids);
        GET DIAGNOSTICS arow = ROW_COUNT; 
        RETURN arow;
    END
$$;


ALTER FUNCTION w4_application_functions.pay_conversions(conversion_ids text) OWNER TO w4;

--
-- Name: pays_on_friendly_name(integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION pays_on_friendly_name(arg_payon_id integer) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
    BEGIN
        SELECT INTO ret_val alias::VARCHAR FROM campaign_conversion_aliases WHERE id=arg_payon_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.pays_on_friendly_name(arg_payon_id integer) OWNER TO w4;

--
-- Name: pretty_dates(timestamp with time zone); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION pretty_dates(arg_timestamp timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val VARCHAR;
    BEGIN
        ret_val:=arg_timestamp::VARCHAR;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.pretty_dates(arg_timestamp timestamp with time zone) OWNER TO w4;

--
-- Name: publisher_group_members_update(json); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION publisher_group_members_update(arg_member_changes json) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        row RECORD;
        publisher_ids bigint[];
        ret_val json;
    BEGIN
        FOR row IN SELECT pub_id, grp_id, member FROM json_populate_recordset(null::pub_group_members, arg_member_changes->'changes') LOOP
            publisher_ids := array_append(publisher_ids, row.pub_id);
            DELETE FROM publisher_groups_assoc WHERE publisher_id = row.pub_id;
            IF row.member THEN
                INSERT INTO publisher_groups_assoc (publisher_id, group_id) VALUES (row.pub_id, row.grp_id);
            ELSE
                DELETE FROM publisher_groups_assoc WHERE publisher_id = row.pub_id; 
            END IF;
        END LOOP;
        IF array_length(publisher_ids, 1) > 0 THEN
            ret_val := publisher_group_members_update_get_list(publisher_ids);
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.publisher_group_members_update(arg_member_changes json) OWNER TO w4;

--
-- Name: publisher_summary(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION publisher_summary(arg_publisher_id bigint) RETURNS public.pub_sum_return
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val pub_sum_return;
        dbtbal NUMERIC;
    BEGIN
        SELECT INTO dbtbal SUM(total_period_adjustment) FROM "Accounting".acct_publisher_rollup_hour aprh WHERE aprh.status IN (0,10);
        SELECT
              pusr.manager_id
            , mup.first_name || ' ' || mup.last_name AS manager_name
            , pusr.status
            , pup.payment_threshold
            , x.total AS debit_balance
            , pup.payment_schedule
            , pup.payment_to
            , pup.tax_id
            , pup.address_1
            , pup.address_2
            , pup.city
            , pup.region
            , pup.postal_code
            , pup.country
            , pup.phone
            , pup.mobile
            , pup.fax
            , pusr.email
            , pup.website_url
            , pup.messenger_id
            , im.description
        INTO ret_val
        FROM users pusr
        LEFT JOIN user_profiles pup
            ON pusr.id=pup.user_id
        LEFT JOIN im_types im
            ON pup.messenger_type = im.id
        LEFT JOIN users musr
            ON pusr.manager_id=musr.id
        LEFT JOIN user_profiles mup
            ON musr.id=mup.user_id
        LEFT JOIN
            ( SELECT pid, SUM(total_period_adjustment) AS total FROM acct_publisher_ledger apl WHERE apl.status BETWEEN -1 AND 19 GROUP BY pid) X
            ON X.pid=pusr.id
        WHERE pusr.id=arg_publisher_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.publisher_summary(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: read_publisher_robert_json_blob_delete_me(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION read_publisher_robert_json_blob_delete_me(arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE ret_val json;
    BEGIN
        SELECT into ret_val * FROM get_publisher_robert_json_blob_delete_me(arg_publisher_id);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.read_publisher_robert_json_blob_delete_me(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: reject_conversions(text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION reject_conversions(conversion_ids text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        arow INTEGER; ids BIGINT[]; tmpids TEXT[];
    BEGIN
        tmpids=string_to_array(replace(replace(replace(conversion_ids,'"',''),']',''),'[',''),',');
        FOR I IN array_lower(tmpids, 1)..array_upper(tmpids, 1) LOOP
            UPDATE engine_conversions SET status=60 WHERE id=CAST(tmpids[I] as BIGINT);
        END LOOP;
                GET DIAGNOSTICS arow = ROW_COUNT; 
        RETURN arow;
    END
$$;


ALTER FUNCTION w4_application_functions.reject_conversions(conversion_ids text) OWNER TO w4;

--
-- Name: remove_conversion_from_rollups(bigint, bigint, bigint, money, money, money, timestamp with time zone); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION remove_conversion_from_rollups(aid bigint, cid bigint, pid bigint, acpa money, pcpa money, icpa money, ts timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
    BEGIN
    END
$$;


ALTER FUNCTION w4_application_functions.remove_conversion_from_rollups(aid bigint, cid bigint, pid bigint, acpa money, pcpa money, icpa money, ts timestamp with time zone) OWNER TO w4;

--
-- Name: remove_conversion_from_rollups(bigint, bigint, bigint, bigint, money, money, money, money, timestamp with time zone, integer, integer, integer, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION remove_conversion_from_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa money, pcpa money, ppcpa money, icpa money, ts timestamp with time zone, astatus integer, pstatus integer, ppstatus integer, clickid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ahoy BIGINT; aru_hour "Accounting"."acct_advertiser_rollup_hour";
        adoy BIGINT; aru_day "Accounting"."acct_advertiser_rollup_day";
        amoy BIGINT; aru_month "Accounting"."acct_advertiser_rollup_month";
        ay BIGINT;   aru_year "Accounting"."acct_advertiser_rollup_year";
        ihoy BIGINT; iru_hour "Accounting"."acct_internal_rollup_hour";
        idoy BIGINT; iru_day "Accounting"."acct_internal_rollup_day";
        imoy BIGINT; iru_month "Accounting"."acct_internal_rollup_month";
        iy BIGINT;   iru_year "Accounting"."acct_internal_rollup_year";
        phoy BIGINT; pru_hour "Accounting"."acct_publisher_rollup_hour";
        pdoy BIGINT; pru_day "Accounting"."acct_publisher_rollup_day";
        pmoy BIGINT; pru_month "Accounting"."acct_publisher_rollup_month";
        py BIGINT;   pru_year "Accounting"."acct_publisher_rollup_year";
        trans "Accounting"."acct_transaction_ledger";
        exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
        doadv BOOLEAN; doint BOOLEAN; dopub BOOLEAN;
    BEGIN
        doadv=FALSE; doint=FALSE; dopub=FALSE;
        -- Get Rollup Time Boundaries
        ahoy:=make_hoy(ts); adoy:=make_doy(ts); amoy:=make_moy(ts); ay:=make_y(ts);
        ihoy:=make_hoy(ts); idoy:=make_doy(ts); imoy:=make_moy(ts); iy:=make_y(ts);
        phoy:=make_hoy(ts); pdoy:=make_doy(ts); pmoy:=make_moy(ts); py:=make_y(ts);
        -- Check to see if we modify in place or just issue transactions
        IF astatus<>100 AND pstatus<>100 AND acpa <> 0::money AND pcpa <> 0::money THEN
            -- trans_type 1100
            trans:=get_new_acct_transaction_ledger(clickid,1100,aid,cid,pid,NULL,pcpa,acpa,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid::BIGINT,cid::BIGINT,pid::BIGINT,ppid::BIGINT,-1 * acpa::money,-1 * pcpa::money,-1 * ppcpa::money,-1 * icpa::money,transaction_timestamp()::TIMESTAMPTZ);
        ELSEIF astatus<>100 AND acpa <> 0::money THEN
            -- trans_type 110
            trans:=get_new_acct_transaction_ledger(clickid,110,aid,cid,pid,NULL,0,acpa,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid::BIGINT,cid::BIGINT,pid::BIGINT,ppid::BIGINT,-1 * acpa::money,0::money,0::money,-1 * icpa::money,transaction_timestamp()::TIMESTAMPTZ);
        ELSEIF pstatus<>100 AND pcpa <> 0::money THEN
            -- trans_type 510
            trans:=get_new_acct_transaction_ledger(clickid,510,aid,cid,pid,NULL,pcpa,0,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid::BIGINT,cid::BIGINT,pid::BIGINT,ppid::BIGINT,0::money,-1 * pcpa::money,-1 * ppcpa::money,-1 * icpa::money,transaction_timestamp()::TIMESTAMPTZ);
        ELSEIF astatus=100 AND acpa<>0::money THEN
            doadv=TRUE;
            doint=TRUE;
        ELSEIF pstatus=100 AND pcpa<>0::money THEN
            doint=TRUE;
            dopub=TRUE;
        END IF;
        IF ppstatus=100 AND ppcpa<>0::money THEN
            -- Hour
            SELECT INTO pru_hour lookup_acct_publisher_rollup_hour(aid,cid,ppid,phoy,ppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-ppcpa;
                pru_hour.num_conversion:=pru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=ppid;
                pru_hour.cost_per_action:=ppcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:= -1 * ppcpa;
                pru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || ppid || ',publisher_cost_per_action:' || ppcpa || ',hour_of_year:' || phoy || ',timestamp:' || ts || ')','Publisher hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            SELECT INTO pru_day lookup_acct_publisher_rollup_day(aid,cid,ppid,pdoy,ppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment-ppcpa;
                pru_day.num_conversion:=pru_day.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=ppid;
                pru_day.cost_per_action:=ppcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:= -1 * ppcpa;
                pru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || ppid || ',publisher_cost_per_action:' || ppcpa || ',day_of_year:' || pdoy || ',timestamp:' || ts || ')','Publisher day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            SELECT INTO pru_month lookup_acct_publisher_rollup_month(aid,cid,ppid,pmoy,ppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment-ppcpa;
                pru_month.num_conversion:=pru_month.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=ppid;
                pru_month.cost_per_action:=ppcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:= -1 * ppcpa;
                pru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || ppid || ',publisher_cost_per_action:' || ppcpa || ',month_of_year:' || pmoy || ',timestamp:' || ts || ')','Publisher month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            SELECT INTO pru_year lookup_acct_publisher_rollup_year(aid,cid,pid,py,ppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment-ppcpa;
                pru_year.num_conversion:=pru_year.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=ppid;
                pru_year.cost_per_action:=ppcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:= -1 * ppcpa;
                pru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || ppid || ',publisher_cost_per_action:' || ppcpa || ',year:' || py || ',timestamp:' || ts || ')','Publisher year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        ELSEIF ppcpa<>0 THEN
            -- trans_type 510
            trans:=get_new_acct_transaction_ledger(clickid,510,aid,cid,ppid,NULL,ppcpa,0::money,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid::BIGINT,cid::BIGINT,pid::BIGINT,ppid::BIGINT,0::money,-1 * pcpa::money,-1 * ppcpa::money,-1 * icpa::money,transaction_timestamp()::TIMESTAMPTZ);
        END IF;
        -- Update Advertiser Rollups
        IF doadv THEN
            -- Hour
            SELECT INTO aru_hour lookup_acct_advertiser_rollup_hour(aid,cid,pid,ahoy,acpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment-acpa;
                aru_hour.num_conversion:=aru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_hour.a_id:=aid;
                aru_hour.c_id:=cid;
                aru_hour.p_id:=pid;
                aru_hour.cost_per_action:=acpa;
                aru_hour.a_hoy:=ahoy;
                aru_hour.status:=100;
                aru_hour.total_period_adjustment:= -1 * acpa;
                aru_hour.num_conversion:= -1;
                -- Log the incident, potential data anomaly
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',advertiser_cost_per_action:' || acpa || ',hour_of_year:' || ahoy || ',timestamp:' || ts || ')','Advertiser hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            SELECT INTO aru_day lookup_acct_advertiser_rollup_day(aid,cid,pid,adoy,acpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment-acpa;
                aru_day.num_conversion:=aru_day.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_day.a_id:=aid;
                aru_day.c_id:=cid;
                aru_day.p_id:=pid;
                aru_day.cost_per_action:=acpa;
                aru_day.a_doy:=adoy;
                aru_day.status:=100;
                aru_day.total_period_adjustment:= -1 * acpa;
                aru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',advertiser_cost_per_action:' || acpa || ',day_of_year:' || adoy || ',timestamp:' || ts || ')','Advertiser day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            SELECT INTO aru_month lookup_acct_advertiser_rollup_month(aid,cid,pid,amoy,acpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment-acpa;
                aru_month.num_conversion:=aru_month.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_month.a_id:=aid;
                aru_month.c_id:=cid;
                aru_month.p_id:=pid;
                aru_month.cost_per_action:=acpa;
                aru_month.a_moy:=amoy;
                aru_month.status:=100;
                aru_month.total_period_adjustment:= -1 * acpa;
                aru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',advertiser_cost_per_action:' || acpa || ',month_of_year:' || amoy || ',timestamp:' || ts || ')','Advertiser month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            SELECT INTO aru_year lookup_acct_advertiser_rollup_year(aid,cid,pid,ay,acpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment-acpa;
                aru_year.num_conversion:=aru_year.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_year.a_id:=aid;
                aru_year.c_id:=cid;
                aru_year.p_id:=pid;
                aru_year.cost_per_action:=acpa;
                aru_year.a_y:=ay;
                aru_year.status:=100;
                aru_year.total_period_adjustment:= -1 * acpa;
                aru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',advertiser_cost_per_action:' || acpa || ',year:' || ay || ',timestamp:' || ts || ')','Advertiser year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_advertiser_rollup_year(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
        END IF;
        -- Update Internal Rollups
        IF doint THEN
            -- Hour
            SELECT INTO iru_hour lookup_acct_internal_rollup_hour(aid,cid,pid,ihoy,icpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment-icpa;
                iru_hour.num_conversion:=iru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_hour.a_id:=aid;
                iru_hour.c_id:=cid;
                iru_hour.p_id:=pid;
                iru_hour.cost_per_action:=icpa;
                iru_hour.i_hoy:=ihoy;
                iru_hour.status:=100;
                iru_hour.total_period_adjustment:= -1 * icpa;
                iru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',internal_cost_per_action:' || icpa || ',hour_of_year:' || ihoy || ',timestamp:' || ts || ')','Internal hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            SELECT INTO iru_day lookup_acct_internal_rollup_day(aid,cid,pid,idoy,icpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment-icpa;
                iru_day.num_conversion:=iru_day.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_day.a_id:=aid;
                iru_day.c_id:=cid;
                iru_day.p_id:=pid;
                iru_day.cost_per_action:=icpa;
                iru_day.i_doy:=idoy;
                iru_day.status:=100;
                iru_day.total_period_adjustment:= -1 * icpa;
                iru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',internal_cost_per_action:' || icpa || ',day_of_year:' || idoy || ',timestamp:' || ts || ')','Internal day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            SELECT INTO iru_month lookup_acct_internal_rollup_month(aid,cid,pid,imoy,icpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment-icpa;
                iru_month.num_conversion:=iru_month.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_month.a_id:=aid;
                iru_month.c_id:=cid;
                iru_month.p_id:=pid;
                iru_month.cost_per_action:=icpa;
                iru_month.i_moy:=imoy;
                iru_month.status:=100;
                iru_month.total_period_adjustment:= -1 * icpa;
                iru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',internal_cost_per_action:' || icpa || ',month_of_year:' || imoy || ',timestamp:' || ts || ')','Internal month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            SELECT INTO iru_year lookup_acct_internal_rollup_year(aid,cid,pid,iy,icpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment-icpa;
                iru_year.num_conversion:=iru_year.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_year.a_id:=aid;
                iru_year.c_id:=cid;
                iru_year.p_id:=pid;
                iru_year.cost_per_action:=icpa;
                iru_year.i_y:=iy;
                iru_year.status:=100;
                iru_year.total_period_adjustment:= -1 * icpa;
                iru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',internal_cost_per_action:' || icpa || ',year:' || iy || ',timestamp:' || ts || ')','Internal year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_internal_rollup_year(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
        END IF;
        -- Update Publisher Rollups
        IF dopub THEN
            -- Hour
            SELECT INTO pru_hour lookup_acct_publisher_rollup_hour(aid,cid,pid,phoy,pcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-pcpa;
                pru_hour.num_conversion:=pru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=pid;
                pru_hour.cost_per_action:=pcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:= -1 * pcpa;
                pru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',publisher_cost_per_action:' || pcpa || ',hour_of_year:' || phoy || ',timestamp:' || ts || ')','Publisher hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            SELECT INTO pru_day lookup_acct_publisher_rollup_day(aid,cid,pid,pdoy,pcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment-pcpa;
                pru_day.num_conversion:=pru_day.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=pid;
                pru_day.cost_per_action:=pcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:= -1 * pcpa;
                pru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',publisher_cost_per_action:' || pcpa || ',day_of_year:' || pdoy || ',timestamp:' || ts || ')','Publisher day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            SELECT INTO pru_month lookup_acct_publisher_rollup_month(aid,cid,pid,pmoy,pcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment-pcpa;
                pru_month.num_conversion:=pru_month.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=pid;
                pru_month.cost_per_action:=pcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:= -1 * pcpa;
                pru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',publisher_cost_per_action:' || pcpa || ',month_of_year:' || pmoy || ',timestamp:' || ts || ')','Publisher month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            SELECT INTO pru_year lookup_acct_publisher_rollup_year(aid,cid,pid,py,pcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment-pcpa;
                pru_year.num_conversion:=pru_year.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=pid;
                pru_year.cost_per_action:=pcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:= -1 * pcpa;
                pru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',publisher_cost_per_action:' || pcpa ||AAAA ',year:' || py || ',timestamp:' || ts || ')','Publisher year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        RETURN TRUE;
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
    END
$$;


ALTER FUNCTION w4_application_functions.remove_conversion_from_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa money, pcpa money, ppcpa money, icpa money, ts timestamp with time zone, astatus integer, pstatus integer, ppstatus integer, clickid bigint) OWNER TO w4;

--
-- Name: remove_conversion_from_rollups(bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, integer, integer, integer, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION remove_conversion_from_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa numeric, pcpa numeric, ppcpa numeric, icpa numeric, ts timestamp with time zone, astatus integer, pstatus integer, ppstatus integer, clickid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ahoy BIGINT; aru_hour "acct_advertiser_rollup_hour";
        adoy BIGINT; aru_day "acct_advertiser_rollup_day";
        amoy BIGINT; aru_month "acct_advertiser_rollup_month";
        ay BIGINT;   aru_year "acct_advertiser_rollup_year";
        ihoy BIGINT; iru_hour "acct_internal_rollup_hour";
        idoy BIGINT; iru_day "acct_internal_rollup_day";
        imoy BIGINT; iru_month "acct_internal_rollup_month";
        iy BIGINT;   iru_year "acct_internal_rollup_year";
        phoy BIGINT; pru_hour "acct_publisher_rollup_hour";
        pdoy BIGINT; pru_day "acct_publisher_rollup_day";
        pmoy BIGINT; pru_month "acct_publisher_rollup_month";
        py BIGINT;   pru_year "acct_publisher_rollup_year";
        trans acct_transaction_ledger;
        exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
        doadv BOOLEAN; doint BOOLEAN; dopub BOOLEAN;
    BEGIN
        doadv=FALSE; doint=FALSE; dopub=FALSE;
        -- Get Rollup Time Boundaries
        ahoy:=make_hoy(ts); adoy:=make_doy(ts); amoy:=make_moy(ts); ay:=make_y(ts);
        ihoy:=make_hoy(ts); idoy:=make_doy(ts); imoy:=make_moy(ts); iy:=make_y(ts);
        phoy:=make_hoy(ts); pdoy:=make_doy(ts); pmoy:=make_moy(ts); py:=make_y(ts);
        -- Check to see if we modify in place or just issue transactions
        IF astatus<>100 AND pstatus<>100 AND acpa <> 0::numeric AND pcpa <> 0::numeric THEN
            -- trans_type 1100
            trans:=get_new_acct_transaction_ledger(clickid,1100,aid,cid,pid,NULL,pcpa,acpa,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid,cid,pid,0,-1 * acpa,-1 * pcpa,0,-1 * icpa,transaction_timestamp());
        ELSEIF astatus<>100 AND acpa <> 0::numeric THEN
            -- trans_type 110
            trans:=get_new_acct_transaction_ledger(clickid,110,aid,cid,pid,NULL,0,acpa,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid,cid,pid,0,-1 * acpa,0,0,-1 * icpa,transaction_timestamp());
        ELSEIF pstatus<>100 AND pcpa <> 0::numeric THEN
            -- trans_type 510
            trans:=get_new_acct_transaction_ledger(clickid,510,aid,cid,pid,NULL,pcpa,0,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid,cid,pid,0,0,-1 * pcpa,0,-1 * icpa,transaction_timestamp());
        ELSEIF astatus=100 AND acpa<>0::numeric THEN
            doadv=TRUE;
            doint=TRUE;
        ELSEIF pstatus=100 AND pcpa<>0::numeric THEN
            doint=TRUE;
            dopub=TRUE;
        END IF;
        IF ppstatus=100 AND ppcpa<>0::numeric THEN
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(aid,cid,ppid,phoy,ppcpa);
            PERFORM * FROM lookup_acct_publisher_rollup_hour(aid,cid,ppid,phoy,ppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-ppcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=ppid;
                pru_hour.cost_per_action:=ppcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:= -1 * ppcpa;
                pru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || ppid || ',publisher_cost_per_action:' || ppcpa || ',hour_of_year:' || phoy || ',timestamp:' || ts || ')','Publisher hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(aid,cid,ppid,pdoy,ppcpa);
            PERFORM * FROM lookup_acct_publisher_rollup_day(aid,cid,ppid,pdoy,ppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment-ppcpa;
                pru_day.num_conversion:=pru_day.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=ppid;
                pru_day.cost_per_action:=ppcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:= -1 * ppcpa;
                pru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || ppid || ',publisher_cost_per_action:' || ppcpa || ',day_of_year:' || pdoy || ',timestamp:' || ts || ')','Publisher day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(aid,cid,ppid,pmoy,ppcpa);
            PERFORM * FROM lookup_acct_publisher_rollup_month(aid,cid,ppid,pmoy,ppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment-ppcpa;
                pru_month.num_conversion:=pru_month.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=ppid;
                pru_month.cost_per_action:=ppcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:= -1 * ppcpa;
                pru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || ppid || ',publisher_cost_per_action:' || ppcpa || ',month_of_year:' || pmoy || ',timestamp:' || ts || ')','Publisher month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(aid,cid,pid,py,ppcpa);
            PERFORM * FROM lookup_acct_publisher_rollup_year(aid,cid,pid,py,ppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment-ppcpa;
                pru_year.num_conversion:=pru_year.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=ppid;
                pru_year.cost_per_action:=ppcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:= -1 * ppcpa;
                pru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || ppid || ',publisher_cost_per_action:' || ppcpa || ',year:' || py || ',timestamp:' || ts || ')','Publisher year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        ELSEIF ppcpa<>0 THEN
            -- trans_type 510
            trans:=get_new_acct_transaction_ledger(clickid,510,aid,cid,ppid,NULL,ppcpa,0::numeric,transaction_timestamp(),COALESCE((SELECT created_date FROM engine_clicks WHERE id=clickid),transaction_timestamp()),NULL,1);
            PERFORM add_conversion_to_rollups(aid,cid,ppid,0,-1 * ppcpa,-1 * icpa,transaction_timestamp());
        END IF;
        -- Update Advertiser Rollups
        IF doadv THEN
            -- Hour
            aru_hour:=lookup_acct_advertiser_rollup_hour(aid,cid,pid,ahoy,acpa);
            PERFORM * FROM lookup_acct_advertiser_rollup_hour(aid,cid,pid,ahoy,acpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment-acpa;
                aru_hour.num_conversion:=aru_hour.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_hour.a_id:=aid;
                aru_hour.c_id:=cid;
                aru_hour.p_id:=pid;
                aru_hour.cost_per_action:=acpa;
                aru_hour.a_hoy:=ahoy;
                aru_hour.status:=100;
                aru_hour.total_period_adjustment:= -1 * acpa;
                aru_hour.num_conversion:= -1;
                -- Log the incident, potential data anomaly
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',advertiser_cost_per_action:' || acpa || ',hour_of_year:' || ahoy || ',timestamp:' || ts || ')','Advertiser hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            aru_day:=lookup_acct_advertiser_rollup_day(aid,cid,pid,adoy,acpa);
            PERFORM * FROM lookup_acct_advertiser_rollup_day(aid,cid,pid,adoy,acpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment-acpa;
                aru_day.num_conversion:=aru_day.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_day.a_id:=aid;
                aru_day.c_id:=cid;
                aru_day.p_id:=pid;
                aru_day.cost_per_action:=acpa;
                aru_day.a_doy:=adoy;
                aru_day.status:=100;
                aru_day.total_period_adjustment:= -1 * acpa;
                aru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',advertiser_cost_per_action:' || acpa || ',day_of_year:' || adoy || ',timestamp:' || ts || ')','Advertiser day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            aru_month:=lookup_acct_advertiser_rollup_month(aid,cid,pid,amoy,acpa);
            PERFORM * FROM lookup_acct_advertiser_rollup_month(aid,cid,pid,amoy,acpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment-acpa;
                aru_month.num_conversion:=aru_month.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_month.a_id:=aid;
                aru_month.c_id:=cid;
                aru_month.p_id:=pid;
                aru_month.cost_per_action:=acpa;
                aru_month.a_moy:=amoy;
                aru_month.status:=100;
                aru_month.total_period_adjustment:= -1 * acpa;
                aru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',advertiser_cost_per_action:' || acpa || ',month_of_year:' || amoy || ',timestamp:' || ts || ')','Advertiser month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            aru_year:=lookup_acct_advertiser_rollup_year(aid,cid,pid,ay,acpa);
            PERFORM * FROM lookup_acct_advertiser_rollup_year(aid,cid,pid,ay,acpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment-acpa;
                aru_year.num_conversion:=aru_year.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_year.a_id:=aid;
                aru_year.c_id:=cid;
                aru_year.p_id:=pid;
                aru_year.cost_per_action:=acpa;
                aru_year.a_y:=ay;
                aru_year.status:=100;
                aru_year.total_period_adjustment:= -1 * acpa;
                aru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',advertiser_cost_per_action:' || acpa || ',year:' || ay || ',timestamp:' || ts || ')','Advertiser year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_advertiser_rollup_hour(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
        END IF;
        -- Update Internal Rollups
        IF doint THEN
            -- Hour
            iru_hour:=lookup_acct_internal_rollup_hour(aid,cid,pid,ihoy,icpa);
            PERFORM * FROM lookup_acct_internal_rollup_hour(aid,cid,pid,ihoy,icpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment-icpa;
                iru_hour.num_conversion:=iru_hour.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_hour.a_id:=aid;
                iru_hour.c_id:=cid;
                iru_hour.p_id:=pid;
                iru_hour.cost_per_action:=icpa;
                iru_hour.i_hoy:=ihoy;
                iru_hour.status:=100;
                iru_hour.total_period_adjustment:= -1 * icpa;
                iru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',internal_cost_per_action:' || icpa || ',hour_of_year:' || ihoy || ',timestamp:' || ts || ')','Internal hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            iru_day:=lookup_acct_internal_rollup_day(aid,cid,pid,idoy,icpa);
            PERFORM * FROM lookup_acct_internal_rollup_day(aid,cid,pid,idoy,icpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment-icpa;
                iru_day.num_conversion:=iru_day.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_day.a_id:=aid;
                iru_day.c_id:=cid;
                iru_day.p_id:=pid;
                iru_day.cost_per_action:=icpa;
                iru_day.i_doy:=idoy;
                iru_day.status:=100;
                iru_day.total_period_adjustment:= -1 * icpa;
                iru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',internal_cost_per_action:' || icpa || ',day_of_year:' || idoy || ',timestamp:' || ts || ')','Internal day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            iru_month:=lookup_acct_internal_rollup_month(aid,cid,pid,imoy,icpa);
            PERFORM * FROM lookup_acct_internal_rollup_month(aid,cid,pid,imoy,icpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment-icpa;
                iru_month.num_conversion:=iru_month.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_month.a_id:=aid;
                iru_month.c_id:=cid;
                iru_month.p_id:=pid;
                iru_month.cost_per_action:=icpa;
                iru_month.i_moy:=imoy;
                iru_month.status:=100;
                iru_month.total_period_adjustment:= -1 * icpa;
                iru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',internal_cost_per_action:' || icpa || ',month_of_year:' || imoy || ',timestamp:' || ts || ')','Internal month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            iru_year:=lookup_acct_internal_rollup_year(aid,cid,pid,iy,icpa);
            PERFORM * FROM lookup_acct_internal_rollup_year(aid,cid,pid,iy,icpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment-icpa;
                iru_year.num_conversion:=iru_year.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_year.a_id:=aid;
                iru_year.c_id:=cid;
                iru_year.p_id:=pid;
                iru_year.cost_per_action:=icpa;
                iru_year.i_y:=iy;
                iru_year.status:=100;
                iru_year.total_period_adjustment:= -1 * icpa;
                iru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',internal_cost_per_action:' || icpa || ',year:' || iy || ',timestamp:' || ts || ')','Internal year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_internal_rollup_hour(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
        END IF;
        -- Update Publisher Rollups
        IF dopub THEN
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(aid,cid,pid,phoy,pcpa);
            PERFORM * FROM lookup_acct_publisher_rollup_hour(aid,cid,pid,phoy,pcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-pcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=pid;
                pru_hour.cost_per_action:=pcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:= -1 * pcpa;
                pru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',publisher_cost_per_action:' || pcpa || ',hour_of_year:' || phoy || ',timestamp:' || ts || ')','Publisher hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(aid,cid,pid,pdoy,pcpa);
            PERFORM * FROM lookup_acct_publisher_rollup_day(aid,cid,pid,pdoy,pcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment-pcpa;
                pru_day.num_conversion:=pru_day.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=pid;
                pru_day.cost_per_action:=pcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:= -1 * pcpa;
                pru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',publisher_cost_per_action:' || pcpa || ',day_of_year:' || pdoy || ',timestamp:' || ts || ')','Publisher day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(aid,cid,pid,pmoy,pcpa);
            PERFORM * FROM lookup_acct_publisher_rollup_month(aid,cid,pid,pmoy,pcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment-pcpa;
                pru_month.num_conversion:=pru_month.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=pid;
                pru_month.cost_per_action:=pcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:= -1 * pcpa;
                pru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',publisher_cost_per_action:' || pcpa || ',month_of_year:' || pmoy || ',timestamp:' || ts || ')','Publisher month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(aid,cid,pid,py,pcpa);
            PERFORM * FROM lookup_acct_publisher_rollup_year(aid,cid,pid,py,pcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment-pcpa;
                pru_year.num_conversion:=pru_year.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=pid;
                pru_year.cost_per_action:=pcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:= -1 * pcpa;
                pru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || aid || ',campaign_id:' || cid || ',publisher_id:' || pid || ',publisher_cost_per_action:' || pcpa || ',year:' || py || ',timestamp:' || ts || ')','Publisher year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        RETURN TRUE;
        /*
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
        */
    END;
$$;


ALTER FUNCTION w4_application_functions.remove_conversion_from_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa numeric, pcpa numeric, ppcpa numeric, icpa numeric, ts timestamp with time zone, astatus integer, pstatus integer, ppstatus integer, clickid bigint) OWNER TO w4;

--
-- Name: request_campaign_access(bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION request_campaign_access(arg_publisher_id bigint, arg_campaign_id bigint) RETURNS public.pub_campaign_list
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val pub_campaign_list;
    BEGIN
        PERFORM * FROM campaign_assigned_publishers WHERE publisher_id=arg_publisher_id AND campaign_id=arg_campaign_id;
        IF FOUND THEN
            RAISE WARNING 'You have already requested access to this campaign.';
        ELSE
            INSERT INTO campaign_assigned_publishers VALUES (arg_campaign_id::BIGINT, arg_publisher_id::BIGINT, 'pending'::VARCHAR, ''::TEXT, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,''::TEXT);
        END IF;
        SELECT INTO ret_val 
                  cmp."name" AS campaign_name
                , cmp.id AS campaign_id
                , COALESCE(po.override_payout
                , cmp.default_payout)AS publisher_payout
                , pays_on_friendly_name(cmp.payout_model_id) AS pays_on
                , geos_json(cmp.id) AS geos_json
                , categories_json(cmp.id) AS categories
                , channels_json(cmp.id) AS channels
                , categories_ids_json(cmp.id) AS categories_ids
                , channels_ids_json(cmp.id) AS channel_ids
                , return_geo_ids_json(cmp.id) AS country_ids
                , to_char(cmp.expiry_date,'Month DD, YYYY') AS expires
                , cmp.description AS campaign_description
                , CASE cmp.access_type WHEN 1 THEN 'public' WHEN 2 THEN 'approved' WHEN 3 THEN CASE WHEN cap.status IS NULL THEN 'request' ELSE cap.status::TEXT END END AS approval_status
                , CASE WHEN (cmp.new_until::TIMESTAMPTZ > (now() + INTERVAL '1 day')::TIMESTAMPTZ) THEN TRUE ELSE FALSE END AS is_new
            FROM campaigns cmp
            LEFT JOIN publisher_overrides po 
                ON po.publisher_id=arg_publisher_id 
                AND po.campaign_id=cmp.id 
		AND (po.effective_date < now() OR po.effective_date IS NULL)
		AND (po.expiration_date > now() OR po.expiration_date IS NULL) 
            LEFT JOIN campaign_assigned_publishers cap 
                ON cap.campaign_id=cmp.id 
                AND cap.publisher_id=arg_publisher_id
            WHERE cmp.id=arg_campaign_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.request_campaign_access(arg_publisher_id bigint, arg_campaign_id bigint) OWNER TO w4;

--
-- Name: return_geo_ids_json(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION return_geo_ids_json(arg_campaign_id bigint) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        wrong_id VARCHAR;
        ret_val VARCHAR;
        i VARCHAR;
    BEGIN
        ret_val:='[';
        i:='"';
        FOR wrong_id IN SELECT country FROM campaign_geotargeting WHERE campaign_id=arg_campaign_id LOOP
            ret_val:=ret_val || i || wrong_id::VARCHAR || '"';
            i:=',"';
        END LOOP;
        ret_val:=ret_val || ']';
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.return_geo_ids_json(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: rollup_clicks_totals(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION rollup_clicks_totals() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ -- Trigger must run as a BEFORE INSERT UPDATE OR DELETE,for performance.
    DECLARE
	/* Rollup Time Dimentions */
	act_hoy BIGINT;act_doy BIGINT;act_moy BIGINT;act_y BIGINT;hoy_id BIGINT;doy_id BIGINT;moy_id BIGINT;y_id BIGINT;
	/* Rollup Noun Dimentions */
        aid BIGINT;cid BIGINT;pid BIGINT;ppid BIGINT;
	/* Rollup Changes on Execution */
        clicks_delta BIGINT;total_clicks_delta BIGINT;
	/* Geographic Dimentions */
        countryname VARCHAR;regionname VARCHAR;cityname VARCHAR;
	/* User Agent Dimentions */
        browsername VARCHAR;platformname VARCHAR;
    /* Creatives Dimention */
        creativeid BIGINT;
	/* Base Url(referrer_url)Dimention */
        baseuri VARCHAR;
	/* Publisher Generated Sub Id Dimentions */
        subid1 TEXT;subid2 TEXT;subid3 TEXT;subid4 TEXT;
    BEGIN -- Determine if insert,update,or delete
        IF(TG_OP='INSERT')THEN -- Sane defaults for INSERT,+1 click +1 total_clicks
            SELECT INTO cid NEW.campaign_id;SELECT INTO pid NEW.publisher_id;SELECT INTO ppid NEW.parent_publisher_id;SELECT INTO aid COALESCE((SELECT c.advertiser_id FROM campaigns c WHERE c.id=NEW.campaign_id),0);-- Get the nouns we're tracking
            SELECT INTO act_hoy make_hoy(NEW.created_date);SELECT INTO act_doy make_doy(NEW.created_date);SELECT INTO act_moy make_moy(NEW.created_date);SELECT INTO act_y make_y(NEW.created_date);-- Get the periods we care about
            SELECT INTO subid1 NEW.sub_id_1;SELECT INTO subid2 NEW.sub_id_2;SELECT INTO subid3 NEW.sub_id_3;SELECT INTO subid4 NEW.sub_id_4;-- Sub Ids for Publisher Sub ID reporting
            SELECT INTO countryname NEW.country;SELECT INTO regionname NEW.region_name;SELECT INTO cityname NEW.city;-- Get the Geo Data for reporting
            SELECT INTO browsername browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = NEW.browser_id;SELECT INTO platformname platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=NEW.platform_id;-- Get the User Agent info
            SELECT INTO creativeid NEW.creative_id;SELECT INTO baseuri NEW.base_uri;-- Finally,the base url for referrer tracking and the creative id for reporting
            SELECT INTO clicks_delta 1;SELECT INTO total_clicks_delta 1;-- Deltas
        ELSEIF(TG_OP='UPDATE')THEN -- Update the total_clicks field,because we're already accounted for the INSERT
            SELECT INTO cid NEW.campaign_id;SELECT INTO pid NEW.publisher_id;SELECT INTO ppid NEW.parent_publisher_id;SELECT INTO aid COALESCE((SELECT c.advertiser_id FROM campaigns c WHERE c.id=NEW.campaign_id),0);-- Get the nouns we're tracking
            SELECT INTO act_hoy make_hoy(NEW.created_date);SELECT INTO act_doy make_doy(NEW.created_date);SELECT INTO act_moy make_moy(NEW.created_date);SELECT INTO act_y make_y(NEW.created_date);-- Get the periods we care about            SELECT INTO subid1 NEW.sub_id_1;SELECT INTO subid1 NEW.sub_id_2;SELECT INTO subid1 NEW.sub_id_3;SELECT INTO subid1 NEW.sub_id_4;
            SELECT INTO subid1 NEW.sub_id_1;SELECT INTO subid2 NEW.sub_id_2;SELECT INTO subid3 NEW.sub_id_3;SELECT INTO subid4 NEW.sub_id_4;-- Sub Ids for Publisher Sub ID reporting
            SELECT INTO countryname NEW.country;SELECT INTO regionname NEW.region_name;SELECT INTO cityname NEW.city;-- Get the Geo Data for reporting
            SELECT INTO browsername  browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = NEW.browser_id;SELECT INTO platformname  platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=NEW.platform_id;-- Get the User Agent info
            SELECT INTO clicks_delta 0;SELECT INTO total_clicks_delta(NEW.nb_dupes-OLD.nb_dupes);-- Deltas
            SELECT INTO creativeid NEW.creative_id;SELECT INTO baseuri NEW.base_uri;-- Finally,the base url for referrer tracking and the creative id for reporting
        ELSEIF(TG_OP='DELETE')THEN -- Remove the click from the clicks and the nb_dupes+1 total_clicks
            SELECT INTO clicks_delta -1;SELECT INTO total_clicks_delta 0-(OLD.nb_dupes+1);-- Deltas
            SELECT INTO cid OLD.campaign_id;SELECT INTO pid OLD.publisher_id;SELECT INTO ppid OLD.parent_publisher_id;SELECT INTO aid COALESCE((SELECT c.advertiser_id FROM campaigns c WHERE c.id=OLD.campaign_id),0);-- Get the nouns we're tracking
            SELECT INTO act_hoy make_hoy(OLD.created_date);SELECT INTO act_doy make_doy(OLD.created_date);SELECT INTO act_moy make_moy(OLD.created_date);SELECT INTO act_y make_y(OLD.created_date);-- Get the periods we care about
            SELECT INTO subid1 OLD.sub_id_1;SELECT INTO subid2 OLD.sub_id_2;SELECT INTO subid3 OLD.sub_id_3;SELECT INTO subid4 OLD.sub_id_4;-- Sub Ids for Publisher Sub ID reporting
	        SELECT INTO countryname OLD.country;SELECT INTO regionname OLD.region_name;SELECT INTO cityname OLD.city;-- Get the Geo Data for reporting
            SELECT INTO browsername  browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = OLD.browser_id;SELECT INTO platformname  platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=OLD.platform_id;-- Get the User Agent info
            SELECT INTO creativeid NEW.creative_id;SELECT INTO baseuri OLD.base_uri;-- Finally,the base url for referrer tracking and the creative id for reporting
        END IF;
        /* GENERAL ROLLUP AREA - NO EXTRA DIMENTIONS */ 
        -- Determine if we're in a new hourly rollup period
        SELECT INTO hoy_id id FROM reports_clicks_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1);
        IF FOUND THEN UPDATE reports_clicks_rollup_hourly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=hoy_id;
        ELSE INSERT INTO reports_clicks_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,hoy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,act_hoy);END IF;
        -- Determine if we're in a new daily rollup period
        SELECT INTO doy_id id FROM reports_clicks_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1);
        IF FOUND THEN UPDATE reports_clicks_rollup_daily SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=doy_id;
        ELSE INSERT INTO reports_clicks_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,doy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,act_doy);END IF;
        -- Determine if we're in a new monthly rollup period
        SELECT INTO moy_id id FROM reports_clicks_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1);
        IF FOUND THEN UPDATE reports_clicks_rollup_monthly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=moy_id;
        ELSE INSERT INTO reports_clicks_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,moy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,act_moy);END IF;
        -- Determine if we're in a new yearly rollup period
        SELECT INTO y_id id FROM reports_clicks_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1);
        IF FOUND THEN UPDATE reports_clicks_rollup_yearly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=y_id;
        ELSE INSERT INTO reports_clicks_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,y)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,act_y);END IF;
        /* SUBID ROLLUP AREA - SUBID EXTRA DIMENTIONS */ 
        -- Determine if we're in a new hourly rollup period
        SELECT INTO hoy_id id FROM reports_clicks_subid_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'');
        IF FOUND THEN UPDATE reports_clicks_subid_rollup_hourly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=hoy_id;
        ELSE INSERT INTO reports_clicks_subid_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,sub_id_1,sub_id_2,sub_id_3,sub_id_4,hoy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,subid1,subid2,subid3,subid4,act_hoy);END IF;
        -- Determine if we're in a new daily rollup period
        SELECT INTO doy_id id FROM reports_clicks_subid_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'');
        IF FOUND THEN UPDATE reports_clicks_subid_rollup_daily SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=doy_id;
        ELSE INSERT INTO reports_clicks_subid_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,sub_id_1,sub_id_2,sub_id_3,sub_id_4,doy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,subid1,subid2,subid3,subid4,act_doy);END IF;
        -- Determine if we're in a new monthly rollup period
        SELECT INTO moy_id id FROM reports_clicks_subid_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'');
        IF FOUND THEN UPDATE reports_clicks_subid_rollup_monthly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=moy_id;
        ELSE INSERT INTO reports_clicks_subid_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,sub_id_1,sub_id_2,sub_id_3,sub_id_4,moy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,subid1,subid2,subid3,subid4,act_moy);END IF;
        -- Determine if we're in a new yearly rollup period
        SELECT INTO y_id id FROM reports_clicks_subid_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'');
        IF FOUND THEN UPDATE reports_clicks_subid_rollup_yearly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=y_id;
        ELSE INSERT INTO reports_clicks_subid_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,sub_id_1,sub_id_2,sub_id_3,sub_id_4,y)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,subid1,subid2,subid3,subid4,act_y);END IF;
        /* GEO ROLLUP AREA - GEO EXTRA DIMENTIONS */ 
        -- Determine if we're in a new hourly rollup period
        SELECT INTO hoy_id id FROM reports_clicks_geo_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'');
        IF FOUND THEN UPDATE reports_clicks_geo_rollup_hourly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=hoy_id;
        ELSE INSERT INTO reports_clicks_geo_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,country,region_name,city_name,hoy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,countryname,regionname,cityname,act_hoy);END IF;
        -- Determine if we're in a new daily rollup period
        SELECT INTO doy_id id FROM reports_clicks_geo_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'');
        IF FOUND THEN UPDATE reports_clicks_geo_rollup_daily SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=doy_id;
        ELSE INSERT INTO reports_clicks_geo_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,country,region_name,city_name,doy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,countryname,regionname,cityname,act_doy);END IF;
        -- Determine if we're in a new monthly rollup period
        SELECT INTO moy_id id FROM reports_clicks_geo_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'');
        IF FOUND THEN UPDATE reports_clicks_geo_rollup_monthly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=moy_id;
        ELSE INSERT INTO reports_clicks_geo_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,country,region_name,city_name,moy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,countryname,regionname,cityname,act_moy);END IF;
        -- Determine if we're in a new yearly rollup period
        SELECT INTO y_id id FROM reports_clicks_geo_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'');
        IF FOUND THEN UPDATE reports_clicks_geo_rollup_yearly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=y_id;
        ELSE INSERT INTO reports_clicks_geo_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,country,region_name,city_name,y)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,countryname,regionname,cityname,act_y);END IF;
        /* USER AGENT ROLLUP AREA - USER AGENT EXTRA DIMENTIONS */ 
        -- Determine if we're in a new hourly rollup period
        SELECT INTO hoy_id id FROM reports_clicks_ua_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'');
        IF FOUND THEN UPDATE reports_clicks_ua_rollup_hourly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=hoy_id;
        ELSE INSERT INTO reports_clicks_ua_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,browser_name,platform_name,hoy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,browsername,platformname,act_hoy);END IF;
        -- Determine if we're in a new daily rollup period
        SELECT INTO doy_id id FROM reports_clicks_ua_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'');
        IF FOUND THEN UPDATE reports_clicks_ua_rollup_daily SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=doy_id;
        ELSE INSERT INTO reports_clicks_ua_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,browser_name,platform_name,doy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,browsername,platformname,act_doy);END IF;
        -- Determine if we're in a new monthly rollup period
        SELECT INTO moy_id id FROM reports_clicks_ua_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'');
        IF FOUND THEN UPDATE reports_clicks_ua_rollup_monthly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=moy_id;
        ELSE INSERT INTO reports_clicks_ua_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,browser_name,platform_name,moy)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,browsername,platformname,act_moy);END IF;
        -- Determine if we're in a new yearly rollup period
        SELECT INTO y_id id FROM reports_clicks_ua_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'');
        IF FOUND THEN UPDATE reports_clicks_ua_rollup_yearly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=y_id;
        ELSE INSERT INTO reports_clicks_ua_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,browser_name,platform_name,y)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,browsername,platformname,act_y);END IF;
        /* WIDE ROLLUP AREA - EVERY EXTRA DIMENTION */ 
         -- Determine if we're in a new hourly rollup period
        SELECT INTO hoy_id id FROM reports_clicks_wide_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
        IF FOUND THEN UPDATE reports_clicks_wide_rollup_hourly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=hoy_id;
        ELSE INSERT INTO reports_clicks_wide_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,hoy,creative_id)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_hoy,creativeid);END IF;
        -- Determine if we're in a new daily rollup period
        SELECT INTO doy_id id FROM reports_clicks_wide_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
        IF FOUND THEN UPDATE reports_clicks_wide_rollup_daily SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=doy_id;
        ELSE INSERT INTO reports_clicks_wide_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,doy,creative_id)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_doy,creativeid);END IF;
        -- Determine if we're in a new monthly rollup period
        SELECT INTO moy_id id FROM reports_clicks_wide_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
        IF FOUND THEN UPDATE reports_clicks_wide_rollup_monthly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=moy_id;
        ELSE INSERT INTO reports_clicks_wide_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,moy,creative_id)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_moy,creativeid);END IF;
        -- Determine if we're in a new yearly rollup period
        SELECT INTO y_id id FROM reports_clicks_wide_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
        IF FOUND THEN UPDATE reports_clicks_wide_rollup_yearly SET total_clicks=total_clicks+total_clicks_delta,unique_clicks=unique_clicks+clicks_delta WHERE id=y_id;
        ELSE INSERT INTO reports_clicks_wide_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_clicks,unique_clicks,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,y,creative_id)VALUES(pid,ppid,cid,aid,total_clicks_delta,clicks_delta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_y,creativeid);END IF;
        RETURN NEW;-- Be a good little trigger and return the NEW record
    END;
$$;


ALTER FUNCTION w4_application_functions.rollup_clicks_totals() OWNER TO w4;

--
-- Name: rollup_conversions_totals(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION rollup_conversions_totals() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
	/* Rollup Time Dimentions */
	act_hoy BIGINT;act_doy BIGINT;act_moy BIGINT;act_y BIGINT;hoy_id BIGINT;doy_id BIGINT;moy_id BIGINT;y_id BIGINT;
	/* Rollup Changes on Execution */
    conversionsdelta BIGINT;payindelta money;payoutdelta money;profitdelta money;payin money; payout money;
	/* Rollup Noun Dimensions */
    aid BIGINT;cid BIGINT;pid BIGINT;ppid BIGINT;aclid BIGINT;convid BIGINT;newstatus INTEGER;
    /* Geographic Dimensions */
    countryname VARCHAR;regionname VARCHAR;cityname VARCHAR;
	/* User Agent Dimensions */
    browsername VARCHAR;platformname VARCHAR;
    /* Creatives Dimention */
    creativeid BIGINT;
	/* Base Url(referrer_url)Dimention */
    baseuri VARCHAR;
	/* Publisher Generated Sub Id Dimensions */
    subid1 TEXT; subid2 TEXT; subid3 TEXT; subid4 TEXT;
    BEGIN
        IF (TG_OP = 'INSERT') THEN
            /* Set created date */
            IF NEW.created_date IS NULL THEN
                NEW.created_date=transaction_timestamp();
            END IF;
            /* Set the modified date to same as created date */
            NEW.modified_date=transaction_timestamp();
            /* Set the status to NEW */
            NEW.status=1;
            /* Get the static nouns in order */
            cid:=NEW.campaign_id; pid:=NEW.publisher_id; ppid:=NEW.parent_publisher_id; SELECT INTO aid (SELECT c.advertiser_id FROM campaigns c WHERE c.id=NEW.campaign_id);
            /* Get the additional dimentional nouns in order */
            /* Start with GEO */
            countryname:=NEW.country; regionname:=NEW.region_name; cityname:=NEW.city;
            /* Then User-Agent */
            SELECT INTO browsername browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = NEW.browser_id;SELECT INTO platformname platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=NEW.platform_id;
            /* Sub IDs */
            SELECT * FROM get_sub_ids(NEW.click_id) INTO subid1, subid2, subid3, subid4;
            /* Referrer and Creative info */
            baseuri:=NEW.referral_url;creativeid:=NEW.creative_id;
            /* Get the temporal information we care about */
            act_hoy:=make_hoy(NEW.created_date); act_doy:=make_doy(NEW.created_date); act_moy:=make_moy(NEW.created_date); act_y:=make_y(NEW.created_date);
			/* Get the fields to provide the deltas */
            conversionsdelta:=1;
            newstatus:=NEW.status;
            convid:=NEW.id;
            payin:=NEW.payin;
            payout:=NEW.payout;
            payindelta:=NEW.payin;
            payoutdelta:=NEW.payout;
            profitdelta:=NEW.payin-NEW.payout;
        ELSEIF (TG_OP = 'UPDATE') THEN
            /* Set the new modified date */
            NEW.modified_date=transaction_timestamp();
            /* Get the static nouns in order */
            cid:=NEW.campaign_id; pid:=NEW.publisher_id; ppid:=NEW.parent_publisher_id; SELECT INTO aid (SELECT c.advertiser_id FROM campaigns c WHERE c.id=NEW.campaign_id);
            /* Get the additional dimentional nouns in order */
            /* Start with GEO */
            countryname:=NEW.country; regionname:=NEW.region_name; cityname:=NEW.city;
            /* Then User-Agent */
            SELECT INTO browsername browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = NEW.browser_id;SELECT INTO platformname platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=NEW.platform_id;
            /* Sub IDs */
            SELECT * FROM get_sub_ids(NEW.click_id) INTO subid1, subid2, subid3, subid4;
           /* Referrer and Creative info */
            baseuri:=NEW.referral_url;creativeid:=NEW.creative_id;
            /* Get the temporal information we care about */
            act_hoy:=make_hoy(NEW.created_date); act_doy:=make_doy(NEW.created_date); act_moy:=make_moy(NEW.created_date); act_y:=make_y(NEW.created_date);
			/* Get the fields to provide the deltas */
			CASE OLD.status WHEN 50, 60 THEN
				/* OK, this conversion was rejected, let's see what it's status changed to */
				CASE NEW.status WHEN 1, 10, 20, 30, 31, 32, 33 THEN
				    /* UN-Reject it */
				    /* OK, likely a values edit or a status progression. Use OLD/NEW record deltas */
            		/* Have to run a DELETE case, then leave the INSERT case for the fallthrough */
                    /* Get the OLD static nouns in order */
                    cid:=OLD.campaign_id; pid:=OLD.publisher_id; ppid:=OLD.parent_publisher_id; SELECT INTO aid (SELECT c.advertiser_id FROM campaigns c WHERE c.id=OLD.campaign_id);
                    /* Get the temporal information we care about */
                    act_hoy:=make_hoy(OLD.created_date); act_doy:=make_doy(OLD.created_date); act_moy:=make_moy(OLD.created_date); act_y:=make_y(OLD.created_date);
                    /* Get the additional dimentional nouns in order */
                    /* Start with GEO */
                    countryname:=OLD.country; regionname:=OLD.region_name; cityname:=OLD.city;
                    /* Then User-Agent */
                    SELECT INTO browsername browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = OLD.browser_id;SELECT INTO platformname platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=OLD.platform_id;
                    /* Sub IDs */
                    SELECT * FROM get_sub_ids(OLD.click_id) INTO subid1, subid2, subid3, subid4;
                    /* Referrer and Creative info */
                    baseuri:=OLD.referral_url;creativeid:=OLD.creative_id;
			        /* Get the fields to provide the deltas */
                    conversionsdelta:=1;
                    newstatus:=NEW.status;
                    convid:=OLD.id;
                    payin:=OLD.payin;
                    payout:=OLD.payout;
                    payindelta:=OLD.payin;
                    payoutdelta:=OLD.payout;
                    profitdelta:=(OLD.payin-OLD.payout);
				WHEN 50, 60 THEN
					/* It's still rejected, no need to update anything */
					RETURN NEW;
				END CASE;
			WHEN 1, 10, 20, 30, 31, 32, 33 THEN
				/* OK, this conversion was previously accepted, let's check for status changes */
				CASE NEW.status WHEN 1, 10, 20, 30, 31, 32, 33 THEN
					/* OK, likely a values edit or a status progression. Use OLD/NEW record deltas */
            		/* Have to run a DELETE case, then leave the INSERT case for the fallthrough */
                    /* Get the OLD static nouns in order */
                    cid:=OLD.campaign_id; pid:=OLD.publisher_id; ppid:=OLD.parent_publisher_id; SELECT INTO aid (SELECT c.advertiser_id FROM campaigns c WHERE c.id=OLD.campaign_id);
                    /* Get the temporal information we care about */
                    act_hoy:=make_hoy(OLD.created_date); act_doy:=make_doy(OLD.created_date); act_moy:=make_moy(OLD.created_date); act_y:=make_y(OLD.created_date);
                    /* Get the additional dimentional nouns in order */
                    /* Start with GEO */
                    countryname:=OLD.country; regionname:=OLD.region_name; cityname:=OLD.city;
                    /* Then User-Agent */
                    SELECT INTO browsername browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = OLD.browser_id;SELECT INTO platformname platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=OLD.platform_id;
                    /* Sub IDs */
                    SELECT * FROM get_sub_ids(OLD.click_id) INTO subid1, subid2, subid3, subid4;
                    /* And Referrer */
                    baseuri:=OLD.referral_url;creativeid:=OLD.creative_id;
			        /* Get the fields to provide the deltas */
                    conversionsdelta:=-1;
                    newstatus:=55;
                    convid:=OLD.id;
                    payin:=OLD.payin;
                    payout:=OLD.payout;
                    payindelta:=-1 * OLD.payin;
                    payoutdelta:=-1 * OLD.payout;
                    profitdelta:=-1 * (OLD.payin-OLD.payout);
                    /* Run the Delete business - single level indent to define as a "block", not a true closure */
                        /* GENERAL ROLLUP AREA - NO EXTRA DIMENSIONS */

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
                        ELSE INSERT INTO reporting.reports_conversions_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,hoy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,act_hoy);END IF;

                        SELECT INTO doy_id id FROM reporting.reports_conversions_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
                        ELSE INSERT INTO reporting.reports_conversions_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,doy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,act_doy);END IF;

                        SELECT INTO moy_id id FROM reporting.reports_conversions_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
                        ELSE INSERT INTO reporting.reports_conversions_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,moy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,act_moy);END IF;

                        SELECT INTO y_id id FROM reporting.reports_conversions_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
                        ELSE INSERT INTO reporting.reports_conversions_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,y)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,act_y);END IF;

                        /* SUBID ROLLUP AREA - SUBID EXTRA DIMENTIONS */

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_subid_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_subid_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
                        ELSE INSERT INTO reporting.reports_conversions_subid_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,sub_id_1,sub_id_2,sub_id_3,sub_id_4,hoy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,subid1,subid2,subid3,subid4,act_hoy);END IF;

                        SELECT INTO doy_id id FROM reporting.reports_conversions_subid_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_subid_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
                        ELSE INSERT INTO reporting.reports_conversions_subid_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,sub_id_1,sub_id_2,sub_id_3,sub_id_4,doy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,subid1,subid2,subid3,subid4,act_doy);END IF;

                        SELECT INTO moy_id id FROM reporting.reports_conversions_subid_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_subid_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
                        ELSE INSERT INTO reporting.reports_conversions_subid_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,sub_id_1,sub_id_2,sub_id_3,sub_id_4,moy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,subid1,subid2,subid3,subid4,act_moy);END IF;

                        SELECT INTO y_id id FROM reporting.reports_conversions_subid_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_subid_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
                        ELSE INSERT INTO reporting.reports_conversions_subid_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,sub_id_1,sub_id_2,sub_id_3,sub_id_4,y)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,subid1,subid2,subid3,subid4,act_y);END IF;

                        /* GEO ROLLUP AREA - GEO EXTRA DIMENTIONS */

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_geo_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_geo_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
                        ELSE INSERT INTO reporting.reports_conversions_geo_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,country,region_name,city_name,hoy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,countryname,regionname,cityname,act_hoy);END IF;

                        SELECT INTO doy_id id FROM reporting.reports_conversions_geo_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_geo_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
                        ELSE INSERT INTO reporting.reports_conversions_geo_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,country,region_name,city_name,doy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,countryname,regionname,cityname,act_doy);END IF;

                        SELECT INTO moy_id id FROM reporting.reports_conversions_geo_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_geo_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
                        ELSE INSERT INTO reporting.reports_conversions_geo_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,country,region_name,city_name,moy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,countryname,regionname,cityname,act_moy);END IF;

                        SELECT INTO y_id id FROM reporting.reports_conversions_geo_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_geo_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
                        ELSE INSERT INTO reporting.reports_conversions_geo_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,country,region_name,city_name,y)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,countryname,regionname,cityname,act_y);END IF;
                        
                        /* USER AGENT ROLLUP AREA - USER AGENT EXTRA DIMENSIONS */

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_ua_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_ua_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
                        ELSE INSERT INTO reporting.reports_conversions_ua_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,hoy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,act_hoy);END IF;

                        SELECT INTO doy_id id FROM reporting.reports_conversions_ua_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_ua_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
                        ELSE INSERT INTO reporting.reports_conversions_ua_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,doy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,act_doy);END IF;

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_ua_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_ua_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
                        ELSE INSERT INTO reporting.reports_conversions_ua_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,moy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,act_moy);END IF;

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_ua_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND payin_amount=payin AND payout_amount=payout;
                        IF FOUND THEN UPDATE reporting.reports_conversions_ua_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
                        ELSE INSERT INTO reporting.reports_conversions_ua_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,y)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,act_y);END IF;

                        /* WIDE ROLLUP AREA - EVERY EXTRA DIMENTION */

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_wide_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND payin_amount=payin AND payout_amount=payout AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
                        IF FOUND THEN UPDATE reporting.reports_conversions_wide_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
                        ELSE INSERT INTO reporting.reports_conversions_wide_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,hoy,creative_id)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_hoy,creativeid);END IF;

                        SELECT INTO doy_id id FROM reporting.reports_conversions_wide_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND payin_amount=payin AND payout_amount=payout AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
                        IF FOUND THEN UPDATE reporting.reports_conversions_wide_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
                        ELSE INSERT INTO reporting.reports_conversions_wide_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,doy,creative_id)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_doy,creativeid);END IF;

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_wide_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND payin_amount=payin AND payout_amount=payout AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
                        IF FOUND THEN UPDATE reporting.reports_conversions_wide_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
                        ELSE INSERT INTO reporting.reports_conversions_wide_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,moy,creative_id)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_moy,creativeid);END IF;

                        SELECT INTO hoy_id id FROM reporting.reports_conversions_wide_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND payin_amount=payin AND payout_amount=payout AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
                        IF FOUND THEN UPDATE reporting.reports_conversions_wide_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
                        ELSE INSERT INTO reporting.reports_conversions_wide_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,y,creative_id)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_y,creativeid);END IF;

            		/* Prepare the NEW record for the fallthough */
		            /* Get the NEW static nouns in order */
                    cid:=NEW.campaign_id; pid:=NEW.publisher_id; ppid:=NEW.parent_publisher_id; SELECT INTO aid (SELECT c.advertiser_id FROM campaigns c WHERE c.id=NEW.campaign_id);
                    /* Get the additional dimentional nouns in order */
                    /* Start with GEO */
                    countryname:=NEW.country; regionname:=NEW.region_name; cityname:=NEW.city;
                    /* Then User-Agent */
                    SELECT INTO browsername browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = NEW.browser_id;SELECT INTO platformname platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=NEW.platform_id;
                    /* Sub IDs */
                    SELECT * FROM get_sub_ids(NEW.click_id) INTO subid1, subid2, subid3, subid4;
                    /* Referrer and Creative info */
                    baseuri:=NEW.referral_url;creativeid:=NEW.creative_id;
                    /* Get the fields to provide the deltas */
            		conversionsdelta:=1;
		            newstatus:=NEW.status;
		            convid:=NEW.id;
		            payin:=NEW.payin;
        		    payout:=NEW.payout;
        		    payindelta:=NEW.payin;
        		    payoutdelta:=NEW.payout;
        		    profitdelta:=(NEW.payin-NEW.payout);
				WHEN 50, 60 THEN
					/* OK, this conversion was rejected, let's remove it's values */
		            conversionsdelta:=-1;
		            newstatus:=NEW.status;
		            convid:=NEW.id;
		            payin:=NEW.payin;
        		    payout:=NEW.payout;
        		    payindelta:=-1 * NEW.payin;
        		    payoutdelta:=-1 * NEW.payout;
        		    profitdelta:=-1 * (NEW.payin-NEW.payout);
				END CASE;
			END CASE;
        ELSEIF (TG_OP = 'DELETE') THEN
            /* Get the static nouns in order */
            cid:=OLD.campaign_id; pid:=OLD.publisher_id; ppid:=OLD.parent_publisher_id; SELECT INTO aid (SELECT c.advertiser_id FROM campaigns c WHERE c.id=OLD.campaign_id);
            /* Get the temporal information we care about */
            act_hoy:=make_hoy(OLD.created_date); act_doy:=make_doy(OLD.created_date); act_moy:=make_moy(OLD.created_date); act_y:=make_y(OLD.created_date);
            /* Get the additional dimentional nouns in order */
            /* Start with GEO */
            countryname:=OLD.country; regionname:=OLD.region_name; cityname:=OLD.city;
            /* Then User-Agent */
            SELECT INTO browsername browser_name || ' ' || browser_version FROM user_agent_browser_lookup WHERE id = OLD.browser_id;SELECT INTO platformname platform_name || ' ' || platform_version FROM user_agent_platform_lookup WHERE id=OLD.platform_id;
            /* Sub IDs */
            SELECT * FROM get_sub_ids(OLD.click_id) INTO subid1, subid2, subid3, subid4;
            /* Referrer and Creative info */
            baseuri:=OLD.referral_url;creativeid:=OLD.creative_id;
			/* Get the fields to provide the deltas */
            conversionsdelta:=-1;
            newstatus:=55;
            convid:=OLD.id;
            payin:=OLD.payin;
            payout:=OLD.payout;
            payindelta:=-1 * OLD.payin;
            payoutdelta:=-1 * OLD.payout;
            profitdelta:=-1 * (OLD.payin-OLD.payout);
        END IF;
        /* GENERAL ROLLUP AREA - NO EXTRA DIMENSIONS */

        SELECT INTO hoy_id id FROM reporting.reports_conversions_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
        ELSE INSERT INTO reporting.reports_conversions_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,hoy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,act_hoy);END IF;

        SELECT INTO doy_id id FROM reporting.reports_conversions_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
        ELSE INSERT INTO reporting.reports_conversions_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,doy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,act_doy);END IF;

        SELECT INTO moy_id id FROM reporting.reports_conversions_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
        ELSE INSERT INTO reporting.reports_conversions_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,moy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,act_moy);END IF;

        SELECT INTO y_id id FROM reporting.reports_conversions_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
        ELSE INSERT INTO reporting.reports_conversions_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,y)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,act_y);END IF;

        /* SUBID ROLLUP AREA - SUBID EXTRA DIMENTIONS */

        SELECT INTO hoy_id id FROM reporting.reports_conversions_subid_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_subid_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
        ELSE INSERT INTO reporting.reports_conversions_subid_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,sub_id_1,sub_id_2,sub_id_3,sub_id_4,hoy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,subid1,subid2,subid3,subid4,act_hoy);END IF;

        SELECT INTO doy_id id FROM reporting.reports_conversions_subid_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_subid_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
        ELSE INSERT INTO reporting.reports_conversions_subid_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,sub_id_1,sub_id_2,sub_id_3,sub_id_4,doy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,subid1,subid2,subid3,subid4,act_doy);END IF;

        SELECT INTO moy_id id FROM reporting.reports_conversions_subid_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_subid_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
        ELSE INSERT INTO reporting.reports_conversions_subid_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,sub_id_1,sub_id_2,sub_id_3,sub_id_4,moy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,subid1,subid2,subid3,subid4,act_moy);END IF;

        SELECT INTO y_id id FROM reporting.reports_conversions_subid_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_subid_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
        ELSE INSERT INTO reporting.reports_conversions_subid_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,sub_id_1,sub_id_2,sub_id_3,sub_id_4,y)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,subid1,subid2,subid3,subid4,act_y);END IF;

        /* GEO ROLLUP AREA - GEO EXTRA DIMENTIONS */

        SELECT INTO hoy_id id FROM reporting.reports_conversions_geo_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_geo_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
        ELSE INSERT INTO reporting.reports_conversions_geo_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,country,region_name,city_name,hoy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,countryname,regionname,cityname,act_hoy);END IF;

        SELECT INTO doy_id id FROM reporting.reports_conversions_geo_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_geo_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
        ELSE INSERT INTO reporting.reports_conversions_geo_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,country,region_name,city_name,doy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,countryname,regionname,cityname,act_doy);END IF;

        SELECT INTO moy_id id FROM reporting.reports_conversions_geo_rollup_monthly WHERE moy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_geo_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
        ELSE INSERT INTO reporting.reports_conversions_geo_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,country,region_name,city_name,moy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,countryname,regionname,cityname,act_moy);END IF;

        SELECT INTO y_id id FROM reporting.reports_conversions_geo_rollup_yearly WHERE y=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_geo_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
        ELSE INSERT INTO reporting.reports_conversions_geo_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,country,region_name,city_name,y)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,countryname,regionname,cityname,act_y);END IF;
        
        /* USER AGENT ROLLUP AREA - USER AGENT EXTRA DIMENSIONS */

        SELECT INTO hoy_id id FROM reporting.reports_conversions_ua_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_ua_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
        ELSE INSERT INTO reporting.reports_conversions_ua_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,hoy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,act_hoy);END IF;

        SELECT INTO doy_id id FROM reporting.reports_conversions_ua_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_ua_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
        ELSE INSERT INTO reporting.reports_conversions_ua_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,doy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,act_doy);END IF;

        SELECT INTO hoy_id id FROM reporting.reports_conversions_ua_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_ua_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
        ELSE INSERT INTO reporting.reports_conversions_ua_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,moy)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,act_moy);END IF;

        SELECT INTO hoy_id id FROM reporting.reports_conversions_ua_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND payin_amount=payin AND payout_amount=payout;
        IF FOUND THEN UPDATE reporting.reports_conversions_ua_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
        ELSE INSERT INTO reporting.reports_conversions_ua_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,y)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,act_y);END IF;

        /* WIDE ROLLUP AREA - EVERY EXTRA DIMENTION */

        SELECT INTO hoy_id id FROM reporting.reports_conversions_wide_rollup_hourly WHERE hoy=act_hoy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND payin_amount=payin AND payout_amount=payout AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
        IF FOUND THEN UPDATE reporting.reports_conversions_wide_rollup_hourly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=hoy_id;
        ELSE INSERT INTO reporting.reports_conversions_wide_rollup_hourly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,hoy,creative_id)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_hoy,creativeid);END IF;

        SELECT INTO doy_id id FROM reporting.reports_conversions_wide_rollup_daily WHERE doy=act_doy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND payin_amount=payin AND payout_amount=payout AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
        IF FOUND THEN UPDATE reporting.reports_conversions_wide_rollup_daily SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=doy_id;
        ELSE INSERT INTO reporting.reports_conversions_wide_rollup_daily(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,doy,creative_id)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_doy,creativeid);END IF;

        SELECT INTO hoy_id id FROM reporting.reports_conversions_wide_rollup_monthly WHERE moy=act_moy AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND payin_amount=payin AND payout_amount=payout AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
        IF FOUND THEN UPDATE reporting.reports_conversions_wide_rollup_monthly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=moy_id;
        ELSE INSERT INTO reporting.reports_conversions_wide_rollup_monthly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,moy,creative_id)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_moy,creativeid);END IF;

        SELECT INTO hoy_id id FROM reporting.reports_conversions_wide_rollup_yearly WHERE y=act_y AND advertiser_id=aid AND campaign_id=cid AND publisher_id=pid AND COALESCE(publisher_pid,-1)=COALESCE(ppid,-1) AND COALESCE(browser_name,'')=COALESCE(browsername,'')  AND COALESCE(country,'')=COALESCE(countryname,'') AND COALESCE(region_name,'')=COALESCE(regionname,'') AND COALESCE(city_name,'')=COALESCE(cityname,'') AND COALESCE(platform_name,'')=COALESCE(platformname,'') AND COALESCE(sub_id_1,'')=COALESCE(subid1,'') AND COALESCE(sub_id_2,'')=COALESCE(subid2,'') AND COALESCE(sub_id_3,'')=COALESCE(subid3,'') AND COALESCE(sub_id_4,'')=COALESCE(subid4,'') AND COALESCE(base_uri,'')=COALESCE(baseuri,'') AND payin_amount=payin AND payout_amount=payout AND COALESCE(creative_id,0)=COALESCE(creativeid,0);
        IF FOUND THEN UPDATE reporting.reports_conversions_wide_rollup_yearly SET total_conversions=total_conversions+conversionsdelta,total_pay_in=total_pay_in+payindelta,total_pay_out=total_pay_out+payoutdelta,profit=profit+profitdelta WHERE id=y_id;
        ELSE INSERT INTO reporting.reports_conversions_wide_rollup_yearly(publisher_id,publisher_pid,campaign_id,advertiser_id,total_conversions,total_pay_in,total_pay_out,payin_amount,payout_amount,profit,browser_name,platform_name,country,region_name,city_name,sub_id_1,sub_id_2,sub_id_3,sub_id_4,base_uri,y,creative_id)VALUES(pid,ppid,cid,aid,conversionsdelta,payindelta,payoutdelta,payin,payout,profitdelta,browsername,platformname,countryname,regionname,cityname,subid1,subid2,subid3,subid4,baseuri,act_y,creativeid);END IF;

        /* Finally put it into the accounting conversions ledger to start the auto-accounting process */
		SELECT INTO aclid id FROM "Accounting"."acct_conversion_ledger" acl WHERE acl.conversion_id=convid;
        IF FOUND THEN
	        IF newstatus = 55 THEN
	        	PERFORM delete_conversion(OLD);
        	ELSE
        		PERFORM update_conversion(OLD,NEW);
        	END IF;
        ELSE

            IF (TG_OP = 'INSERT') THEN
                PERFORM insert_new_conversion(NEW);
            ELSE
		IF (TG_OP = 'DELETE') THEN
			PERFORM delete_conversion(OLD);
		ELSE
			PERFORM update_conversion(OLD,NEW);
		END IF;
            END IF;
        END IF;
        RETURN NEW;
    END;
$$;


ALTER FUNCTION w4_application_functions.rollup_conversions_totals() OWNER TO w4;

--
-- Name: search_advertisers(text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_advertisers(arg_search text, arg_limit_number bigint) RETURNS SETOF public.typeahead_return
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val typeahead_return;
        ctr BIGINT;
        ids BIGINT[];
        qry TEXT;
    BEGIN
        ids:=array_append(ids,-1::BIGINT);
        ctr:=0;

        -- Look for an EXACT match
        FOR ret_val IN ( SELECT "id", "name" FROM advertisers WHERE "name" ILIKE arg_search OR "id"::VARCHAR = arg_search ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        
        -- Look for stuff that starts with
        FOR ret_val IN ( SELECT "id", "name" FROM advertisers WHERE ( NOT id = ANY( ids ) ) AND ( "name" ILIKE arg_search || '%' OR "id"::VARCHAR ILIKE arg_search || '%' ) ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;

        -- Look for stuff that ends with
        FOR ret_val IN ( SELECT "id", "name" FROM advertisers WHERE ( NOT id = ANY( ids ) ) AND ( "name" ILIKE '%' || arg_search OR "id"::VARCHAR ILIKE '%' || arg_search ) ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        
        -- Look for stuff that contains
        FOR ret_val IN ( SELECT "id", "name" FROM advertisers WHERE ( NOT id = ANY( ids ) ) AND ( "name" ILIKE '%' || arg_search || '%' OR "id"::VARCHAR ILIKE '%' || arg_search || '%' ) ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.search_advertisers(arg_search text, arg_limit_number bigint) OWNER TO w4;

--
-- Name: search_all_entities(text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_all_entities(arg_search text, arg_limit_number bigint) RETURNS SETOF public.all_entity_typeahead_return
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
    BEGIN        
        RETURN	QUERY SELECT *, 'Advertiser'::VARCHAR AS "type" FROM search_advertisers( arg_search, arg_limit_number / 3 ) 
		UNION SELECT *, 'Campaign'::VARCHAR   AS "type" FROM search_campaigns( arg_search, arg_limit_number / 3 )
		UNION SELECT *, 'Publisher'::VARCHAR  AS "type" FROM search_publishers( arg_search, arg_limit_number / 3 ); --  ORDER BY 3;
        END;
$$;


ALTER FUNCTION w4_application_functions.search_all_entities(arg_search text, arg_limit_number bigint) OWNER TO w4;

--
-- Name: search_all_geos(bigint[]); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_all_geos(arg_geo_ids bigint[]) RETURNS bigint[]
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val BIGINT[];
        cur_val BIGINT;
        use_union TEXT;
        vs TEXT;
    BEGIN
        IF arg_geo_ids <> '{}' THEN
            use_union:='';
            vs:='SELECT DISTINCT xXx.id AS id FROM (';
            FOREACH cur_val SLICE 1 IN ARRAY arg_geo_ids LOOP
                vs:=vs || use_union || 'SELECT INTO id search_geos(' || cur_val || ')';
                use_union:=' UNION ';
            END LOOP;
            vs:=vs || use_union || 'SELECT id FROM campaigns WHERE id NOT IN (SELECT campaign_id FROM campaign_geotargeting)) xXx';
        ELSE
            vs:='SELECT id FROM campaigns';
        END IF;
        FOR cur_val IN EXECUTE vs LOOP
            ret_val:=array_append(ret_val,cur_val);
        END LOOP;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.search_all_geos(arg_geo_ids bigint[]) OWNER TO w4;

--
-- Name: search_campaigns(text, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_campaigns(arg_search text, arg_limit_number bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS SETOF public.typeahead_return
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        ret_val typeahead_return;
        ctr BIGINT;
        ids BIGINT[];
        qry TEXT;
    BEGIN
        ids:=array_append(ids,-1::BIGINT);
        ctr:=0;

        -- Look for an EXACT match
        FOR ret_val IN ( SELECT "id", "name" FROM campaigns WHERE ("name" ILIKE arg_search OR "id"::VARCHAR = arg_search) AND (arg_currency_id IS NULL OR arg_currency_id = currency_id) ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        
        -- Look for stuff that starts with
        FOR ret_val IN ( SELECT "id", "name" FROM campaigns WHERE ( NOT id = ANY( ids ) ) AND ( "name" ILIKE arg_search || '%' OR "id"::VARCHAR ILIKE arg_search || '%' ) AND (arg_currency_id IS NULL OR arg_currency_id = currency_id) ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;

        -- Look for stuff that ends with
        FOR ret_val IN ( SELECT "id", "name" FROM campaigns WHERE ( NOT id = ANY( ids ) ) AND ( "name" ILIKE '%' || arg_search OR "id"::VARCHAR ILIKE '%' || arg_search ) AND (arg_currency_id IS NULL OR arg_currency_id = currency_id) ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        
        -- Look for stuff that contains
        FOR ret_val IN ( SELECT "id", "name" FROM campaigns WHERE ( NOT id = ANY( ids ) ) AND ( "name" ILIKE '%' || arg_search || '%' OR "id"::VARCHAR ILIKE '%' || arg_search || '%' ) AND (arg_currency_id IS NULL OR arg_currency_id = currency_id) ORDER BY 2 ) LOOP
            IF ctr < arg_limit_number THEN
                ctr:=ctr+1;
                ids:=array_append(ids,ret_val.id::BIGINT);
                -- RAISE INFO 'Returned ID was [%]',ret_val.id;
                RETURN NEXT ret_val;
            ELSE
                RETURN;
            END IF;
        END LOOP;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.search_campaigns(arg_search text, arg_limit_number bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: search_city(text, bigint, bigint, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_city(arg_city_search text, arg_region_id bigint, arg_country_id bigint, arg_limit_number integer) RETURNS TABLE(id bigint, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        wc TEXT;
        countrycode VARCHAR;
        regioncode VARCHAR;
    BEGIN
        arg_city_search:=replace(arg_city_search,' ','%');
        IF arg_region_id <> -1 AND arg_region_id IS NOT NULL THEN
            SELECT INTO regioncode local_name FROM geo_typeahead_region WHERE geo_typeahead_region.id=arg_region_id;
            IF arg_country_id <> -1 AND arg_country_id IS NOT NULL THEN
                SELECT INTO countrycode iso FROM geo_typeahead_countries WHERE geo_typeahead_countries.id=arg_country_id;
                wc:=$$ AND country_code='$$ || countrycode || $$' AND admin1_code='$$ || regioncode || $$' $$;
            ELSE
                wc:=$$ AND admin1_code='$$ || regioncode || $$' $$;
            END IF;
        ELSE
            IF arg_country_id <> -1 AND arg_country_id IS NOT NULL THEN
                SELECT INTO countrycode iso FROM geo_typeahead_countries WHERE geo_typeahead_countries.id=arg_country_id;
                wc:=$$ AND country_code='$$ || countrycode || $$' $$;
            ELSE
                wc:='';
            END IF;            
        END IF;
        RAISE INFO 'FUCKING WHERE CLAUSE [%]',wc;
        RETURN QUERY EXECUTE $$SELECT XxX.id::BIGINT, XxX.val::TEXT FROM (SELECT id, place_name_ascii AS val FROM geo_typeahead_cities WHERE search_string ~* '^$$ || arg_city_search || $$%' $$ || wc || $$ UNION SELECT id, place_name_ascii AS val FROM geo_typeahead_cities WHERE search_string ILIKE '%$$ || arg_city_search || $$%' $$ || wc || $$ LIMIT $$ || arg_limit_number || $$)XxX;$$;
    END;
$_$;


ALTER FUNCTION w4_application_functions.search_city(arg_city_search text, arg_region_id bigint, arg_country_id bigint, arg_limit_number integer) OWNER TO w4;

--
-- Name: search_country(text, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_country(arg_country_search text, arg_limit_number integer) RETURNS TABLE(id bigint, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        csa TEXT;
        csb TEXT;
        csc TEXT;
        qry TEXT;
    BEGIN
        arg_country_search:=replace(arg_country_search,' ','%');
        csa:='%' || arg_country_search || '%';
        csb:='^' || arg_country_search || '%';
        csc:='%' || arg_country_search || '%';
        qry:=$$SELECT XxX.id,XxX.val::TEXT FROM (SELECT geo_typeahead_countries.id, country AS val, set_order FROM geo_typeahead_countries WHERE country_search ILIKE '$$ || csa || $$' AND set_order < 50
        UNION
        SELECT geo_typeahead_countries.id, country AS val, set_order FROM geo_typeahead_countries WHERE country_search ~* '$$ || csb || $$'
        UNION
        SELECT geo_typeahead_countries.id, country AS val, set_order FROM geo_typeahead_countries WHERE country_search ILIKE '$$ || csc || $$' AND set_order > 50 ORDER BY set_order,val) XxX LIMIT $$ || arg_limit_number || $$;$$;
        RETURN QUERY EXECUTE qry;                
    END;
$_$;


ALTER FUNCTION w4_application_functions.search_country(arg_country_search text, arg_limit_number integer) OWNER TO w4;

--
-- Name: search_geos(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_geos(arg_geo_id bigint) RETURNS SETOF bigint
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        search_country VARCHAR; search_region VARCHAR; search_city VARCHAR; ret_val BIGINT;
    BEGIN
        SELECT INTO search_country country FROM campaign_geotargeting WHERE id=arg_geo_id;
        SELECT INTO search_region COALESCE(region,'') FROM campaign_geotargeting WHERE id=arg_geo_id;
        SELECT INTO search_city COALESCE(city,'') FROM campaign_geotargeting WHERE id=arg_geo_id;
        IF (search_region > '') THEN
            IF search_city > '' THEN
                FOR ret_val IN SELECT campaign_id FROM campaign_geotargeting WHERE country=search_country AND (region=search_region OR COALESCE(region,'')='') AND (city=search_city OR COALESCE(city,'')='') LOOP
                    RETURN NEXT ret_val;
                END LOOP;
        RETURN;
            ELSE
                FOR ret_val IN SELECT campaign_id FROM campaign_geotargeting WHERE country=search_country AND (region=search_region OR COALESCE(region,'')='') LOOP
                    RETURN NEXT ret_val;
                END LOOP;
            END IF;
        ELSE
            FOR ret_val IN SELECT campaign_id FROM campaign_geotargeting WHERE country=search_country LOOP
                RETURN NEXT ret_val;
            END LOOP;
        END IF;
        RETURN;
    END;
$$;


ALTER FUNCTION w4_application_functions.search_geos(arg_geo_id bigint) OWNER TO w4;

--
-- Name: search_publishers(text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_publishers(arg_search text DEFAULT NULL::text, arg_limit_number bigint DEFAULT (5)::bigint) RETURNS SETOF public.typeahead_return
    LANGUAGE plpgsql
    AS $$
begin
	RETURN QUERY SELECT entity_id,entity_name::character varying FROM vw_entity_search_publishers WHERE 
		lower(search_field) LIKE '%'||lower(arg_search)||'%'
		LIMIT arg_limit_number;
    END;
$$;


ALTER FUNCTION w4_application_functions.search_publishers(arg_search text, arg_limit_number bigint) OWNER TO w4;

--
-- Name: search_region(text, bigint, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_region(arg_region_search text, arg_country_id bigint, arg_limit_number integer) RETURNS TABLE(id bigint, val text)
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        wc TEXT;
        cty VARCHAR;
    BEGIN
	wc := '';
	
        IF arg_country_id IS NOT NULL AND arg_country_id <> -1 THEN
	    cty := geo_typeahead_countries.iso FROM geo_typeahead_countries WHERE geo_typeahead_countries.id = arg_country_id;
            wc  := ' AND admin1_code = ' || quote_literal( cty );
        END IF;

        arg_region_search := replace( arg_region_search, '\', '\\' );
        arg_region_search := replace( arg_region_search, '%', '\%' );
        arg_region_search := replace( arg_region_search, '_', '\_' );
        
        arg_region_search := replace( arg_region_search, ' ', '%' );
        
	RETURN QUERY EXECUTE 
            'SELECT
		XxX.id::BIGINT,
		XxX.val::TEXT
            FROM
            (
		SELECT
			id,
			ascii_name AS val 
		FROM 
			geo_typeahead_region 
		WHERE
			region_search ~* ' || quote_literal( arg_region_search ) || wc || '
		UNION
		SELECT
			id,
			ascii_name AS val 
		FROM
			geo_typeahead_region
		WHERE
			region_search ILIKE ' || quote_literal( arg_region_search || '%' ) || wc || '
		UNION
		SELECT
			id,
			ascii_name AS val 
		FROM
			geo_typeahead_region
		WHERE
			region_search ILIKE ' || quote_literal( '%' || arg_region_search ) || wc || '
		UNION
		SELECT
			id,
			ascii_name AS val 
		FROM
			geo_typeahead_region
		WHERE
			region_search ILIKE ' || quote_literal( '%' || arg_region_search || '%' ) || wc || '
            ) XxX
            LIMIT ' || arg_limit_number;
    END;
$$;


ALTER FUNCTION w4_application_functions.search_region(arg_region_search text, arg_country_id bigint, arg_limit_number integer) OWNER TO w4;

--
-- Name: search_targeting_city(text, text, text, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_targeting_city(arg_city_search text, arg_region_short text, arg_country_short text, arg_limit_number integer) RETURNS TABLE(id bigint, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        wc TEXT;
        countrycode VARCHAR;
        regioncode VARCHAR;
    BEGIN
        arg_city_search:=replace(arg_city_search,' ','%');
        IF arg_region_short IS NOT NULL THEN
            SELECT INTO regioncode region FROM regions WHERE regions.region=arg_region_short;
            IF arg_country_short IS NOT NULL THEN
                SELECT INTO countrycode country FROM countries WHERE countries.country=arg_country_short;
                wc:=$$ AND country='$$ || countrycode || $$' AND region='$$ || regioncode || $$' $$;
            ELSE
                wc:=$$ AND region='$$ || regioncode || $$' $$;
            END IF;
        ELSE
            IF arg_country_short IS NOT NULL THEN
                SELECT INTO countrycode country FROM countries WHERE countries.country=arg_country_short;
                wc:=$$ AND country='$$ || countrycode || $$' $$;
            ELSE
                wc:='';
            END IF;            
        END IF;
        RAISE INFO 'FUCKING WHERE CLAUSE [%]',wc;
        RETURN QUERY EXECUTE $$SELECT XxX.id::BIGINT, XxX.val::TEXT FROM (SELECT id, name AS val FROM cities WHERE name ~* '^$$ || arg_city_search || $$%' $$ || wc || $$ UNION SELECT id, name AS val FROM cities WHERE name ILIKE '%$$ || arg_city_search || $$%' $$ || wc || $$ LIMIT $$ || arg_limit_number || $$)XxX;$$;
    END;
$_$;


ALTER FUNCTION w4_application_functions.search_targeting_city(arg_city_search text, arg_region_short text, arg_country_short text, arg_limit_number integer) OWNER TO w4;

--
-- Name: search_targeting_country(text, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_targeting_country(arg_country_search text, arg_limit_number integer) RETURNS TABLE(id text, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        csa TEXT;
        csb TEXT;
        csc TEXT;
        qry TEXT;
    BEGIN
        arg_country_search:=replace(arg_country_search,' ','%');
        csa:='%' || arg_country_search || '%';
        csb:='^' || arg_country_search || '%';
        csc:='%' || arg_country_search || '%';
        qry:=$$SELECT XxX.id::TEXT,XxX.val::TEXT FROM (SELECT countries.country as id, name AS val FROM countries WHERE name ILIKE '$$ || csa || $$'
        UNION
        SELECT countries.country as id, name AS val FROM countries WHERE name ~* '$$ || csb || $$'
        UNION
        SELECT countries.country as id, name AS val FROM countries WHERE name ILIKE '$$ || csc || $$' ORDER BY val) XxX LIMIT $$ || arg_limit_number || $$;$$;
        RETURN QUERY EXECUTE qry;                
    END;
$_$;


ALTER FUNCTION w4_application_functions.search_targeting_country(arg_country_search text, arg_limit_number integer) OWNER TO w4;

--
-- Name: search_targeting_region(text, text, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION search_targeting_region(arg_region_search text, arg_country_short text, arg_limit_number integer) RETURNS TABLE(id text, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        wc TEXT;
        cty VARCHAR;
        qry TEXT;
    BEGIN
        IF arg_country_short IS NOT NULL THEN
	    SELECT INTO cty countries.country FROM countries WHERE countries.country=arg_country_short;
            wc:=$$ AND country='$$ || cty || $$' $$;
        ELSE
            wc:='';
        END IF;
        arg_region_search:=replace(arg_region_search,' ','%');
        qry:=$$SELECT XxX.id::TEXT, XxX.val::TEXT FROM (
            SELECT region AS id, name AS val FROM regions WHERE name ~* '^$$ || arg_region_search || $$%'$$ || wc || $$
            UNION
            SELECT region AS id, name AS val FROM regions WHERE name ILIKE '%$$ || arg_region_search || $$%'$$ || wc || $$) XxX LIMIT $$ || arg_limit_number || $$;$$;
            RETURN QUERY EXECUTE qry;
    END;
$_$;


ALTER FUNCTION w4_application_functions.search_targeting_region(arg_region_search text, arg_country_short text, arg_limit_number integer) OWNER TO w4;

--
-- Name: set_advertiser_contact(bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION set_advertiser_contact(arg_advertiser_id bigint, arg_contact_id bigint, arg_is_primary boolean DEFAULT false, arg_is_billing boolean DEFAULT false) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ct RECORD;
	BEGIN
	    IF arg_is_primary THEN
	        SELECT INTO ct
                    c.id,
                    c.first_name,
                    c.last_name,
                    c.address_1,
                    c.address_2,
                    c.country_id,
                    c.region_id,
                    c.city_id,
                    c.city_name,
                    c.postal_code,
                    c.messenger_name,
                    im.description AS messenger_type,
                    c.primary_phone,
                    c.secondary_phone,
                    c.fax,
                    c.email_address,
                    c.is_primary,
                    c.is_billing
                FROM contacts c
                LEFT JOIN im_types im ON ct.messenger_type = im.id
                WHERE id=arg_contact_id;

                UPDATE advertisers SET primary_contact_id=arg_contact_id, contact_name=ct.first_name || ' ' || ct.last_name, phone=ct.primary_phone, mobile=ct.secondary_phone, email=ct.email_address, messenger_id=ct.messenger_name || ' ' || ct.messenger_type::text, fax=ct.fax, address_1=ct.address_1, address_2=ct.address_2, city=ct.city_name, "state"=(SELECT ascii_name FROM geo_typeahead_region WHERE id=ct.region_id), country=(SELECT country FROM geo_typeahead_countries WHERE id=ct.country_id), zip=ct.postal_code  WHERE id=arg_advertiser_id;
	    END IF;

	    IF arg_is_billing THEN
	        SELECT INTO ct
                    c.id,
                    c.first_name,
                    c.last_name,
                    c.address_1,
                    c.address_2,
                    c.country_id,
                    c.region_id,
                    c.city_id,
                    c.city_name,
                    c.postal_code,
                    c.messenger_name,
                    im.description AS messenger_type,
                    c.primary_phone,
                    c.secondary_phone,
                    c.fax,
                    c.email_address,
                    c.is_primary,
                    c.is_billing
                FROM contacts c
                LEFT JOIN im_types im ON ct.messenger_type = im.id
                WHERE id=arg_contact_id;

                UPDATE advertisers SET billing_contact_id=arg_contact_id, contact_name=ct.first_name || ' ' || ct.last_name, phone=ct.primary_phone, mobile=ct.secondary_phone, email=ct.email_address, messenger_id=ct.messenger_name || ' ' || ct.messenger_type::text, fax=ct.fax, address_1=ct.address_1, address_2=ct.address_2, city=ct.city_name, "state"=(SELECT ascii_name FROM geo_typeahead_region WHERE id=ct.region_id), country=(SELECT country FROM geo_typeahead_countries WHERE id=ct.country_id), zip=ct.postal_code  WHERE id=arg_advertiser_id;
	    END IF;

	    PERFORM * FROM advertiser_contacts WHERE advertiser_id=arg_advertiser_id AND contact_id=arg_contact_id;
	    IF NOT FOUND THEN
	        INSERT INTO advertiser_contacts ("advertiser_id","contact_id") VALUES (arg_advertiser_id,arg_contact_id);
	    END IF;
	    RETURN arg_contact_id;
	END;
$$;


ALTER FUNCTION w4_application_functions.set_advertiser_contact(arg_advertiser_id bigint, arg_contact_id bigint, arg_is_primary boolean, arg_is_billing boolean) OWNER TO w4;

--
-- Name: set_publisher_contact(bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION set_publisher_contact(arg_publisher_id bigint, arg_contact_id bigint, arg_is_primary boolean DEFAULT false, arg_is_billing boolean DEFAULT false) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ct contacts;
	BEGIN
        IF arg_is_primary THEN
            SELECT INTO ct * FROM contacts WHERE id=arg_contact_id;
            UPDATE users SET primary_contact_id=arg_contact_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET first_name=ct.first_name, last_name=ct.last_name, address_1=ct.address_1, address_2=ct.address_2, city=ct.city_name, "state"=(SELECT region FROM geo_typeahead_region WHERE id=ct.region_id), country=(SELECT country FROM geo_typeahead_countries WHERE id=ct.country_id), zip=ct.postal_code, phone=ct.primary_phone, cell=ct.secondary_phone, messenger_id=ct.messenger_name, messenger_type=ct.messenger_type, fax=ct.fax WHERE user_id=arg_publisher_id;
        END IF;
        IF arg_is_billing THEN
            SELECT INTO ct * FROM contacts WHERE id=arg_contact_id;
            UPDATE users SET billing_contact_id=arg_contact_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET payment_address_1=arg_address_1, payment_address_2=arg_address_2, payment_city=arg_city_name, payment_region=(SELECT region FROM geo_typeahead_region WHERE id=arg_region_id), payment_postal_code=arg_postal_code, payment_country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id) WHERE user_id=arg_publisher_id;
        END IF;        
	    PERFORM * FROM publisher_contact WHERE publisher_id=arg_publisher_id AND contact_id=arg_contact_id;
	    IF NOT FOUND THEN
	        INSERT INTO publisher_contact ("publisher_id","contact_id") VALUES (arg_publisher_id,arg_contact_id);
	    END IF;
	    RETURN arg_contact_id;
	END;
$$;


ALTER FUNCTION w4_application_functions.set_publisher_contact(arg_publisher_id bigint, arg_contact_id bigint, arg_is_primary boolean, arg_is_billing boolean) OWNER TO w4;

--
-- Name: set_publisher_dashboard_layout(bigint, json); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION set_publisher_dashboard_layout(arg_publisher_id bigint, arg_layout json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        sid BIGINT;
    BEGIN
        SELECT INTO sid id FROM publisher_interface_settings WHERE publisher_id=arg_publisher_id AND ui_location='Dashboard';
        IF NOT FOUND THEN
            INSERT INTO publisher_interface_settings ("publisher_id","ui_location","settings") VALUES (arg_publisher_id,'Dashboard',arg_layout);
        ELSE
            UPDATE publisher_interface_settings SET "settings"=arg_layout WHERE id=sid;
        END IF;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.set_publisher_dashboard_layout(arg_publisher_id bigint, arg_layout json) OWNER TO w4;

--
-- Name: set_publisher_robert_json_blob_delete_me(bigint, json); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION set_publisher_robert_json_blob_delete_me(arg_publisher_id bigint, arg_layout json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        sid BIGINT;
    BEGIN
        SELECT INTO sid id FROM publisher_interface_settings WHERE publisher_id=arg_publisher_id AND ui_location='TEST';
        IF NOT FOUND THEN
            INSERT INTO publisher_interface_settings ("publisher_id","ui_location","settings") VALUES (arg_publisher_id,'TEST',arg_layout);
        ELSE
            UPDATE publisher_interface_settings SET "settings"=arg_layout WHERE id=sid;
        END IF;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4_application_functions.set_publisher_robert_json_blob_delete_me(arg_publisher_id bigint, arg_layout json) OWNER TO w4;

--
-- Name: store_engine_decisioning_audit(bigint, bigint, bigint, text, text, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION store_engine_decisioning_audit(arg_click_id bigint, arg_conversion_id bigint, arg_audit_reasoning_ordinal bigint, arg_decisioning_code text, arg_message text, arg_campaign_id bigint DEFAULT 0, arg_advertiser_id bigint DEFAULT 0, arg_publisher_id bigint DEFAULT 0) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BIGINT;
    BEGIN
        ret_val:=nextval('engine_audit_log_id_seq');
        INSERT INTO engine_audit_log VALUES (ret_val,arg_click_id,arg_conversion_id,arg_decisioning_code, arg_message, CURRENT_TIMESTAMP,arg_campaign_id, arg_advertiser_id, arg_publisher_id, arg_audit_reasoning_ordinal);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.store_engine_decisioning_audit(arg_click_id bigint, arg_conversion_id bigint, arg_audit_reasoning_ordinal bigint, arg_decisioning_code text, arg_message text, arg_campaign_id bigint, arg_advertiser_id bigint, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: store_engine_decisioning_audit(bigint, bigint, text, text, bigint, bigint, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION store_engine_decisioning_audit(arg_click_id bigint, arg_conversion_id bigint, arg_decisioning_code text, arg_message text, arg_campaign_id bigint DEFAULT 0, arg_advertiser_id bigint DEFAULT 0, arg_publisher_id bigint DEFAULT 0, arg_audit_reason_ordinal bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BIGINT;
    BEGIN
        ret_val:=nextval('engine_audit_log_id_seq');
        INSERT INTO engine_audit_log VALUES (ret_val,arg_click_id,arg_conversion_id,arg_decisioning_code, arg_message, CURRENT_TIMESTAMP,arg_campaign_id, arg_advertiser_id, arg_publisher_id, arg_audit_reason_ordinal);
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.store_engine_decisioning_audit(arg_click_id bigint, arg_conversion_id bigint, arg_decisioning_code text, arg_message text, arg_campaign_id bigint, arg_advertiser_id bigint, arg_publisher_id bigint, arg_audit_reason_ordinal bigint) OWNER TO w4;

--
-- Name: truncate_tables(character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION truncate_tables(username character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    statements CURSOR FOR
        SELECT tablename FROM pg_tables
        WHERE tableowner = username AND schemaname = 'public';
BEGIN
    FOR stmt IN statements LOOP
        EXECUTE 'TRUNCATE TABLE ' || quote_ident(stmt.tablename) || ' CASCADE;';
    END LOOP;
END;
$$;


ALTER FUNCTION w4_application_functions.truncate_tables(username character varying) OWNER TO w4;

--
-- Name: update_advertiser_account(bigint, text, bigint, text, text, bigint, text, text, text, text, text, text, text, text, text, text, public.advertiser_status); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_advertiser_account(arg_id bigint, arg_name text DEFAULT NULL::text, arg_manager_id bigint DEFAULT NULL::bigint, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_postal_code text DEFAULT NULL::text, arg_ftp_password text DEFAULT NULL::text, arg_confirm_ftp_password text DEFAULT NULL::text, arg_tracking_url text DEFAULT NULL::text, arg_tracking_username text DEFAULT NULL::text, arg_tracking_password text DEFAULT NULL::text, arg_account_notes text DEFAULT NULL::text, arg_url text DEFAULT NULL::text, arg_status public.advertiser_status DEFAULT NULL::public.advertiser_status) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
	account_contact_id bigint;
	var_region_id bigint;
        var_city_id bigint;
        var_country_name text;
        var_ftp_username text;
        var_ftp_folder text;
 
    BEGIN
        
        PERFORM id FROM advertisers WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified advertiser (%).', arg_id;
        END IF;

        SELECT country_name, region_id, city_id FROM geo_get(arg_country_id, arg_region_name, arg_city_name) INTO var_country_name, var_region_id, var_city_id;

        IF arg_ftp_password <> arg_confirm_ftp_password THEN
            RAISE EXCEPTION 'The FTP password verifiation does not match.';
        END IF;

	UPDATE advertisers SET 
		"name"              = COALESCE( arg_name,              "name"              ),
		manager_id          = arg_manager_id,
		note_login_url      = COALESCE( arg_tracking_url,      note_login_url      ),
		note_login_username = COALESCE( arg_tracking_username, note_login_username ),
		note_login_password = COALESCE( arg_tracking_password, note_login_password ),
		description         = COALESCE( arg_account_notes,     description         ),
		url                 = COALESCE( arg_url,               url                 ),
		country             = COALESCE( var_country_name,      country             ),
		state               = COALESCE( arg_region_name,       state               ),
		city                = COALESCE( arg_city_name,         city                ),
		zip                 = COALESCE( arg_postal_code,       zip                 ),
		address_1           = COALESCE( arg_address_1,         address_1           ),
		address_2           = COALESCE( arg_address_2,         address_2           ),
		status              = COALESCE( arg_status::text,      status              )
	WHERE id = arg_id;

        UPDATE ftp.user SET
            password = COALESCE (arg_ftp_password, password)
        WHERE advertiser_id = arg_id;

        IF (NOT FOUND) THEN
            var_ftp_username := CONCAT('a', arg_id::text);
            var_ftp_folder := CONCAT('/home/', var_ftp_username);
            INSERT INTO ftp.user
                (username, password, advertiser_id, folder, gid)
                VALUES (var_ftp_username, arg_ftp_password, arg_id, var_ftp_folder, 1);
        END IF;

        account_contact_id := a.account_contact_id FROM advertisers a WHERE id = arg_id;
	
	PERFORM update_advertiser_contact
	(
		account_contact_id,
		arg_id,
		NULL::text,
		NULL::text,
		arg_address_1,
		arg_address_2,
		arg_country_id,
		var_region_id,
		var_city_id,
		arg_city_name,
		arg_postal_code
	);
	
        RETURN get_advertiser_account( arg_id );

    END;
$$;


ALTER FUNCTION w4_application_functions.update_advertiser_account(arg_id bigint, arg_name text, arg_manager_id bigint, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_name text, arg_city_name text, arg_postal_code text, arg_ftp_password text, arg_confirm_ftp_password text, arg_tracking_url text, arg_tracking_username text, arg_tracking_password text, arg_account_notes text, arg_url text, arg_status public.advertiser_status) OWNER TO w4;

--
-- Name: update_advertiser_billing(bigint, numeric, text, text, text, bigint, text, text, text, boolean, integer); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_advertiser_billing(arg_id bigint, arg_credit_limit numeric DEFAULT NULL::numeric, arg_credit_limit_per text DEFAULT NULL::text, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_postal_code text DEFAULT NULL::text, arg_allow_over_limit boolean DEFAULT false, arg_payment_terms_id integer DEFAULT NULL::integer) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        billing_contact_id bigint;
	var_region_id bigint;
        var_city_id bigint;
        credit_terms_text text;

    BEGIN
    
        PERFORM id FROM advertisers WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified advertiser (%).',arg_id;
        END IF;

        SELECT region_id, city_id FROM geo_get(arg_country_id, arg_region_name, arg_city_name) INTO var_region_id, var_city_id;
        credit_terms_text := CASE WHEN arg_allow_over_limit = TRUE THEN 'yes' ELSE 'no' END;

        UPDATE advertisers SET 
		allow_over_limit   = COALESCE( credit_terms_text,      allow_over_limit   ),
		credit_limit       = COALESCE( arg_credit_limit,       credit_limit       ),
		credit_limit_per   = COALESCE( arg_credit_limit_per,   credit_limit_per   ),
		payment_terms_id   = COALESCE( arg_payment_terms_id,   payment_terms_id   ),
		billing_country_id = COALESCE( arg_country_id,         billing_country_id ),
		billing_region_id  = COALESCE( var_region_id,          billing_region_id  ),
		billing_city       = COALESCE( arg_city_name,              billing_city       ),
		billing_address_1  = COALESCE( arg_address_1,          billing_address_1  ),
		billing_address_2  = COALESCE( arg_address_2,          billing_address_2  )
        WHERE id = arg_id;

        billing_contact_id := a.billing_contact_id FROM advertisers a WHERE id = arg_id;
	PERFORM update_advertiser_contact
	(
		billing_contact_id,
		arg_id,
		NULL::text,
		NULL::text,
		arg_address_1,
		arg_address_2,
		arg_country_id,
		var_region_id,
		var_city_id,
		arg_city_name,
		arg_postal_code
	);
	RETURN get_advertiser_billing( arg_id );
    END;
$$;


ALTER FUNCTION w4_application_functions.update_advertiser_billing(arg_id bigint, arg_credit_limit numeric, arg_credit_limit_per text, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_name text, arg_city_name text, arg_postal_code text, arg_allow_over_limit boolean, arg_payment_terms_id integer) OWNER TO w4;

--
-- Name: update_advertiser_contact(bigint, bigint, character varying, character varying, character varying, character varying, bigint, bigint, bigint, character varying, character varying, character varying, bigint, character varying, character varying, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_advertiser_contact(arg_id bigint, arg_advertiser_id bigint, arg_first_name character varying DEFAULT NULL::character varying, arg_last_name character varying DEFAULT NULL::character varying, arg_address_1 character varying DEFAULT NULL::character varying, arg_address_2 character varying DEFAULT NULL::character varying, arg_country_id bigint DEFAULT (-1), arg_region_id bigint DEFAULT (-1), arg_city_id bigint DEFAULT (-1), arg_city_name character varying DEFAULT NULL::character varying, arg_postal_code character varying DEFAULT NULL::character varying, arg_messenger_name character varying DEFAULT NULL::character varying, arg_messenger_type bigint DEFAULT NULL::bigint, arg_primary_phone character varying DEFAULT NULL::character varying, arg_secondary_phone character varying DEFAULT NULL::character varying, arg_fax character varying DEFAULT NULL::character varying, arg_email_address character varying DEFAULT NULL::character varying, arg_is_primary boolean DEFAULT false, arg_is_billing boolean DEFAULT false) RETURNS public.contacts
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ct contacts;
        adv advertisers;
    BEGIN

        PERFORM * FROM update_contact(arg_id,arg_first_name, arg_last_name, arg_address_1, arg_address_2, arg_country_id, arg_region_id, arg_city_id, arg_city_name, arg_postal_code, arg_messenger_name, arg_messenger_type, arg_primary_phone, arg_secondary_phone, arg_fax, arg_email_address);
	IF arg_is_primary THEN
            UPDATE advertisers SET primary_contact_id=arg_id, contact_name=arg_first_name || ' ' || arg_last_name, phone=arg_primary_phone, mobile=arg_secondary_phone, email=arg_email_address, messenger_id=arg_messenger_name || ' ' || arg_messenger_type, fax=arg_fax, address_1=arg_address_1, address_2=arg_address_2, city=arg_city_name, "state"=(SELECT ascii_name FROM geo_typeahead_region WHERE id=arg_region_id), country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id), zip=arg_postal_code  WHERE id=arg_advertiser_id;
	END IF;
	IF arg_is_billing THEN
            UPDATE advertisers SET billing_contact_id=arg_id, billing_first_name=arg_first_name, billing_last_name=arg_last_name, billing_address_1=arg_address_1, billing_address_2=arg_address_2, billing_city=arg_city_name, billing_region_id=arg_region_id, billing_country_id=arg_country_id WHERE id=arg_advertiser_id;
	END IF;

	adv := ROW( a.* ) FROM advertisers a WHERE id = arg_advertiser_id;
        ct  := ROW( c.* ) FROM contacts c    WHERE id = arg_id;

	ct.is_primary := adv.primary_contact_id = arg_id;
	ct.is_billing := adv.billing_contact_id = arg_id;
        
        RETURN ct;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_advertiser_contact(arg_id bigint, arg_advertiser_id bigint, arg_first_name character varying, arg_last_name character varying, arg_address_1 character varying, arg_address_2 character varying, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_city_name character varying, arg_postal_code character varying, arg_messenger_name character varying, arg_messenger_type bigint, arg_primary_phone character varying, arg_secondary_phone character varying, arg_fax character varying, arg_email_address character varying, arg_is_primary boolean, arg_is_billing boolean) OWNER TO w4;

--
-- Name: update_alert_to_archived(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_alert_to_archived(arg_alert_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        ret_val:=TRUE;
        UPDATE messages SET message_status=4 WHERE id=arg_alert_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_alert_to_archived(arg_alert_id bigint) OWNER TO w4;

--
-- Name: update_alert_to_deleted(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_alert_to_deleted(arg_alert_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        ret_val:=TRUE;
        UPDATE messages SET message_status=5 WHERE id=arg_alert_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_alert_to_deleted(arg_alert_id bigint) OWNER TO w4;

--
-- Name: update_alert_to_read(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_alert_to_read(arg_alert_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        ret_val:=TRUE;
        UPDATE messages SET message_status=3 WHERE id=arg_alert_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_alert_to_read(arg_alert_id bigint) OWNER TO w4;

--
-- Name: update_category(bigint, character varying, text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_category(arg_id bigint, arg_name character varying, arg_description text, arg_parent_id bigint DEFAULT 0) RETURNS public.vw_category
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val vw_category;
        check_val BIGINT;
        chk_val BIGINT;
        cat_depth INTEGER;
        max_depth INTEGER;
        count_var INTEGER;
    BEGIN
        max_depth:=2; -- Allow for a depth of 2 per Jason
        SELECT INTO chk_val parent_id FROM categories WHERE id=arg_id;
        IF chk_val <> arg_parent_id THEN
            IF arg_parent_id > 0 THEN
                -- Check parent_id to ensure that it won't cause recursion
                cat_depth:=0;
                chk_val:=arg_parent_id;
                LOOP
                    cat_depth:=cat_depth+1;
                    SELECT INTO check_val parent_id FROM categories WHERE id=chk_val;
                    IF check_val > 0 THEN
                        chk_val:=check_val;
                    ELSE
                        -- It's OK to insert, it's not past the recursion limit. Make sure no other siblings with the same name
                        UPDATE categories SET "name"=arg_name, "description"=arg_description, "parent_id"=arg_parent_id WHERE id=arg_id;
                        SELECT INTO ret_val * FROM vw_category WHERE id=arg_id;
                        RETURN ret_val;                       
                    END IF;
                    IF cat_depth > max_depth THEN
                        -- It's NOT OK to insert this, it's past the recursion limit
                        RAISE WARNING 'You can not assign a category to a category that is % deep',max_depth;
                    END IF;
                END LOOP;
            ELSE
                -- Top level Category
                UPDATE categories SET "name"=arg_name, "description"=arg_description, "parent_id"=arg_parent_id WHERE id=arg_id;
                SELECT INTO ret_val * FROM vw_category WHERE id=arg_id;
                RETURN ret_val;
            END IF;
        ELSE
            -- Check to make sure no siblings share the same name
            UPDATE categories SET "name"=arg_name, "description"=arg_description, "parent_id"=arg_parent_id WHERE id=arg_id;
            SELECT INTO ret_val * FROM vw_category WHERE id=arg_id;
            RETURN ret_val;
        END IF;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_category(arg_id bigint, arg_name character varying, arg_description text, arg_parent_id bigint) OWNER TO w4;

--
-- Name: update_cmpl_downloaded(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_cmpl_downloaded() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.downloaded_ts := CURRENT_TIMESTAMP; 
    RETURN NEW;
END;
$$;


ALTER FUNCTION w4_application_functions.update_cmpl_downloaded() OWNER TO w4;

--
-- Name: update_cmpl_exceptions(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_cmpl_exceptions() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.created_ts := CURRENT_TIMESTAMP; 
    RETURN NEW;
END;
$$;


ALTER FUNCTION w4_application_functions.update_cmpl_exceptions() OWNER TO w4;

--
-- Name: update_cmpl_notifications(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_cmpl_notifications() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.create_ts := CURRENT_TIMESTAMP; 
    RETURN NEW;
END;
$$;


ALTER FUNCTION w4_application_functions.update_cmpl_notifications() OWNER TO w4;

--
-- Name: update_cmpl_suppression_file(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_cmpl_suppression_file() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.modified_date := CURRENT_TIMESTAMP; 
    RETURN NEW;
END;
$$;


ALTER FUNCTION w4_application_functions.update_cmpl_suppression_file() OWNER TO w4;

--
-- Name: update_contact(bigint, text, text, text, text, bigint, bigint, bigint, text, text, text, bigint, text, text, text, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_contact(arg_id bigint, arg_first_name text DEFAULT NULL::text, arg_last_name text DEFAULT NULL::text, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_id bigint DEFAULT NULL::bigint, arg_city_id bigint DEFAULT NULL::bigint, arg_city_name text DEFAULT NULL::text, arg_postal_code text DEFAULT NULL::text, arg_messenger_name text DEFAULT NULL::text, arg_messenger_type bigint DEFAULT NULL::bigint, arg_primary_phone text DEFAULT NULL::text, arg_secondary_phone text DEFAULT NULL::text, arg_fax text DEFAULT NULL::text, arg_email_address text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
	BEGIN
	
		-- NOTE: Ugh, not even sure NULLIFs are necessary
		UPDATE contacts SET
			first_name      = COALESCE( arg_first_name,      first_name      ),
			last_name       = COALESCE( arg_last_name,       last_name       ),
			address_1       = COALESCE( arg_address_1,       address_1       ),
			address_2       = COALESCE( arg_address_2,       address_2       ),
			country_id      = COALESCE( NULLIF( arg_country_id, -1 ), country_id ),
			region_id       = COALESCE( NULLIF( arg_region_id,  -1 ), region_id  ),
			city_id         = COALESCE( NULLIF( arg_city_id,    -1 ), city_id    ),
			city_name       = COALESCE( arg_city_name,       city_name       ),
			postal_code     = COALESCE( arg_postal_code,     postal_code     ),
			messenger_name  = COALESCE( arg_messenger_name,  messenger_name  ),
			messenger_type  = COALESCE( arg_messenger_type,  messenger_type  ),
			primary_phone   = COALESCE( arg_primary_phone,   primary_phone   ),
			secondary_phone = COALESCE( arg_secondary_phone, secondary_phone ),
			fax             = COALESCE( arg_fax,             fax             ),
			email_address   = COALESCE( arg_email_address,   email_address   )
		WHERE id = arg_id;

		RETURN arg_id;
		
	END;
$$;


ALTER FUNCTION w4_application_functions.update_contact(arg_id bigint, arg_first_name text, arg_last_name text, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_city_name text, arg_postal_code text, arg_messenger_name text, arg_messenger_type bigint, arg_primary_phone text, arg_secondary_phone text, arg_fax text, arg_email_address text) OWNER TO w4;

--
-- Name: update_conversion(public.engine_conversions, public.engine_conversions); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_conversion(old_cnv public.engine_conversions, new_cnv public.engine_conversions) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        acl acct_conversion_ledger;
        aal acct_advertiser_ledger;
        ail acct_internal_ledger;
        apl acct_publisher_ledger;
        appl acct_publisher_ledger;
        atl acct_transaction_ledger;
	change_pay BOOLEAN;
        click_id BIGINT; conversion_id BIGINT; amt numeric; new_cnv_advertiser_id BIGINT; old_cnv_advertiser_id BIGINT;
        exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
        acpa NUMERIC; pcpa NUMERIC; ppcpa NUMERIC; icpa NUMERIC; 
    BEGIN
	change_pay:=FALSE;
        SELECT INTO old_cnv_advertiser_id (SELECT c.advertiser_id FROM campaigns c WHERE c.id=old_cnv.campaign_id);
        SELECT INTO new_cnv_advertiser_id (SELECT c.advertiser_id FROM campaigns c WHERE c.id=new_cnv.campaign_id);
        -- Get CPA info
        acpa:=old_cnv.payin::NUMERIC;
        pcpa:=COALESCE(old_cnv.parent_payout::NUMERIC,old_cnv.payout::NUMERIC)::NUMERIC;
        ppcpa:=CASE WHEN old_cnv.parent_payout::NUMERIC-old_cnv.payout::NUMERIC > 0::NUMERIC THEN old_cnv.parent_payout::NUMERIC ELSE 0::NUMERIC END;
        icpa:=old_cnv.payin::NUMERIC-old_cnv.payout::NUMERIC;
        -- Grab the standard conversion to ledger identifier click_id::BIGINT
        click_id:=old_cnv.click_id;
        conversion_id=old_cnv.id;
        -- Get all of the ledger records involved
        acl:=get_acct_conversion_ledger_by_clickid(conversion_id::BIGINT);
        aal:=get_acct_advertiser_ledger_by_clickid(conversion_id::BIGINT);
        ail:=get_acct_internal_ledger_by_clickid(conversion_id::BIGINT);
        apl:=get_acct_publisher_ledger_by_clickid(conversion_id::BIGINT);
        appl:=get_acct_parent_publisher_ledger(apl.id);
        -- Determine if it's being approved, declined, or is a fact change
        CASE old_cnv.status WHEN 50, 60 THEN
            -- This WAS a rejected conversion, see if it's still to be rejected
            CASE new_cnv.status WHEN 50, 60 THEN
                -- It's STILL rejected, likely a fact change
                -- status
                IF old_cnv.status <> new_cnv.status THEN
                    acl.status:=new_cnv.status;
                    aal.status:=new_cnv.status;
                    ail.status:=new_cnv.status;
                    apl.status:=new_cnv.status;
                    IF appl.id IS NOT NULL THEN
                        appl.status:=new_cnv.status;
                    END IF;
                END IF;
                -- advertiser_id
                IF old_cnv_advertiser_id <> new_cnv_advertiser_id THEN
                    acl.advertiser_id:=new_cnv_advertiser_id;
                    aal.advertiser_id:=new_cnv_advertiser_id;
                    ail.advertiser_id:=new_cnv_advertiser_id;
                    apl.advertiser_id:=new_cnv_advertiser_id;
                    IF appl.id IS NOT NULL THEN
                        appl.advertiser_id:=new_cnv_advertiser_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- campaign_id
                IF old_cnv.campaign_id <> new_cnv.campaign_id THEN
                    acl.campaign_id:=new_cnv.campaign_id;
                    aal.campaign_id:=new_cnv.campaign_id;
                    ail.campaign_id:=new_cnv.campaign_id;
                    apl.campaign_id:=new_cnv.campaign_id;
                    IF appl.id IS NOT NULL THEN
                        appl.campaign_id:=new_cnv.campaign_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- publisher_id
                IF old_cnv.publisher_id <> new_cnv.publisher_id THEN
                    acl.publisher_id:=new_cnv.publisher_id;
                    aal.publisher_id:=new_cnv.publisher_id;
                    ail.publisher_id:=new_cnv.publisher_id;
                    apl.publisher_id:=new_cnv.publisher_id;
                    IF appl.id IS NOT NULL THEN
                        appl.publisher_id:=new_cnv.publisher_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- publisher_pid
                IF old_cnv.parent_publisher_id <> new_cnv.parent_publisher_id THEN
                    acl.publisher_pid:=new_cnv.parent_publisher_id;
                    aal.publisher_pid:=new_cnv.parent_publisher_id;
                    ail.publisher_pid:=new_cnv.parent_publisher_id;
                    apl.publisher_pid:=new_cnv.parent_publisher_id;
                    IF appl.id IS NOT NULL THEN
                        appl.publisher_pid:=new_cnv.parent_publisher_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
            ELSE
                -- OK, it's been re-approved, let's check for other fact changes
                -- status
                IF old_cnv.status <> new_cnv.status THEN
                    acl.status:=new_cnv.status;
                    aal.status:=new_cnv.status;
                    ail.status:=new_cnv.status;
                    apl.status:=new_cnv.status;
                    IF appl.id IS NOT NULL THEN
                        appl.status:=new_cnv.status;
                    END IF;
                END IF;
                -- advertiser_id
                IF old_cnv_advertiser_id <> new_cnv_advertiser_id THEN
                    acl.advertiser_id:=new_cnv_advertiser_id;
                    aal.advertiser_id:=new_cnv_advertiser_id;
                    ail.advertiser_id:=new_cnv_advertiser_id;
                    apl.advertiser_id:=new_cnv_advertiser_id;
                    IF appl.id IS NOT NULL THEN
                        appl.advertiser_id:=new_cnv_advertiser_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- campaign_id
                IF old_cnv.campaign_id <> new_cnv.campaign_id THEN
                    acl.campaign_id:=new_cnv.campaign_id;
                    aal.campaign_id:=new_cnv.campaign_id;
                    ail.campaign_id:=new_cnv.campaign_id;
                    apl.campaign_id:=new_cnv.campaign_id;
                    IF appl.id IS NOT NULL THEN
                        appl.campaign_id:=new_cnv.campaign_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- publisher_id
                IF old_cnv.publisher_id <> new_cnv.publisher_id THEN
                    acl.publisher_id:=new_cnv.publisher_id;
                    aal.publisher_id:=new_cnv.publisher_id;
                    ail.publisher_id:=new_cnv.publisher_id;
                    apl.publisher_id:=new_cnv.publisher_id;
                    IF appl.id IS NOT NULL THEN
                        appl.publisher_id:=new_cnv.publisher_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- publisher_pid
                IF old_cnv.parent_publisher_id <> new_cnv.parent_publisher_id THEN
                    acl.publisher_pid:=new_cnv.parent_publisher_id;
                    aal.publisher_pid:=new_cnv.parent_publisher_id;
                    ail.publisher_pid:=new_cnv.parent_publisher_id;
                    apl.publisher_pid:=new_cnv.parent_publisher_id;
                    IF appl.id IS NOT NULL THEN
                        appl.publisher_pid:=new_cnv.parent_publisher_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- payments
                IF old_cnv.payin <> new_cnv.payin OR old_cnv.payout <> new_cnv.payout OR change_pay THEN
                    PERFORM update_conversion_rollups(old_cnv_advertiser_id,old_cnv.campaign_id,old_cnv.publisher_id,old_cnv.parent_publisher_id,
                    old_cnv.payin::NUMERIC,COALESCE(old_cnv.parent_payout::NUMERIC,old_cnv.payout::NUMERIC)::NUMERIC,
                    CASE WHEN old_cnv.parent_payout::NUMERIC-old_cnv.payout::NUMERIC > 0::NUMERIC THEN old_cnv.parent_payout::NUMERIC ELSE 0::NUMERIC END,
                        old_cnv.payin::NUMERIC-old_cnv.payout::NUMERIC,old_cnv.modified_date,new_cnv_advertiser_id,new_cnv.campaign_id,new_cnv.publisher_id,
                        new_cnv.parent_publisher_id,new_cnv.payin::NUMERIC,COALESCE(new_cnv.parent_payout::NUMERIC,new_cnv.payout::NUMERIC)::NUMERIC,
                        CASE WHEN new_cnv.parent_payout::NUMERIC-new_cnv.payout::NUMERIC > 0::NUMERIC THEN new_cnv.parent_payout::money ELSE 0::NUMERIC END,
                        new_cnv.payin::NUMERIC-new_cnv.payout::NUMERIC,transaction_timestamp(),acl.advertiser_invoice_status,acl.publisher_invoice_status,acl.parent_publisher_invoice_status,conversion_id::BIGINT);
                    acl.pay_in_amt:=new_cnv.payin;
                    aal.debit_amt:=new_cnv.payin;
                    ail.credit_amt:=new_cnv.payin;
                    acl.pay_out_amt:=new_cnv.payout;
                    ail.debit_amt:=new_cnv.payout;
                    IF appl.id IS NOT NULL THEN
                        apl.credit_amt:=COALESCE(new_cnv.parent_payout-new_cnv.payout,new_cnv.payout);
                        appl.credit_amt:=CASE WHEN new_cnv.parent_payout::NUMERIC > 0::numeric THEN new_cnv.parent_payout::NUMERIC ELSE 0::numeric END;
                    END IF;
                END IF;
            END CASE;
        ELSE
            -- This WAS an approved conversion, see if it's being rejected
            CASE new_cnv.status WHEN 50, 60 THEN
                -- OK, it's being rejected, so we adjust it out and check for other fact changes
                -- status
                IF old_cnv.status <> new_cnv.status THEN
                    acl.status:=new_cnv.status;
                    aal.status:=new_cnv.status;
                    ail.status:=new_cnv.status;
                    apl.status:=new_cnv.status;
                    IF appl.id IS NOT NULL THEN
                        appl.status:=new_cnv.status;
                    END IF;
                END IF;
                -- advertiser_id
                IF old_cnv_advertiser_id <> new_cnv_advertiser_id THEN
                    acl.advertiser_id:=new_cnv_advertiser_id;
                    aal.advertiser_id:=new_cnv_advertiser_id;
                    ail.advertiser_id:=new_cnv_advertiser_id;
                    apl.advertiser_id:=new_cnv_advertiser_id;
                    IF appl.id IS NOT NULL THEN
                       appl.advertiser_id:=new_cnv_advertiser_id;
                    END IF;
                END IF;
                -- campaign_id
                IF old_cnv.campaign_id <> new_cnv.campaign_id THEN
                    acl.campaign_id:=new_cnv.campaign_id;
                    aal.campaign_id:=new_cnv.campaign_id;
                    ail.campaign_id:=new_cnv.campaign_id;
                    apl.campaign_id:=new_cnv.campaign_id;
                    IF appl.id IS NOT NULL THEN
                        appl.campaign_id:=new_cnv.campaign_id;
                    END IF;
                END IF;
                -- publisher_id
                IF old_cnv.publisher_id <> new_cnv.publisher_id THEN
                    acl.publisher_id:=new_cnv.publisher_id;
                    aal.publisher_id:=new_cnv.publisher_id;
                    ail.publisher_id:=new_cnv.publisher_id;
                    apl.publisher_id:=new_cnv.publisher_id;
                    IF appl.id IS NOT NULL THEN
                        appl.publisher_id:=new_cnv.publisher_id;
                    END IF;
                END IF;
                -- publisher_pid
                IF old_cnv.parent_publisher_id <> new_cnv.parent_publisher_id THEN
                    acl.publisher_pid:=new_cnv.parent_publisher_id;
                    aal.publisher_pid:=new_cnv.parent_publisher_id;
                    ail.publisher_pid:=new_cnv.parent_publisher_id;
                    apl.publisher_pid:=new_cnv.parent_publisher_id;
                    IF appl.id IS NOT NULL THEN
                        appl.publisher_pid:=new_cnv.parent_publisher_id;
                    END IF;
                END IF;
                -- Adjust the old conversion out
                PERFORM remove_conversion_from_rollups(
                      old_cnv_advertiser_id::BIGINT
                    , old_cnv.campaign_id::BIGINT
                    , old_cnv.publisher_id::BIGINT
                    , old_cnv.parent_publisher_id::BIGINT
                    , acpa::NUMERIC
                    , pcpa::NUMERIC
                    , ppcpa::NUMERIC
                    , icpa::NUMERIC
                    , old_cnv.created_date::TIMESTAMPTZ
                    , acl.advertiser_invoice_status::INTEGER
                    , acl.publisher_invoice_status::INTEGER
                    , acl.parent_publisher_invoice_status::INTEGER
                    , old_cnv.click_id::BIGINT);
            ELSE
                -- It's STILL approved, likely a fact change
                -- status
                IF old_cnv.status <> new_cnv.status THEN
                    acl.status:=new_cnv.status;
                    aal.status:=new_cnv.status;
                    ail.status:=new_cnv.status;
                    apl.status:=new_cnv.status;
                    IF appl.id IS NOT NULL THEN
                        appl.status:=new_cnv.status;
                    END IF;
                END IF;
                -- advertiser_id
                IF old_cnv_advertiser_id <> new_cnv_advertiser_id THEN
                    acl.advertiser_id:=new_cnv_advertiser_id;
                    aal.advertiser_id:=new_cnv_advertiser_id;
                    ail.advertiser_id:=new_cnv_advertiser_id;
                    apl.advertiser_id:=new_cnv_advertiser_id;
                    IF appl.id IS NOT NULL THEN
                        appl.advertiser_id:=new_cnv_advertiser_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- campaign_id
                IF old_cnv.campaign_id <> new_cnv.campaign_id THEN
                    acl.campaign_id:=new_cnv.campaign_id;
                    aal.campaign_id:=new_cnv.campaign_id;
                    ail.campaign_id:=new_cnv.campaign_id;
                    apl.campaign_id:=new_cnv.campaign_id;
                    IF appl.id IS NOT NULL THEN
                        appl.campaign_id:=new_cnv.campaign_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- publisher_id
                IF old_cnv.publisher_id <> new_cnv.publisher_id THEN
                    acl.publisher_id:=new_cnv.publisher_id;
                    aal.publisher_id:=new_cnv.publisher_id;
                    ail.publisher_id:=new_cnv.publisher_id;
                    apl.publisher_id:=new_cnv.publisher_id;
                    IF appl.id IS NOT NULL THEN
                        appl.publisher_id:=new_cnv.publisher_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- publisher_pid
                IF old_cnv.parent_publisher_id <> new_cnv.parent_publisher_id THEN
                    acl.publisher_pid:=new_cnv.parent_publisher_id;
                    aal.publisher_pid:=new_cnv.parent_publisher_id;
                    ail.publisher_pid:=new_cnv.parent_publisher_id;
                    apl.publisher_pid:=new_cnv.parent_publisher_id;
                    IF appl.id IS NOT NULL THEN
                        appl.publisher_pid:=new_cnv.parent_publisher_id;
                    END IF;
		    change_pay:=TRUE;
                END IF;
                -- payments
                IF old_cnv.payin <> new_cnv.payin OR old_cnv.payout <> new_cnv.payout OR change_pay THEN
                    PERFORM update_conversion_rollups(old_cnv_advertiser_id,old_cnv.campaign_id,old_cnv.publisher_id,old_cnv.parent_publisher_id,
                    old_cnv.payin::NUMERIC,COALESCE(old_cnv.parent_payout::NUMERIC,old_cnv.payout::NUMERIC)::NUMERIC,
                    CASE WHEN old_cnv.parent_payout::NUMERIC-old_cnv.payout::NUMERIC > 0::NUMERIC THEN old_cnv.parent_payout::NUMERIC ELSE 0::NUMERIC END,
                        old_cnv.payin::NUMERIC-old_cnv.payout::NUMERIC,old_cnv.modified_date,new_cnv_advertiser_id,new_cnv.campaign_id,new_cnv.publisher_id,
                        new_cnv.parent_publisher_id,new_cnv.payin::NUMERIC,COALESCE(new_cnv.parent_payout::NUMERIC,new_cnv.payout::NUMERIC)::NUMERIC,
                        CASE WHEN new_cnv.parent_payout::NUMERIC-new_cnv.payout::NUMERIC > 0::NUMERIC THEN new_cnv.parent_payout::NUMERIC ELSE 0::NUMERIC END,
                        new_cnv.payin::NUMERIC-new_cnv.payout::NUMERIC,transaction_timestamp(),acl.advertiser_invoice_status,acl.publisher_invoice_status,acl.parent_publisher_invoice_status,conversion_id::BIGINT);
                    acl.pay_in_amt:=new_cnv.payin::NUMERIC;
                    aal.debit_amt:=new_cnv.payin::NUMERIC;
                    ail.credit_amt:=new_cnv.payin::NUMERIC;
                    acl.pay_out_amt:=new_cnv.payout::NUMERIC;
                    ail.debit_amt:=new_cnv.payout::NUMERIC;
                    IF appl.id IS NOT NULL THEN
                        apl.credit_amt:=COALESCE(new_cnv.parent_payout-new_cnv.payout,new_cnv.payout)::NUMERIC;
                        apl.credit_amt:=CASE WHEN new_cnv.parent_payout::NUMERIC > 0 THEN new_cnv.parent_payout::NUMERIC ELSE 0 END;
                    END IF;
                END IF;
            END CASE;
        END CASE;
        PERFORM set_acct_conversion_ledger(acl);
        PERFORM set_acct_advertiser_ledger(aal);
        PERFORM set_acct_internal_ledger(ail);
        PERFORM set_acct_publisher_ledger(apl);
        IF appl.id IS NOT NULL THEN
            PERFORM set_acct_publisher_ledger(appl);
        END IF;
        RETURN TRUE;
        /*
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
        */
     END;
$$;


ALTER FUNCTION w4_application_functions.update_conversion(old_cnv public.engine_conversions, new_cnv public.engine_conversions) OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: engine_clicks; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_clicks (
    id bigint NOT NULL,
    campaign_id integer,
    publisher_id bigint,
    parent_publisher_id bigint,
    redirect_url_id integer,
    consumer_id bigint,
    creative_id integer,
    ip_address inet,
    continent character(2) DEFAULT NULL::bpchar,
    country character varying(255) DEFAULT NULL::character varying,
    region character varying(2) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT (1)::smallint NOT NULL,
    channel bigint,
    nb_dupes integer DEFAULT 0 NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    created_date timestamp with time zone NOT NULL,
    base_uri character varying(250) DEFAULT NULL::character varying,
    referral_url text,
    rollup_id bigint,
    rollup_clicks bigint DEFAULT 0,
    hitpath_ref_id text
);


ALTER TABLE public.engine_clicks OWNER TO w4;

--
-- Name: user_agent_browser_lookup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_agent_browser_lookup (
    id bigint NOT NULL,
    browser_name character varying(255) DEFAULT NULL::character varying,
    browser_version character varying(255) DEFAULT NULL::character varying,
    browser_description character varying(255) DEFAULT NULL::character varying,
    browser_special character varying(32) DEFAULT NULL::character varying
);


ALTER TABLE public.user_agent_browser_lookup OWNER TO w4;

--
-- Name: TABLE user_agent_browser_lookup; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE user_agent_browser_lookup IS 'Allows for compact Browser Indexes';


--
-- Name: user_agent_platform_lookup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_agent_platform_lookup (
    id bigint NOT NULL,
    platform_name character varying(255) DEFAULT NULL::character varying,
    platform_version character varying(255) DEFAULT NULL::character varying,
    platform_description character varying(255) DEFAULT NULL::character varying,
    platform_special character varying(32) DEFAULT NULL::character varying
);


ALTER TABLE public.user_agent_platform_lookup OWNER TO w4;

--
-- Name: TABLE user_agent_platform_lookup; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE user_agent_platform_lookup IS 'Allows for compact Platform Indexes';


--
-- Name: vw_admin_details_traffic; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_admin_details_traffic AS
 SELECT acl.id AS conversion_id,
    COALESCE((clk.campaign_id)::bigint, acl.campaign_id) AS campaign_id,
    cmp.advertiser_id,
    COALESCE(clk.publisher_id, acl.publisher_id) AS publisher_id,
    COALESCE(clk.id, (0)::bigint) AS click_id,
    COALESCE(usp.company_name, (concat(usp.first_name, ' ', usp.last_name))::character varying, ''::character varying) AS publisher_name,
    COALESCE(clk.created_date, acl.created_date) AS click_date,
    (COALESCE(host(clk.ip_address), host(acl.ip_address)))::character(15) AS ip_address,
    (COALESCE(clk.referral_url, acl.referral_url))::character varying(2048) AS referral_url,
    COALESCE(NULLIF((((uapl.platform_name)::text || ' '::text) || (uapl.platform_version)::text), ' '::text), 'Unknown'::text) AS os,
    COALESCE(NULLIF((((uabl.browser_name)::text || ' '::text) || (uabl.browser_version)::text), ' '::text), 'Unknown'::text) AS browser,
    (COALESCE(
        CASE
            WHEN (acl.status < 50) THEN acl.payin
            ELSE (0)::money
        END, (0)::money))::numeric AS pay_in_amt,
    (COALESCE(
        CASE
            WHEN (acl.status < 50) THEN acl.payout
            ELSE (0)::money
        END, (0)::money))::numeric AS pay_out_amt,
        CASE
            WHEN (acl.status < 50) THEN 'approved'::text
            WHEN (acl.status > 50) THEN 'rejected'::text
            ELSE 'null'::text
        END AS status,
    cmp.currency_id
   FROM ((((((engine_clicks clk
   FULL JOIN engine_conversions acl ON ((clk.id = acl.click_id)))
   LEFT JOIN campaigns cmp ON ((COALESCE((clk.campaign_id)::bigint, acl.campaign_id) = cmp.id)))
   LEFT JOIN users usr ON ((COALESCE(clk.publisher_id, acl.publisher_id) = usr.id)))
   LEFT JOIN user_profiles usp ON ((usr.id = usp.user_id)))
   LEFT JOIN user_agent_browser_lookup uabl ON ((COALESCE(clk.browser_id, acl.browser_id) = uabl.id)))
   LEFT JOIN user_agent_platform_lookup uapl ON ((COALESCE(clk.platform_id, acl.platform_id) = uapl.id)))
  ORDER BY clk.created_date DESC;


ALTER TABLE public.vw_admin_details_traffic OWNER TO w4;

SET search_path = w4_application_functions, pg_catalog;

--
-- Name: update_conversion_pay(bigint, numeric, numeric); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_conversion_pay(arg_conversion_id bigint, arg_payin numeric, arg_payout numeric) RETURNS public.vw_admin_details_traffic
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        use_comma TEXT;
        uv TEXT;
        ret_val vw_admin_details_traffic;
    BEGIN        
        use_comma:='';
        uv:='';
        IF arg_payin IS NOT NULL THEN
                uv:=uv || use_comma || $$ payin=$$ || arg_payin;
                use_comma:=',';
        END IF;
        IF arg_payout IS NOT NULL THEN
                uv:=uv || use_comma || $$ payout=$$ || arg_payout;
                use_comma:=',';
        END IF;

        PERFORM * FROM engine_conversions WHERE id=arg_conversion_id;
        IF FOUND THEN
            execute 'UPDATE engine_conversions SET ' || uv || 'WHERE id=' || arg_conversion_id || ';';
        ELSE
            RAISE EXCEPTION 'No conversion found with that id.';
        END IF;
        SELECT INTO ret_val * FROM vw_admin_details_traffic WHERE conversion_id=arg_conversion_id;
        RETURN ret_val;
    END;
$_$;


ALTER FUNCTION w4_application_functions.update_conversion_pay(arg_conversion_id bigint, arg_payin numeric, arg_payout numeric) OWNER TO w4;

--
-- Name: update_conversion_rollups(bigint, bigint, bigint, bigint, money, money, money, money, timestamp with time zone, bigint, bigint, bigint, bigint, money, money, money, money, timestamp with time zone, integer, integer, integer, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_conversion_rollups(oaid bigint, ocid bigint, opid bigint, oppid bigint, oacpa money, opcpa money, oppcpa money, oicpa money, ots timestamp with time zone, naid bigint, ncid bigint, npid bigint, nppid bigint, nacpa money, npcpa money, nppcpa money, nicpa money, nts timestamp with time zone, astatus integer, pstatus integer, ppstatus integer, clickid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        oahoy BIGINT; nahoy BIGINT; aru_hour  "Accounting"."acct_advertiser_rollup_hour";
        oadoy BIGINT; namoy BIGINT; aru_day   "Accounting"."acct_advertiser_rollup_day";
        oamoy BIGINT; nadoy BIGINT; aru_month "Accounting"."acct_advertiser_rollup_month";
        oay BIGINT;   nay BIGINT;   aru_year  "Accounting"."acct_advertiser_rollup_year";
        oihoy BIGINT; nihoy BIGINT; iru_hour  "Accounting"."acct_internal_rollup_hour";
        oidoy BIGINT; nidoy BIGINT; iru_day   "Accounting"."acct_internal_rollup_day";
        oimoy BIGINT; nimoy BIGINT; iru_month "Accounting"."acct_internal_rollup_month";
        oiy BIGINT;   niy BIGINT;   iru_year  "Accounting"."acct_internal_rollup_year";
        ophoy BIGINT; nphoy BIGINT; pru_hour  "Accounting"."acct_publisher_rollup_hour";
        opdoy BIGINT; npdoy BIGINT; pru_day   "Accounting"."acct_publisher_rollup_day";
        opmoy BIGINT; npmoy BIGINT; pru_month "Accounting"."acct_publisher_rollup_month";
        opy BIGINT;   npy BIGINT;   pru_year  "Accounting"."acct_publisher_rollup_year";
        exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
        trans RECORD; do_move_adv BOOLEAN; do_move_int BOOLEAN; do_move_pub BOOLEAN;
    BEGIN
        -- Get Rollup Time Boundaries
        oahoy:=make_hoy(ots); oadoy:=make_doy(ots); oamoy:=make_moy(ots); oay:=make_y(ots);
        oihoy:=make_hoy(ots); oidoy:=make_doy(ots); oimoy:=make_moy(ots); oiy:=make_y(ots);
        ophoy:=make_hoy(ots); opdoy:=make_doy(ots); opmoy:=make_moy(ots); opy:=make_y(ots);
        nahoy:=make_hoy(nts); nadoy:=make_doy(nts); namoy:=make_moy(nts); nay:=make_y(nts);
        nihoy:=make_hoy(nts); nidoy:=make_doy(nts); nimoy:=make_moy(nts); niy:=make_y(nts);
        nphoy:=make_hoy(nts); npdoy:=make_doy(nts); npmoy:=make_moy(nts); npy:=make_y(nts);
         -- Initialize everything to no change
        do_move_adv:=FALSE; do_move_int:=FALSE; do_move_pub:=FALSE;
        -- Check to see if we modify in place or just issue transactions
        IF astatus<>100 AND pstatus<>100 AND acpa <> 0::money AND pcpa <> 0::money THEN
            -- trans_type 1100
            trans:=get_new_acct_transaction_ledger(clickid,1100,aid,cid,pid,NULL,pcpa,acpa,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid,cid,pid,acpa,pcpa,icpa,transaction_timestamp());
        ELSEIF astatus<>100 AND acpa <> 0::money THEN
            -- trans_type 110
            trans:=get_new_acct_transaction_ledger(clickid,110,aid,cid,pid,NULL,0::money,acpa,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid,cid,pid,acpa,0::money,icpa,transaction_timestamp());
        ELSEIF pstatus<>100 AND pcpa <> 0::money THEN
            -- trans_type 510
            trans:=get_new_acct_transaction_ledger(clickid,510,aid,cid,pid,NULL,pcpa,0,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(aid,cid,pid,0::money,pcpa,icpa,transaction_timestamp());
        ELSEIF astatus=100 AND acpa<>0::money THEN
            do_move_adv=TRUE;
            do_move_int=TRUE;
        ELSEIF pstatus=100 AND pcpa<>0::money THEN
            do_move_int=TRUE;
            do_move_pub=TRUE;
        END IF;
                IF ppstatus=100 AND ppcpa<>0::money THEN
            -- Hour
            SELECT INTO pru_hour lookup_acct_publisher_rollup_hour(oaid,ocid,oppid,ophoy,oppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-oppcpa;
                pru_hour.num_conversion:=pru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_hour.a_id:=oaid;
                pru_hour.c_id:=ocid;
                pru_hour.p_id:=oppid;
                pru_hour.cost_per_action:=oppcpa;
                pru_hour.p_hoy:=ophoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:= -1 * oppcpa;
                pru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || oppid || ',publisher_cost_per_action:' || oppcpa || ',hour_of_year:' || ophoy || ',timestamp:' || ots || ')','Publisher hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            SELECT INTO pru_day lookup_acct_publisher_rollup_day(oaid,ocid,oppid,oppdoy,oppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-oppcpa;
                pru_hour.num_conversion:=pru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_day.a_id:=oaid;
                pru_day.c_id:=ocid;
                pru_day.p_id:=oppid;
                pru_day.cost_per_action:=oppcpa;
                pru_day.p_doy:=opdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:= -1 * oppcpa;
                pru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || oppid || ',publisher_cost_per_action:' || oppcpa || ',day_of_year:' || opdoy || ',timestamp:' || ots || ')','Publisher day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            SELECT INTO pru_month lookup_acct_publisher_rollup_month(oaid,ocid,oppid,opmoy,oppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment-oppcpa;
                pru_month.num_conversion:=pru_month.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_month.a_id:=oaid;
                pru_month.c_id:=ocid;
                pru_month.p_id:=oppid;
                pru_month.cost_per_action:=oppcpa;
                pru_month.p_moy:=opmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:= -1 * oppcpa;
                pru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || oppid || ',publisher_cost_per_action:' || oppcpa || ',month_of_year:' || opmoy || ',timestamp:' || ots || ')','Publisher month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            SELECT INTO pru_year lookup_acct_publisher_rollup_year(oaid,ocid,oppid,opy,oppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment-oppcpa;
                pru_year.num_conversion:=pru_year.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_year.a_id:=oaid;
                pru_year.c_id:=ocid;
                pru_year.p_id:=oppid;
                pru_year.cost_per_action:=oppcpa;
                pru_year.p_y:=opy;
                pru_year.status:=100;
                pru_year.total_period_adjustment:= -1 * oppcpa;
                pru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || oppid || ',publisher_cost_per_action:' || oppcpa || ',year_of_year:' || opy || ',timestamp:' || ots || ')','Publisher year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
            -- Now add them back
            -- Hour
            SELECT INTO pru_hour lookup_acct_publisher_rollup_hour(naid,ncid,npid,nphoy,npcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+nppcpa;
                pru_hour.num_conversion:=pru_hour.num_converions+1;
            ELSE
                pru_hour.a_id:=naid;
                pru_hour.c_id:=ncid;
                pru_hour.p_id:=nppid;
                pru_hour.cost_per_action:=nppcpa;
                pru_hour.p_hoy:=nphoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=nppcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            SELECT INTO pru_day lookup_acct_publisher_rollup_day(naid,ncid,nppid,npdoy,nppcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+nppcpa;
                pru_day.num_conversion:=pru_day.num_converions+1;
            ELSE
                pru_day.a_id:=naid;
                pru_day.c_id:=ncid;
                pru_day.p_id:=nppid;
                pru_day.cost_per_action:=nppcpa;
                pru_day.p_doy:=npdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=nppcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            SELECT INTO pru_month lookup_acct_publisher_rollup_month(naid,ncid,nppid,npmoy,nppcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+nppcpa;
                pru_month.num_conversion:=pru_month.num_converions+1;
            ELSE
                pru_month.a_id:=naid;
                pru_month.c_id:=ncid;
                pru_month.p_id:=nppid;
                pru_month.cost_per_action:=nppcpa;
                pru_month.p_moy:=npmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=nppcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            SELECT INTO pru_year lookup_acct_publisher_rollup_year(naid,ncid,nppid,npy,nppcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+nppcpa;
                pru_year.num_conversion:=pru_year.num_converions+1;
            ELSE
                pru_year.a_id:=naid;
                pru_year.c_id:=ncid;
                pru_year.p_id:=nppid;
                pru_year.cost_per_action:=nppcpa;
                pru_year.p_y:=npy;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=nppcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        ELSEIF nppcpa-oppcpa<>0::money THEN
            -- trans_type 510
            trans:=get_new_acct_transaction_ledger(clickid,510,naid,ncid,nppid,NULL,nppcpa-oppcpa,0,transaction_timestamp(),(SELECT created_date FROM engine_clicks WHERE id=clickid),NULL,1);
            PERFORM add_conversion_to_rollups(naid,ncid,nppid,0,-1 * nppcpa-oppcpa,-1 * nicpa,transaction_timestamp());
        END IF;
        -- Compare to see if anything relevant changed
        IF oaid <> naid     THEN do_move_adv:=TRUE; do_move_int:=TRUE; do_move_pub:=TRUE; END IF; -- Moving advertisers
        IF ocid <> ncid     THEN do_move_adv:=TRUE; do_move_int:=TRUE; do_move_pub:=TRUE; END IF; -- Moving campaigns
        IF opid <> npid     THEN do_move_pub:=TRUE; do_move_int:=TRUE; do_move_pub:=TRUE; END IF; -- Moving publishers
        IF ots <> nts       THEN do_move_adv:=TRUE; do_move_int:=TRUE; do_move_pub:=TRUE; END IF; -- Moving Time Period
        IF oacpa <> nacpa   THEN do_move_adv:=TRUE; END IF; -- Moving Advertiser CPA
        IF oicpa <> nicpa   THEN do_move_int:=TRUE; END IF; -- Moving Internal CPA
        IF opcpa <> npcpa   THEN do_move_pub:=TRUE; END IF; -- Moving Publisher CPA
        IF do_move_adv=FALSE AND do_move_int=FALSE AND do_move_pub=FALSE THEN RETURN TRUE; END IF; -- Nothing relevant changed so nothing to update
        -- Modify existing rollups
        IF do_move_adv THEN
            -- Update Advertiser Rollups
            -- Hour
            SELECT INTO aru_hour lookup_acct_advertiser_rollup_hour(oaid,ocid,opid,oahoy,oacpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment-oacpa;
                aru_hour.num_conversion:=aru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_hour.a_id:=oaid;
                aru_hour.c_id:=ocid;
                aru_hour.p_id:=opid;
                aru_hour.cost_per_action:=oacpa;
                aru_hour.a_hoy:=oahoy;
                aru_hour.status:=100;
                aru_hour.total_period_adjustment:= -1 * oacpa;
                aru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',advertiser_cost_per_action:' || oacpa || ',hour_of_year:' || oahoy || ',timestamp:' || ots || ')','Advertiser hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            SELECT INTO aru_day lookup_acct_advertiser_rollup_day(oaid,ocid,opid,oadoy,oacpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment-oacpa;
                aru_day.num_conversion:=aru_day.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_day.a_id:=oaid;
                aru_day.c_id:=ocid;
                aru_day.p_id:=opid;
                aru_day.cost_per_action:=oacpa;
                aru_day.a_doy:=oadoy;
                aru_day.status:=100;
                aru_day.total_period_adjustment:= -1 * oacpa;
                aru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',advertiser_cost_per_action:' || oacpa || ',day_of_year:' || oadoy || ',timestamp:' || ots || ')','Advertiser day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            SELECT INTO aru_month lookup_acct_advertiser_rollup_month(oaid,ocid,opid,oamoy,oacpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment-oacpa;
                aru_month.num_conversion:=aru_month.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_month.a_id:=oaid;
                aru_month.c_id:=ocid;
                aru_month.p_id:=opid;
                aru_month.cost_per_action:=oacpa;
                aru_month.a_moy:=oamoy;
                aru_month.status:=100;
                aru_month.total_period_adjustment:= -1 * oacpa;
                aru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',advertiser_cost_per_action:' || oacpa || ',month_of_year:' || oamoy || ',timestamp:' || ots || ')','Advertiser month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            SELECT INTO aru_year lookup_acct_advertiser_rollup_year(oaid,ocid,opid,oay,oacpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment-oacpa;
                aru_year.num_conversion:=aru_year.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                aru_year.a_id:=oaid;
                aru_year.c_id:=ocid;
                aru_year.p_id:=opid;
                aru_year.cost_per_action:=oacpa;
                aru_year.a_y:=oay;
                aru_year.status:=100;
                aru_year.total_period_adjustment:= -1 * oacpa;
                aru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',advertiser_cost_per_action:' || oacpa || ',year:' || oay || ',timestamp:' || ots || ')','Advertiser year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_advertiser_rollup_year(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
            -- Update Advertiser Rollups
            -- Hour
            SELECT INTO aru_hour lookup_acct_advertiser_rollup_hour(naid,ncid,npid,nahoy,nacpa);
            IF FOUND THEN
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment+nacpa;
                aru_hour.num_conversion:=aru_hour.num_converions+1;
            ELSE
                aru_hour.a_id:=naid;
                aru_hour.c_id:=ncid;
                aru_hour.p_id:=npid;
                aru_hour.cost_per_action:=nacpa;
                aru_hour.a_hoy:=nahoy;
                aru_hour.status:=100;
                aru_hour.total_period_adjustment:=nacpa;
                aru_hour.num_conversion:=1;
            END IF;
            -- Day
            SELECT INTO aru_day lookup_acct_advertiser_rollup_day(naid,ncid,npid,nadoy,nacpa);
            IF FOUND THEN
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment+nacpa;
                aru_day.num_conversion:=aru_day.num_converions+1;
            ELSE
                aru_day.a_id:=naid;
                aru_day.c_id:=ncid;
                aru_day.p_id:=npid;
                aru_day.cost_per_action:=nacpa;
                aru_day.a_doy:=nadoy;
                aru_day.status:=100;
                aru_day.total_period_adjustment:=nacpa;
                aru_day.num_conversion:=1;
            END IF;
            -- Month
            SELECT INTO aru_month lookup_acct_advertiser_rollup_month(naid,ncid,npid,namoy,nacpa);
            IF FOUND THEN
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment+nacpa;
                aru_month.num_conversion:=aru_month.num_converions+1;
            ELSE
                aru_month.a_id:=naid;
                aru_month.c_id:=ncid;
                aru_month.p_id:=npid;
                aru_month.cost_per_action:=nacpa;
                aru_month.a_moy:=namoy;
                aru_month.status:=100;
                aru_month.total_period_adjustment:=nacpa;
                aru_month.num_conversion:=1;
            END IF;
            -- Year
            SELECT INTO aru_year lookup_acct_advertiser_rollup_year(naid,ncid,npid,nay,nacpa);
            IF FOUND THEN
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment+nacpa;
                aru_year.num_conversion:=aru_year.num_converions+1;
            ELSE
                aru_year.a_id:=naid;
                aru_year.c_id:=ncid;
                aru_year.p_id:=npid;
                aru_year.cost_per_action:=nacpa;
                aru_year.a_y:=nay;
                aru_year.status:=100;
                aru_year.total_period_adjustment:=nacpa;
                aru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_advertiser_rollup_year(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
        END IF;
        IF do_move_int THEN
            -- Update Internal Rollups
            -- Hour
            SELECT INTO iru_hour lookup_acct_internal_rollup_hour(oaid,ocid,opid,oihoy,oicpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment-oicpa;
                iru_hour.num_conversion:=iru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_hour.a_id:=oaid;
                iru_hour.c_id:=ocid;
                iru_hour.p_id:=opid;
                iru_hour.cost_per_action:=oicpa;
                iru_hour.i_hoy:=oihoy;
                iru_hour.status:=100;
                iru_hour.total_period_adjustment:= -1 * oicpa;
                iru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',internal_cost_per_action:' || oicpa || ',hour_of_year:' || oihoy || ',timestamp:' || ots || ')','Internal hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            SELECT INTO iru_day lookup_acct_internal_rollup_day(oaid,ocid,opid,oidoy,oicpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment-oicpa;
                iru_day.num_conversion:=iru_day.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_day.a_id:=oaid;
                iru_day.c_id:=ocid;
                iru_day.p_id:=opid;
                iru_day.cost_per_action:=oicpa;
                iru_day.i_doy:=oidoy;
                iru_day.status:=100;
                iru_day.total_period_adjustment:= -1 * oicpa;
                iru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',internal_cost_per_action:' || oicpa || ',day_of_year:' || oidoy || ',timestamp:' || ots || ')','Internal day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            SELECT INTO iru_month lookup_acct_internal_rollup_month(oaid,ocid,opid,oimoy,oicpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment-oicpa;
                iru_month.num_conversion:=iru_month.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_month.a_id:=oaid;
                iru_month.c_id:=ocid;
                iru_month.p_id:=opid;
                iru_month.cost_per_action:=oicpa;
                iru_month.i_moy:=oimoy;
                iru_month.status:=100;
                iru_month.total_period_adjustment:= -1 * oicpa;
                iru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',internal_cost_per_action:' || oicpa || ',month_of_year:' || oimoy || ',timestamp:' || ots || ')','Internal month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            SELECT INTO iru_year lookup_acct_internal_rollup_year(oaid,ocid,opid,oiy,oicpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment-oicpa;
                iru_year.num_conversion:=iru_year.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                iru_year.a_id:=oaid;
                iru_year.c_id:=ocid;
                iru_year.p_id:=opid;
                iru_year.cost_per_action:=oicpa;
                iru_year.i_y:=oiy;
                iru_year.status:=100;
                iru_year.total_period_adjustment:= -1 * oicpa;
                iru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',internal_cost_per_action:' || oicpa || ',year:' || oiy || ',timestamp:' || ots || ')','Internal year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_internal_rollup_year(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
            -- Update Internal Rollups
            -- Hour
            SELECT INTO iru_hour lookup_acct_internal_rollup_hour(naid,ncid,npid,nihoy,nicpa);
            IF FOUND THEN
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment+nicpa;
                iru_hour.num_conversion:=iru_hour.num_converions+1;
            ELSE
                iru_hour.a_id:=naid;
                iru_hour.c_id:=ncid;
                iru_hour.p_id:=npid;
                iru_hour.cost_per_action:=nicpa;
                iru_hour.i_hoy:=nihoy;
                iru_hour.status:=100;
                iru_hour.total_period_adjustment:=nicpa;
                iru_hour.num_conversion:=1;
            END IF;
            -- Day
            SELECT INTO iru_day lookup_acct_internal_rollup_day(naid,ncid,npid,nidoy,nicpa);
            IF FOUND THEN
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment+nicpa;
                iru_day.num_conversion:=iru_day.num_converions+1;
            ELSE
                iru_day.a_id:=naid;
                iru_day.c_id:=ncid;
                iru_day.p_id:=npid;
                iru_day.cost_per_action:=nicpa;
                iru_day.i_doy:=nidoy;
                iru_day.status:=100;
                iru_day.total_period_adjustment:=nicpa;
                iru_day.num_conversion:=1;
            END IF;
            -- Month
            SELECT INTO iru_month lookup_acct_internal_rollup_month(naid,ncid,npid,nimoy,nicpa);
            IF FOUND THEN
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment+nicpa;
                iru_month.num_conversion:=iru_month.num_converions+1;
            ELSE
                iru_month.a_id:=naid;
                iru_month.c_id:=ncid;
                iru_month.p_id:=npid;
                iru_month.cost_per_action:=nicpa;
                iru_month.i_moy:=nimoy;
                iru_month.status:=100;
                iru_month.total_period_adjustment:=nicpa;
                iru_month.num_conversion:=1;
            END IF;
            -- Year
            SELECT INTO iru_year lookup_acct_internal_rollup_year(naid,ncid,npid,niy,nicpa);
            IF FOUND THEN
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment+nicpa;
                iru_year.num_conversion:=iru_year.num_converions+1;
            ELSE
                iru_year.a_id:=naid;
                iru_year.c_id:=ncid;
                iru_year.p_id:=npid;
                iru_year.cost_per_action:=nicpa;
                iru_year.i_y:=niy;
                iru_year.status:=100;
                iru_year.total_period_adjustment:=nicpa;
                iru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_internal_rollup_year(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
        END IF;
        IF do_move_pub THEN
            -- Update Advertiser Rollups
            -- Hour
            SELECT INTO pru_hour lookup_acct_publisher_rollup_hour(oaid,ocid,opid,ophoy,opcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-opcpa;
                pru_hour.num_conversion:=pru_hour.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_hour.a_id:=oaid;
                pru_hour.c_id:=ocid;
                pru_hour.p_id:=opid;
                pru_hour.cost_per_action:=opcpa;
                pru_hour.p_hoy:=ophoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:= -1 * opcpa;
                pru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',publisher_cost_per_action:' || opcpa || ',hour_of_year:' || ophoy || ',timestamp:' || ots || ')','Publisher hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            SELECT INTO pru_day lookup_acct_publisher_rollup_day(oaid,ocid,opid,opdoy,opcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment-opcpa;
                pru_day.num_conversion:=pru_day.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_day.a_id:=oaid;
                pru_day.c_id:=ocid;
                pru_day.p_id:=opid;
                pru_day.cost_per_action:=opcpa;
                pru_day.p_doy:=opdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:= -1 * opcpa;
                pru_day.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',publisher_cost_per_action:' || opcpa || ',day_of_year:' || opdoy || ',timestamp:' || ots || ')','Publisher day conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Month
            SELECT INTO pru_month lookup_acct_publisher_rollup_month(oaid,ocid,opid,opmoy,opcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment-opcpa;
                pru_month.num_conversion:=pru_month.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_month.a_id:=oaid;
                pru_month.c_id:=ocid;
                pru_month.p_id:=opid;
                pru_month.cost_per_action:=opcpa;
                pru_month.p_moy:=opmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:= -1 * opcpa;
                pru_month.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',publisher_cost_per_action:' || opcpa || ',month_of_year:' || opmoy || ',timestamp:' || ots || ')','Publisher month conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Year
            SELECT INTO pru_year lookup_acct_publisher_rollup_year(oaid,ocid,opid,opy,opcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment-opcpa;
                pru_year.num_conversion:=pru_year.num_converions-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_year.a_id:=oaid;
                pru_year.c_id:=ocid;
                pru_year.p_id:=opid;
                pru_year.cost_per_action:=opcpa;
                pru_year.p_y:=opy;
                pru_year.status:=100;
                pru_year.total_period_adjustment:= -1 * opcpa;
                pru_year.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','update_conversion_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || opid || ',publisher_cost_per_action:' || opcpa || ',year:' || opy || ',timestamp:' || ots || ')','Publisher year conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
            -- Update Publisher Rollups
            -- Hour
            SELECT INTO pru_hour lookup_acct_publisher_rollup_hour(naid,ncid,npid,nphoy,npcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+npcpa;
                pru_hour.num_conversion:=pru_hour.num_converions+1;
            ELSE
                pru_hour.a_id:=naid;
                pru_hour.c_id:=ncid;
                pru_hour.p_id:=npid;
                pru_hour.cost_per_action:=npcpa;
                pru_hour.p_hoy:=nphoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=npcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            SELECT INTO pru_day lookup_acct_publisher_rollup_day(naid,ncid,npid,npdoy,npcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+npcpa;
                pru_day.num_conversion:=pru_day.num_converions+1;
            ELSE
                pru_day.a_id:=naid;
                pru_day.c_id:=ncid;
                pru_day.p_id:=npid;
                pru_day.cost_per_action:=npcpa;
                pru_day.p_doy:=npdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=npcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            SELECT INTO pru_month lookup_acct_publisher_rollup_month(naid,ncid,npid,npmoy,npcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+npcpa;
                pru_month.num_conversion:=pru_month.num_converions+1;
            ELSE
                pru_month.a_id:=naid;
                pru_month.c_id:=ncid;
                pru_month.p_id:=npid;
                pru_month.cost_per_action:=npcpa;
                pru_month.p_moy:=npmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=npcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            SELECT INTO pru_year lookup_acct_publisher_rollup_year(naid,ncid,npid,npy,npcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+npcpa;
                pru_year.num_conversion:=pru_year.num_converions+1;
            ELSE
                pru_year.a_id:=naid;
                pru_year.c_id:=ncid;
                pru_year.p_id:=npid;
                pru_year.cost_per_action:=npcpa;
                pru_year.p_y:=npy;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=npcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        RETURN TRUE;
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
    END
$$;


ALTER FUNCTION w4_application_functions.update_conversion_rollups(oaid bigint, ocid bigint, opid bigint, oppid bigint, oacpa money, opcpa money, oppcpa money, oicpa money, ots timestamp with time zone, naid bigint, ncid bigint, npid bigint, nppid bigint, nacpa money, npcpa money, nppcpa money, nicpa money, nts timestamp with time zone, astatus integer, pstatus integer, ppstatus integer, clickid bigint) OWNER TO w4;

--
-- Name: update_conversion_rollups(bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, integer, integer, integer, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_conversion_rollups(oaid bigint, ocid bigint, opid bigint, oppid bigint, oacpa numeric, opcpa numeric, oppcpa numeric, oicpa numeric, ots timestamp with time zone, naid bigint, ncid bigint, npid bigint, nppid bigint, nacpa numeric, npcpa numeric, nppcpa numeric, nicpa numeric, nts timestamp with time zone, astatus integer, pstatus integer, ppstatus integer, clickid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        oahoy BIGINT; nahoy BIGINT; aru_hour  acct_advertiser_rollup_hour;
        oadoy BIGINT; namoy BIGINT; aru_day   acct_advertiser_rollup_day;
        oamoy BIGINT; nadoy BIGINT; aru_month acct_advertiser_rollup_month;
        oay BIGINT;   nay BIGINT;   aru_year  acct_advertiser_rollup_year;
        oihoy BIGINT; nihoy BIGINT; iru_hour  acct_internal_rollup_hour;
        oidoy BIGINT; nidoy BIGINT; iru_day   acct_internal_rollup_day;
        oimoy BIGINT; nimoy BIGINT; iru_month acct_internal_rollup_month;
        oiy BIGINT;   niy BIGINT;   iru_year  acct_internal_rollup_year;
        ophoy BIGINT; nphoy BIGINT; pru_hour  acct_publisher_rollup_hour;
        opdoy BIGINT; npdoy BIGINT; pru_day   acct_publisher_rollup_day;
        opmoy BIGINT; npmoy BIGINT; pru_month acct_publisher_rollup_month;
        opy BIGINT;   npy BIGINT;   pru_year  acct_publisher_rollup_year;
        exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
        trans RECORD; do_move_adv BOOLEAN; do_move_int BOOLEAN; do_move_pub BOOLEAN;
    BEGIN
        -- Get Rollup Time Boundaries
        oahoy:=make_hoy(ots); oadoy:=make_doy(ots); oamoy:=make_moy(ots); oay:=make_y(ots);
        oihoy:=make_hoy(ots); oidoy:=make_doy(ots); oimoy:=make_moy(ots); oiy:=make_y(ots);
        ophoy:=make_hoy(ots); opdoy:=make_doy(ots); opmoy:=make_moy(ots); opy:=make_y(ots);
        nahoy:=make_hoy(nts); nadoy:=make_doy(nts); namoy:=make_moy(nts); nay:=make_y(nts);
        nihoy:=make_hoy(nts); nidoy:=make_doy(nts); nimoy:=make_moy(nts); niy:=make_y(nts);
        nphoy:=make_hoy(nts); npdoy:=make_doy(nts); npmoy:=make_moy(nts); npy:=make_y(nts);
         -- Initialize everything to no change
        do_move_adv:=FALSE; do_move_int:=FALSE; do_move_pub:=FALSE;
        -- Check to see if we modify in place or just issue transactions
        IF astatus<>100 AND pstatus<>100 AND nacpa <> 0::numeric AND npcpa <> 0::numeric THEN
            -- trans_type 1100
            trans:=get_new_acct_transaction_ledger(clickid,1100,naid,ncid,npid,NULL,npcpa,nacpa,transaction_timestamp(),COALESCE((SELECT created_date FROM engine_clicks WHERE id=clickid),transaction_timestamp()),NULL,1);
            PERFORM add_conversion_to_rollups(naid,ncid,npid,nppid,nacpa,npcpa,nppcpa,nicpa,transaction_timestamp());
        ELSEIF astatus<>100 AND nacpa <> 0::numeric THEN
            -- trans_type 110
            trans:=get_new_acct_transaction_ledger(clickid,110,naid,ncid,npid,NULL,0::numeric,nacpa,transaction_timestamp(),COALESCE((SELECT created_date FROM engine_clicks WHERE id=clickid),transaction_timestamp()),NULL,1);
            PERFORM add_conversion_to_rollups(naid,ncid,npid,nppid,nacpa,0::numeric,0::numeric,nicpa,transaction_timestamp());
        ELSEIF pstatus<>100 AND npcpa <> 0::numeric THEN
            -- trans_type 510
            trans:=get_new_acct_transaction_ledger(clickid,510,naid,ncid,npid,NULL,npcpa,0,transaction_timestamp(),COALESCE((SELECT created_date FROM engine_clicks WHERE id=clickid),transaction_timestamp()),NULL,1);
            PERFORM add_conversion_to_rollups(naid,ncid,npid,nppid,0::numeric,npcpa,nppcpa,nicpa,transaction_timestamp());
        ELSEIF astatus=100 AND nacpa<>0::numeric THEN
            do_move_adv=TRUE;
            do_move_int=TRUE;
        ELSEIF pstatus=100 AND npcpa<>0::numeric THEN
            do_move_int=TRUE;
            do_move_pub=TRUE;
        END IF;
                IF ppstatus=100 AND nppcpa<>0::numeric THEN
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(oaid,ocid,oppid,ophoy,oppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-oppcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion-1;
            ELSE
                -- For Completeness, this should NEVER happen
                pru_hour.a_id:=oaid;
                pru_hour.c_id:=ocid;
                pru_hour.p_id:=oppid;
                pru_hour.cost_per_action:=oppcpa;
                pru_hour.p_hoy:=ophoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:= -1 * oppcpa;
                pru_hour.num_conversion:= -1;
                PERFORM log_potential_data_anomaly('accounting rollup trigger calls','remove_conversion_from_rollups','(advertiser_id:' || oaid || ',campaign_id:' || ocid || ',publisher_id:' || oppid || ',publisher_cost_per_action:' || oppcpa || ',hour_of_year:' || ophoy || ',timestamp:' || ots || ')','Publisher hour conversion rollup lookup failed on REMOVE operation.','Removing a member value from non-existant aggregates indicates member or aggregate corruption','HIGH');
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(oaid,ocid,oppid,oppdoy,oppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-oppcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion-1;
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(oaid,ocid,oppid,opmoy,oppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment-oppcpa;
                pru_month.num_conversion:=pru_month.num_conversion-1;
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(oaid,ocid,oppid,opy,oppcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment-oppcpa;
                pru_year.num_conversion:=pru_year.num_conversion-1;
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
            -- Now add them back
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(naid,ncid,npid,nphoy,npcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+nppcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion+1;
            ELSE
                pru_hour.a_id:=naid;
                pru_hour.c_id:=ncid;
                pru_hour.p_id:=nppid;
                pru_hour.cost_per_action:=nppcpa;
                pru_hour.p_hoy:=nphoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=nppcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(naid,ncid,nppid,npdoy,nppcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+nppcpa;
                pru_day.num_conversion:=pru_day.num_conversion+1;
            ELSE
                pru_day.a_id:=naid;
                pru_day.c_id:=ncid;
                pru_day.p_id:=nppid;
                pru_day.cost_per_action:=nppcpa;
                pru_day.p_doy:=npdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=nppcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(naid,ncid,nppid,npmoy,nppcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+nppcpa;
                pru_month.num_conversion:=pru_month.num_conversion+1;
            ELSE
                pru_month.a_id:=naid;
                pru_month.c_id:=ncid;
                pru_month.p_id:=nppid;
                pru_month.cost_per_action:=nppcpa;
                pru_month.p_moy:=npmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=nppcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(naid,ncid,nppid,npy,nppcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+nppcpa;
                pru_year.num_conversion:=pru_year.num_conversion+1;
            ELSE
                pru_year.a_id:=naid;
                pru_year.c_id:=ncid;
                pru_year.p_id:=nppid;
                pru_year.cost_per_action:=nppcpa;
                pru_year.p_y:=npy;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=nppcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        ELSEIF nppcpa-oppcpa<>0::numeric THEN
            -- trans_type 510
            trans:=get_new_acct_transaction_ledger(clickid,510,naid,ncid,nppid,NULL,nppcpa-oppcpa,0,transaction_timestamp(),COALESCE((SELECT created_date FROM engine_clicks WHERE id=clickid),transaction_timestamp()),NULL,1);
            PERFORM add_conversion_to_rollups(naid,ncid,nppid,0,-1 * nppcpa-oppcpa,-1 * nicpa,transaction_timestamp());
        END IF;
        -- Compare to see if anything relevant changed
        IF oaid <> naid     THEN do_move_adv:=TRUE; do_move_int:=TRUE; do_move_pub:=TRUE; END IF; -- Moving advertisers
        IF ocid <> ncid     THEN do_move_adv:=TRUE; do_move_int:=TRUE; do_move_pub:=TRUE; END IF; -- Moving campaigns
        IF opid <> npid     THEN do_move_pub:=TRUE; do_move_int:=TRUE; do_move_pub:=TRUE; END IF; -- Moving publishers
        IF ots <> nts       THEN do_move_adv:=TRUE; do_move_int:=TRUE; do_move_pub:=TRUE; END IF; -- Moving Time Period
        IF oacpa <> nacpa   THEN do_move_adv:=TRUE; END IF; -- Moving Advertiser CPA
        IF oicpa <> nicpa   THEN do_move_int:=TRUE; END IF; -- Moving Internal CPA
        IF opcpa <> npcpa   THEN do_move_pub:=TRUE; END IF; -- Moving Publisher CPA
        IF do_move_adv=FALSE AND do_move_int=FALSE AND do_move_pub=FALSE THEN RETURN TRUE; END IF; -- Nothing relevant changed so nothing to update
        -- Modify existing rollups
        IF do_move_adv THEN
            -- Update Advertiser Rollups
            -- Hour
            aru_hour:=lookup_acct_advertiser_rollup_hour(oaid,ocid,opid,oahoy,oacpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment-oacpa;
                aru_hour.num_conversion:=aru_hour.num_conversion-1;
            END IF;
            -- Day
            aru_day:=lookup_acct_advertiser_rollup_day(oaid,ocid,opid,oadoy,oacpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment-oacpa;
                aru_day.num_conversion:=aru_day.num_conversion-1;
            END IF;
            -- Month
            aru_month:=lookup_acct_advertiser_rollup_month(oaid,ocid,opid,oamoy,oacpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment-oacpa;
                aru_month.num_conversion:=aru_month.num_conversion-1;
            END IF;
            -- Year
            aru_year:=lookup_acct_advertiser_rollup_year(oaid,ocid,opid,oay,oacpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment-oacpa;
                aru_year.num_conversion:=aru_year.num_conversion-1;
            END IF;
            PERFORM save_acct_advertiser_rollup_hour(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
            -- Update Advertiser Rollups
            -- Hour
            aru_hour:=lookup_acct_advertiser_rollup_hour(naid,ncid,npid,nahoy,nacpa);
            IF FOUND THEN
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment+nacpa;
                aru_hour.num_conversion:=aru_hour.num_conversion+1;
            ELSE
                aru_hour.a_id:=naid;
                aru_hour.c_id:=ncid;
                aru_hour.p_id:=npid;
                aru_hour.cost_per_action:=nacpa;
                aru_hour.a_hoy:=nahoy;
                aru_hour.status:=100;
                aru_hour.total_period_adjustment:=nacpa;
                aru_hour.num_conversion:=1;
            END IF;
            -- Day
            aru_day:=lookup_acct_advertiser_rollup_day(naid,ncid,npid,nadoy,nacpa);
            IF FOUND THEN
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment+nacpa;
                aru_day.num_conversion:=aru_day.num_conversion+1;
            ELSE
                aru_day.a_id:=naid;
                aru_day.c_id:=ncid;
                aru_day.p_id:=npid;
                aru_day.cost_per_action:=nacpa;
                aru_day.a_doy:=nadoy;
                aru_day.status:=100;
                aru_day.total_period_adjustment:=nacpa;
                aru_day.num_conversion:=1;
            END IF;
            -- Month
            aru_month:=lookup_acct_advertiser_rollup_month(naid,ncid,npid,namoy,nacpa);
            IF FOUND THEN
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment+nacpa;
                aru_month.num_conversion:=aru_month.num_conversion+1;
            ELSE
                aru_month.a_id:=naid;
                aru_month.c_id:=ncid;
                aru_month.p_id:=npid;
                aru_month.cost_per_action:=nacpa;
                aru_month.a_moy:=namoy;
                aru_month.status:=100;
                aru_month.total_period_adjustment:=nacpa;
                aru_month.num_conversion:=1;
            END IF;
            -- Year
            aru_year:=lookup_acct_advertiser_rollup_year(naid,ncid,npid,nay,nacpa);
            IF FOUND THEN
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment+nacpa;
                aru_year.num_conversion:=aru_year.num_conversion+1;
            ELSE
                aru_year.a_id:=naid;
                aru_year.c_id:=ncid;
                aru_year.p_id:=npid;
                aru_year.cost_per_action:=nacpa;
                aru_year.a_y:=nay;
                aru_year.status:=100;
                aru_year.total_period_adjustment:=nacpa;
                aru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_advertiser_rollup_hour(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
        END IF;
        IF do_move_int THEN
            -- Update Internal Rollups
            -- Hour
            iru_hour:=lookup_acct_internal_rollup_hour(oaid,ocid,opid,oihoy,oicpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment-oicpa;
                iru_hour.num_conversion:=iru_hour.num_conversion-1;
            END IF;
            -- Day
            iru_day:=lookup_acct_internal_rollup_day(oaid,ocid,opid,oidoy,oicpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment-oicpa;
                iru_day.num_conversion:=iru_day.num_conversion-1;
            END IF;
            -- Month
            iru_month:=lookup_acct_internal_rollup_month(oaid,ocid,opid,oimoy,oicpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment-oicpa;
                iru_month.num_conversion:=iru_month.num_conversion-1;
            END IF;
            -- Year
            iru_year:=lookup_acct_internal_rollup_year(oaid,ocid,opid,oiy,oicpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment-oicpa;
                iru_year.num_conversion:=iru_year.num_conversion-1;
            END IF;
            PERFORM save_acct_internal_rollup_hour(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
            -- Update Internal Rollups
            -- Hour
            iru_hour:=lookup_acct_internal_rollup_hour(naid,ncid,npid,nihoy,nicpa);
            IF FOUND THEN
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment+nicpa;
                iru_hour.num_conversion:=iru_hour.num_conversion+1;
            ELSE
                iru_hour.a_id:=naid;
                iru_hour.c_id:=ncid;
                iru_hour.p_id:=npid;
                iru_hour.cost_per_action:=nicpa;
                iru_hour.i_hoy:=nihoy;
                iru_hour.status:=100;
                iru_hour.total_period_adjustment:=nicpa;
                iru_hour.num_conversion:=1;
            END IF;
            -- Day
            iru_day:=lookup_acct_internal_rollup_day(naid,ncid,npid,nidoy,nicpa);
            IF FOUND THEN
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment+nicpa;
                iru_day.num_conversion:=iru_day.num_conversion+1;
            ELSE
                iru_day.a_id:=naid;
                iru_day.c_id:=ncid;
                iru_day.p_id:=npid;
                iru_day.cost_per_action:=nicpa;
                iru_day.i_doy:=nidoy;
                iru_day.status:=100;
                iru_day.total_period_adjustment:=nicpa;
                iru_day.num_conversion:=1;
            END IF;
            -- Month
            iru_month:=lookup_acct_internal_rollup_month(naid,ncid,npid,nimoy,nicpa);
            IF FOUND THEN
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment+nicpa;
                iru_month.num_conversion:=iru_month.num_conversion+1;
            ELSE
                iru_month.a_id:=naid;
                iru_month.c_id:=ncid;
                iru_month.p_id:=npid;
                iru_month.cost_per_action:=nicpa;
                iru_month.i_moy:=nimoy;
                iru_month.status:=100;
                iru_month.total_period_adjustment:=nicpa;
                iru_month.num_conversion:=1;
            END IF;
            -- Year
            iru_year:=lookup_acct_internal_rollup_year(naid,ncid,npid,niy,nicpa);
            IF FOUND THEN
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment+nicpa;
                iru_year.num_conversion:=iru_year.num_conversion+1;
            ELSE
                iru_year.a_id:=naid;
                iru_year.c_id:=ncid;
                iru_year.p_id:=npid;
                iru_year.cost_per_action:=nicpa;
                iru_year.i_y:=niy;
                iru_year.status:=100;
                iru_year.total_period_adjustment:=nicpa;
                iru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_internal_rollup_hour(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
        END IF;
        IF do_move_pub THEN
            -- Update Advertiser Rollups
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(oaid,ocid,opid,ophoy,opcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment-opcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion-1;
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(oaid,ocid,opid,opdoy,opcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment-opcpa;
                pru_day.num_conversion:=pru_day.num_conversion-1;
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(oaid,ocid,opid,opmoy,opcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment-opcpa;
                pru_month.num_conversion:=pru_month.num_conversion-1;
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(oaid,ocid,opid,opy,opcpa);
            IF FOUND THEN
                -- For Completeness, this should ALWAYS happen
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment-opcpa;
                pru_year.num_conversion:=pru_year.num_conversion-1;
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
            -- Update Publisher Rollups
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(naid,ncid,npid,nphoy,npcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+npcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion+1;
            ELSE
                pru_hour.a_id:=naid;
                pru_hour.c_id:=ncid;
                pru_hour.p_id:=npid;
                pru_hour.cost_per_action:=npcpa;
                pru_hour.p_hoy:=nphoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=npcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(naid,ncid,npid,npdoy,npcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+npcpa;
                pru_day.num_conversion:=pru_day.num_conversion+1;
            ELSE
                pru_day.a_id:=naid;
                pru_day.c_id:=ncid;
                pru_day.p_id:=npid;
                pru_day.cost_per_action:=npcpa;
                pru_day.p_doy:=npdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=npcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(naid,ncid,npid,npmoy,npcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+npcpa;
                pru_month.num_conversion:=pru_month.num_conversion+1;
            ELSE
                pru_month.a_id:=naid;
                pru_month.c_id:=ncid;
                pru_month.p_id:=npid;
                pru_month.cost_per_action:=npcpa;
                pru_month.p_moy:=npmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=npcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(naid,ncid,npid,npy,npcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+npcpa;
                pru_year.num_conversion:=pru_year.num_conversion+1;
            ELSE
                pru_year.a_id:=naid;
                pru_year.c_id:=ncid;
                pru_year.p_id:=npid;
                pru_year.cost_per_action:=npcpa;
                pru_year.p_y:=npy;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=npcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        RETURN TRUE;
        /*
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
        */
    END
$$;


ALTER FUNCTION w4_application_functions.update_conversion_rollups(oaid bigint, ocid bigint, opid bigint, oppid bigint, oacpa numeric, opcpa numeric, oppcpa numeric, oicpa numeric, ots timestamp with time zone, naid bigint, ncid bigint, npid bigint, nppid bigint, nacpa numeric, npcpa numeric, nppcpa numeric, nicpa numeric, nts timestamp with time zone, astatus integer, pstatus integer, ppstatus integer, clickid bigint) OWNER TO w4;

--
-- Name: update_file(bigint, text, text, text, integer, integer, integer, public.status_entity, bigint, text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_file(arg_id bigint, arg_file_name text, arg_folder text, arg_mime_type text, arg_width integer, arg_height integer, arg_size integer, arg_status public.status_entity, arg_user_id bigint, arg_extension text, arg_parent_file_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
    BEGIN        

        IF arg_width   <= 0 OR
	   arg_height  <= 0 OR
	   arg_size    <= 0 OR
	   arg_user_id <= 0 OR
	   arg_parent_file_id <= 0 THEN

		RAISE EXCEPTION 'Invalid Parameter specified.';
		RETURN NULL;

	END IF;
	
        PERFORM * FROM files WHERE id = arg_id;
        IF FOUND THEN
		UPDATE files SET
			file_name      = COALESCE( arg_file_name,      file_name      ),
			folder         = COALESCE( arg_folder,         folder         ),
			mime_type      = COALESCE( arg_mime_type,      mime_type      ),
			width          = COALESCE( arg_width,          width          ),
			height         = COALESCE( arg_height,         height         ),
			size           = COALESCE( arg_size,           size           ),
			status         = COALESCE( arg_status,         status         ),
			user_id        = COALESCE( arg_user_id,        user_id        ),
			"extension"    = COALESCE( arg_extension,      "extension"    ),
			parent_file_id = COALESCE( arg_parent_file_id, parent_file_id )
		WHERE id = arg_id;
        ELSE
            RAISE EXCEPTION 'No file found with that id.';
        END IF;

        RETURN arg_id;
    END;

$$;


ALTER FUNCTION w4_application_functions.update_file(arg_id bigint, arg_file_name text, arg_folder text, arg_mime_type text, arg_width integer, arg_height integer, arg_size integer, arg_status public.status_entity, arg_user_id bigint, arg_extension text, arg_parent_file_id bigint) OWNER TO w4;

--
-- Name: update_global_settings(bigint, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_global_settings(arg_id bigint, arg_value text) RETURNS TABLE(id bigint, name text, value text, type text)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        IF arg_id <= 0 OR arg_id IS NULL OR arg_value IS NULL THEN
            RAISE EXCEPTION 'Missing one or more required params.';
            RETURN;
        END IF;
        PERFORM * FROM global_settings WHERE global_settings.id=arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'No global setting with that type.';
            RETURN;
        END IF;
	UPDATE global_settings SET "value" = arg_value WHERE global_settings.id = arg_id;
	RETURN QUERY SELECT gs."id", gs."name"::text, gs."value"::text, gs."type"::text FROM global_settings gs WHERE gs.id = arg_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_global_settings(arg_id bigint, arg_value text) OWNER TO w4;

--
-- Name: update_global_settings(text, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_global_settings(arg_type text, arg_value text) RETURNS TABLE(type character, name text, value text)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        IF arg_type = '' OR arg_type IS NULL OR arg_value IS NULL THEN
            RAISE EXCEPTION 'One or more invalid parameters';
            RETURN;
        END IF;
        PERFORM * FROM global_settings WHERE global_settings.type=arg_type;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'No global setting with that type.';
            RETURN;
        END IF;
        UPDATE global_settings SET "value" = arg_value WHERE global_settings.type = arg_type;
        RETURN QUERY SELECT gs."type", gs."name", gs."value" FROM global_settings gs WHERE gs.type = arg_type;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_global_settings(arg_type text, arg_value text) OWNER TO w4;

--
-- Name: update_message_to_archived(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_message_to_archived(arg_message_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        ret_val:=TRUE;
        UPDATE messages SET message_status=4 WHERE id=arg_message_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_message_to_archived(arg_message_id bigint) OWNER TO w4;

--
-- Name: update_message_to_deleted(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_message_to_deleted(arg_message_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        ret_val:=TRUE;
        UPDATE messages SET message_status=5 WHERE id=arg_message_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_message_to_deleted(arg_message_id bigint) OWNER TO w4;

--
-- Name: update_message_to_read(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_message_to_read(arg_message_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BOOLEAN;
    BEGIN
        ret_val:=TRUE;
        UPDATE messages SET message_status=3 WHERE id=arg_message_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_message_to_read(arg_message_id bigint) OWNER TO w4;

--
-- Name: update_piggyback_pixel(bigint, bigint, bigint, character varying, integer, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_piggyback_pixel(arg_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_code character varying, arg_tracking_type_id integer, arg_user_id bigint) RETURNS public.vw_piggyback_pixel
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        use_comma TEXT;
        uv TEXT;
        ret_val vw_piggyback_pixel;
    BEGIN        
        use_comma:='';
        uv:='';
        IF arg_campaign_id > 0 THEN
                uv:=uv || use_comma || $$ campaign_id=$$ || arg_campaign_id;
                use_comma:=',';
        END IF;
        IF arg_publisher_id > 0 THEN
                uv:=uv || use_comma || $$ publisher_id=$$ || arg_publisher_id;
                use_comma:=',';
        END IF;
        if arg_code IS NOT NULL THEN
                uv:=uv || use_comma || $$ code='$$ || arg_code || $$'$$;
                use_comma:=',';
        END IF;
        IF arg_user_id > 0 THEN
                uv:=uv || use_comma || $$ user_id=$$ || arg_user_id;
                use_comma:=',';
        END IF;
        uv:=uv || use_comma || $$ last_updated='$$ || CURRENT_TIMESTAMP || $$'$$;

        IF arg_tracking_type_id IS NOT NULL THEN
            PERFORM * FROM campaign_tracking_type_lookup WHERE id=arg_tracking_type_id;
            IF NOT FOUND THEN
                RAISE EXCEPTION 'Tracking type id not found.';
            END IF;
            uv:=uv || use_comma || $$ type='$$ || arg_tracking_type_id || $$'$$;
            use_comma:=',';
        END IF;

        PERFORM * FROM campaign_piggyback_pixels WHERE id=arg_id AND status='active';
        IF FOUND THEN
            execute 'UPDATE campaign_piggyback_pixels SET ' || uv || 'WHERE id=' || arg_id || ';';
        ELSE
            RAISE EXCEPTION 'No active piggyback pixel with that id.';
        END IF;
        SELECT INTO ret_val * FROM vw_piggyback_pixel WHERE id=arg_id;
        RETURN ret_val;
    END;
$_$;


ALTER FUNCTION w4_application_functions.update_piggyback_pixel(arg_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_code character varying, arg_tracking_type_id integer, arg_user_id bigint) OWNER TO w4;

--
-- Name: update_piggyback_pixel(bigint, bigint, bigint, text, integer, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_piggyback_pixel(arg_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_code text, arg_tracking_type_id integer, arg_user_id bigint) RETURNS public.vw_piggyback_pixel
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val vw_piggyback_pixel;
    BEGIN        
    
        IF arg_tracking_type_id IS NOT NULL THEN

            PERFORM * FROM campaign_tracking_type_lookup WHERE id = arg_tracking_type_id;
            IF NOT FOUND THEN
                RAISE EXCEPTION 'Tracking type id not found.';
                RETURN NULL;
            END IF;
            
        END IF;

        PERFORM * FROM campaign_piggyback_pixels WHERE id = arg_id AND status = 'active';
        IF NOT FOUND THEN
            RAISE EXCEPTION 'No active piggyback pixel with that id.';
            RETURN NULL;
        END IF;

	UPDATE campaign_piggyback_pixels SET 
		campaign_id  = COALESCE( arg_campaign_id,      campaign_id  ),
		publisher_id = COALESCE( arg_publisher_id,     publisher_id ),
		code         = COALESCE( arg_code,             code         ),
		user_id      = COALESCE( arg_user_id,          user_id      ),
		"type"       = COALESCE( arg_tracking_type_id, "type"       ),
		last_updated = CURRENT_TIMESTAMP
	WHERE id = arg_id;
        
        SELECT INTO STRICT ret_val * FROM vw_piggyback_pixel WHERE id = arg_id;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_piggyback_pixel(arg_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_code text, arg_tracking_type_id integer, arg_user_id bigint) OWNER TO w4;

--
-- Name: update_publisher(integer, text, text, text, text, bigint, bigint, text, text, text, integer, numeric, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher(arg_id integer, arg_login_name text, arg_email_address text, arg_password text, arg_active text, arg_parent_id bigint, arg_manager_id bigint, arg_url text, arg_tax_id text, arg_payment_to text, arg_payment_by integer, arg_payment_threshold numeric, arg_payment_schedule text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    BEGIN

	IF arg_login_name IS NOT NULL AND arg_login_name <> '' THEN
	
		PERFORM login_name FROM users WHERE login_name ILIKE arg_login_name AND id <> arg_id;
		IF FOUND THEN
		    RAISE EXCEPTION 'The login name [%] is already in use', arg_login_name;
		    RETURN NULL;
		END IF;

        END IF;
        
        -- ugh, not sure the nullif's need to be here, previously arg_manager_id was only included if > -1
        UPDATE users SET 
		login_name = COALESCE( NULLIF( arg_login_name,    '' ), login_name ),
		email      = COALESCE( NULLIF( arg_email_address, '' ), email      ),
		"password" = COALESCE( NULLIF( arg_password,      '' ), "password" ),
		active     = COALESCE( NULLIF( arg_active,        '' ), active     ),
		manager_id = COALESCE( NULLIF( arg_manager_id,    -1 ), manager_id )
	WHERE id = arg_id;

	-- ugh not sure if the nullif's need to be here
        UPDATE user_profiles SET 
		website_url       = COALESCE( NULLIF( arg_url,               '' ), website_url       ),
		tax_id            = COALESCE( NULLIF( arg_tax_id,            '' ), tax_id            ),
		payment_to        = COALESCE( NULLIF( arg_payment_to,        '' ), payment_to        ),
		payment_by        = COALESCE( NULLIF( arg_payment_by,        -1 ), payment_by        ),
		payment_threshold = COALESCE( NULLIF( arg_payment_threshold, -1 ), payment_threshold ),
		payment_schedule  = COALESCE( NULLIF( arg_payment_schedule,  '' ), payment_schedule  )
	WHERE user_id = arg_id;

	-- TODO: return a row
        RETURN arg_id;
        
    END;
$$;


ALTER FUNCTION w4_application_functions.update_publisher(arg_id integer, arg_login_name text, arg_email_address text, arg_password text, arg_active text, arg_parent_id bigint, arg_manager_id bigint, arg_url text, arg_tax_id text, arg_payment_to text, arg_payment_by integer, arg_payment_threshold numeric, arg_payment_schedule text) OWNER TO w4;

--
-- Name: update_publisher_account(bigint, text, text, bigint, text, text, text, text, text, character, text, bigint, text, text, text, bigint, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher_account(arg_id bigint, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_postal_code text DEFAULT NULL::text, arg_email_address text DEFAULT NULL::text, arg_login_name text DEFAULT NULL::text, arg_password_hash character DEFAULT NULL::character(40), arg_status text DEFAULT NULL::text, arg_manager_id bigint DEFAULT NULL::bigint, arg_url text DEFAULT NULL::text, arg_publisher_name text DEFAULT NULL::text, arg_notes text DEFAULT NULL::text, arg_referrer_id bigint DEFAULT NULL::bigint, arg_parent_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        account_contact_id bigint;
	var_region_id bigint;
        var_city_id bigint;

    BEGIN
        PERFORM id FROM users WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher (%).', arg_id;
        END IF;

        SELECT region_id, city_id FROM geo_get(arg_country_id, arg_region_name, arg_city_name) INTO var_region_id, var_city_id;

        UPDATE user_profiles SET
		website_url  = COALESCE( arg_url,              website_url  ),
		company_name = COALESCE( arg_publisher_name,   company_name ),
		address_1    = COALESCE( arg_address_1,        address_1    ),
		address_2    = COALESCE( arg_address_2,        address_2    ),
		country      = COALESCE( arg_country_id::text, country      ),
		state        = COALESCE( arg_region_name,          state        ),
		city         = COALESCE( arg_city_name,            city         ),
		zip          = COALESCE( arg_postal_code,      zip          ),
		notes        = COALESCE( arg_notes,            notes        )
	WHERE user_id = arg_id;

        UPDATE users SET
		manager_id = COALESCE( arg_manager_id,    manager_id ),
		email      = COALESCE( arg_email_address, email      ),
		login_name = COALESCE( arg_login_name,    login_name ),
		"password" = COALESCE( arg_password_hash, "password" ),
		active     = COALESCE( arg_status,        active     ),
                referrer_id  = COALESCE( arg_referrer_id, referrer_id  ),
                parent_id  = COALESCE( arg_parent_id, parent_id  )
	WHERE id = arg_id;

        account_contact_id := users.account_contact_id FROM users WHERE id = arg_id;
        PERFORM * FROM update_publisher_contact
        (
		account_contact_id,
		arg_id,
		NULL::text,
		NULL::text,
		arg_address_1,
		arg_address_2,
		arg_country_id,
		var_region_id,
		var_city_id,
		arg_city_name,
		arg_postal_code
	);
        RETURN get_publisher_account( arg_id );
    END;
$$;


ALTER FUNCTION w4_application_functions.update_publisher_account(arg_id bigint, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_name text, arg_city_name text, arg_postal_code text, arg_email_address text, arg_login_name text, arg_password_hash character, arg_status text, arg_manager_id bigint, arg_url text, arg_publisher_name text, arg_notes text, arg_referrer_id bigint, arg_parent_id bigint) OWNER TO w4;

--
-- Name: update_publisher_ban(bigint, bigint, bigint, bigint, text, text, text, text, public.status_entity); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher_ban(arg_ban_id bigint, arg_publisher_id bigint, arg_advertiser_id bigint, arg_campaign_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_status public.status_entity) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    BEGIN
	-- NOTE: Unsure this function is even used
	-- NOTE: Previously skipped updating publisher/advertiser/campaign id values if they were <= 0
        UPDATE advertiser_banned_publishers SET
		publisher_id  = COALESCE( arg_publisher_id,  publisher_id  ),
		advertiser_id = COALESCE( arg_advertiser_id, advertiser_id ),
		campaign_id   = COALESCE( arg_campaign_id,   campaign_id   ),
		sub_id_1      = COALESCE( arg_sub_id_1,      sub_id_1      ),
		sub_id_2      = COALESCE( arg_sub_id_2,      sub_id_2      ),
		sub_id_3      = COALESCE( arg_sub_id_3,      sub_id_3      ),
		sub_id_4      = COALESCE( arg_sub_id_4,      sub_id_4      ),
		status        = COALESCE( arg_status,        status        )
        WHERE id = arg_ban_id;
        
        RETURN arg_ban_id;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_publisher_ban(arg_ban_id bigint, arg_publisher_id bigint, arg_advertiser_id bigint, arg_campaign_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_status public.status_entity) OWNER TO w4;

--
-- Name: update_publisher_billing(bigint, text, text, bigint, text, text, text, text, text, bigint, numeric, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher_billing(arg_id bigint, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_postal_code text DEFAULT NULL::text, arg_taxid text DEFAULT NULL::text, arg_payment_to text DEFAULT NULL::text, arg_payment_method_id bigint DEFAULT NULL::bigint, arg_payment_threshold numeric DEFAULT NULL::numeric, arg_payment_schedule text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        billing_contact_id bigint;        
	var_region_id bigint;
        var_city_id bigint;

    BEGIN
                
        PERFORM id FROM users WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher (%).', arg_id;
        END IF;

        SELECT region_id, city_id FROM geo_get(arg_country_id, arg_region_name, arg_city_name) INTO var_region_id, var_city_id;

	-- UGH - why is the payment_country_id data stored in a text field
	UPDATE user_profiles SET 
		payment_address_1   = COALESCE( arg_address_1,         payment_address_1 ),
		payment_address_2   = COALESCE( arg_address_2,         payment_address_2 ),
		payment_country     = COALESCE( arg_country_id::text,  payment_country ),
		payment_region      = COALESCE( arg_region_name,           payment_region ),
		payment_city        = COALESCE( arg_city_name,             payment_city ),
		payment_postal_code = COALESCE( arg_postal_code,       payment_postal_code ),
		payment_to          = COALESCE( arg_payment_to,        payment_to ),
		payment_by          = COALESCE( arg_payment_method_id, payment_by ),
		tax_id		    = COALESCE( arg_taxid,             tax_id ),
		payment_threshold   = COALESCE( arg_payment_threshold, payment_threshold ),
		payment_schedule    = COALESCE( arg_payment_schedule,  payment_schedule )
	WHERE user_id = arg_id;

	billing_contact_id := users.billing_contact_id FROM users WHERE id = arg_id;

        PERFORM * FROM update_publisher_contact
        (
		billing_contact_id, 
		arg_id, 
		NULL::text, 
		NULL::text, 
		arg_address_1, 
		arg_address_2, 
		arg_country_id,
		var_region_id,
		var_city_id,
		arg_city_name, 
		arg_postal_code 
	);
	
        RETURN get_publisher_billing( arg_id );
    END;
$$;


ALTER FUNCTION w4_application_functions.update_publisher_billing(arg_id bigint, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_name text, arg_city_name text, arg_postal_code text, arg_taxid text, arg_payment_to text, arg_payment_method_id bigint, arg_payment_threshold numeric, arg_payment_schedule text) OWNER TO w4;

--
-- Name: update_publisher_contact(bigint, bigint, character varying, character varying, character varying, character varying, bigint, bigint, bigint, character varying, character varying, character varying, bigint, character varying, character varying, character varying, character varying, boolean, boolean); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher_contact(arg_id bigint, arg_publisher_id bigint, arg_first_name character varying DEFAULT NULL::character varying, arg_last_name character varying DEFAULT NULL::character varying, arg_address_1 character varying DEFAULT NULL::character varying, arg_address_2 character varying DEFAULT NULL::character varying, arg_country_id bigint DEFAULT (-1), arg_region_id bigint DEFAULT (-1), arg_city_id bigint DEFAULT (-1), arg_city_name character varying DEFAULT NULL::character varying, arg_postal_code character varying DEFAULT NULL::character varying, arg_messenger_name character varying DEFAULT NULL::character varying, arg_messenger_type bigint DEFAULT NULL::bigint, arg_primary_phone character varying DEFAULT NULL::character varying, arg_secondary_phone character varying DEFAULT NULL::character varying, arg_fax character varying DEFAULT NULL::character varying, arg_email_address character varying DEFAULT NULL::character varying, arg_is_primary boolean DEFAULT false, arg_is_billing boolean DEFAULT false) RETURNS public.contacts
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ct contacts;
        pub users;
    BEGIN
        PERFORM * FROM update_contact(arg_id,arg_first_name, arg_last_name, arg_address_1, arg_address_2, arg_country_id, arg_region_id, arg_city_id, arg_city_name, arg_postal_code, arg_messenger_name, arg_messenger_type, arg_primary_phone, arg_secondary_phone, arg_fax, arg_email_address);
        IF arg_is_billing THEN
            UPDATE users SET primary_contact_id=arg_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET first_name=arg_first_name, last_name=arg_last_name, address_1=arg_address_1, address_2=arg_address_2, city=arg_city_name, "state"=(SELECT region FROM geo_typeahead_region WHERE id=arg_region_id), country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id), zip=arg_postal_code, phone=arg_primary_phone, cell=arg_secondary_phone, messenger_id=arg_messenger_name, messenger_type=arg_messenger_type, fax=arg_fax WHERE user_id=arg_publisher_id;
        END IF;
        IF arg_is_primary THEN
            UPDATE users SET primary_contact_id=arg_id WHERE id=arg_publisher_id;
            UPDATE user_profiles SET payment_address_1=arg_address_1, payment_address_2=arg_address_2, payment_city=arg_city_name, payment_region=(SELECT region FROM geo_typeahead_region WHERE id=arg_region_id), payment_postal_code=arg_postal_code, payment_country=(SELECT country FROM geo_typeahead_countries WHERE id=arg_country_id) WHERE user_id=arg_publisher_id;
        END IF;
        SELECT INTO pub * FROM users WHERE id=arg_publisher_id;
        SELECT INTO ct * FROM contacts WHERE id=arg_id;
        IF pub.primary_contact_id = arg_id THEN
            ct.is_primary:=TRUE;
        ELSE
            ct.is_primary:=FALSE;
        END IF;
        IF pub.billing_contact_id = arg_id THEN
            ct.is_billing:=TRUE;
        ELSE
            ct.is_billing:=FALSE;
        END IF;
        RETURN ct; 
    END;
$$;


ALTER FUNCTION w4_application_functions.update_publisher_contact(arg_id bigint, arg_publisher_id bigint, arg_first_name character varying, arg_last_name character varying, arg_address_1 character varying, arg_address_2 character varying, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_city_name character varying, arg_postal_code character varying, arg_messenger_name character varying, arg_messenger_type bigint, arg_primary_phone character varying, arg_secondary_phone character varying, arg_fax character varying, arg_email_address character varying, arg_is_primary boolean, arg_is_billing boolean) OWNER TO w4;

--
-- Name: update_publisher_contact_from_account_changes(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher_contact_from_account_changes(arg_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        cur_rec_id bigint;
        pub users;
        pac publisher_account_changes;
        contact_type TEXT;
        update_set TEXT;
        update_usr TEXT;
        update_profile TEXT;
        json_tuples RECORD;
        value_type TEXT;
    BEGIN
        update_set:='';
        update_usr:='';
        update_profile:='';
        SELECT INTO pac * FROM publisher_account_changes WHERE id=arg_id;
        SELECT INTO pub * FROM users WHERE id=pac.publisher_id;
        CASE WHEN pac.contact_type='primary' THEN
            cur_rec_id:=pub.primary_contact_id;
        WHEN pac.contact_type='billing' THEN
            cur_rec_id:=pub.billing_contact_id;
        ELSE
            cur_rec_id:=pub.account_contact_id;
        END CASE;
        FOR json_tuples IN SELECT * FROM json_each_text(pac."data"::json) LOOP
            select data_type::TEXT from information_schema.columns WHERE (table_name = 'contacts' OR table_name='user_profiles' OR table_name='users' OR table_name='user_profile_pics') AND column_name=json_tuples.key INTO value_type;
            CASE WHEN value_type = ANY (ARRAY['smallint','integer','bigint','decimal','numeric','real','double precision','serial','bigserial']) THEN
                CASE WHEN json_tuples.key = ANY (ARRAY['password','login_name']) THEN
                    update_usr:=update_usr || $$"$$ || json_tuples.key || $$" = $$ || json_tuples.value || $$, $$;
                WHEN json_tuples.key='image_id' THEN
                    PERFORM * FROM user_profile_pics WHERE user_id=pac.publisher_id;
                    IF FOUND THEN
                        EXECUTE $$UPDATE user_profile_pics SET image_id='$$ || json_tuples.value || $$' WHERE user_id=$$ || pac.publisher_id || ';';
                    ELSE
                        EXECUTE $$INSERT INTO user_profile_pics (user_id, image_id) VALUES ($$ || pac.publisher_id || $$,'$$ || json_tuples.value || $$');$$;
                    END IF;
                WHEN json_tuples.key = ANY (ARRAY['website_url','tax_id','payment_method_id','payment_to']) THEN
                    update_profile:=update_profile || $$"$$ || json_tuples.key || $$" = $$ || json_tuples.value || $$, $$;
                ELSE
                    update_set:=update_set || $$"$$ || json_tuples.key || $$" = $$ || json_tuples.value || $$, $$;
                    IF (pac.contact_type='primary' OR pac.contact_type='account') THEN
                        CASE WHEN json_tuples.key='primary_phone' THEN
                            update_profile:=update_profile || $$"phone"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='secondary_phone' THEN
                            update_profile:=update_profile || $$"cell"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='first_name' THEN
                            update_profile:=update_profile || $$ "first_name"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='last_name' THEN
                            update_profile:=update_profile || $$"last_name"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='fax' THEN
                            update_profile:=update_profile || $$"fax"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='messenger_name' THEN
                            update_profile:=update_profile || $$"messenger_id"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='messenger_type' THEN
                            update_profile:=update_profile || $$"messenger_type"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='address_1' THEN
                            update_profile:=update_profile || $$"address_1"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='address_2' THEN
                            update_profile:=update_profile || $$"address_2"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='country_id' THEN
                            update_profile:=update_profile || $$"country"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='region_id' THEN
                            update_profile:=update_profile || $$"state"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='city_id' THEN
                            update_profile:=update_profile || $$"city"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='postal_code' THEN
                            update_profile:=update_profile || $$"zip"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='eail_address' THEN
                            update_profile:=update_profile || $$"contact_email"=$$ || json_tuples.value || $$, $$;
                        ELSE
                        END CASE;
                    ELSE
                        CASE WHEN json_tuples.key='address_1' THEN
                            update_profile:=update_profile || $$"payment_address_1"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='address_2' THEN
                            update_profile:=update_profile || $$"payment_address_2"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='country_id' THEN
                            update_profile:=update_profile || $$"payment_country"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='region_id' THEN
                            update_profile:=update_profile || $$"payment_region"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='city_id' THEN
                            update_profile:=update_profile || $$"payment_city"=$$ || json_tuples.value || $$, $$;
                        WHEN json_tuples.key='postal_code' THEN
                            update_profile:=update_profile || $$"payment_postal_code"=$$ || json_tuples.value || $$, $$;
                        ELSE
                        END CASE;
                    END IF;
                END CASE;
            ELSE
                CASE WHEN json_tuples.key = ANY (ARRAY['password','login_name']) THEN
                    update_usr:=update_usr || $$"$$ || json_tuples.key || $$" = '$$ || json_tuples.value || $$', $$;
                WHEN json_tuples.key='image_id' THEN
                    PERFORM * FROM user_profile_pics WHERE user_id=pac.publisher_id;
                    IF FOUND THEN
                        EXECUTE $$UPDATE user_profile_pics SET image_id='$$ || json_tuples.value || $$' WHERE user_id = $$ || pac.publisher_id || ';';
                    ELSE
                        EXECUTE $$INSERT INTO user_profile_pics (user_id, image_id) VALUES ($$ || pac.publisher_id || $$,'$$ || json_tuples.value || $$');$$;
                    END IF;
                WHEN json_tuples.key = ANY (ARRAY['website_url','tax_id','payment_method_id','payment_to']) THEN
                    update_profile:=update_profile || $$"$$ || json_tuples.key || $$" = '$$ || json_tuples.value || $$', $$;
                ELSE
                    IF json_tuples.key='email' THEN json_tuples.key:='email_address'; END IF;
                    update_set:=update_set || $$"$$ || json_tuples.key || $$" = '$$ || json_tuples.value || $$', $$;
                    IF  (pac.contact_type='primary' OR  pac.contact_type='account') THEN
                        CASE WHEN json_tuples.key='primary_phone' THEN
                            update_profile:=update_profile || $$"phone"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='secondary_phone' THEN
                            update_profile:=update_profile || $$"cell"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='first_name' THEN
                            update_profile:=update_profile || $$ "first_name"= '$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='last_name' THEN
                            update_profile:=update_profile || $$"last_name"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='fax' THEN
                            update_profile:=update_profile || $$"fax"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='messenger_name' THEN
                            update_profile:=update_profile || $$"messenger_id"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='messenger_type' THEN
                            update_profile:=update_profile || $$"messenger_type"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='address_1' THEN
                            update_profile:=update_profile || $$"address_1"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='address_2' THEN
                            update_profile:=update_profile || $$"address_2"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='country_id' THEN
                            update_profile:=update_profile || $$"country"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='region_id' THEN
                            update_profile:=update_profile || $$"state"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='city_id' THEN
                            update_profile:=update_profile || $$"city"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='postal_code' THEN
                            update_profile:=update_profile || $$"zip"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='email_address' THEN
                            update_profile:=update_profile || $$"contact_email"='$$ || json_tuples.value || $$', $$;
                        ELSE
                        END CASE;
                    ELSE
                        CASE WHEN json_tuples.key='address_1' THEN
                            update_profile:=update_profile || $$"payment_address_1"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='address_2' THEN
                            update_profile:=update_profile || $$"payment_address_2"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='country_id' THEN
                            update_profile:=update_profile || $$"payment_country"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='region_id' THEN
                            update_profile:=update_profile || $$"payment_region"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='city_id' THEN
                            update_profile:=update_profile || $$"payment_city"='$$ || json_tuples.value || $$', $$;
                        WHEN json_tuples.key='postal_code' THEN
                            update_profile:=update_profile || $$"payment_postal_code"='$$ || json_tuples.value || $$', $$;
                        ELSE
                        END CASE;
                    END IF;
                END CASE;
            END CASE;
        END LOOP;
        update_set:=trim( both ', ' from update_set );
        update_usr:=trim( both ', ' from update_usr );
        update_profile:=trim( both ', ' from update_profile );
        IF update_set <> '' THEN
            EXECUTE $$UPDATE contacts SET $$ || update_set || $$ WHERE id=$$ || cur_rec_id;
        END IF;
        IF update_usr <> '' THEN
            EXECUTE $$UPDATE users SET $$ || update_usr || $$ WHERE id=$$ || pac.publisher_id;
        END IF;
        IF update_profile <> '' THEN
            EXECUTE $$UPDATE user_profiles SET $$ || update_profile || $$ WHERE user_id=$$ || pac.publisher_id;
        END IF;
        RETURN cur_rec_id;
    END;
$_$;


ALTER FUNCTION w4_application_functions.update_publisher_contact_from_account_changes(arg_id bigint) OWNER TO w4;

--
-- Name: update_publisher_dashboard_layout(bigint, json); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher_dashboard_layout(arg_publisher_id bigint, arg_layout json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN w4_application_functions.set_publisher_dashboard_layout(arg_publisher_id, arg_layout);
    END;
$$;


ALTER FUNCTION w4_application_functions.update_publisher_dashboard_layout(arg_publisher_id bigint, arg_layout json) OWNER TO w4;

--
-- Name: update_publisher_override(bigint, bigint, bigint, numeric, numeric, json, text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher_override(arg_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_payout numeric DEFAULT NULL::numeric, arg_payin numeric DEFAULT NULL::numeric, arg_subids_json json DEFAULT NULL::json, arg_landing_page text DEFAULT NULL::text, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS public.vw_publisher_override
    LANGUAGE plpgsql
    AS $$
    DECLARE
	retval vw_publisher_override;
        sub_ids text[];
        cols text[];
        vals text;
    BEGIN
        sub_ids = json_array_convert( arg_subids_json );
        
        IF make_doy( arg_start_date ) = make_doy( now() ) THEN
            arg_start_date := now();
        END IF;
	UPDATE publisher_overrides SET 
		publisher_id                     = COALESCE( arg_publisher_id,         publisher_id                     ),
		campaign_id                      = COALESCE( arg_campaign_id,          campaign_id                      ),
		override_payin                   = COALESCE( arg_payin,                override_payin                   ),
		override_payout                  = COALESCE( arg_payout,               override_payout                  ),
		sub_id_1                         = COALESCE( NULLIF( sub_ids[1], '' ), sub_id_1                         ),
		sub_id_2                         = COALESCE( NULLIF( sub_ids[2], '' ), sub_id_2                         ),
		sub_id_3                         = COALESCE( NULLIF( sub_ids[3], '' ), sub_id_3                         ),
		sub_id_4                         = COALESCE( NULLIF( sub_ids[4], '' ), sub_id_4                         ),
		effective_date                   = COALESCE( arg_start_date,           effective_date                   ),
		expiration_date                  = COALESCE( arg_end_date,             expiration_date                  ),
		override_advertiser_landing_page = COALESCE( arg_landing_page,         override_advertiser_landing_page )
	WHERE id = arg_id;
	SELECT INTO retval * FROM vw_publisher_override v WHERE id = arg_id;
        RETURN retval;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_publisher_override(arg_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_payout numeric, arg_payin numeric, arg_subids_json json, arg_landing_page text, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone) OWNER TO w4;

--
-- Name: update_publisher_robert_json_blob_delete_me(bigint, json); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_publisher_robert_json_blob_delete_me(arg_publisher_id bigint, arg_layout json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN w4_application_functions.set_publisher_robert_json_blob_delete_me(arg_publisher_id, arg_layout);
    END;
$$;


ALTER FUNCTION w4_application_functions.update_publisher_robert_json_blob_delete_me(arg_publisher_id bigint, arg_layout json) OWNER TO w4;

--
-- Name: update_pubs_available_campaigns(bigint, bigint, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_pubs_available_campaigns(arg_id bigint, arg_publisher_id bigint, arg_memo text DEFAULT NULL::text) RETURNS public.pub_campaign_list
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val pub_campaign_list;
    BEGIN
        PERFORM * FROM campaign_assigned_publishers WHERE publisher_id=arg_publisher_id AND campaign_id=arg_id;
        IF FOUND THEN
            RAISE EXCEPTION 'You have already requested access to this campaign.';
        ELSE
            INSERT INTO campaign_assigned_publishers VALUES (arg_id::BIGINT, arg_publisher_id::BIGINT, 'pending'::VARCHAR, ''::TEXT, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, arg_memo::TEXT);
        END IF;

        SELECT INTO ret_val * FROM get_pubs_available_campaigns
        (
            arg_publisher_id      := arg_publisher_id, 
            arg_channel_ids_json  := '[]', 
            arg_pays_on_ids_json  := '[]', 
            arg_category_ids_json := '[]', 
            arg_geos_ids_json     := '[]', 
            arg_offset            := 0, 
            arg_limit             := 999999999
        ) WHERE campaign_id = arg_id;
        
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_pubs_available_campaigns(arg_id bigint, arg_publisher_id bigint, arg_memo text) OWNER TO w4;

--
-- Name: update_user(text, text, text, text, bigint, bigint, text, text, bigint, text, bigint, text); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION update_user(arg_login_name text, arg_email_address text, arg_first_name text, arg_last_name text, arg_id bigint DEFAULT NULL::bigint, arg_manager_id bigint DEFAULT NULL::bigint, arg_primary_phone text DEFAULT NULL::text, arg_messenger_name text DEFAULT NULL::text, arg_messenger_type bigint DEFAULT NULL::bigint, arg_password text DEFAULT NULL::text, arg_image_id bigint DEFAULT NULL::bigint, arg_access text DEFAULT 'admin'::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        contact_id bigint;
        new_user_id bigint;
        var_image_id text := arg_image_id::text;

    BEGIN
	IF arg_login_name = '' THEN
		RAISE EXCEPTION 'Invalid login name';
	END IF;

	PERFORM login_name FROM users WHERE login_name ILIKE arg_login_name AND (id <> arg_id OR arg_id IS NULL);
	IF FOUND THEN
		RAISE EXCEPTION 'The login name [%] is in use by another user', arg_login_name;
	END IF;

	IF arg_id IS NULL THEN
            contact_id := nextval ('contacts_id_seq');
            INSERT INTO contacts
                (id, first_name, last_name, primary_phone, messenger_name, messenger_type)
                VALUES (contact_id, arg_first_name, arg_last_name, arg_primary_phone, arg_messenger_name, arg_messenger_type);
            new_user_id := nextval ('users_id_seq');
            INSERT INTO users
                (id, login_name, password, email, access, active, manager_id, primary_contact_id)
                VALUES (new_user_id, arg_login_name, arg_password, arg_email_address, arg_access, 'active', arg_manager_id, contact_id);
            INSERT INTO user_profiles
                (image_id, first_name, last_name, phone, messenger_id, messenger_type, user_id)
                VALUES (var_image_id, arg_first_name, arg_last_name, arg_primary_phone, arg_messenger_name, arg_messenger_type, new_user_id);
            RETURN user_profiles_get(new_user_id);
        ELSE
            PERFORM * FROM users WHERE id = arg_id;
            IF NOT FOUND THEN
                /* No user like that, return an exception */
                RAISE EXCEPTION 'The user [%] was not found', arg_id;
            END IF;

            SELECT primary_contact_id INTO contact_id FROM users WHERE id = arg_id;

            arg_password := NULLIF( arg_password, '' );

            UPDATE users SET 
                    login_name = COALESCE( arg_login_name,    login_name ),
                    password   = COALESCE( arg_password,      password   ),
                    email      = COALESCE( arg_email_address, email      ),
                    manager_id = COALESCE( arg_manager_id, 0 ),
                    access = COALESCE(arg_access, access)
            WHERE id = arg_id;

            UPDATE contacts SET
                    first_name     = COALESCE( arg_first_name,     first_name     ),
                    last_name      = COALESCE( arg_last_name,      last_name      ),
                    primary_phone  = COALESCE( arg_primary_phone,  primary_phone  ),
                    messenger_name = COALESCE( arg_messenger_name, messenger_name ),
                    messenger_type = COALESCE( arg_messenger_type, messenger_type )
            WHERE id = contact_id;

            UPDATE user_profiles SET
                    image_id       = COALESCE( var_image_id,       image_id ),
                    first_name     = COALESCE( arg_first_name,     first_name     ),
                    last_name      = COALESCE( arg_last_name,      last_name      ),
                    phone          = COALESCE( arg_primary_phone,  phone  ),
                    messenger_id   = COALESCE( arg_messenger_name, messenger_id ),
                    messenger_type = COALESCE( arg_messenger_type, messenger_type )
            WHERE user_id = arg_id;

            RETURN user_profiles_get(arg_id);
        END IF;
    END;
$$;


ALTER FUNCTION w4_application_functions.update_user(arg_login_name text, arg_email_address text, arg_first_name text, arg_last_name text, arg_id bigint, arg_manager_id bigint, arg_primary_phone text, arg_messenger_name text, arg_messenger_type bigint, arg_password text, arg_image_id bigint, arg_access text) OWNER TO w4;

--
-- Name: updatecampaigncategory(bigint, character varying, text, bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION updatecampaigncategory(cat_id bigint, cat_name character varying, cat_description text, cat_parent bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BIGINT;
        check_val BIGINT;
        chk_val BIGINT;
        cat_depth INTEGER;
        max_depth INTEGER;
        count_var INTEGER;
    BEGIN
        max_depth:=37; -- Allow for a depth of 38 per Glen
        ret_val:=-1;
        SELECT INTO chk_val parent_id FROM categories WHERE id=cat_id;
        IF chk_val <> cat_parent THEN
            IF cat_parent > 0 THEN
                -- Check parent_id to ensure that it won't cause recursion
                cat_depth:=0;
                chk_val:=cat_parent;
                LOOP
                    cat_depth:=cat_depth+1;
                    SELECT INTO check_val parent_id FROM categories WHERE id=chk_val;
                    IF check_val > 0 THEN
                        chk_val:=check_val;
                    ELSE
                        -- It's OK to insert, it's not past the recursion limit. Make sure no other siblings with the same name
                        SELECT INTO count_var count("name") FROM categories WHERE parent_id=cat_parent AND "name"=cat_name AND id <> cat_id;
                        IF count_var > 0 THEN
                            RETURN -3;
                        ELSE
                            UPDATE categories SET "name"=cat_name, "description"=cat_description, "parent_id"=cat_parent WHERE id=cat_id;
                            RETURN cat_id;
                        END IF;                        
                    END IF;
                    IF cat_depth > max_depth THEN
                        -- It's NOT OK to insert this, it's past the recursion limit
                        RETURN -2;
                    END IF;
                END LOOP;
            ELSE
                -- Top level Category
            SELECT INTO count_var count("name") FROM categories WHERE parent_id=cat_parent AND "name"=cat_name AND id <> cat_id;
                IF count_var > 0 THEN
                    RETURN -3;
                ELSE
                    UPDATE categories SET "name"=cat_name, "description"=cat_description, "parent_id"=cat_parent WHERE id=cat_id;
                    RETURN cat_id;
                END IF;
            END IF;
        ELSE
            -- Check to make sure no siblings share the same name
            SELECT INTO count_var count("name") FROM categories WHERE parent_id=cat_parent AND "name"=cat_name AND id <> cat_id;
            IF count_var > 0 THEN
                RETURN -3;
            ELSE
                UPDATE categories SET "name"=cat_name, "description"=cat_description, "parent_id"=cat_parent WHERE id=cat_id;
                RETURN cat_id;
            END IF;
        END IF;
    END;
$$;


ALTER FUNCTION w4_application_functions.updatecampaigncategory(cat_id bigint, cat_name character varying, cat_description text, cat_parent bigint) OWNER TO w4;

--
-- Name: updatepublisher(integer, character varying, character varying, character varying, character varying, bigint, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, bigint, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, numeric, character varying); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION updatepublisher(uid integer, loginname character varying, users_email character varying, users_password character varying, users_active character varying, users_manager_id bigint, companyname character varying, firstname character varying, lastname character varying, address1 character varying, address2 character varying, country character varying, state character varying, city character varying, zip character varying, phone character varying, cell character varying, messengerid bigint, messengertype character varying, websiteurl character varying, paymentaddress1 character varying, paymentaddress2 character varying, paymentcountry character varying, paymentregion character varying, paymentcity character varying, paymentpostalcode character varying, taxid character varying, paymentto character varying, paymentby integer, paymentthreshold numeric, paymentschedule character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        primary_cid BIGINT;
        billing_cid BIGINT;
        ucv TEXT;
    BEGIN
        RETURN 1;
    END;
$$;


ALTER FUNCTION w4_application_functions.updatepublisher(uid integer, loginname character varying, users_email character varying, users_password character varying, users_active character varying, users_manager_id bigint, companyname character varying, firstname character varying, lastname character varying, address1 character varying, address2 character varying, country character varying, state character varying, city character varying, zip character varying, phone character varying, cell character varying, messengerid bigint, messengertype character varying, websiteurl character varying, paymentaddress1 character varying, paymentaddress2 character varying, paymentcountry character varying, paymentregion character varying, paymentcity character varying, paymentpostalcode character varying, taxid character varying, paymentto character varying, paymentby integer, paymentthreshold numeric, paymentschedule character varying) OWNER TO w4;

--
-- Name: user_profile_get(bigint); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION user_profile_get(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    usr.id
                    , usr.email
                    , COALESCE(con.first_name, usp.first_name) AS first_name
                    , COALESCE(con.last_name, usp.last_name) AS last_name
                    , usr.login_name
                    , CONCAT (COALESCE(mcon.first_name, mup.first_name), ' ', COALESCE(mcon.last_name, mup.last_name)) AS manager_name
                    , COALESCE(con.messenger_name, usp.messenger_id) AS messenger_name
                    , COALESCE(con.messenger_type, usp.messenger_type) AS messenger_type
                    , usp.image_id
                    , COALESCE(con.primary_phone, usp.phone) AS primary_phone
                INTO ret_val
                FROM users usr 
		LEFT JOIN user_profiles usp 
                    ON usr.id = usp.user_id 
                LEFT JOIN contacts con
                    ON con.id = usr.primary_contact_id
                LEFT JOIN users mgr
                    ON mgr.id = usr.manager_id
                LEFT JOIN contacts mcon
                    ON mcon.id = mgr.primary_contact_id
                LEFT JOIN user_profiles mup
                    ON mup.user_id = mgr.id
                WHERE usr.id = arg_id
            ) row;

        IF NOT FOUND THEN
            PERFORM * FROM users WHERE users.id = arg_id AND users.access = 'admin';
            IF NOT FOUND THEN
                    RAISE EXCEPTION 'The user id [%] does not exist for any user or administrator.', arg_id;
            END IF;
        END IF;
        RETURN ret_val;

    END;
$$;


ALTER FUNCTION w4_application_functions.user_profile_get(arg_id bigint) OWNER TO w4;

--
-- Name: uuid(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION uuid() RETURNS uuid
    LANGUAGE sql
    AS $$
 SELECT CAST(md5(current_database()|| user ||current_timestamp ||random()) as uuid)
$$;


ALTER FUNCTION w4_application_functions.uuid() OWNER TO w4;

--
-- Name: version_advertiser_record(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION version_advertiser_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    new_version_number BIGINT;
    new_version_row public.advertiser_versions;
    BEGIN
        -- Determine if insert or update
        IF (TG_OP = 'UPDATE') THEN
            -- Get the new version info if this is an update
            SELECT INTO new_version_number COALESCE(MAX(version_id)+1,1) FROM advertiser_versions WHERE id = NEW.id;
        ELSEIF (TG_OP = 'INSERT') THEN
            -- Just do a raw insert with version number of 1 and canon date of 0 TIMESTAMPTZ
            new_version_number=1;
        END IF;   
        new_version_row = ROW(
            NEW.id, -- advertiser_id
            new_version_number, -- version_id 
            NEW.manager_id,
            NEW.name,
            NEW.credit_limit,
            NEW.credit_limit_per,
            NEW.payment_terms_id,
            NEW.allow_over_limit,
            NEW.send_alert_if_credit_is_used,
            NEW.credit_alert_type,
            NEW.credit_alert_value,
            NEW.next_payment_due_date,
            NEW.status,
            NEW.created,
            NEW.modified,
            NEW.contact_name,
            NEW.phone,
            NEW.mobile,
            NEW.email,
            NEW.address_1,
            NEW.address_2,
            NEW.city,
            NEW.state,
            NEW.zip,
            NEW.country,
            NEW.messenger_id,
            NEW.fax,
            NEW.url,
            NEW.description,
            NEW.send_alert_if_credit_percent_to,
            NEW.ftp_password,
            NEW.note_login_url,
            NEW.note_login_username,
            NEW.note_login_password,
            NEW.billing_company,
            NEW.billing_first_name,
            NEW.billing_last_name,
            NEW.billing_address_1,
            NEW.billing_address_2,
            NEW.billing_city,
            NEW.billing_region_id,
            NEW.billing_country_id,
            NEW.primary_contact_id,
            NEW.billing_contact_id,
            transaction_timestamp() -- version_start_date
        );
        -- Save the versioned record
        INSERT INTO advertiser_versions VALUES (new_version_row.*);
        -- Be a good little trigger and return the NEW record
        RETURN NEW;        
    END
$$;


ALTER FUNCTION w4_application_functions.version_advertiser_record() OWNER TO w4;

--
-- Name: version_campaign_record(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION version_campaign_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    new_version_number BIGINT;
    new_version_row public.campaign_versions;
    BEGIN
        -- Determine if insert or update
        IF (TG_OP = 'UPDATE') THEN
            -- Get the new version info if this is an update
            SELECT INTO new_version_number COALESCE(MAX(version_id)+1,1) FROM campaign_versions WHERE id = NEW.id;
        ELSEIF (TG_OP = 'INSERT') THEN
            -- Just do a raw insert with version number of 1 and canon date of 0 TIMESTAMPTZ
            new_version_number=1;
        END IF;   
        new_version_row = ROW(
            NEW.id, -- campaign_id
            new_version_number, -- version_id
            NEW.advertiser_id,
            NEW.user_id,
            NEW.name,
            NEW.description,
            NEW.restrictions,
            NEW.default_redirect_url,
            NEW.screenshot_id,
            NEW.landing_pages,
            NEW.failure_redirect_type,
            NEW.failure_redirect_url,
            NEW.failure_redirect_campaign_id,
            NEW.unsubscription_url,
            NEW.unsubscription_screenshot_id,
            NEW.default_payout,
            NEW.payout_type,
            NEW.payout_model_id,
            NEW.default_payin,
            NEW.payin_type,
            NEW.payin_model_id,
            NEW.start_date,
            NEW.is_expiration,
            NEW.expiry_date,
            NEW.geotargeting_postal_code_directive,
            NEW.outgeo_redirect_type,
            NEW.outgeo_redirect_url,
            NEW.outgeo_redirect_campaign_id,
            NEW.outgeo_redirect_screenshot_id,
            NEW.cookie_duration_time,
            NEW.cookie_duration_unit,
            NEW.access_type,
            NEW.status,
            NEW.epc,
            NEW.tracking_type,
            NEW.tracking_secure,
            NEW.new_until,
            NEW.do_redirect_mobile,
            NEW.mobile_redirect_url,
            NEW.mobile_screenshot_id,
            transaction_timestamp() -- version_start_date
        );
        -- Save the versioned record
        INSERT INTO campaign_versions VALUES (new_version_row.*);
        -- Be a good little trigger and return the NEW record
        RETURN NEW;        
    END
$$;


ALTER FUNCTION w4_application_functions.version_campaign_record() OWNER TO w4;

--
-- Name: version_user_profile_record(); Type: FUNCTION; Schema: w4_application_functions; Owner: w4
--

CREATE FUNCTION version_user_profile_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    new_version_number BIGINT;
    new_version_row public.user_profile_versions;
    BEGIN
        -- Determine if insert or update
        IF (TG_OP = 'UPDATE') THEN
            -- Get the new version info if this is an update
            SELECT INTO new_version_number COALESCE(MAX(version_id)+1,1) FROM user_profile_versions WHERE id = NEW.id;
        ELSEIF (TG_OP = 'INSERT') THEN
            -- Just do a raw insert with version number of 1 and canon date of 0 TIMESTAMPTZ
            new_version_number=1;
        END IF;   
        new_version_row = ROW(
            NEW.id,
            new_version_number,
            NEW.user_uuid,
            NEW.first_name,
            NEW.last_name,
            NEW.address_1,
            NEW.address_2,
            NEW.city,
            NEW.state,
            NEW.zip,
            NEW.country,
            NEW.created,
            NEW.modified,
            NEW.image_id,
            NEW.phone,
            NEW.cell,
            NEW.messenger_id,
            NEW.messenger_type,
            NEW.skype,
            NEW.preferred_language,
            NEW.contact_email,
            NEW.tier_id,
            NEW.currency,
            NEW.region,
            NEW.fax,
            NEW.company_name,
            NEW.company_position,
            NEW.payment_address_1,
            NEW.payment_address_2,
            NEW.payment_city,
            NEW.payment_region,
            NEW.payment_postal_code,
            NEW.payment_country,
            NEW.payment_to,
            NEW.payment_by,
            NEW.payment_schedule,
            NEW.payment_threshold,
            NEW.tax_id,
            NEW.website_url,
            NEW.website_category,
            NEW.website_marketing,
            NEW.is_network_account,
            NEW.is_require_renewed_terms,
            NEW.has_uploaded_w9_file,
            NEW.approver_id,
            NEW.approve_date,
            NEW.registration_comment,
            NEW.register_ip_address,
            NEW.register_date,
            NEW.payment_bank_routing_number,
            NEW.payment_bank_account_number,
            transaction_timestamp() -- version_start_date
        );
        -- Save the versioned record
        INSERT INTO user_profile_versions VALUES (new_version_row.*);
        -- Be a good little trigger and return the NEW record
        RETURN NEW;        
    END
$$;


ALTER FUNCTION w4_application_functions.version_user_profile_record() OWNER TO w4;

SET search_path = w4_automatic_functions, pg_catalog;

--
-- Name: add_conversion_to_rollups(bigint, bigint, bigint, money, money, money, timestamp with time zone); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION add_conversion_to_rollups(aid bigint, cid bigint, pid bigint, acpa money, pcpa money, icpa money, ts timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
    BEGIN
    END
$$;


ALTER FUNCTION w4_automatic_functions.add_conversion_to_rollups(aid bigint, cid bigint, pid bigint, acpa money, pcpa money, icpa money, ts timestamp with time zone) OWNER TO w4;

--
-- Name: add_conversion_to_rollups(bigint, bigint, bigint, bigint, money, money, money, money, timestamp with time zone); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION add_conversion_to_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa money, pcpa money, ppcpa money, icpa money, ts timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ahoy BIGINT; aru_hour "Accounting"."acct_advertiser_rollup_hour";
        adoy BIGINT; aru_day "Accounting"."acct_advertiser_rollup_day";
        amoy BIGINT; aru_month "Accounting"."acct_advertiser_rollup_month";
        ay BIGINT; aru_year "Accounting"."acct_advertiser_rollup_year";
        ihoy BIGINT; iru_hour "Accounting"."acct_internal_rollup_hour";
        idoy BIGINT; iru_day "Accounting"."acct_internal_rollup_day";
        imoy BIGINT; iru_month "Accounting"."acct_internal_rollup_month";
        iy BIGINT; iru_year "Accounting"."acct_internal_rollup_year";
        phoy BIGINT; pru_hour "Accounting"."acct_publisher_rollup_hour";
        pdoy BIGINT; pru_day "Accounting"."acct_publisher_rollup_day";
        pmoy BIGINT; pru_month "Accounting"."acct_publisher_rollup_month";
        py BIGINT; pru_year "Accounting"."acct_publisher_rollup_year";
        exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
    BEGIN
        -- Get Rollup Time Boundaries
        ahoy:=make_hoy(ts); adoy:=make_doy(ts); amoy:=make_moy(ts); ay:=make_y(ts);
        ihoy:=make_hoy(ts); idoy:=make_doy(ts); imoy:=make_moy(ts); iy:=make_y(ts);
        phoy:=make_hoy(ts); pdoy:=make_doy(ts); pmoy:=make_moy(ts); py:=make_y(ts);
        -- Update Advertiser Rollups
        IF acpa<>0::money THEN
            -- Hour
            SELECT INTO aru_hour lookup_acct_advertiser_rollup_hour(aid,cid,pid,ahoy,acpa);
            IF FOUND THEN
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment+acpa;
                aru_hour.num_conversion:=aru_hour.num_converions+1;
            ELSE
                aru_hour.a_id:=aid;
                aru_hour.c_id:=cid;
                aru_hour.p_id:=pid;
                aru_hour.cost_per_action:=acpa;
                aru_hour.a_hoy:=ahoy;
                aru_hour.status:=100;
                aru_hour.total_period_adjustment:=acpa;
                aru_hour.num_conversion:=1;
            END IF;
            -- Day
            SELECT INTO aru_day lookup_acct_advertiser_rollup_day(aid,cid,pid,adoy,acpa);
            IF FOUND THEN
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment+acpa;
                aru_day.num_conversion:=aru_day.num_converions+1;
            ELSE
                aru_day.a_id:=aid;
                aru_day.c_id:=cid;
                aru_day.p_id:=pid;
                aru_day.cost_per_action:=acpa;
                aru_day.a_doy:=adoy;
                aru_day.status:=100;
                aru_day.total_period_adjustment:=acpa;
                aru_day.num_conversion:=1;
            END IF;
            -- Month
            SELECT INTO aru_month lookup_acct_advertiser_rollup_month(aid,cid,pid,amoy,acpa);
            IF FOUND THEN
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment+acpa;
                aru_month.num_conversion:=aru_month.num_converions+1;
            ELSE
                aru_month.a_id:=aid;
                aru_month.c_id:=cid;
                aru_month.p_id:=pid;
                aru_month.cost_per_action:=acpa;
                aru_month.a_moy:=amoy;
                aru_month.status:=100;
                aru_month.total_period_adjustment:=acpa;
                aru_month.num_conversion:=1;
            END IF;
            -- Year
            SELECT INTO aru_year lookup_acct_advertiser_rollup_year(aid,cid,pid,ay,acpa);
            IF FOUND THEN
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment+acpa;
                aru_year.num_conversion:=aru_year.num_converions+1;
            ELSE
                aru_year.a_id:=aid;
                aru_year.c_id:=cid;
                aru_year.p_id:=pid;
                aru_year.cost_per_action:=acpa;
                aru_year.a_y:=ay;
                aru_year.status:=100;
                aru_year.total_period_adjustment:=acpa;
                aru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_advertiser_rollup_year(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
        END IF;
        -- Update Internal Rollups
        IF icpa<>0::money THEN
            -- Hour
            SELECT INTO iru_hour lookup_acct_internal_rollup_hour(aid,cid,pid,ihoy,icpa);
            IF FOUND THEN
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment+icpa;
                iru_hour.num_conversion:=iru_hour.num_converions+1;
            ELSE
                iru_hour.a_id:=aid;
                iru_hour.c_id:=cid;
                iru_hour.p_id:=pid;
                iru_hour.cost_per_action:=icpa;
                iru_hour.i_hoy:=ihoy;
                iru_hour.status:=100;
                iru_hour.total_period_adjustment:=icpa;
                iru_hour.num_conversion:=1;
            END IF;
            -- Day
            SELECT INTO iru_day lookup_acct_internal_rollup_day(aid,cid,pid,idoy,icpa);
            IF FOUND THEN
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment+icpa;
                iru_day.num_conversion:=iru_day.num_converions+1;
            ELSE
                iru_day.a_id:=aid;
                iru_day.c_id:=cid;
                iru_day.p_id:=pid;
                iru_day.cost_per_action:=icpa;
                iru_day.i_doy:=idoy;
                iru_day.status:=100;
                iru_day.total_period_adjustment:=icpa;
                iru_day.num_conversion:=1;
            END IF;
            -- Month
            SELECT INTO iru_month lookup_acct_internal_rollup_month(aid,cid,pid,imoy,icpa);
            IF FOUND THEN
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment+icpa;
                iru_month.num_conversion:=iru_month.num_converions+1;
            ELSE
                iru_month.a_id:=aid;
                iru_month.c_id:=cid;
                iru_month.p_id:=pid;
                iru_month.cost_per_action:=icpa;
                iru_month.i_moy:=imoy;
                iru_month.status:=100;
                iru_month.total_period_adjustment:=icpa;
                iru_month.num_conversion:=1;
            END IF;
            -- Year
            SELECT INTO iru_year lookup_acct_internal_rollup_year(aid,cid,pid,iy,icpa);
            IF FOUND THEN
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment+icpa;
                iru_year.num_conversion:=iru_year.num_converions+1;
            ELSE
                iru_year.a_id:=aid;
                iru_year.c_id:=cid;
                iru_year.p_id:=pid;
                iru_year.cost_per_action:=icpa;
                iru_year.i_y:=iy;
                iru_year.status:=100;
                iru_year.total_period_adjustment:=icpa;
                iru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_internal_rollup_year(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
        END IF;
        -- Update Publisher Rollups
        IF pcpa<>0::money THEN
            -- Hour
            SELECT INTO pru_hour lookup_acct_publisher_rollup_hour(aid,cid,pid,phoy,pcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+pcpa;
                pru_hour.num_conversion:=pru_hour.num_converions+1;
            ELSE
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=pid;
                pru_hour.cost_per_action:=pcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=pcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            SELECT INTO pru_day lookup_acct_publisher_rollup_day(aid,cid,pid,pdoy,pcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+pcpa;
                pru_day.num_conversion:=pru_day.num_converions+1;
            ELSE
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=pid;
                pru_day.cost_per_action:=pcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=pcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            SELECT INTO pru_month lookup_acct_publisher_rollup_month(aid,cid,pid,pmoy,pcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+pcpa;
                pru_month.num_conversion:=pru_month.num_converions+1;
            ELSE
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=pid;
                pru_month.cost_per_action:=pcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=pcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            SELECT INTO pru_year lookup_acct_publisher_rollup_year(aid,cid,pid,py,pcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+pcpa;
                pru_year.num_conversion:=pru_year.num_converions+1;
            ELSE
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=pid;
                pru_year.cost_per_action:=pcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=pcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        IF ppcpa<>0::money THEN
            -- Hour
            SELECT INTO pru_hour lookup_acct_publisher_rollup_hour(aid,cid,ppid,phoy,ppcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+ppcpa;
                pru_hour.num_conversion:=pru_hour.num_converions+1;
            ELSE
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=ppid;
                pru_hour.cost_per_action:=pcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=ppcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            SELECT INTO pru_day lookup_acct_publisher_rollup_day(aid,cid,ppid,pdoy,ppcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+ppcpa;
                pru_day.num_conversion:=pru_day.num_converions+1;
            ELSE
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=ppid;
                pru_day.cost_per_action:=pcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=ppcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            SELECT INTO pru_month lookup_acct_publisher_rollup_month(aid,cid,ppid,pmoy,ppcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+ppcpa;
                pru_month.num_conversion:=pru_month.num_converions+1;
            ELSE
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=ppid;
                pru_month.cost_per_action:=ppcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=ppcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            SELECT INTO pru_year lookup_acct_publisher_rollup_year(aid,cid,ppid,py,ppcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+ppcpa;
                pru_year.num_conversion:=pru_year.num_converions+1;
            ELSE
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=ppid;
                pru_year.cost_per_action:=ppcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=ppcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        RETURN TRUE;
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
    END
$$;


ALTER FUNCTION w4_automatic_functions.add_conversion_to_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa money, pcpa money, ppcpa money, icpa money, ts timestamp with time zone) OWNER TO w4;

--
-- Name: add_conversion_to_rollups(bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION add_conversion_to_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa numeric, pcpa numeric, ppcpa numeric, icpa numeric, ts timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ahoy BIGINT; aru_hour acct_advertiser_rollup_hour; adoy BIGINT; aru_day acct_advertiser_rollup_day; amoy BIGINT; aru_month acct_advertiser_rollup_month; ay BIGINT; aru_year acct_advertiser_rollup_year; ihoy BIGINT; iru_hour acct_internal_rollup_hour; idoy BIGINT; iru_day acct_internal_rollup_day; imoy BIGINT; iru_month acct_internal_rollup_month; iy BIGINT; iru_year acct_internal_rollup_year; phoy BIGINT; pru_hour acct_publisher_rollup_hour; pdoy BIGINT; pru_day acct_publisher_rollup_day; pmoy BIGINT; pru_month acct_publisher_rollup_month; py BIGINT; pru_year acct_publisher_rollup_year; exstate TEXT; exmsg TEXT; exdetail TEXT; exhint TEXT; excontext TEXT;
    BEGIN
        -- Get Rollup Time Boundaries
        ahoy:=make_hoy(ts); adoy:=make_doy(ts); amoy:=make_moy(ts); ay:=make_y(ts); ihoy:=make_hoy(ts); idoy:=make_doy(ts); imoy:=make_moy(ts); iy:=make_y(ts); phoy:=make_hoy(ts); pdoy:=make_doy(ts); pmoy:=make_moy(ts); py:=make_y(ts);
        -- Update Advertiser Rollups
        IF acpa<>0::numeric THEN
            -- Hour
            aru_hour:=lookup_acct_advertiser_rollup_hour(aid,cid,pid,ahoy,acpa);
            IF FOUND THEN
                aru_hour.total_period_adjustment:=aru_hour.total_period_adjustment+acpa;
                aru_hour.num_conversion:=aru_hour.num_conversion+1;
            ELSE
                aru_hour.a_id:=aid;
                aru_hour.c_id:=cid;
                aru_hour.p_id:=pid;
                aru_hour.cost_per_action:=acpa;
                aru_hour.a_hoy:=ahoy;
                aru_hour.status:=100;
                aru_hour.total_period_adjustment:=acpa;
                aru_hour.num_conversion:=1;
            END IF;
            -- Day
            aru_day:=lookup_acct_advertiser_rollup_day(aid,cid,pid,adoy,acpa);
            IF FOUND THEN
                aru_day.total_period_adjustment:=aru_day.total_period_adjustment+acpa;
                aru_day.num_conversion:=aru_day.num_conversion+1;
            ELSE
                aru_day.a_id:=aid;
                aru_day.c_id:=cid;
                aru_day.p_id:=pid;
                aru_day.cost_per_action:=acpa;
                aru_day.a_doy:=adoy;
                aru_day.status:=100;
                aru_day.total_period_adjustment:=acpa;
                aru_day.num_conversion:=1;
            END IF;
            -- Month
            aru_month:=lookup_acct_advertiser_rollup_month(aid,cid,pid,amoy,acpa);
            IF FOUND THEN
                aru_month.total_period_adjustment:=aru_month.total_period_adjustment+acpa;
                aru_month.num_conversion:=aru_month.num_conversion+1;
            ELSE
                aru_month.a_id:=aid;
                aru_month.c_id:=cid;
                aru_month.p_id:=pid;
                aru_month.cost_per_action:=acpa;
                aru_month.a_moy:=amoy;
                aru_month.status:=100;
                aru_month.total_period_adjustment:=acpa;
                aru_month.num_conversion:=1;
            END IF;
            -- Year
            aru_year:=lookup_acct_advertiser_rollup_year(aid,cid,pid,ay,acpa);
            IF FOUND THEN
                aru_year.total_period_adjustment:=aru_year.total_period_adjustment+acpa;
                aru_year.num_conversion:=aru_year.num_conversion+1;
            ELSE
                aru_year.a_id:=aid;
                aru_year.c_id:=cid;
                aru_year.p_id:=pid;
                aru_year.cost_per_action:=acpa;
                aru_year.a_y:=ay;
                aru_year.status:=100;
                aru_year.total_period_adjustment:=acpa;
                aru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_advertiser_rollup_hour(aru_hour);
            PERFORM save_acct_advertiser_rollup_day(aru_day);
            PERFORM save_acct_advertiser_rollup_month(aru_month);
            PERFORM save_acct_advertiser_rollup_year(aru_year);
        END IF;
        -- Update Internal Rollups
        IF icpa<>0::numeric THEN
            -- Hour
            iru_hour:=lookup_acct_internal_rollup_hour(aid,cid,pid,ihoy,icpa);
            IF FOUND THEN
                iru_hour.total_period_adjustment:=iru_hour.total_period_adjustment+icpa;
                iru_hour.num_conversion:=iru_hour.num_conversion+1;
            ELSE
                iru_hour.a_id:=aid;
                iru_hour.c_id:=cid;
                iru_hour.p_id:=pid;
                iru_hour.cost_per_action:=icpa;
                iru_hour.i_hoy:=ihoy;
                iru_hour.status:=100;
                iru_hour.total_period_adjustment:=icpa;
                iru_hour.num_conversion:=1;
            END IF;
            -- Day
            iru_day:=lookup_acct_internal_rollup_day(aid,cid,pid,idoy,icpa);
            IF FOUND THEN
                iru_day.total_period_adjustment:=iru_day.total_period_adjustment+icpa;
                iru_day.num_conversion:=iru_day.num_conversion+1;
            ELSE
                iru_day.a_id:=aid;
                iru_day.c_id:=cid;
                iru_day.p_id:=pid;
                iru_day.cost_per_action:=icpa;
                iru_day.i_doy:=idoy;
                iru_day.status:=100;
                iru_day.total_period_adjustment:=icpa;
                iru_day.num_conversion:=1;
            END IF;
            -- Month
            iru_month:=lookup_acct_internal_rollup_month(aid,cid,pid,imoy,icpa);
            IF FOUND THEN
                iru_month.total_period_adjustment:=iru_month.total_period_adjustment+icpa;
                iru_month.num_conversion:=iru_month.num_conversion+1;
            ELSE
                iru_month.a_id:=aid;
                iru_month.c_id:=cid;
                iru_month.p_id:=pid;
                iru_month.cost_per_action:=icpa;
                iru_month.i_moy:=imoy;
                iru_month.status:=100;
                iru_month.total_period_adjustment:=icpa;
                iru_month.num_conversion:=1;
            END IF;
            -- Year
            iru_year:=lookup_acct_internal_rollup_year(aid,cid,pid,iy,icpa);
            IF FOUND THEN
                iru_year.total_period_adjustment:=iru_year.total_period_adjustment+icpa;
                iru_year.num_conversion:=iru_year.num_conversion+1;
            ELSE
                iru_year.a_id:=aid;
                iru_year.c_id:=cid;
                iru_year.p_id:=pid;
                iru_year.cost_per_action:=icpa;
                iru_year.i_y:=iy;
                iru_year.status:=100;
                iru_year.total_period_adjustment:=icpa;
                iru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_internal_rollup_hour(iru_hour);
            PERFORM save_acct_internal_rollup_day(iru_day);
            PERFORM save_acct_internal_rollup_month(iru_month);
            PERFORM save_acct_internal_rollup_year(iru_year);
        END IF;
        -- Update Publisher Rollups
        IF pcpa<>0::numeric THEN
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(aid,cid,pid,phoy,pcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+pcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion+1;
            ELSE
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=pid;
                pru_hour.cost_per_action:=pcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=pcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(aid,cid,pid,pdoy,pcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+pcpa;
                pru_day.num_conversion:=pru_day.num_conversion+1;
            ELSE
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=pid;
                pru_day.cost_per_action:=pcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=pcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(aid,cid,pid,pmoy,pcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+pcpa;
                pru_month.num_conversion:=pru_month.num_conversion+1;
            ELSE
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=pid;
                pru_month.cost_per_action:=pcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=pcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(aid,cid,pid,py,pcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+pcpa;
                pru_year.num_conversion:=pru_year.num_conversion+1;
            ELSE
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=pid;
                pru_year.cost_per_action:=pcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=pcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_hour(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        IF ppcpa<>0::numeric THEN
            -- Hour
            pru_hour:=lookup_acct_publisher_rollup_hour(aid,cid,ppid,phoy,ppcpa);
            IF FOUND THEN
                pru_hour.total_period_adjustment:=pru_hour.total_period_adjustment+ppcpa;
                pru_hour.num_conversion:=pru_hour.num_conversion+1;
            ELSE
                pru_hour.a_id:=aid;
                pru_hour.c_id:=cid;
                pru_hour.p_id:=ppid;
                pru_hour.cost_per_action:=pcpa;
                pru_hour.p_hoy:=phoy;
                pru_hour.status:=100;
                pru_hour.total_period_adjustment:=ppcpa;
                pru_hour.num_conversion:=1;
            END IF;
            -- Day
            pru_day:=lookup_acct_publisher_rollup_day(aid,cid,ppid,pdoy,ppcpa);
            IF FOUND THEN
                pru_day.total_period_adjustment:=pru_day.total_period_adjustment+ppcpa;
                pru_day.num_conversion:=pru_day.num_conversion+1;
            ELSE
                pru_day.a_id:=aid;
                pru_day.c_id:=cid;
                pru_day.p_id:=ppid;
                pru_day.cost_per_action:=pcpa;
                pru_day.p_doy:=pdoy;
                pru_day.status:=100;
                pru_day.total_period_adjustment:=ppcpa;
                pru_day.num_conversion:=1;
            END IF;
            -- Month
            pru_month:=lookup_acct_publisher_rollup_month(aid,cid,ppid,pmoy,ppcpa);
            IF FOUND THEN
                pru_month.total_period_adjustment:=pru_month.total_period_adjustment+ppcpa;
                pru_month.num_conversion:=pru_month.num_conversion+1;
            ELSE
                pru_month.a_id:=aid;
                pru_month.c_id:=cid;
                pru_month.p_id:=ppid;
                pru_month.cost_per_action:=ppcpa;
                pru_month.p_moy:=pmoy;
                pru_month.status:=100;
                pru_month.total_period_adjustment:=ppcpa;
                pru_month.num_conversion:=1;
            END IF;
            -- Year
            pru_year:=lookup_acct_publisher_rollup_year(aid,cid,ppid,py,ppcpa);
            IF FOUND THEN
                pru_year.total_period_adjustment:=pru_year.total_period_adjustment+ppcpa;
                pru_year.num_conversion:=pru_year.num_conversion+1;
            ELSE
                pru_year.a_id:=aid;
                pru_year.c_id:=cid;
                pru_year.p_id:=ppid;
                pru_year.cost_per_action:=ppcpa;
                pru_year.p_y:=py;
                pru_year.status:=100;
                pru_year.total_period_adjustment:=ppcpa;
                pru_year.num_conversion:=1;
            END IF;
            PERFORM save_acct_publisher_rollup_year(pru_hour);
            PERFORM save_acct_publisher_rollup_day(pru_day);
            PERFORM save_acct_publisher_rollup_month(pru_month);
            PERFORM save_acct_publisher_rollup_year(pru_year);
        END IF;
        RETURN TRUE;
        /*
    EXCEPTION WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS exstate   = RETURNED_SQLSTATE,
                                exmsg     = MESSAGE_TEXT,
                                exdetail  = PG_EXCEPTION_DETAIL,
                                exhint    = PG_EXCEPTION_HINT,
                                excontext = PG_EXCEPTION_CONTEXT;
        PERFORM log_potential_data_anomaly('adding rollup procedure exception','SQLSTATE: ' || exstate || ' ' || exmsg,excontext,exdetail,exhint,'EXCEPTION');
        RETURN FALSE;
        */
    END
$$;


ALTER FUNCTION w4_automatic_functions.add_conversion_to_rollups(aid bigint, cid bigint, pid bigint, ppid bigint, acpa numeric, pcpa numeric, ppcpa numeric, icpa numeric, ts timestamp with time zone) OWNER TO w4;

--
-- Name: all_function_overloads(text, boolean, boolean, text, boolean); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION all_function_overloads(arg_function_name text, arg_match_pattern_end boolean DEFAULT false, arg_match_pattern_begin boolean DEFAULT false, arg_alter_owner text DEFAULT NULL::text, arg_execute boolean DEFAULT false) RETURNS text
    LANGUAGE plpgsql
    AS $$
        DECLARE
            funcrow RECORD;
            var_numfunctions smallint := 0;
            var_numparameters int;
            i int;
            var_paramtext text;
            var_script text:= '';
            var_function_name text := NULL;
            var_schema_name text := NULL;
            var_schema_oid oid := -1;

        BEGIN
            SELECT substring(arg_function_name from '(.*)\.') INTO  var_schema_name;
            IF(var_schema_name NOTNULL) THEN  --- a schema was given
                SELECT substring(arg_function_name from '\.(.*)') INTO  var_function_name;
                SELECT max(pgn.oid) from pg_proc pgp LEFT JOIN pg_catalog.pg_namespace pgn ON pgp.pronamespace = pgn.oid WHERE pgn.nspname = var_schema_name INTO var_schema_oid;
            ELSE 
                var_function_name  = arg_function_name;
            END IF;


            IF(arg_match_pattern_end) THEN
                var_function_name := var_function_name||'%';
            END IF;
            IF(arg_match_pattern_begin) THEN
                var_function_name := '%'||var_function_name;
            END IF;



            FOR funcrow IN SELECT proargtypes,proname,pronamespace FROM pg_proc WHERE proname LIKE var_function_name AND (pronamespace = var_schema_oid OR var_schema_oid = -1) LOOP
                --for some reason array_upper is off by one for the oidvector type, hence the +1
                var_numparameters = array_upper(funcrow.proargtypes, 1) + 1;
                i = 0;
                var_paramtext = funcrow.proname || '(';

                LOOP
                IF i < var_numparameters THEN
                    IF i > 0 THEN
                    var_paramtext = var_paramtext || ', ';
                    END IF;
                    var_paramtext = var_paramtext || (SELECT typname FROM pg_type WHERE oid = funcrow.proargtypes[i]);
                    i = i + 1;
                ELSE
                    EXIT;
                END IF;
                END LOOP;
                IF(arg_alter_owner NOTNULL) THEN
                var_script = var_script || '    ALTER FUNCTION '||(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = funcrow.pronamespace)||'.'|| var_paramtext ||') OWNER TO '||arg_alter_owner||'; 
';
                ELSE
                var_script = var_script || '    DROP FUNCTION IF EXISTS '||(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = funcrow.pronamespace)||'.'|| var_paramtext ||'); 
';
                END IF;
                var_numfunctions = var_numfunctions + 1;

            END LOOP;
            ----IF(arg_execute)THEN   ---- No executes on QA 
            ----    EXECUTE var_script;
            ----END IF;

            RETURN E'-- Found '||var_numfunctions||' functions matching: ' || arg_function_name || E' -- 
' || var_script;

            /* ---------------------------------------------------[ TESTING ] ------------------------------------------------------------
                arg_match_pattern_end boolean DEFAULT false, ---- i.e. publisher_piggyback_pixel_get, publisher_piggyback_pixel_update,  
                arg_match_pattern_begin boolean DEFAULT false,  ---- i.e. publisher_piggyback_pixel_get, campaign_piggyback_pixel_get
                arg_drop boolean DEFAULT false  ---- actually drop it(true), or just return the drop script (FALSE)?

    
                -- RETURN DROP SCRIPT FOR ALL audit_log_* FUNCTIONS IN w4api SCHEMA
                    SELECT test_helpers.drop_all_function_overloads(
                                        arg_function_name:='w4api.audit_log_', 
                                        arg_match_pattern_end:=true
                                        );

                -- REALLY DROP ALL *_piggyback_pixel FUNCTIONS in any schema
                    SELECT test_helpers.drop_all_function_overloads(
                                        arg_function_name:='piggyback_pixel', 
                                        arg_match_pattern_begin:=true,
                                        arg_execute:=true
                                        );
                                        
                -- RETURN DROP SCRIPT FOR ALL FUNCTIONS THAT CONTAIN THE WORD PIGGYBACK    IN w4_application_functions SCHEMA
                    SELECT test_helpers.all_function_overloads(
                                        arg_function_name:='w4_application_functions.piggyback', 
                                        arg_match_pattern_begin:=true,
                                        arg_match_pattern_end:=true
                                        );
                    RESULTS
                    -- FOUND 4 functions matching: w4_application_functions.piggyback --
                        DROP FUNCTION IF EXISTS w4_application_functions.create_piggyback_pixel(int8, int8, varchar, int4, int8, int8); 
                        DROP FUNCTION IF EXISTS w4_application_functions.delete_piggyback_pixel(int8); 
                        DROP FUNCTION IF EXISTS w4_application_functions.update_piggyback_pixel(int8, int8, int8, varchar, int4, int8); 
                        DROP FUNCTION IF EXISTS w4_application_functions.update_piggyback_pixel(int8, int8, int8, text, int4, int8); 

                -- GENERATE ALTER SCRIPTS FOR ALL REMAINING pubs_campaigns_recommendations FUNCTIONS
                    select w4_automatic_functions.all_function_overloads(
                        arg_function_name:='w4api.pubs_campaign_recommendations', 
                        arg_match_pattern_end:=true,
                        arg_alter_owner:='w4',
                        arg_execute:=true
                        );

                    RESULTS
                    -- Found 2 functions matching: w4api.pubs_campaign_recommendations -- 
                        ALTER FUNCTION w4api.pubs_campaign_recommendations_get(int8, int8, int8, json, json, json, json, int8, numeric, numeric, timestamptz, timestamptz, text, int8, int8, bool) OWNER TO w4; 
                        ALTER FUNCTION w4api.pubs_campaign_recommendations_get_list(int8, int8, int8, json, json, json, json, int8, numeric, numeric, timestamptz, timestamptz, text, int8, int8, bool) OWNER TO w4; 
            */

        END;
    $$;


ALTER FUNCTION w4_automatic_functions.all_function_overloads(arg_function_name text, arg_match_pattern_end boolean, arg_match_pattern_begin boolean, arg_alter_owner text, arg_execute boolean) OWNER TO w4;

--
-- Name: clean_json_array(json, boolean, boolean, boolean, text); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION clean_json_array(arg_json_arr json DEFAULT NULL::json, arg_return_int boolean DEFAULT false, arg_return_number boolean DEFAULT false, arg_return_text boolean DEFAULT false, arg_null_replace text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
            DECLARE
            ret_val text;       
            var_int_arr bigint[];
            var_num_arr numeric[];
            var_text_arr text[];
            var_e text;
            BEGIN
            IF((arg_json_arr IS NULL)OR((arg_json_arr)::text='[]')OR((arg_json_arr)::text='{}')) THEN
            return NULL;
            END IF;
            var_text_arr = string_to_array(((arg_json_arr)::text),',');
            IF(arg_return_int) THEN            
                IF(arg_null_replace IS NULL)THEN
                  var_int_arr := ARRAY(
                    SELECT v::integer 
                        FROM unnest(json_array_convert(arg_json_arr)) AS v 
                        WHERE v~E'^\\d+$');
                ELSE
                var_int_arr := ARRAY(
                    SELECT 
                        CASE WHEN v~E'^\\d+$' 
                        THEN v::integer 
                        ELSE arg_null_replace::integer 
                        END 
                    FROM unnest(json_array_convert(arg_json_arr)) AS v);
                END IF;
                  ret_val := array_to_string(var_int_arr, ',');
            ELSIF(arg_return_number)THEN
                IF(arg_null_replace IS NULL)THEN
                var_num_arr := ARRAY(
                    SELECT regexp_replace(v, E'[^0-9\.]','', 'g')::numeric 
                        FROM unnest(json_array_convert(arg_json_arr)) AS v 
                        WHERE length(regexp_replace(v, E'[^0-9\.]','', 'g'))>0);
                ELSE
                  var_num_arr := ARRAY(
                    SELECT 
                        CASE 
                        WHEN (length(regexp_replace(v, E'[^0-9\.]','', 'g'))>0) 
                        THEN regexp_replace(v, E'[^0-9\.]','', 'g')::numeric 
                        ELSE arg_null_replace::numeric 
                        END
                    FROM unnest(json_array_convert(arg_json_arr)) AS v
                    );
                 END IF;
                  ret_val := array_to_string(var_num_arr, ',');
            ELSE
                IF(arg_null_replace IS NULL)THEN
                var_text_arr := ARRAY(SELECT v::text FROM unnest(json_array_convert(arg_json_arr)) AS v WHERE length(v) > 0);
                ELSE
                  var_text_arr := ARRAY(SELECT CASE WHEN length(v) > 0 THEN v::text ELSE arg_null_replace END FROM unnest(json_array_convert(arg_json_arr)) AS v); 
                 END IF;
                  ret_val := array_to_string(var_text_arr, ',');
            END IF;
            
    RETURN ret_val;
            END
        $_$;


ALTER FUNCTION w4_automatic_functions.clean_json_array(arg_json_arr json, arg_return_int boolean, arg_return_number boolean, arg_return_text boolean, arg_null_replace text) OWNER TO w4;

--
-- Name: from_hex(text); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION from_hex(t text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN EXECUTE 'SELECT x'''||t||'''::integer AS hex' LOOP
        RETURN r.hex;
    END LOOP;
END
$$;


ALTER FUNCTION w4_automatic_functions.from_hex(t text) OWNER TO w4;

--
-- Name: having_clause_build(text, text, text); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION having_clause_build(arg_value text, arg_segment text, arg_having_clause text) RETURNS text
    LANGUAGE plpgsql
    AS $$
    BEGIN
        IF (arg_value IS NOT NULL) THEN
            IF (arg_having_clause = '') THEN
                arg_having_clause := ' HAVING ';
            ELSE
                arg_having_clause := arg_having_clause || ' AND ';
            END IF;
            arg_having_clause := arg_having_clause || arg_segment;
        END IF;
        RETURN arg_having_clause;
    END
$$;


ALTER FUNCTION w4_automatic_functions.having_clause_build(arg_value text, arg_segment text, arg_having_clause text) OWNER TO w4;

--
-- Name: normalization_io_get(text, text, text); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION normalization_io_get(arg_function_name text DEFAULT NULL::text, arg_db_var text DEFAULT NULL::text, arg_ui_var text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
    DECLARE
	var_db_var text; 
	var_ui_var text;
    BEGIN

    IF((arg_db_var NOTNULL)AND(arg_ui_var NOTNULL)) THEN  ---- if both values are given, update current values
	SELECT ui_var FROM normalization_io WHERE 
		lower(regexp_replace(db_var, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_db_var, E'[^A-Za-z0-9]','', 'g')) 
		AND lower(regexp_replace(function_name, E'[^A-Za-z0-9]','', 'g'))  = lower(regexp_replace(arg_function_name, E'[^A-Za-z0-9]','', 'g'))  
		INTO var_ui_var;   		--- update db_var from known ui_var
	IF (FOUND) THEN
	     UPDATE normalization_io SET ui_var = arg_ui_var WHERE
		lower(regexp_replace(db_var, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_db_var, E'[^A-Za-z0-9]','', 'g')) 
		AND 
		lower(regexp_replace(function_name, E'[^A-Za-z0-9]','', 'g'))  = lower(regexp_replace(arg_function_name, E'[^A-Za-z0-9]','', 'g'));
		var_ui_var = arg_ui_var;
	ELSE
	     SELECT db_var FROM normalization_io WHERE 
		lower(regexp_replace(ui_var, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_ui_var, E'[^A-Za-z0-9]','', 'g')) 
		AND 
		lower(regexp_replace(function_name, E'[^A-Za-z0-9]','', 'g'))  = lower(regexp_replace(arg_function_name, E'[^A-Za-z0-9]','', 'g'))
		INTO var_db_var;	--- else update ui_var from known db_var
		IF (FOUND) THEN
			UPDATE normalization_io SET db_var = arg_db_var WHERE 
				lower(regexp_replace(ui_var, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_ui_var, E'[^A-Za-z0-9]','', 'g')) 
				AND 
				lower(regexp_replace(function_name, E'[^A-Za-z0-9]','', 'g'))  = lower(regexp_replace(arg_function_name, E'[^A-Za-z0-9]','', 'g'));
				var_db_var = arg_db_var;
		ELSE
			IF(arg_function_name NOTNULL) THEN
			INSERT INTO normalization_io(function_name, db_var, ui_var) 					--- else add new row for db_var & ui_var
				VALUES(arg_function_name, arg_db_var, arg_ui_var); 
				var_ui_var = arg_ui_var; 
			END IF;
		END IF;	
	END IF;
		RETURN COALESCE(var_db_var,var_ui_var);
    END IF;

    IF(arg_db_var NOTNULL)THEN    ---- db var given, so return ui_var
		SELECT ui_var FROM normalization_io WHERE 
			lower(regexp_replace(db_var, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_db_var, E'[^A-Za-z0-9]','', 'g')) 
			AND 
			lower(regexp_replace(function_name, E'[^A-Za-z0-9]','', 'g'))  = lower(regexp_replace(arg_function_name, E'[^A-Za-z0-9]','', 'g'))
			INTO var_ui_var;
	IF (NOT FOUND) THEN
		RETURN arg_db_var;
	END IF;
    END IF;

    IF(arg_ui_var NOTNULL)THEN    ---- db var given, so return ui_var
	SELECT db_var FROM normalization_io WHERE lower(regexp_replace(ui_var, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_ui_var, E'[^A-Za-z0-9]','', 'g')) 
		AND lower(regexp_replace(function_name, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_function_name, E'[^A-Za-z0-9]','', 'g')) INTO var_db_var;		
	IF (NOT FOUND) THEN
		RETURN arg_ui_var;		
	END IF;
    END IF;

    RETURN COALESCE(var_db_var,var_ui_var);
    END;
$$;


ALTER FUNCTION w4_automatic_functions.normalization_io_get(arg_function_name text, arg_db_var text, arg_ui_var text) OWNER TO w4;

--
-- Name: order_clause_build(text, text); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION order_clause_build(arg_orderby text, arg_default_orderby text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        sort TEXT;
        direction TEXT;
    ret_val TEXT;
    BEGIN
    IF(length(arg_orderby) < 1) THEN
        arg_orderby :=  NULL;
    END IF;
        sort      := COALESCE (arg_orderby, arg_default_orderby);
        direction := '';
        direction := CASE direction = '' AND sort ~* '\s+ASC$'  WHEN TRUE THEN 'ASC'  ELSE direction END;
        direction := CASE direction = '' AND sort ~* '\s+DESC$' WHEN TRUE THEN 'DESC' ELSE direction END;
        sort      := regexp_replace (sort, '\s+(' || direction || ')$', '', 'i');
        ret_val   := ' ORDER BY ' || sort || ' ' || direction || ' ';
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4_automatic_functions.order_clause_build(arg_orderby text, arg_default_orderby text) OWNER TO w4;

--
-- Name: where_clause_build(text, text, text); Type: FUNCTION; Schema: w4_automatic_functions; Owner: w4
--

CREATE FUNCTION where_clause_build(arg_value text, arg_segment text, arg_where_clause text) RETURNS text
    LANGUAGE plpgsql
    AS $$
    BEGIN
        IF (arg_value IS NOT NULL) THEN
            IF (arg_where_clause = '') THEN
                arg_where_clause := ' WHERE ';
            ELSE
                arg_where_clause := arg_where_clause || ' AND ';
            END IF;
            arg_where_clause := arg_where_clause || arg_segment;
        END IF;
        RETURN arg_where_clause;
    END
$$;


ALTER FUNCTION w4_automatic_functions.where_clause_build(arg_value text, arg_segment text, arg_where_clause text) OWNER TO w4;

SET search_path = w4api, pg_catalog;

--
-- Name: admin_alert_settings_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_alert_settings_get(arg_user_id bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        var_found_id bigint; 
        var_campaign_cap_alerts json;
        var_advertiser_cap_alerts json;
        var_publisher_cap_alerts json;
        var_global_cap_alerts json; 
    BEGIN
SELECT json_array_elements((  
SELECT w4api.admin_alert_sub_settings_get_list(
    arg_user_id:=arg_user_id,
    arg_entity_type:='cap', 
    arg_entity_name:='campaign'
  ))) INTO var_campaign_cap_alerts;
SELECT json_array_elements((
SELECT w4api.admin_alert_sub_settings_get_list(
    arg_user_id:=arg_user_id,
    arg_entity_type:='cap', 
    arg_entity_name:='advertiser'
  ))) INTO var_advertiser_cap_alerts;
SELECT json_array_elements((
SELECT w4api.admin_alert_sub_settings_get_list(
    arg_user_id:=arg_user_id,
    arg_entity_type:='cap', 
    arg_entity_name:='publisher'
  ))) INTO var_publisher_cap_alerts;
SELECT json_array_elements((
SELECT w4api.admin_alert_sub_settings_get_list(
    arg_user_id:=arg_user_id,
    arg_entity_type:='cap' 
))) INTO var_global_cap_alerts;

        SELECT row_to_json (row)
          FROM (
		SELECT
		COALESCE(var_campaign_cap_alerts ->> 'alert_when',var_global_cap_alerts ->> 'alert_when',(SELECT value FROM global_settings WHERE name = 'Cap Alert Percent')) AS campaign_cap_alert_when,
		COALESCE(var_campaign_cap_alerts ->> 'alert_unit',var_global_cap_alerts ->> 'alert_unit','percent') AS campaign_cap_alert_unit,
		COALESCE(var_campaign_cap_alerts ->> 'alert_status',var_global_cap_alerts ->> 'alert_status','TRUE') AS campaign_cap_alert_status,
		COALESCE(var_advertiser_cap_alerts ->> 'alert_when',var_global_cap_alerts ->> 'alert_when',(SELECT value FROM global_settings WHERE name = 'Cap Alert Percent')) AS advertiser_cap_alert_when,
		COALESCE(var_advertiser_cap_alerts ->> 'alert_unit',var_global_cap_alerts ->> 'alert_unit','percent') AS advertiser_cap_alert_unit,
		COALESCE(var_advertiser_cap_alerts ->> 'alert_status',var_global_cap_alerts ->> 'alert_status','TRUE') AS advertiser_cap_alert_status,
		COALESCE(var_publisher_cap_alerts ->> 'alert_when',var_global_cap_alerts ->> 'alert_when',(SELECT value FROM global_settings WHERE name = 'Cap Alert Percent')) AS publisher_cap_alert_when,
		COALESCE(var_publisher_cap_alerts ->> 'alert_unit',var_global_cap_alerts ->> 'alert_unit','percent') AS publisher_cap_alert_unit,
		COALESCE(var_publisher_cap_alerts ->> 'alert_status',var_global_cap_alerts ->> 'alert_status','TRUE') AS publisher_cap_alert_status,
		COALESCE(var_global_cap_alerts ->> 'alert_when',(SELECT value FROM global_settings WHERE name = 'Cap Alert Percent')) AS global_cap_alert_when,
		COALESCE(var_global_cap_alerts ->> 'alert_unit','percent') AS global_cap_alert_unit,
		COALESCE(var_global_cap_alerts ->> 'alert_status','TRUE') AS global_cap_alert_status
          )row INTO ret_val;
    
    RETURN ret_val;
    END;
  $$;


ALTER FUNCTION w4api.admin_alert_settings_get(arg_user_id bigint) OWNER TO w4;

--
-- Name: admin_alert_settings_update(bigint, bigint, text, text, boolean, text, text, boolean, text, text, boolean, text, text, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_alert_settings_update(arg_id bigint DEFAULT (0)::bigint, arg_user_id bigint DEFAULT (0)::bigint, arg_advertiser_cap_alert_when text DEFAULT NULL::text, arg_advertiser_cap_alert_unit text DEFAULT NULL::text, arg_advertiser_cap_alert_status boolean DEFAULT NULL::boolean, arg_publisher_cap_alert_when text DEFAULT NULL::text, arg_publisher_cap_alert_unit text DEFAULT NULL::text, arg_publisher_cap_alert_status boolean DEFAULT NULL::boolean, arg_campaign_cap_alert_when text DEFAULT NULL::text, arg_campaign_cap_alert_unit text DEFAULT NULL::text, arg_campaign_cap_alert_status boolean DEFAULT NULL::boolean, arg_global_cap_alert_when text DEFAULT NULL::text, arg_global_cap_alert_unit text DEFAULT NULL::text, arg_global_cap_alert_status boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
    BEGIN
SELECT w4api.admin_alert_sub_settings_update(
  arg_id:=arg_id,
    arg_user_id:=arg_user_id, 
    arg_entity_id:=0,
    arg_entity_type:='cap', 
    arg_entity_name:='campaign', 
      arg_sub_entity_type:='', 
    arg_sub_entity_name:='', 
    arg_alert_when:=arg_campaign_cap_alert_when, 
    arg_alert_unit:=arg_campaign_cap_alert_unit, 
    arg_alert_status:=arg_campaign_cap_alert_status
  ) AS campaigns,
  w4api.admin_alert_sub_settings_update(
  arg_id:=arg_id,
    arg_user_id:=arg_user_id,
    arg_entity_id:=0, 
    arg_entity_type:='cap', 
    arg_entity_name:='advertiser', 
      arg_sub_entity_type:='', 
    arg_sub_entity_name:='', 
    arg_alert_when:=arg_advertiser_cap_alert_when, 
    arg_alert_unit:=arg_advertiser_cap_alert_unit, 
    arg_alert_status:=arg_advertiser_cap_alert_status
  ) AS advertisers,
   w4api.admin_alert_sub_settings_update(
    arg_id:=arg_id,
    arg_user_id:=arg_user_id, 
    arg_entity_id:=0,
    arg_entity_type:='cap', 
    arg_entity_name:='publisher', 
     arg_sub_entity_type:='', 
    arg_sub_entity_name:='', 
    arg_alert_unit:=arg_publisher_cap_alert_unit, 
    arg_alert_when:=arg_publisher_cap_alert_when, 
    arg_alert_status:=arg_publisher_cap_alert_status
  ) AS publishers,-------- its just pulling the value from global?? never the percent or the on/off
 w4api.admin_alert_sub_settings_update(
    arg_user_id:=arg_user_id, 
    arg_entity_type:='cap', 
    arg_alert_unit:=arg_global_cap_alert_unit, 
    arg_alert_when:= (SELECT value FROM global_settings WHERE name = 'Cap Alert Percent'),
    arg_alert_status:=arg_global_cap_alert_status
  ) AS global INTO ret_val;
 RETURN (SELECT w4api.admin_alert_settings_get(arg_user_id:=arg_user_id));
 RETURN ret_val ;
    END;
  $$;


ALTER FUNCTION w4api.admin_alert_settings_update(arg_id bigint, arg_user_id bigint, arg_advertiser_cap_alert_when text, arg_advertiser_cap_alert_unit text, arg_advertiser_cap_alert_status boolean, arg_publisher_cap_alert_when text, arg_publisher_cap_alert_unit text, arg_publisher_cap_alert_status boolean, arg_campaign_cap_alert_when text, arg_campaign_cap_alert_unit text, arg_campaign_cap_alert_status boolean, arg_global_cap_alert_when text, arg_global_cap_alert_unit text, arg_global_cap_alert_status boolean) OWNER TO w4;

--
-- Name: admin_alert_sub_settings_get_list(bigint, bigint, bigint, text, text, bigint, text, text, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_alert_sub_settings_get_list(arg_id bigint DEFAULT (0)::bigint, arg_user_id bigint DEFAULT (0)::bigint, arg_entity_id bigint DEFAULT (0)::bigint, arg_entity_type text DEFAULT ''::text, arg_entity_name text DEFAULT ''::text, arg_sub_entity_id bigint DEFAULT (0)::bigint, arg_sub_entity_type text DEFAULT ''::text, arg_sub_entity_name text DEFAULT ''::text, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        select_clause text;  
    BEGIN
    IF(arg_count) THEN
    select_clause = 'count(id)';
    ELSE
    select_clause = 
  'COALESCE(alert_when,'''') AS alert_when,
  COALESCE(alert_unit,'''') AS alert_unit,
    COALESCE(alert_status,NULL) AS alert_status';
    END IF;
    
    EXECUTE
  'SELECT
    array_to_json (array_agg(row_to_json (results)))
        FROM (
      SELECT row_to_json (row)
          FROM (

SELECT '||select_clause||'
  FROM admin_alert_settings
    WHERE
  ('||arg_id||'<>0  AND id = '||arg_id||')
OR (
     user_id = '||arg_user_id||'
      AND entity_id = '||arg_entity_id||'
          AND entity_type = '''||arg_entity_type||'''
              AND entity_name = '''||arg_entity_name||'''
      AND sub_entity_id = '||arg_sub_entity_id ||'
          AND sub_entity_type = '''||arg_sub_entity_type|| '''
              AND sub_entity_name = '''||arg_sub_entity_name||''')

        ) row
                                    ) results;'
                        INTO ret_val;
                        RETURN ret_val;
    END;
  $$;


ALTER FUNCTION w4api.admin_alert_sub_settings_get_list(arg_id bigint, arg_user_id bigint, arg_entity_id bigint, arg_entity_type text, arg_entity_name text, arg_sub_entity_id bigint, arg_sub_entity_type text, arg_sub_entity_name text, arg_count boolean) OWNER TO w4;

--
-- Name: admin_alert_sub_settings_update(bigint, bigint, bigint, text, text, bigint, text, text, text, text, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_alert_sub_settings_update(arg_id bigint DEFAULT (0)::bigint, arg_user_id bigint DEFAULT (0)::bigint, arg_entity_id bigint DEFAULT (0)::bigint, arg_entity_type text DEFAULT ''::text, arg_entity_name text DEFAULT ''::text, arg_sub_entity_id bigint DEFAULT (0)::bigint, arg_sub_entity_type text DEFAULT ''::text, arg_sub_entity_name text DEFAULT ''::text, arg_alert_unit text DEFAULT NULL::text, arg_alert_when text DEFAULT NULL::text, arg_alert_status boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        var_found_id bigint;  
    BEGIN

  SELECT id FROM admin_alert_settings
    WHERE user_id = arg_user_id 
      AND entity_id = arg_entity_id 
          AND entity_type = arg_entity_type 
              AND entity_name = arg_entity_name
      AND sub_entity_id = arg_sub_entity_id 
          AND sub_entity_type = arg_sub_entity_type 
              AND sub_entity_name = arg_sub_entity_name INTO var_found_id;
  IF (FOUND) THEN
    UPDATE admin_alert_settings
      SET
          alert_when=COALESCE(arg_alert_when,alert_when),
          alert_unit=COALESCE(arg_alert_unit,alert_unit),
          alert_status=COALESCE(arg_alert_status,alert_status),
          modified=CURRENT_TIMESTAMP
    WHERE id = var_found_id;
  ELSE
    INSERT INTO admin_alert_settings (
          user_id,
          entity_id,
          entity_type,
          entity_name,
          sub_entity_id,
          sub_entity_type,
          sub_entity_name,
          alert_when,
          alert_unit,
          alert_status,
          modified
        )
    VALUES(
          arg_user_id,
          arg_entity_id,
          arg_entity_type,
          arg_entity_name,
          arg_sub_entity_id,
          arg_sub_entity_type,
          arg_sub_entity_name,
          arg_alert_when,
          arg_alert_unit,
          arg_alert_status,
          CURRENT_TIMESTAMP) RETURNING id INTO var_found_id; 
  END IF;
      RETURN  (SELECT w4api.admin_alert_sub_settings_get_list(arg_id:=var_found_id));
    END;
  $$;


ALTER FUNCTION w4api.admin_alert_sub_settings_update(arg_id bigint, arg_user_id bigint, arg_entity_id bigint, arg_entity_type text, arg_entity_name text, arg_sub_entity_id bigint, arg_sub_entity_type text, arg_sub_entity_name text, arg_alert_unit text, arg_alert_when text, arg_alert_status boolean) OWNER TO w4;

--
-- Name: admin_global_settings_check(bigint, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_global_settings_check(arg_id bigint DEFAULT (- (1)::bigint), arg_name text DEFAULT NULL::text, arg_type text DEFAULT NULL::text, arg_value text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	    BEGIN

        PERFORM id FROM global_settings  ---- CHECK: IF a setting with that name already exists
        	WHERE lower(regexp_replace(name, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_name, E'[^A-Za-z0-9]','', 'g')) AND id != arg_id;  
		IF(FOUND) THEN
			RAISE EXCEPTION 'Global Setting named "%" already exists.', arg_name; 
			RETURN FALSE;
		END IF; 

		IF(arg_id != -1) THEN
			PERFORM name FROM global_settings WHERE id = arg_id;  ---- CHECK: if arg_id is a valid id
		 		IF(NOT FOUND) THEN
					RAISE EXCEPTION 'Global Setting ID:% was not found.', arg_id; 
					RETURN FALSE; 
				END IF; 
		END IF; 
	
		RETURN true;	  
    END;
$$;


ALTER FUNCTION w4api.admin_global_settings_check(arg_id bigint, arg_name text, arg_type text, arg_value text) OWNER TO w4;

--
-- Name: admin_global_settings_create(text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_global_settings_create(arg_name text, arg_value text DEFAULT NULL::text, arg_type text DEFAULT '0'::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		var_new_id integer;
	    BEGIN
	    IF((SELECT w4api.admin_global_settings_check(arg_name:=arg_name,arg_value:=arg_value))<> true) THEN RETURN ('{}'); END IF;
	    INSERT INTO global_settings(
	        name, 
	        value, 
	        type
		)
	    VALUES(
	        arg_name,
	        arg_value,
	        arg_type   
		) RETURNING id INTO var_new_id;
	RETURN  ('{' || '"new": ' || (SELECT w4api.admin_global_settings_get_list(var_new_id)) || '}')::json;
    END;
$$;


ALTER FUNCTION w4api.admin_global_settings_create(arg_name text, arg_value text, arg_type text) OWNER TO w4;

--
-- Name: admin_global_settings_delete(bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_global_settings_delete(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_type text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
		    DECLARE
			delete_where_clause text  := '';
			var_type text := '';
			var_name text := '';
		    BEGIN
		    PERFORM * FROM global_settings WHERE id = arg_id;
			IF((NOT FOUND) AND (arg_id NOTNULL)) THEN
				RAISE EXCEPTION 'Global Setting ID:% was not found.', arg_id; 
				RETURN false;
			ELSE
				delete_where_clause := w4_automatic_functions.where_clause_build(arg_id::TEXT, 'id = ' || arg_id, delete_where_clause);
			END IF;

			
		    SELECT type FROM global_settings WHERE lower(regexp_replace(type, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_type, E'[^A-Za-z0-9]','', 'g')) INTO var_type;
			IF((NOT FOUND) AND (arg_type NOTNULL)) THEN
				RAISE EXCEPTION 'Global Settings of type: "%" were not found.', arg_type; 
				RETURN false;
			ELSE
				delete_where_clause := w4_automatic_functions.where_clause_build(var_type::TEXT, 'type = ''' || var_type||'''', delete_where_clause);
			END IF;

		     
		    SELECT name FROM global_settings WHERE lower(regexp_replace(name, E'[^A-Za-z0-9]','', 'g')) = lower(regexp_replace(arg_name, E'[^A-Za-z0-9]','', 'g')) INTO var_name;
			IF((NOT FOUND) AND (arg_name NOTNULL)) THEN
				RAISE EXCEPTION 'Global Setting named "%" was not found.', arg_name; 
				RETURN false;
			ELSE
				delete_where_clause := w4_automatic_functions.where_clause_build(var_name::TEXT, 'name = ''' || var_name||'''', delete_where_clause);
			END IF;

		    IF(length(delete_where_clause) > 9) THEN --- length(WHERE id=1) = 10
			EXECUTE 'DELETE FROM global_settings' || delete_where_clause;
		    	RETURN true;
		    END IF;
		RETURN false;
	    END;
	$$;


ALTER FUNCTION w4api.admin_global_settings_delete(arg_id bigint, arg_name text, arg_type text) OWNER TO w4;

--
-- Name: admin_global_settings_get(bigint, text, text, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_global_settings_get(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_type text DEFAULT NULL::text, arg_value text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
		var_count_json text :='';
	    BEGIN	        
		IF arg_count THEN
		     var_count_json:= ', "count": ' || (SELECT w4api.admin_global_settings_get_list(
			arg_id:=arg_id,
			arg_name:=arg_name,
			arg_value:=arg_value,
			arg_type:=arg_type,
			arg_count:=true))::text;
		END IF;
		ret_val := ('{"results": ' || (SELECT w4api.admin_global_settings_get_list(
			arg_id:=arg_id,
			arg_name:=arg_name,
			arg_value:=arg_value,
			arg_type:=arg_type,
			arg_orderby:=arg_orderby,
			arg_limit:=arg_limit,
			arg_offset:=arg_offset)) || var_count_json  || '}')::json;
	RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.admin_global_settings_get(arg_id bigint, arg_name text, arg_type text, arg_value text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: admin_global_settings_get_list(bigint, text, text, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_global_settings_get_list(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_type text DEFAULT NULL::text, arg_value text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
   ret_val json;
   where_clause text := ''; 
   order_clause text := ''; 
    BEGIN
	where_clause := w4_automatic_functions.where_clause_build(arg_id::TEXT, ' id = ' || arg_id, where_clause);
	where_clause := w4_automatic_functions.where_clause_build(arg_name::TEXT, ' name = ''' || arg_name||'''', where_clause);
	where_clause := w4_automatic_functions.where_clause_build(arg_value::TEXT, ' value = ''' || arg_value||'''', where_clause);
	where_clause := w4_automatic_functions.where_clause_build(arg_value::TEXT, ' type = ''' || arg_type||'''', where_clause);
	order_clause := order_clause_build(arg_orderby, 'id ASC');
	IF(arg_count) THEN  
	     EXECUTE
		'SELECT COALESCE (COUNT(1), 0) 
			FROM ( SELECT id FROM global_settings' 
		     || where_clause ||' ) AS count'
		INTO ret_val;			
	 ELSE 
	     EXECUTE
		'SELECT array_to_json (array_agg(row_to_json (results)))
		    FROM (        
			SELECT row_to_json (row)
			    FROM ( 
				SELECT 
				   id 
				  ,name
				  ,type
				  ,value                           
				FROM global_settings' 
				|| where_clause
				|| order_clause
				|| ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
				|| ' OFFSET ' || arg_offset || '
			    ) row
			) results'
		INTO ret_val;
	    END IF;
	RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.admin_global_settings_get_list(arg_id bigint, arg_name text, arg_type text, arg_value text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: admin_global_settings_update(bigint, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_global_settings_update(arg_id bigint, arg_name text DEFAULT NULL::text, arg_value text DEFAULT NULL::text, arg_type text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
	    BEGIN

	IF((SELECT w4api.admin_global_settings_check(arg_name:=arg_name,arg_value:=arg_value,arg_type:=arg_type,arg_id:=arg_id))<> true) THEN RETURN ('{}'); END IF;
	UPDATE global_settings SET
		  name = COALESCE(arg_name,name),
		  value = COALESCE(arg_value,value),
		  type = COALESCE(arg_type,type,(arg_id)::text)
		WHERE id = arg_id;

		ret_val := ('{ "results": ' || (SELECT w4api.admin_global_settings_get_list(arg_id := arg_id)) || '}')::json;
	RETURN ret_val;	  
    END;
$$;


ALTER FUNCTION w4api.admin_global_settings_update(arg_id bigint, arg_name text, arg_value text, arg_type text) OWNER TO w4;

--
-- Name: admin_pubs_terms_get(bigint, bigint, timestamp with time zone, integer, text, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_pubs_terms_get(arg_id bigint DEFAULT NULL::bigint, arg_modified_by bigint DEFAULT NULL::bigint, arg_date_modified timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_limit integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;		
		where_clause text := '';
		order_clause text := '';
		var_count text :='';
	    BEGIN
		where_clause := w4_automatic_functions.where_clause_build(arg_id::TEXT, 'apt.id = ' || arg_id, where_clause);
		where_clause := w4_automatic_functions.where_clause_build(arg_modified_by::TEXT, 'apt.modified_by = ' || arg_modified_by, where_clause);
		where_clause := w4_automatic_functions.where_clause_build(arg_date_modified::TEXT, 'apt.date_modified::date = ''' ||arg_date_modified::date||'''', where_clause);		
		order_clause :=  w4_automatic_functions.order_clause_build(arg_orderby, 'apt.id DESC');
		
	      EXECUTE
		    'SELECT row_to_json (row)
				    FROM (
					SELECT
					    apt.modified_by AS modified_by_id,
					    up.first_name||'' ''||up.last_name AS modified_by_name,
					    apt.date_modified,
					    apt.terms
					FROM admin_pubs_terms apt
					LEFT JOIN user_profiles up ON apt.modified_by=up.user_id'
					||where_clause|| ' '||order_clause|| ' LIMIT ' || COALESCE(arg_limit::text, '1') || ' OFFSET ' || arg_offset || '
				    ) row'
		INTO ret_val;

		IF(arg_count)THEN 
		EXECUTE
		    'SELECT 
			count(id)::text
				FROM admin_pubs_terms' || where_clause 
		INTO var_count;
		var_count = ', count: ' ||var_count ;     
		END IF;
        
	RETURN  ('{' || '"results":' || ret_val || var_count||'}')::json;	  
    END;
$$;


ALTER FUNCTION w4api.admin_pubs_terms_get(arg_id bigint, arg_modified_by bigint, arg_date_modified timestamp with time zone, arg_limit integer, arg_orderby text, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: admin_pubs_terms_update(text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION admin_pubs_terms_update(arg_terms text DEFAULT NULL::text, arg_user_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
		var_new_tc_id bigint;
	BEGIN
	PERFORM id FROM users WHERE active='active' AND (access = 'admin' OR access = 'accountant') AND id = arg_user_id;
	IF FOUND THEN	
	INSERT INTO admin_pubs_terms (terms,modified_by) VALUES(arg_terms,arg_user_id) RETURNING id INTO var_new_tc_id;
	RETURN (SELECT w4api.admin_pubs_terms_get(arg_id := COALESCE(var_new_tc_id,currval('admin_pubs_terms_id_seq'))));
	ELSE
		RAISE WARNING 'Insufficient permission to alter''Publisher Terms and Conditions'' at this time.';
			RETURN('{' || '"results":{}}')::json;
	END IF;
    END;
$$;


ALTER FUNCTION w4api.admin_pubs_terms_update(arg_terms text, arg_user_id bigint) OWNER TO w4;

--
-- Name: advertiser_banned_publisher_create(bigint, bigint, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_banned_publisher_create(arg_advertiser_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_campaign_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM * FROM advertisers WHERE id = arg_advertiser_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No advertiser found with the id: %', arg_advertiser_id;
        END IF;
        
        PERFORM * FROM users WHERE id = arg_publisher_id AND access='publisher';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No publisher found with the id: %', arg_publisher_id;
        END IF;

        PERFORM * FROM advertiser_banned_publishers WHERE
            (advertiser_id = arg_advertiser_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(arg_campaign_id, 0) = COALESCE(campaign_id, 0)) AND
            (COALESCE(arg_sub_id_1, '') = sub_id_1) AND
            (COALESCE(arg_sub_id_2, '') = sub_id_2) AND
            (COALESCE(arg_sub_id_3, '') = sub_id_3) AND
            (COALESCE(arg_sub_id_4, '') = sub_id_4) AND
            (status = 'active');
        IF (FOUND) THEN
            RAISE EXCEPTION 'That banned publisher combination exists already.';
        END IF;

        INSERT INTO advertiser_banned_publishers
            (advertiser_id, publisher_id, campaign_id, sub_id_1, sub_id_2, sub_id_3, sub_id_4, status)
            VALUES (arg_advertiser_id, arg_publisher_id, arg_campaign_id, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, 'active');

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.advertiser_banned_publisher_create(arg_advertiser_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_campaign_id bigint) OWNER TO w4;

--
-- Name: advertiser_banned_publisher_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_banned_publisher_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM advertiser_banned_publishers WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher advertiser banned publisher (%).', arg_id;
        END IF;

        UPDATE advertiser_banned_publishers SET
            status = 'inactive'
        WHERE id = arg_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.advertiser_banned_publisher_delete(arg_id bigint) OWNER TO w4;

--
-- Name: advertiser_banned_publisher_get(text, text, bigint, text, text, text, text, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_banned_publisher_get(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_advertiser_id bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (advertiser_banned_publisher_get_count(arg_search_campaign, arg_search_publisher, arg_advertiser_id, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || advertiser_banned_publisher_get_list(null, arg_search_campaign, arg_search_publisher, arg_advertiser_id, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.advertiser_banned_publisher_get(arg_search_campaign text, arg_search_publisher text, arg_advertiser_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: advertiser_banned_publisher_get_count(text, text, bigint, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_banned_publisher_get_count(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_advertiser_id bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'abp.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'abp.publisher_id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'abp.campaign_id = ' || arg_search_campaign, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);
        where_clause := where_clause_build(arg_sub_id_1::TEXT, 'abp.sub_id_1 = $$' || arg_sub_id_1 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_2::TEXT, 'abp.sub_id_2 = $$' || arg_sub_id_2 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_3::TEXT, 'abp.sub_id_3 = $$' || arg_sub_id_3 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_4::TEXT, 'abp.sub_id_4 = $$' || arg_sub_id_4 || '$$', where_clause);
        where_clause := where_clause_build('active', 'abp.status = $$active$$', where_clause);

        IF (arg_search_campaign IS NULL) THEN
            where_clause := where_clause_build('advertiser specific', 'abp.campaign_id IS NULL', where_clause);
        END IF;

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0)
                                FROM advertiser_banned_publishers abp
                                LEFT JOIN advertisers ad ON abp.advertiser_id = ad.id
                                LEFT JOIN users u ON abp.publisher_id = u.id
                                LEFT JOIN user_profiles up ON (u.id = up.user_id)
                                LEFT JOIN campaigns c ON abp.campaign_id = c.id '
                                || where_clause ||
            ' LIMIT 1; '
        INTO retval;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.advertiser_banned_publisher_get_count(arg_search_campaign text, arg_search_publisher text, arg_advertiser_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: advertiser_banned_publisher_get_list(bigint, text, text, bigint, text, text, text, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_banned_publisher_get_list(arg_id bigint DEFAULT NULL::bigint, arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_advertiser_id bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        order_clause TEXT;
        var_advertiser_id bigint;

    BEGIN
        where_clause := where_clause_build(arg_id::TEXT, 'abp.id = ' || arg_id, where_clause);
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'abp.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'abp.publisher_id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'abp.campaign_id = ' || arg_search_campaign, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);
        where_clause := where_clause_build(arg_sub_id_1::TEXT, 'abp.sub_id_1 = $$' || arg_sub_id_1 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_2::TEXT, 'abp.sub_id_2 = $$' || arg_sub_id_2 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_3::TEXT, 'abp.sub_id_3 = $$' || arg_sub_id_3 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_4::TEXT, 'abp.sub_id_4 = $$' || arg_sub_id_4 || '$$', where_clause);        
        where_clause := where_clause_build('active', 'abp.status = $$active$$', where_clause);

        IF (arg_search_campaign IS NULL) THEN
            where_clause := where_clause_build('advertiser specific', 'abp.campaign_id IS NULL', where_clause);
        END IF;

        order_clause := order_clause_build(arg_orderby, 'abp.id');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                               SELECT
                                    abp.id AS id,
                                    abp.advertiser_id AS advertiser_id,
                                    ad.name AS advertiser_name,
                                    abp.publisher_id AS publisher_id, 
                                    COALESCE(up.company_name, pg_catalog.concat(up.first_name, CHR(1), up.last_name)::character varying) AS publisher_name, 
                                    abp.campaign_id AS campaign_id,
                                    c.name AS campaign_name,
                                    abp.sub_id_1 AS sub_id_1,
                                    abp.sub_id_2 AS sub_id_2, 
                                    abp.sub_id_3 AS sub_id_3,
                                    abp.sub_id_4 AS sub_id_4
                                FROM advertiser_banned_publishers abp
                                LEFT JOIN advertisers ad ON abp.advertiser_id = ad.id
                                LEFT JOIN users u ON abp.publisher_id = u.id
                                LEFT JOIN user_profiles up ON (u.id = up.user_id)
                                LEFT JOIN campaigns c ON abp.campaign_id = c.id'
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' ||arg_offset || '
                            ) row
                    ) results;'
        INTO retval;
        RETURN retval;
    END
$_$;


ALTER FUNCTION w4api.advertiser_banned_publisher_get_list(arg_id bigint, arg_search_campaign text, arg_search_publisher text, arg_advertiser_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: advertiser_banned_publisher_update(bigint, bigint, bigint, bigint, text, text, text, text, public.status_entity); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_banned_publisher_update(arg_id bigint, arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_status public.status_entity DEFAULT NULL::public.status_entity) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM advertiser_banned_publishers WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher advertiser banned publisher (%).', arg_id;
        END IF;

        UPDATE advertiser_banned_publishers SET            
            campaign_id     = COALESCE (arg_campaign_id, campaign_id),
            publisher_id    = COALESCE (arg_publisher_id, publisher_id),
            sub_id_1        = COALESCE (arg_sub_id_1, sub_id_1),
            sub_id_2        = COALESCE (arg_sub_id_2, sub_id_2),
            sub_id_3        = COALESCE (arg_sub_id_3, sub_id_3),
            sub_id_4        = COALESCE (arg_sub_id_4, sub_id_4),
            status          = COALESCE (arg_status, status)
        WHERE id = arg_id;

        RETURN advertiser_banned_publisher_get_list(arg_id);
    END;
$$;


ALTER FUNCTION w4api.advertiser_banned_publisher_update(arg_id bigint, arg_advertiser_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_status public.status_entity) OWNER TO w4;

--
-- Name: advertiser_details_date_get(bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_details_date_get(arg_advertiser_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (advertiser_details_date_get_count(arg_advertiser_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || advertiser_details_date_get_list(arg_advertiser_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.advertiser_details_date_get(arg_advertiser_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: advertiser_details_date_get_count(bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_details_date_get_count(arg_advertiser_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'rd.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    rd.doy AS date, 
                    rd.advertiser_id, 
                    count(DISTINCT rd.campaign_id) AS campaigns, 
                    sum(rd.unique_clicks) AS clicks, 
                    sum(rd.total_conversions) AS conversions, 
                    COALESCE(sum(rd.total_conversions) / NULLIF(sum(rd.unique_clicks), 0::numeric) * 100::numeric, 0::numeric) AS conversion_pct, 
                    COALESCE(sum(rd.total_pay_in) / NULLIF(sum(rd.unique_clicks), 0::numeric), 0) AS epc,
                    sum(rd.total_pay_in) AS total_in, 
                    sum(rd.total_pay_out) AS total_out, 
                    COALESCE(sum(rd.total_pay_in) - sum(rd.total_pay_out), 0) AS total_profit, 
                    COALESCE((sum(rd.total_pay_in) - sum(rd.total_pay_out)) * 100::numeric / NULLIF(sum(rd.total_pay_in), 0::numeric), 0::numeric) AS profit_pct, 
                    COALESCE(sum(rd.total_pay_in)/NULLIF(sum(rd.total_conversions),0),0) AS average_in,
                    COALESCE(sum(rd.total_pay_out)/NULLIF(sum(rd.total_conversions),0),0) AS average_out
                FROM reports_daily rd
                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id '
                || where_clause || '
                GROUP BY rd.doy, rd.advertiser_id
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.advertiser_details_date_get_count(arg_advertiser_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: advertiser_details_date_get_list(bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_details_date_get_list(arg_advertiser_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'rd.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'date DESC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    rd.doy AS date, 
                                    rd.advertiser_id, 
                                    count(DISTINCT rd.campaign_id) AS campaigns, 
                                    sum(rd.unique_clicks) AS clicks, 
                                    sum(rd.total_clicks) AS total_clicks, 
                                    sum(rd.total_conversions) AS conversions, 
                                    ROUND(COALESCE(sum(rd.total_conversions) / NULLIF(sum(rd.unique_clicks), 0::numeric), 0)::numeric, 4) AS conversion_pct, 
                                    COALESCE(sum(rd.total_pay_in) / NULLIF(sum(rd.unique_clicks), 0::numeric), 0) AS epc,
                                    sum(rd.total_pay_in) AS total_in, 
                                    sum(rd.total_pay_out) AS total_out, 
                                    COALESCE(sum(rd.total_pay_in) - sum(rd.total_pay_out), 0) AS total_profit, 
                                    ROUND(COALESCE(1 - sum(rd.total_pay_out) / NULLIF(sum(rd.total_pay_in), 0), 0)::numeric, 4) AS profit_pct, 
                                    COALESCE(sum(rd.total_pay_in)/NULLIF(sum(rd.total_conversions),0),0) AS average_in,
                                    COALESCE(sum(rd.total_pay_out)/NULLIF(sum(rd.total_conversions),0),0) AS average_out
                                FROM reports_daily rd
                                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id '
                                || where_clause || '
                                GROUP BY rd.doy, rd.advertiser_id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.advertiser_details_date_get_list(arg_advertiser_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: advertiser_details_sidebar_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_details_sidebar_get(arg_advertiser_id bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        var_per text;
        join_range_clause text := '';
        join_currency_clause text := '';

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'adv.id = ' || arg_advertiser_id, where_clause);
        
        IF (arg_currency_id IS NOT NULL) THEN
            join_currency_clause := ' AND cmp.currency_id = ' || arg_currency_id;
        END IF;

        SELECT credit_limit_per FROM advertisers WHERE id = arg_advertiser_id INTO var_per;

        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No advertiser found with id: %', arg_advertiser_id;
        END IF;

        CASE var_per
            WHEN 'year' THEN
                join_range_clause := ' AND rd.doy >= ' || make_doy(CURRENT_TIMESTAMP - INTERVAL '1 year') || ' AND rd.doy < ' || make_doy(CURRENT_TIMESTAMP); 
            WHEN 'month' THEN
                join_range_clause := ' AND rd.doy >= ' || make_doy(CURRENT_TIMESTAMP - INTERVAL '1 month') || ' AND rd.doy < ' || make_doy(CURRENT_TIMESTAMP); 
            WHEN 'week' THEN
                join_range_clause := ' AND rd.doy >= ' || make_doy(CURRENT_TIMESTAMP - INTERVAL '1 week') || ' AND rd.doy < ' || make_doy(CURRENT_TIMESTAMP); 
            WHEN 'day' THEN
                join_range_clause := ' AND rd.doy >= ' || make_doy(CURRENT_TIMESTAMP - INTERVAL '1 day') || ' AND rd.doy < ' || make_doy(CURRENT_TIMESTAMP); 
        END CASE;
               
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    max(adv.name) AS advertiser_name,
                                    max(mup.id) AS manager_id,
                                    max(concat(mup.first_name, '' '', mup.last_name)) AS manager_name, 
                                    max(adv.status::text)::character varying AS status, 
                                    max(adv.description) AS notes, 
                                    max(adv.credit_limit) AS credit_limit, 
                                    max(adv.credit_limit_per) AS credit_limit_per, 
                                    max(adv.allow_over_limit) AS allow_over_limit, 
                                    sum(rd.total_pay_in) AS credit_balance, 
                                    COALESCE((max(adv.credit_limit) - sum(rd.total_pay_in)::double precision) / NULLIF(max(adv.credit_limit), 0::double precision) * 100::double precision, 0::double precision) AS credit_percent_under, 
                                    COALESCE((sum(rd.total_pay_in)::double precision - max(adv.credit_limit)) / NULLIF(max(adv.credit_limit), 0::double precision) * 100::double precision, 0::double precision) AS credit_percent_over, 
                                    max(apt.name::text) AS payment_terms, 
                                    max(adv.next_payment_due_date::text)::character varying(36) AS next_payment_due_date, 
                                    COALESCE(max(adv.contact_name), max(pc.first_name) || '' '' || max(pc.last_name)) AS contact_name,
                                    COALESCE(max(adv.phone), max(pc.primary_phone)) AS phone, 
                                    COALESCE(max(adv.address_1), max(ac.address_1)) AS address_1, 
                                    COALESCE(max(adv.address_2), max(ac.address_2)) AS address_2, 
                                    COALESCE(max(adv.city), max(ac.city_name)) AS city, 
                                    COALESCE(max(adv.state), max(acr.ascii_name)) AS state, 
                                    COALESCE(max(adv.zip), max(ac.postal_code)) AS zip, 
                                    COALESCE(max(adv.country), max(acc.country)) AS country, 
                                    COALESCE(max(adv.email), max(pc.email_address)) AS email, 
                                    max(adv.url::text)::character varying(255) AS website,
                                    max(adv.note_login_url::text)::character varying(255) AS note_login_url, 
                                    max(adv.note_login_username::text)::character varying(255) AS note_login_username,
                                    max(adv.note_login_password) AS tracking_password,
                                    max(bc.address_1) AS billing_address_1,
                                    max(bc.address_2) AS billing_address_2,
                                    max(bc.city_name) AS billing_city,
                                    max(r.ascii_name) AS billing_region,
                                    max(c.country) AS billing_country,
                                    max(bc.postal_code) AS billing_zip,
                                    max(im.description) AS messenger_type,
                                    max(bc.messenger_name) AS messenger_name,
                                    max(adv.next_payment_due_date) AS next_payment_due
                                FROM advertisers adv
                                LEFT JOIN users mgr ON mgr.id = adv.manager_id
                                LEFT JOIN user_profiles mup ON mgr.id = mup.user_id
                                LEFT JOIN contacts bc ON adv.billing_contact_id = bc.id
                                LEFT JOIN im_types im ON bc.messenger_type = im.id
                                LEFT JOIN geo_typeahead_countries c ON bc.country_id = c.id
                                LEFT JOIN geo_typeahead_region r ON bc.region_id = r.id
                                LEFT JOIN contacts pc ON adv.primary_contact_id = pc.id
                                LEFT JOIN contacts ac ON adv.account_contact_id = ac.id
                                LEFT JOIN geo_typeahead_countries acc ON ac.country_id = acc.id
                                LEFT JOIN geo_typeahead_region acr ON ac.region_id = acr.id
                                LEFT JOIN reports_daily rd ON adv.id = rd.advertiser_id ' || join_range_clause || '
                                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id ' || join_currency_clause || '
                                LEFT JOIN advertiser_payment_terms apt ON adv.payment_terms_id = apt.id '
                                || where_clause || '
                                GROUP BY adv.id, mup.first_name, mup.last_name, apt.name, apt.description
                                LIMIT 1
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.advertiser_details_sidebar_get(arg_advertiser_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: advertiser_details_traffic_get(bigint, text, timestamp with time zone, timestamp with time zone, text, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_details_traffic_get(arg_advertiser_id bigint, arg_search_campaign text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        summary json;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (advertiser_details_traffic_get_count(arg_advertiser_id, arg_search_campaign, arg_min_date, arg_max_date, arg_campaign_status, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        IF arg_summary THEN
            summary := advertiser_details_traffic_get_summary(arg_advertiser_id, arg_search_campaign, arg_min_date, arg_max_date, arg_campaign_status, arg_currency_id);
        ELSE
            summary := '{}';
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || advertiser_details_traffic_get_list(arg_advertiser_id, arg_search_campaign, arg_min_date, arg_max_date, arg_campaign_status, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "summary": ' || summary ||
                        ', "count": ' || count_total ||
                        ', "cache": 1'
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.advertiser_details_traffic_get(arg_advertiser_id bigint, arg_search_campaign text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: advertiser_details_traffic_get_count(bigint, text, timestamp with time zone, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_details_traffic_get_count(arg_advertiser_id bigint, arg_search_campaign text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'rd.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'rd.campaign_id = ' || arg_search_campaign, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    rd.campaign_id, 
                    max(cmp.name) AS campaign_name, 
                    sum(rd.unique_clicks) AS clicks,
                    sum(rd.total_conversions) AS conversions,
                    COALESCE(sum(rd.total_conversions) / NULLIF(sum(rd.unique_clicks), 0), 0) * 100 AS conversion_pct,
                    COALESCE(sum(rd.total_pay_in) / NULLIF(sum(rd.unique_clicks), 0), 0) AS aepc,
                    sum(rd.total_pay_in) AS total_in, sum(rd.total_pay_out) AS total_out,
                    sum(rd.profit) AS total_profit,
                    COALESCE(sum(rd.profit) / NULLIF(sum(rd.total_pay_in), 0), 0) * 100 AS profit_pct,
                    COALESCE(sum(rd.total_pay_in) / NULLIF(sum(rd.total_conversions), 0), 0) AS average_in,
                    COALESCE(sum(rd.total_pay_out) / NULLIF(sum(rd.total_conversions), 0), 0) AS average_out,
                    cmp.status,
                    COALESCE(max(v7dtl.unique_clk_trend), $$0+0+0+0+0+0+0$$::character varying::text) AS trending
                FROM reports_daily rd
                LEFT JOIN tvw_7_day_trend_line v7dtl ON rd.campaign_id = v7dtl.campaign_id AND v7dtl.total_clk_trend != ''1''
                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id '
                || where_clause || '
                GROUP BY rd.campaign_id, cmp.status
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.advertiser_details_traffic_get_count(arg_advertiser_id bigint, arg_search_campaign text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: advertiser_details_traffic_get_list(bigint, text, timestamp with time zone, timestamp with time zone, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_details_traffic_get_list(arg_advertiser_id bigint, arg_search_campaign text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
--WHERE v7dtl.publisher_id IS NULL  this was in the original view but not sure as to why
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'rd.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'rd.campaign_id = ' || arg_search_campaign, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    rd.campaign_id, 
                                    max(cmp.name) AS campaign_name, 
                                    sum(rd.unique_clicks) AS clicks,
                                    sum(rd.total_clicks) AS total_clicks,
                                    sum(rd.total_conversions) AS conversions,
                                    ROUND(COALESCE(sum(rd.total_conversions) / NULLIF(sum(rd.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct,
                                    COALESCE(sum(rd.total_pay_in) / NULLIF(sum(rd.unique_clicks), 0), 0) AS aepc,
                                    sum(rd.total_pay_in) AS total_in, sum(rd.total_pay_out) AS total_out,
                                    sum(rd.profit) AS total_profit,
                                    ROUND(COALESCE(1 - sum(rd.profit) / NULLIF(sum(rd.total_pay_in), 0), 0)::numeric, 4) AS profit_pct,
                                    COALESCE(sum(rd.total_pay_in) / NULLIF(sum(rd.total_conversions), 0), 0) AS average_in,
                                    COALESCE(sum(rd.total_pay_out) / NULLIF(sum(rd.total_conversions), 0), 0) AS average_out,
                                    cmp.status,
                                    COALESCE(max(v7dtl.unique_clk_trend), $$0+0+0+0+0+0+0$$::character varying::text) AS trending
                                FROM reports_daily rd
                                LEFT JOIN tvw_7_day_trend_line v7dtl ON rd.campaign_id = v7dtl.campaign_id AND v7dtl.total_clk_trend != ''1'' AND v7dtl.publisher_id IS NULL
                                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id '
                                || where_clause || '
                                GROUP BY rd.campaign_id, cmp.status '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.advertiser_details_traffic_get_list(arg_advertiser_id bigint, arg_search_campaign text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: advertiser_details_traffic_get_summary(bigint, text, timestamp with time zone, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_details_traffic_get_summary(arg_advertiser_id bigint, arg_search_campaign text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'rd.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'rd.campaign_id = ' || arg_search_campaign, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    COALESCE(sum(rd.unique_clicks), 0) AS clicks,
                                    COALESCE(sum(rd.total_clicks), 0) AS total_clicks,
                                    COALESCE(sum(rd.total_conversions), 0) AS conversions,
                                    ROUND(COALESCE(sum(rd.total_conversions) / NULLIF(sum(rd.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct,
                                    COALESCE(sum(rd.total_pay_in) / NULLIF(sum(rd.unique_clicks), 0), 0) AS aepc,
                                    COALESCE(sum(rd.total_pay_in), 0) AS total_in,
                                    COALESCE(sum(rd.total_pay_out), 0) AS total_out,
                                    COALESCE(sum(rd.profit), 0) AS total_profit,
                                    ROUND(COALESCE(sum(rd.profit) / NULLIF(sum(rd.total_pay_in), 0), 0)::numeric, 4) AS profit_pct
                                FROM reports_daily rd
                                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id '
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.advertiser_details_traffic_get_summary(arg_advertiser_id bigint, arg_search_campaign text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: advertiser_get(text, text, json, json, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_get(arg_traffic_search text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_advertiser_ids json DEFAULT NULL::json, arg_manager_ids json DEFAULT NULL::json, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (advertiser_get_count(arg_traffic_search, arg_status, arg_advertiser_ids, arg_manager_ids), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || advertiser_get_list(arg_traffic_search, arg_status, arg_advertiser_ids, arg_manager_ids, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.advertiser_get(arg_traffic_search text, arg_status text, arg_advertiser_ids json, arg_manager_ids json, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: advertiser_get_count(text, text, json, json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_get_count(arg_traffic_search text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_advertiser_ids json DEFAULT NULL::json, arg_manager_ids json DEFAULT NULL::json) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        var_advertiser_ids bigint[];
	var_manager_ids bigint[];

    BEGIN
	IF arg_advertiser_ids IS NOT NULL THEN
		var_advertiser_ids := json_array_convert( arg_advertiser_ids )::bigint[];
	END IF;

	IF arg_manager_ids IS NOT NULL THEN
		var_manager_ids := json_array_convert( arg_manager_ids )::bigint[];
	END IF;

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0)
            FROM advertisers ad
            LEFT JOIN users aum ON (aum.id = ad.manager_id)
            LEFT JOIN contacts acm ON (acm.id = aum.primary_contact_id)
            WHERE
                ($1 IS NULL OR ad.status = $1) AND
                ($2 IS NULL OR ARRAY[ad.id] && $2) AND
                ($3 IS NULL OR ARRAY[ad.manager_id::bigint] && $3) AND
                ($4 IS NULL OR (
                    (ad.id::text ILIKE $4) OR
                    (matches(ad.name, $4)) OR
                    (ad.manager_id::text ILIKE $4 AND aum.access = ''admin'') OR
                    (matches(pg_catalog.concat(acm.first_name, CHR(1), acm.last_name)::text, $4)))
                )
             LIMIT 1; '
        INTO retval
        USING arg_status, var_advertiser_ids, var_manager_ids, arg_traffic_search;

        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.advertiser_get_count(arg_traffic_search text, arg_status text, arg_advertiser_ids json, arg_manager_ids json) OWNER TO w4;

--
-- Name: advertiser_get_list(text, text, json, json, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_get_list(arg_traffic_search text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_advertiser_ids json DEFAULT NULL::json, arg_manager_ids json DEFAULT NULL::json, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        var_advertiser_ids bigint[];
	var_manager_ids bigint[];

    BEGIN
	IF arg_advertiser_ids IS NOT NULL THEN
		var_advertiser_ids := json_array_convert( arg_advertiser_ids )::bigint[];
	END IF;

	IF arg_manager_ids IS NOT NULL THEN
		var_manager_ids := json_array_convert( arg_manager_ids )::bigint[];
	END IF;

        order_clause := order_clause_build(arg_orderby, 'advertiser_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    ad.status AS status,
                                    ad.id AS advertiser_id,
                                    ad.name AS advertiser_name,
                                    ad.manager_id AS manager_id,
                                    CONCAT (COALESCE(acm.first_name, aup.first_name), '' '', COALESCE(acm.last_name, aup.last_name)) AS manager_name, 
                                    ad.url AS tracking_url
                                FROM advertisers ad
                                LEFT JOIN users aum ON (aum.id = ad.manager_id)
                                LEFT JOIN contacts acm ON (acm.id = aum.primary_contact_id)
                                LEFT JOIN user_profiles aup ON (aup.user_id = aum.id)
                                WHERE
                                    ($1 IS NULL OR ad.status = $1) AND
                                    ($2 IS NULL OR ARRAY[ad.id] && $2) AND
                                    ($3 IS NULL OR ARRAY[ad.manager_id::bigint] && $3) AND
                                    ($4 IS NULL OR (
                                        (ad.id::text ILIKE $4) OR
                                        (matches(ad.name, $4)) OR
                                        (ad.manager_id::text ILIKE $4 AND aum.access = ''admin'') OR
                                        (matches(pg_catalog.concat(acm.first_name, CHR(1), acm.last_name)::text, $4)))
                                    ) '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val
        USING arg_status, var_advertiser_ids, var_manager_ids, arg_traffic_search;

        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.advertiser_get_list(arg_traffic_search text, arg_status text, arg_advertiser_ids json, arg_manager_ids json, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: advertiser_id_update(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_id_update(arg_advertiser_id_current bigint, arg_advertiser_id_requested bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_ftp_username text;
        var_ftp_folder text;

    BEGIN
        PERFORM id FROM advertisers WHERE id = arg_advertiser_id_current;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the specified advertiser (%).', arg_advertiser_id_current;
        END IF;

        PERFORM id FROM advertisers WHERE id = arg_advertiser_id_requested;
        IF (FOUND) THEN
            RAISE EXCEPTION 'Requested advertiser id already exists (%).', arg_advertiser_id_requested;
        END IF;

        UPDATE advertisers SET            
            id = arg_advertiser_id_requested
        WHERE id = arg_advertiser_id_current;

        UPDATE advertiser_contacts SET
            advertiser_id = arg_advertiser_id_requested
        WHERE advertiser_id = arg_advertiser_id_current;

        var_ftp_username := CONCAT('a', arg_advertiser_id_requested::text);
        var_ftp_folder := CONCAT('/home/', var_ftp_username);
        UPDATE ftp.user SET
            username = var_ftp_username,
            advertiser_id = arg_advertiser_id_requested,
            folder = var_ftp_folder
        WHERE advertiser_id = arg_advertiser_id_current;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.advertiser_id_update(arg_advertiser_id_current bigint, arg_advertiser_id_requested bigint) OWNER TO w4;

--
-- Name: advertiser_traffic_get(bigint, text, timestamp with time zone, timestamp with time zone, text, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_traffic_get(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_search_advertiser text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_total_in_min numeric DEFAULT NULL::numeric, arg_total_in_max numeric DEFAULT NULL::numeric, arg_total_out_min numeric DEFAULT NULL::numeric, arg_total_out_max numeric DEFAULT NULL::numeric, arg_average_in_min numeric DEFAULT NULL::numeric, arg_average_in_max numeric DEFAULT NULL::numeric, arg_average_out_min numeric DEFAULT NULL::numeric, arg_average_out_max numeric DEFAULT NULL::numeric, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
        summary json;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (advertiser_traffic_get_count(arg_advertiser_id, arg_search_advertiser, arg_min_date, arg_max_date, arg_status, arg_conversion_percent_min,
                arg_conversion_percent_max, arg_profit_percent_min, arg_profit_percent_max, arg_total_in_min, arg_total_in_max, arg_total_out_min, arg_total_out_max,
                arg_average_in_min, arg_average_in_max, arg_average_out_min, arg_average_out_max, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        IF arg_summary THEN
            summary := advertiser_traffic_get_summary(arg_advertiser_id, arg_search_advertiser, arg_min_date, arg_max_date, arg_status, arg_conversion_percent_min,
                arg_conversion_percent_max, arg_profit_percent_min, arg_profit_percent_max, arg_total_in_min, arg_total_in_max, arg_total_out_min, arg_total_out_max,
                arg_average_in_min, arg_average_in_max, arg_average_out_min, arg_average_out_max, arg_currency_id);
        ELSE
            summary := '{}';
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || advertiser_traffic_get_list(arg_advertiser_id, arg_search_advertiser, arg_min_date, arg_max_date, arg_status, arg_conversion_percent_min,
                arg_conversion_percent_max, arg_profit_percent_min, arg_profit_percent_max, arg_total_in_min, arg_total_in_max, arg_total_out_min, arg_total_out_max,
                arg_average_in_min, arg_average_in_max, arg_average_out_min, arg_average_out_max, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "summary": ' || summary ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.advertiser_traffic_get(arg_advertiser_id bigint, arg_search_advertiser text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_total_in_min numeric, arg_total_in_max numeric, arg_total_out_min numeric, arg_total_out_max numeric, arg_average_in_min numeric, arg_average_in_max numeric, arg_average_out_min numeric, arg_average_out_max numeric, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: advertiser_traffic_get_count(bigint, text, timestamp with time zone, timestamp with time zone, text, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_traffic_get_count(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_search_advertiser text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_total_in_min numeric DEFAULT NULL::numeric, arg_total_in_max numeric DEFAULT NULL::numeric, arg_total_out_min numeric DEFAULT NULL::numeric, arg_total_out_max numeric DEFAULT NULL::numeric, arg_average_in_min numeric DEFAULT NULL::numeric, arg_average_in_max numeric DEFAULT NULL::numeric, arg_average_out_min numeric DEFAULT NULL::numeric, arg_average_out_max numeric DEFAULT NULL::numeric, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        having_clause text := '';
        join_clause_rcrd text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'adv.id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_search_advertiser::TEXT, 'adv.name ILIKE $$%' || arg_search_advertiser || '%$$ OR adv.id::text ILIKE $$%' || arg_search_advertiser || '%$$', where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'adv.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build('moreThanZero', '(rcrd.total_clicks > 0 OR rcrd.total_conversions > 0)', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        having_clause := having_clause_build(arg_conversion_percent_min::TEXT, 'COALESCE( sum(rcrd.total_conversions) / NULLIF( sum( rcrd.unique_clicks), 0 ) * 100, 0 ) BETWEEN ' || arg_conversion_percent_min || ' AND ' || arg_conversion_percent_max, having_clause);
        having_clause := having_clause_build(arg_profit_percent_min::TEXT, 'COALESCE( 100 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ) * 100, 0 ) BETWEEN ' || arg_profit_percent_min || ' AND ' || arg_profit_percent_max, having_clause);
        having_clause := having_clause_build(arg_total_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in), 0) BETWEEN ' || arg_total_in_min || ' AND ' || arg_total_in_max, having_clause);
        having_clause := having_clause_build(arg_total_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out), 0) BETWEEN ' || arg_total_out_min || ' AND ' || arg_total_out_max, having_clause);
        having_clause := having_clause_build(arg_average_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_in_min || ' AND ' || arg_average_in_max, having_clause);
        having_clause := having_clause_build(arg_average_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out ) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_out_min || ' AND ' || arg_average_out_max, having_clause);

        IF (arg_min_date IS NOT NULL) THEN
            join_clause_rcrd := ' AND rcrd.doy >= ' || min_doy || ' AND rcrd.doy < ' || max_doy;
        END IF;

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    adv.id AS advertiser_id, 
                    max(adv.name) AS advertiser_name, 
                    max(adv.status) AS status, 
                    max(rcrd.doy) AS doy, 
                    COALESCE( sum(rcrd.total_conversions), 0) AS conversions, 
                    COALESCE( sum(rcrd.total_clicks), 0) AS total_clicks, 
                    COALESCE( sum(rcrd.unique_clicks), 0) AS unique_clicks, 
                    COALESCE( sum(rcrd.total_pay_in), 0) AS total_in, 
                    COALESCE( sum(rcrd.total_pay_out), 0) AS total_out,
                    COALESCE( sum(rcrd.total_conversions) / NULLIF( sum(rcrd.unique_clicks), 0 ) * 100, 0 ) AS conversion_percent,
                    COALESCE( sum(rcrd.total_pay_out) / NULLIF( sum(rcrd.unique_clicks), 0 ), 0 ) AS epc,
                    COALESCE( sum(rcrd.total_pay_in - rcrd.total_pay_out), 0) AS profit,
                    COALESCE( 100 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ) * 100, 0 ) AS profit_percent,
                    COALESCE( sum(rcrd.total_pay_in) / NULLIF(sum(rcrd.total_conversions), 0 ), 0 ) AS average_in,
                    COALESCE( sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_conversions), 0 ), 0 ) AS average_out
                FROM advertisers adv
                LEFT JOIN reports_daily rcrd ON adv.id = rcrd.advertiser_id ' || join_clause_rcrd || '
                LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id '
                || where_clause || '
                GROUP BY adv.id '
                || having_clause || '
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.advertiser_traffic_get_count(arg_advertiser_id bigint, arg_search_advertiser text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_total_in_min numeric, arg_total_in_max numeric, arg_total_out_min numeric, arg_total_out_max numeric, arg_average_in_min numeric, arg_average_in_max numeric, arg_average_out_min numeric, arg_average_out_max numeric, arg_currency_id bigint) OWNER TO w4;

--
-- Name: advertiser_traffic_get_list(bigint, text, timestamp with time zone, timestamp with time zone, text, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_traffic_get_list(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_search_advertiser text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_total_in_min numeric DEFAULT NULL::numeric, arg_total_in_max numeric DEFAULT NULL::numeric, arg_total_out_min numeric DEFAULT NULL::numeric, arg_total_out_max numeric DEFAULT NULL::numeric, arg_average_in_min numeric DEFAULT NULL::numeric, arg_average_in_max numeric DEFAULT NULL::numeric, arg_average_out_min numeric DEFAULT NULL::numeric, arg_average_out_max numeric DEFAULT NULL::numeric, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        having_clause text := '';
        join_clause_rcrd text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'adv.id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_search_advertiser::TEXT, 'adv.name ILIKE $$%' || arg_search_advertiser || '%$$ OR adv.id::text ILIKE $$%' || arg_search_advertiser || '%$$', where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'adv.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build('moreThanZero', '(rcrd.total_clicks > 0 OR rcrd.total_conversions > 0)', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        having_clause := having_clause_build(arg_conversion_percent_min::TEXT, 'COALESCE( sum(rcrd.total_conversions) / NULLIF( sum( rcrd.unique_clicks), 0 ) * 100, 0 ) BETWEEN ' || arg_conversion_percent_min || ' AND ' || arg_conversion_percent_max, having_clause);
        having_clause := having_clause_build(arg_profit_percent_min::TEXT, 'COALESCE( 100 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ) * 100, 0 ) BETWEEN ' || arg_profit_percent_min || ' AND ' || arg_profit_percent_max, having_clause);
        having_clause := having_clause_build(arg_total_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in), 0) BETWEEN ' || arg_total_in_min || ' AND ' || arg_total_in_max, having_clause);
        having_clause := having_clause_build(arg_total_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out), 0) BETWEEN ' || arg_total_out_min || ' AND ' || arg_total_out_max, having_clause);
        having_clause := having_clause_build(arg_average_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_in_min || ' AND ' || arg_average_in_max, having_clause);
        having_clause := having_clause_build(arg_average_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out ) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_out_min || ' AND ' || arg_average_out_max, having_clause);

        order_clause := order_clause_build(arg_orderby, 'advertiser_name ASC');

        IF (arg_min_date IS NOT NULL) THEN
            join_clause_rcrd := ' AND rcrd.doy >= ' || min_doy || ' AND rcrd.doy < ' || max_doy;
        END IF;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    adv.id AS advertiser_id, 
                                    max(adv.name) AS advertiser_name, 
                                    max(adv.status) AS status, 
                                    max(rcrd.doy) AS doy, 
                                    COALESCE( sum(rcrd.total_conversions), 0) AS conversions, 
                                    COALESCE( sum(rcrd.total_clicks), 0) AS total_clicks, 
                                    COALESCE( sum(rcrd.unique_clicks), 0) AS unique_clicks, 
                                    COALESCE( sum(rcrd.total_pay_in), 0) AS total_in, 
                                    COALESCE( sum(rcrd.total_pay_out), 0) AS total_out,
                                    ROUND(COALESCE( sum(rcrd.total_conversions) / NULLIF( sum(rcrd.unique_clicks), 0 ), 0 )::numeric, 4) AS conversion_percent,
                                    COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.unique_clicks), 0 ), 0 ) AS epc,
                                    COALESCE( sum(rcrd.total_pay_in - rcrd.total_pay_out), 0) AS profit,
                                    ROUND(COALESCE( 1 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ), 0 )::numeric, 4) AS profit_percent,
                                    COALESCE( sum(rcrd.total_pay_in) / NULLIF(sum(rcrd.total_conversions), 0 ), 0 ) AS average_in,
                                    COALESCE( sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_conversions), 0 ), 0 ) AS average_out
                                FROM advertisers adv
                                LEFT JOIN reports_daily rcrd ON adv.id = rcrd.advertiser_id ' || join_clause_rcrd || '
                                LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id '
                                || where_clause || '
                                GROUP BY adv.id '
                                || having_clause ||
                                order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.advertiser_traffic_get_list(arg_advertiser_id bigint, arg_search_advertiser text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_total_in_min numeric, arg_total_in_max numeric, arg_total_out_min numeric, arg_total_out_max numeric, arg_average_in_min numeric, arg_average_in_max numeric, arg_average_out_min numeric, arg_average_out_max numeric, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: advertiser_traffic_get_summary(bigint, text, timestamp with time zone, timestamp with time zone, text, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION advertiser_traffic_get_summary(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_search_advertiser text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_total_in_min numeric DEFAULT NULL::numeric, arg_total_in_max numeric DEFAULT NULL::numeric, arg_total_out_min numeric DEFAULT NULL::numeric, arg_total_out_max numeric DEFAULT NULL::numeric, arg_average_in_min numeric DEFAULT NULL::numeric, arg_average_in_max numeric DEFAULT NULL::numeric, arg_average_out_min numeric DEFAULT NULL::numeric, arg_average_out_max numeric DEFAULT NULL::numeric, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        having_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'adv.id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build (arg_search_advertiser::TEXT, 'adv.name ILIKE $$%' || arg_search_advertiser || '%$$ OR adv.id::text ILIKE $$%' || arg_search_advertiser || '%$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rcrd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rcrd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'adv.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        having_clause := having_clause_build(arg_conversion_percent_min::TEXT, 'COALESCE( sum(rcrd.total_conversions) / NULLIF( sum( rcrd.unique_clicks), 0 ) * 100, 0 ) BETWEEN ' || arg_conversion_percent_min || ' AND ' || arg_conversion_percent_max, having_clause);
        having_clause := having_clause_build(arg_profit_percent_min::TEXT, 'COALESCE( 100 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ) * 100, 0 ) BETWEEN ' || arg_profit_percent_min || ' AND ' || arg_profit_percent_max, having_clause);
        having_clause := having_clause_build(arg_total_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in), 0) BETWEEN ' || arg_total_in_min || ' AND ' || arg_total_in_max, having_clause);
        having_clause := having_clause_build(arg_total_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out), 0) BETWEEN ' || arg_total_out_min || ' AND ' || arg_total_out_max, having_clause);
        having_clause := having_clause_build(arg_average_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_in_min || ' AND ' || arg_average_in_max, having_clause);
        having_clause := having_clause_build(arg_average_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out ) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_out_min || ' AND ' || arg_average_out_max, having_clause);

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT 
                                    COALESCE(sum(conversions), 0) AS conversions,
                                    COALESCE(sum(clicks), 0) AS clicks,
                                    COALESCE(sum(total_clicks), 0) AS total_clicks,
                                    ROUND(COALESCE(sum(conversions) / NULLIF(sum(clicks), 0), 0)::numeric, 4) AS rate,
                                    COALESCE(sum(revenue) / NULLIF(sum(clicks), 0 ), 0) AS epc,
                                    COALESCE(sum(revenue), 0) AS revenue,
                                    ROUND(COALESCE(1 - sum(payout) / NULLIF(sum(revenue), 0))::numeric, 4) AS margin,
                                    COALESCE(sum(revenue) - sum(payout), 0) AS profit
                                FROM (
                                    SELECT
                                        COALESCE( sum(rcrd.total_conversions), 0) AS conversions, 
                                        COALESCE( sum(rcrd.unique_clicks), 0) AS clicks,
                                        COALESCE( sum(rcrd.total_clicks), 0) AS total_clicks,
                                        COALESCE( sum(rcrd.total_pay_out), 0 ) AS payout,
                                        COALESCE( sum(rcrd.total_pay_in), 0) AS revenue
                                    FROM advertisers adv
                                    LEFT JOIN reports_daily rcrd ON adv.id = rcrd.advertiser_id
                                    LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id '
                                    || where_clause || '
                                    GROUP BY adv.id '
                                    || having_clause || '
                                ) grouped_result
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.advertiser_traffic_get_summary(arg_advertiser_id bigint, arg_search_advertiser text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_total_in_min numeric, arg_total_in_max numeric, arg_total_out_min numeric, arg_total_out_max numeric, arg_average_in_min numeric, arg_average_in_max numeric, arg_average_out_min numeric, arg_average_out_max numeric, arg_currency_id bigint) OWNER TO w4;

--
-- Name: asset_email_link_mapping_all_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION asset_email_link_mapping_all_delete(arg_asset_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM creative_email_links WHERE creative_id = arg_asset_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No asset email links with  asset id (%).', arg_asset_id;
        END IF;

        DELETE FROM creative_email_links WHERE creative_id = arg_asset_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.asset_email_link_mapping_all_delete(arg_asset_id bigint) OWNER TO w4;

--
-- Name: asset_email_link_mapping_create(bigint, text, text, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION asset_email_link_mapping_create(arg_asset_id bigint, arg_original_url text, arg_redirect_type text, arg_is_html boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN
        PERFORM id FROM creatives WHERE id = arg_asset_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No asset with the id (%).', arg_asset_id;
        END IF;

        INSERT INTO creative_email_links
            (creative_id, original_url, redirect_type, is_html)
            VALUES (arg_asset_id, arg_original_url, arg_redirect_type, arg_is_html)
            RETURNING id
            INTO var_id;

        RETURN asset_email_link_mapping_get_update(var_id);
    END;
$$;


ALTER FUNCTION w4api.asset_email_link_mapping_create(arg_asset_id bigint, arg_original_url text, arg_redirect_type text, arg_is_html boolean) OWNER TO w4;

--
-- Name: asset_email_link_mapping_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION asset_email_link_mapping_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM creative_email_links WHERE id = arg_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No asset email link with id (%).', arg_id;
        END IF;

        DELETE FROM creative_email_links WHERE id = arg_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.asset_email_link_mapping_delete(arg_id bigint) OWNER TO w4;

--
-- Name: asset_email_link_mapping_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION asset_email_link_mapping_get(arg_asset_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;

    BEGIN
        PERFORM id FROM creatives WHERE id = arg_asset_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No asset with the id (%).', arg_asset_id;
        END IF;

        SELECT
            array_to_json (array_agg(row_to_json (results)))
                FROM (
                    SELECT row_to_json (row)
                        FROM (
                            SELECT
                                id,
                                original_url,
                                redirect_type,
                                is_html
                            FROM creative_email_links
                            WHERE creative_id = arg_asset_id
                        ) row
                ) results
        INTO retval;

        RETURN COALESCE (retval, '{}')::json;
    END
$$;


ALTER FUNCTION w4api.asset_email_link_mapping_get(arg_asset_id bigint) OWNER TO w4;

--
-- Name: asset_email_link_mapping_get_update(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION asset_email_link_mapping_get_update() RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        arg_id bigint;

    BEGIN
	arg_id = 25;
        PERFORM id FROM creative_email_links WHERE id = arg_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No asset email link with id (%).', arg_id;
        END IF;

        SELECT
            array_to_json (array_agg(row_to_json (results)))
                FROM (
                    SELECT row_to_json (row)
                        FROM (
                            SELECT
                                id,
                                original_url,
                                redirect_type
                            FROM creative_email_links
                            WHERE id = arg_id
                        ) row
                ) results
        INTO retval;

        RETURN COALESCE (retval, '{}')::json;
    END
$$;


ALTER FUNCTION w4api.asset_email_link_mapping_get_update() OWNER TO w4;

--
-- Name: asset_email_link_mapping_get_update(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION asset_email_link_mapping_get_update(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;

    BEGIN
        PERFORM id FROM creative_email_links WHERE id = arg_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No asset email link with id (%).', arg_id;
        END IF;

        SELECT
            array_to_json (array_agg(row_to_json (results)))
                FROM (
                    SELECT row_to_json (row)
                        FROM (
                            SELECT
                                id,
                                original_url,
                                redirect_type
                            FROM creative_email_links
                            WHERE id = arg_id
                        ) row
                ) results
        INTO retval;

        RETURN COALESCE (retval, '{}')::json;
    END
$$;


ALTER FUNCTION w4api.asset_email_link_mapping_get_update(arg_id bigint) OWNER TO w4;

--
-- Name: asset_email_link_mapping_update(bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION asset_email_link_mapping_update(arg_id bigint, arg_original_url text DEFAULT NULL::text, arg_redirect_type text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM creative_email_links WHERE id = arg_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No asset email link with id (%).', arg_id;
        END IF;

        UPDATE creative_email_links SET            
            original_url     = COALESCE (arg_original_url, original_url),
            redirect_type    = COALESCE (arg_redirect_type, redirect_type)
        WHERE id = arg_id;

        RETURN asset_email_link_mapping_get_update(arg_id);
    END;
$$;


ALTER FUNCTION w4api.asset_email_link_mapping_update(arg_id bigint, arg_original_url text, arg_redirect_type text) OWNER TO w4;

--
-- Name: audit_log_create(bigint, bigint, text, text, integer, integer, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION audit_log_create(arg_entity_id bigint DEFAULT NULL::bigint, arg_user_id bigint DEFAULT (0)::bigint, arg_message text DEFAULT NULL::text, arg_entity_type text DEFAULT NULL::text, arg_entity_type_id integer DEFAULT NULL::integer, arg_currency_id integer DEFAULT NULL::integer, arg_user_ip text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_entity_type_id bigint;        
    BEGIN
    IF((arg_entity_id ISNULL)OR(arg_user_id ISNULL)) THEN
        RETURN FALSE;
    END IF;
    ---SELECT regexp_replace((SELECT inet_client_addr())::text,'/[1-9]', '') INTO var_user_ip;
    SELECT w4api.audit_log_types_index_get(
		arg_is_entity:=true,
		arg_type:=arg_entity_type,
		arg_type_id:=arg_entity_type_id) 
     INTO var_entity_type_id;
       INSERT INTO audit_log
		( 
		entity_id,
		entity_type_id, 
                user_id, 
		user_ip,        
		message,  
		created,
		currency_id
		)
            VALUES (    
		arg_entity_id --- never null?
		,var_entity_type_id 
		,arg_user_id --- default to 0
		,arg_user_ip --- never null
		,arg_message
		,CURRENT_TIMESTAMP
		,arg_currency_id
		);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.audit_log_create(arg_entity_id bigint, arg_user_id bigint, arg_message text, arg_entity_type text, arg_entity_type_id integer, arg_currency_id integer, arg_user_ip text) OWNER TO w4;

--
-- Name: audit_log_create_json(json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION audit_log_create_json(arg_audit_json json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_audit_entry_json json; 
        var_audit_entry audit_entry;
        var_audit_logs_entered_success boolean = true;
    BEGIN
    FOR var_audit_entry_json IN SELECT * FROM json_array_elements(arg_audit_json)  ---- break apart the json array
    LOOP
    select * from json_populate_record(null::audit_entry,var_audit_entry_json) INTO var_audit_entry;
           var_audit_logs_entered_success = 
        ((SELECT w4api.audit_log_create(
		arg_entity_id:=var_audit_entry.entity_id, 
		arg_user_id:=var_audit_entry.user_id, 
		arg_user_ip:=var_audit_entry.user_ip,
		arg_message:=var_audit_entry.message, 
		arg_entity_type:=var_audit_entry.entity_type, 
		arg_entity_type_id:=var_audit_entry.entity_type_id,
		arg_currency_id:=var_audit_entry.currency_id
                  )
               ) AND var_audit_logs_entered_success ----- if audit entry write succeeded: TRUE, else FALSE 
        );      
    END LOOP;
    RETURN var_audit_logs_entered_success;    
    END;
$$;


ALTER FUNCTION w4api.audit_log_create_json(arg_audit_json json) OWNER TO w4;

--
-- Name: audit_log_get(bigint, bigint, text, integer, text, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION audit_log_get(arg_entity_id bigint DEFAULT NULL::bigint, arg_user_id bigint DEFAULT NULL::bigint, arg_entity_type text DEFAULT NULL::text, arg_entity_type_id integer DEFAULT NULL::integer, arg_user_ip text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
     DECLARE
        ret_val json;
        var_count_json text := '';
    BEGIN
    IF arg_count THEN
        var_count_json:= ', "count": ' || 
             ( w4api.audit_log_get_list(
                          arg_entity_id:=arg_entity_id, 
                          arg_user_id:= arg_user_id, 
                          arg_entity_type:= arg_entity_type, 
                          arg_entity_type_id:= arg_entity_type_id, 
                          arg_user_ip:= arg_user_ip, 
                          arg_min_date:=arg_min_date, 
                          arg_max_date:=arg_max_date, 
                          arg_currency_id:=arg_currency_id, 
                          arg_count:=TRUE
                        ))::text;
    END IF;
       ret_val := ('{ "results": ' ||  
            w4api.audit_log_get_list(
                          arg_entity_id:=arg_entity_id, 
                          arg_user_id:= arg_user_id, 
                          arg_entity_type:= arg_entity_type, 
                          arg_entity_type_id:= arg_entity_type_id, 
                          arg_user_ip:= arg_user_ip, 
                          arg_min_date:=arg_min_date, 
                          arg_max_date:=arg_max_date, 
                          arg_currency_id:=arg_currency_id, 
                          arg_limit:=arg_limit, 
                          arg_offset:=arg_offset, 
                          arg_orderby:=arg_orderby                    
                         )
                    || var_count_json  
                    || '}')::json;            
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.audit_log_get(arg_entity_id bigint, arg_user_id bigint, arg_entity_type text, arg_entity_type_id integer, arg_user_ip text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: audit_log_get_list(bigint, bigint, text, integer, text, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION audit_log_get_list(arg_entity_id bigint DEFAULT NULL::bigint, arg_user_id bigint DEFAULT NULL::bigint, arg_entity_type text DEFAULT NULL::text, arg_entity_type_id integer DEFAULT NULL::integer, arg_user_ip text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $_$
     DECLARE
        ret_val json;
        where_clause TEXT := '';
        order_clause TEXT := '';
        var_entity_type_id integer := NULL;
        var_id_campaign integer;
        var_id_advertiser integer;

    BEGIN
    SELECT w4api.audit_log_types_index_get(arg_is_entity:=true,arg_type:=arg_entity_type,arg_type_id:=arg_entity_type_id) INTO var_entity_type_id;
    where_clause := where_clause_build (arg_user_id::TEXT, 'adt.user_id = ' || arg_user_id, where_clause); 
    where_clause := where_clause_build (arg_user_ip::TEXT, 'adt.user_ip = '''||arg_user_ip||'''', where_clause); 
    where_clause := where_clause_build (arg_entity_id::TEXT, 'adt.entity_id = ' ||  arg_entity_id, where_clause);
    where_clause := where_clause_build (var_entity_type_id::TEXT, 'adt.entity_type_id = ' ||  var_entity_type_id, where_clause);
    where_clause := where_clause_build (arg_min_date::TEXT, 'adt.created >= $$' || arg_min_date || '$$', where_clause);
    where_clause := where_clause_build (arg_max_date::TEXT, 'adt.created < $$' || arg_max_date || '$$', where_clause);
    where_clause := where_clause_build(arg_currency_id::TEXT, '(adt.currency_id = -1 OR adt.currency_id = ' || arg_currency_id||')', where_clause);
    order_clause := order_clause_build(arg_orderby, 'adt.created DESC');
    SELECT id FROM audit_log_types WHERE name = 'campaign' INTO var_id_campaign;
    SELECT id FROM audit_log_types WHERE name = 'advertiser' INTO var_id_advertiser;

    IF(arg_count) THEN
        EXECUTE
        'SELECT 
            COALESCE (COUNT(1), 0) FROM (SELECT adt.id FROM audit_log adt LEFT JOIN audit_log_types algt ON algt.id = adt.entity_type_id'
              || where_clause 
              ||') AS the_count'
                      INTO ret_val;
    ELSE       
       EXECUTE
        'SELECT array_to_json (array_agg(row_to_json (results)))
            FROM (        
                SELECT row_to_json (row)
                    FROM ( 
                        SELECT                  
                            adt.user_id AS user_id,                                  
                            adt.user_ip AS user_ip,
                            (SELECT CONCAT(first_name,'' '',last_name) FROM user_profiles WHERE user_id = adt.user_id) AS user_name,
                            adt.entity_id,                         
                            CASE entbase.id
                                WHEN '||var_id_campaign||' THEN (SELECT name FROM campaigns WHERE id = adt.entity_id)  
                                WHEN '||var_id_advertiser||' THEN (SELECT name FROM advertisers WHERE id = adt.entity_id)
                                ELSE CASE (SELECT access FROM users WHERE id = adt.entity_id)
                                    WHEN ''publisher'' THEN (SELECT company_name FROM user_profiles WHERE user_id = adt.entity_id)
                                    ELSE (SELECT CONCAT(c.first_name,'' '',c.last_name) FROM users usr LEFT JOIN contacts c ON c.id = usr.primary_contact_id WHERE usr.id = adt.entity_id)
                                END                                    
                            END as entity_name,
                            entbase.id AS entity_type_id,                
                            initcap(entbase.name) AS entity_type,                                                                               
                            adt.message AS message,                    
                            adt.created,  
                            adt.currency_id                                
                        FROM audit_log adt
                        LEFT JOIN users u ON adt.entity_id = u.id
                        LEFT JOIN audit_log_types ent ON ent.id = adt.entity_type_id
                        LEFT JOIN audit_log_types entbase ON ent.base_type = entbase.id
                        LEFT JOIN campaigns cmp ON adt.entity_id = cmp.id ' 
                        || where_clause 
                        || order_clause 
                        || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
                        || ' OFFSET '|| arg_offset 
                        || ') row 
              ) results'      
            INTO ret_val;
    -----TEST:  SELECT w4api.audit_log_get_list(arg_count:=true,arg_entity_type:='admin',arg_currency_id:=1,arg_offset:=55,arg_limit:=22);
        END IF;
        RETURN ret_val;
    END;
$_$;


ALTER FUNCTION w4api.audit_log_get_list(arg_entity_id bigint, arg_user_id bigint, arg_entity_type text, arg_entity_type_id integer, arg_user_ip text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: audit_log_types_index_get(boolean, text, text, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION audit_log_types_index_get(arg_is_entity boolean DEFAULT true, arg_type text DEFAULT NULL::text, arg_base_type text DEFAULT NULL::text, arg_type_id integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_found_type_id integer; 
    BEGIN
    SELECT id FROM audit_log_types WHERE id = arg_type_id AND is_entity = arg_is_entity INTO var_found_type_id; ---if valid entity_type_id is given, then use valid entity type id
    IF ((NOT FOUND) AND (arg_type NOTNULL)) THEN -- clean string and check for closests match on first 4 letters (smallest length = user)   
  arg_type = lower(regexp_replace(arg_type, E'[^A-Za-z]','', 'g'));
       SELECT id from audit_log_types WHERE name LIKE (substring(arg_type from 1 for 4))||'%' AND is_entity = arg_is_entity INTO var_found_type_id;
        IF (NOT FOUND) THEN   
                INSERT INTO audit_log_types(name,is_entity) VALUES(arg_type,arg_is_entity) RETURNING id INTO var_found_type_id;  --- last resort, add new type to the table
                UPDATE audit_log_types SET base_type = COALESCE((SELECT id FROM audit_log_types WHERE name = arg_base_type),var_found_type_id) WHERE id = var_found_type_id;
        END IF; 
    END IF;  
    RETURN var_found_type_id;
    END;
$$;


ALTER FUNCTION w4api.audit_log_types_index_get(arg_is_entity boolean, arg_type text, arg_base_type text, arg_type_id integer) OWNER TO w4;

--
-- Name: avatar_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION avatar_get(arg_user_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$DECLARE
ret_val bigint;

BEGIN
	EXECUTE
		'SELECT image_id FROM user_profiles WHERE user_id = ' || arg_user_id || ';'
	INTO ret_val;

	RETURN ret_val::bigint;
END;$$;


ALTER FUNCTION w4api.avatar_get(arg_user_id bigint) OWNER TO w4;

--
-- Name: campaign_admin_approvals_get(bigint, json, text, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_admin_approvals_get(arg_publisher_id bigint, arg_campaign_ids json DEFAULT NULL::json, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            retval json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (campaign_admin_approvals_get_count(arg_publisher_id, arg_campaign_ids, arg_status, arg_min_date, arg_max_date, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            retval := 
            (
                    '{' || 
                            '"results": ' || COALESCE (campaign_admin_approvals_get_list(arg_publisher_id, arg_campaign_ids, arg_status, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset), '{}') ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN retval;
      END
$$;


ALTER FUNCTION w4api.campaign_admin_approvals_get(arg_publisher_id bigint, arg_campaign_ids json, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_admin_approvals_get_count(bigint, json, text, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_admin_approvals_get_count(arg_publisher_id bigint, arg_campaign_ids json DEFAULT NULL::json, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        var_campaign_ids bigint[];


    BEGIN
	IF arg_campaign_ids IS NOT NULL THEN  
            var_campaign_ids := json_array_convert(arg_campaign_ids)::bigint[];
	END IF;

        IF (arg_status IS NULL OR arg_status = 'available') THEN
            EXECUTE
                'SELECT
                    COALESCE(COUNT(1) OVER(), 0) FROM (
                        SELECT
                            cmp.id AS campaign_id,
                            cmp.name AS campaign_name,
                            cap.admin_id AS last_modified_by_id,
                            cap.updated_at AS last_modified_date,
                            CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS last_modified_by_name, 
                            cap.status as approved_status
                        FROM campaigns cmp
                        LEFT JOIN campaign_assigned_publishers cap
                            ON cap.campaign_id = cmp.id
                        LEFT JOIN users mgr
                            ON cap.admin_id = mgr.id
                        LEFT JOIN user_profiles mup
                            ON mgr.id = mup.user_id
                        LEFT JOIN contacts mcon
                            ON mcon.id = mgr.primary_contact_id
                        WHERE
                            (cap.publisher_id = $1) AND
                            ($2 IS NULL OR ARRAY[cmp.id] && $2) AND
                            ($3 IS NULL OR cap.status = $3) AND
                            ($4 IS NULL OR cap.created_at >= $4) AND
                            ($5 IS NULL OR cap.created_at < $5) AND
                            ($6 IS NULL OR cmp.currency_id = $6) AND
                            (cmp.access_type > 1)

                        UNION SELECT
                            cmp.id AS campaign_id,
                            cmp.name AS campaign_name,
                            NULL AS last_modified_by_id,
                            NULL AS last_modified_date,
                            NULL AS last_modified_by_name, 
                            NULL as approved_status
                        FROM campaigns cmp
                        LEFT JOIN campaign_assigned_publishers cap
                            ON cap.campaign_id = cmp.id AND cap.publisher_id = $1
                        WHERE
                            ($2 IS NULL OR ARRAY[cmp.id] && $2) AND
                            ($6 IS NULL OR cmp.currency_id = $6) AND
                            (cap.campaign_id IS NULL) AND
                            (cmp.access_type > 1) '
                ') the_count LIMIT 1; '
            INTO ret_val
            USING arg_publisher_id, var_campaign_ids, arg_status, arg_min_date, arg_max_date, arg_currency_id;
        ELSE
            EXECUTE
                'SELECT
                    COALESCE(COUNT(1) OVER(), 0) FROM (
                        SELECT
                            cmp.id AS campaign_id,
                            cmp.name AS campaign_name,
                            cap.admin_id AS last_modified_by_id,
                            cap.updated_at AS last_modified_date,
                            CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS last_modified_by_name, 
                            cap.status as approved_status
                        FROM campaigns cmp
                        LEFT JOIN campaign_assigned_publishers cap
                            ON cap.campaign_id = cmp.id
                        LEFT JOIN users mgr
                            ON cap.admin_id = mgr.id
                        LEFT JOIN user_profiles mup
                            ON mgr.id = mup.user_id
                        LEFT JOIN contacts mcon
                            ON mcon.id = mgr.primary_contact_id
                        WHERE
                            (cap.publisher_id = $1) AND
                            ($2 IS NULL OR ARRAY[cmp.id] && $2) AND
                            ($3 IS NULL OR cap.status = $3) AND
                            ($4 IS NULL OR cap.created_at >= $4) AND
                            ($5 IS NULL OR cap.created_at < $5) AND
                            ($6 IS NULL OR cmp.currency_id = $6) AND
                            (cmp.access_type > 1) '
                ') the_count LIMIT 1; '
            INTO ret_val
            USING arg_publisher_id, var_campaign_ids, arg_status, arg_min_date, arg_max_date, arg_currency_id;
        END IF;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_admin_approvals_get_count(arg_publisher_id bigint, arg_campaign_ids json, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_admin_approvals_get_list(bigint, json, text, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_admin_approvals_get_list(arg_publisher_id bigint, arg_campaign_ids json DEFAULT NULL::json, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        var_campaign_ids bigint[];
        order_clause text;

    BEGIN

	IF arg_campaign_ids IS NOT NULL THEN  
            var_campaign_ids := json_array_convert(arg_campaign_ids)::bigint[];
	END IF;

        order_clause := order_clause_build(arg_orderby, 'campaign_id');
        IF (arg_status IS NULL OR arg_status = 'available') THEN
            EXECUTE
                'SELECT
                    array_to_json (
                        array_agg(row_to_json(results)))
                FROM (
                    SELECT
                        row_to_json (row)
                            FROM (
                                SELECT
                                    cmp.id AS campaign_id,
                                    cmp.name AS campaign_name,
                                    cap.admin_id AS last_modified_by_id,
                                    cap.updated_at AS last_modified_date,
                                    CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS last_modified_by_name, 
                                    cap.status as approved_status
                                FROM campaigns cmp
                                LEFT JOIN campaign_assigned_publishers cap
                                    ON cap.campaign_id = cmp.id
                                LEFT JOIN users mgr
                                    ON cap.admin_id = mgr.id
                                LEFT JOIN user_profiles mup
                                    ON mgr.id = mup.user_id
                                LEFT JOIN contacts mcon
                                    ON mcon.id = mgr.primary_contact_id
                                WHERE
                                    (cap.publisher_id = $1) AND
                                    ($2 IS NULL OR ARRAY[cmp.id] && $2) AND
                                    ($3 IS NULL OR cap.status = $3) AND
                                    ($4 IS NULL OR cap.created_at >= $4) AND
                                    ($5 IS NULL OR cap.created_at < $5) AND
                                    ($6 IS NULL OR cmp.currency_id = $6) AND
                                    (cmp.access_type > 1)

                                UNION SELECT
                                    cmp.id AS campaign_id,
                                    cmp.name AS campaign_name,
                                    NULL AS last_modified_by_id,
                                    NULL AS last_modified_date,
                                    NULL AS last_modified_by_name, 
                                    NULL as approved_status
                                FROM campaigns cmp
                                LEFT JOIN campaign_assigned_publishers cap
                                    ON cap.campaign_id = cmp.id AND cap.publisher_id = $1
                                WHERE
                                    ($2 IS NULL OR ARRAY[cmp.id] && $2) AND
                                    ($6 IS NULL OR cmp.currency_id = $6) AND
                                    (cap.campaign_id IS NULL) AND
                                    (cmp.access_type > 1) '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                ) results;' 
            INTO ret_val
            USING arg_publisher_id, var_campaign_ids, arg_status, arg_min_date, arg_max_date, arg_currency_id;
        ELSE
            EXECUTE
                'SELECT
                    array_to_json (
                        array_agg(row_to_json(results)))
                FROM (
                    SELECT
                        row_to_json (row)
                            FROM (
                                SELECT
                                    cmp.id AS campaign_id,
                                    cmp.name AS campaign_name,
                                    cap.admin_id AS last_modified_by_id,
                                    cap.updated_at AS last_modified_date,
                                    CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS last_modified_by_name, 
                                    cap.status as approved_status
                                FROM campaigns cmp
                                LEFT JOIN campaign_assigned_publishers cap
                                    ON cap.campaign_id = cmp.id
                                LEFT JOIN users mgr
                                    ON cap.admin_id = mgr.id
                                LEFT JOIN user_profiles mup
                                    ON mgr.id = mup.user_id
                                LEFT JOIN contacts mcon
                                    ON mcon.id = mgr.primary_contact_id
                                WHERE
                                    (cap.publisher_id = $1) AND
                                    ($2 IS NULL OR ARRAY[cmp.id] && $2) AND
                                    ($3 IS NULL OR cap.status = $3) AND
                                    ($4 IS NULL OR cap.created_at >= $4) AND
                                    ($5 IS NULL OR cap.created_at < $5) AND
                                    ($6 IS NULL OR cmp.currency_id = $6) AND
                                    (cmp.access_type > 1) '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                ) results;' 
            INTO ret_val
            USING arg_publisher_id, var_campaign_ids, arg_status, arg_min_date, arg_max_date, arg_currency_id;
        END IF;

        RETURN ret_val;

    END
$_$;


ALTER FUNCTION w4api.campaign_admin_approvals_get_list(arg_publisher_id bigint, arg_campaign_ids json, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_admin_approvals_update(json, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_admin_approvals_update(arg_changes json, arg_admin_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        where_clause text := '';
        var_campaign_id bigint;
        var_publisher_id bigint;
        var_status text;
        ret_val json;

    BEGIN
        FOR var_campaign_id, var_publisher_id, var_status IN SELECT * FROM json_populate_recordset(NULL::campaign_approve, arg_changes->'changes') LOOP
            UPDATE campaign_assigned_publishers SET
                status = var_status,
                updated_at = CURRENT_TIMESTAMP,
                admin_id = COALESCE(arg_admin_id, admin_id)
            WHERE campaign_id = var_campaign_id AND publisher_id = var_publisher_id;
            IF (NOT FOUND) THEN
                INSERT INTO campaign_assigned_publishers
                    (campaign_id, publisher_id, status, created_at, updated_at, admin_id)
                    VALUES (var_campaign_id, var_publisher_id, var_status, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, arg_admin_id);
            END IF;
            IF (where_clause = '') THEN
                where_clause := 'WHERE ';
            ELSE
                where_clause := where_clause || ' OR ';
            END IF;
            where_clause := where_clause || ' ((cap.campaign_id = ' || var_campaign_id || ') AND (cap.publisher_id = ' || var_publisher_id || '))';                    
        END LOOP;

        EXECUTE 
            'SELECT
                array_to_json (
                    array_agg(row_to_json(results)))
            FROM (
                SELECT
                    row_to_json (row)
                        FROM (
                            SELECT
                                cap.publisher_id AS publisher_id,
                                cmp.id AS campaign_id,
                                cmp.name AS campaign_name,
                                cap.admin_id AS last_modified_by_id,
                                cap.updated_at AS last_modified_date,
                                CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS last_modified_by_name, 
                                cap.status as approved_status
                            FROM campaign_assigned_publishers cap
                            LEFT JOIN campaigns cmp
                                ON cap.campaign_id = cmp.id
                            LEFT JOIN users mgr
                                ON cap.admin_id = mgr.id
                            LEFT JOIN user_profiles mup
                                ON mgr.id = mup.user_id
                            LEFT JOIN contacts mcon
                                ON mcon.id = mgr.primary_contact_id '
                            || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.campaign_admin_approvals_update(arg_changes json, arg_admin_id bigint) OWNER TO w4;

--
-- Name: campaign_advertiser_id_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_advertiser_id_get(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_ret_val json;

    BEGIN
        SELECT row_to_json (row) FROM (
            SELECT
                advertiser_id
            FROM campaigns
            WHERE
                id = arg_campaign_id
        ) row
        INTO var_ret_val;

        RETURN COALESCE(var_ret_val, '{}');
    END
$$;


ALTER FUNCTION w4api.campaign_advertiser_id_get(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: campaign_approvals_get(text, text, text, timestamp with time zone, timestamp with time zone, text, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_approvals_get(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_search_manager text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            retval json;
            count_total bigint;
            summary json;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (campaign_approvals_get_count(arg_search_campaign, arg_search_publisher, arg_status, arg_min_date, arg_max_date, arg_search_manager, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;
            
            IF arg_summary THEN
                summary := campaign_approvals_get_summary(arg_search_campaign, arg_search_publisher, arg_status, arg_min_date, arg_max_date, arg_search_manager, arg_currency_id);
            ELSE
                summary := '{}';
            END IF;

            retval := 
            (
                    '{' || 
                            '"results": ' || campaign_approvals_get_list(arg_search_campaign, arg_search_publisher, arg_status, arg_min_date, arg_max_date, arg_search_manager, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "summary": ' || summary ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN retval;
      END
$$;


ALTER FUNCTION w4api.campaign_approvals_get(arg_search_campaign text, arg_search_publisher text, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_search_manager text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: campaign_approvals_get_count(text, text, text, timestamp with time zone, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_approvals_get_count(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_search_manager text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'cmp.id = ' || arg_search_campaign::bigint, where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'usr.id = ' || arg_search_publisher::bigint, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'cap.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'cap.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'cap.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_search_manager::TEXT, 'usr.manager_id = ' || arg_search_manager::bigint, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);
        where_clause := where_clause_build('non public access'::TEXT, 'cmp.access_type > 1', where_clause);

        EXECUTE
            'SELECT
                COALESCE(COUNT(1) OVER(), 0) FROM (
                    SELECT
                        cap.campaign_id,
                        CONCAT (cmp.name, CHR(1), cap.campaign_id) AS search_campaign,
                        CONCAT (COALESCE(usp.company_name, pg_catalog.concat(con.first_name, CHR(1), con.last_name)::character varying), CHR(1), publisher_id) AS search_publisher,
                        cmp.name as campaign_name, 
                        cap.created_at as date_of_request,
                        cap.publisher_id as publisher_id, 
                        COALESCE(usp.company_name, pg_catalog.concat(con.first_name, CHR(1), con.last_name)::character varying) as publisher_name,
                        usr.manager_id AS manager_id,
                        CONCAT (mcon.first_name, CHR(1), mcon.last_name) AS manager_name, 
                        cap.status as request_status,
                        cap.memo as request_note,
                        usr.primary_contact_id
                    FROM campaign_assigned_publishers cap
                    LEFT JOIN campaigns cmp
                        ON cap.campaign_id = cmp.id
                    LEFT JOIN users usr
                        ON cap.publisher_id = usr.id
                    LEFT JOIN user_profiles usp
                        ON (usr.id = usp.user_id)
                    LEFT JOIN contacts con
                        ON con.id = usr.primary_contact_id
                    LEFT JOIN users mgr
                        ON mgr.id = usr.manager_id
                    LEFT JOIN contacts mcon
                        ON mcon.id = mgr.primary_contact_id '
                    || where_clause ||
            ') the_count LIMIT 1; '
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_approvals_get_count(arg_search_campaign text, arg_search_publisher text, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_search_manager text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_approvals_get_list(text, text, text, timestamp with time zone, timestamp with time zone, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_approvals_get_list(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_search_manager text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'cmp.id = ' || arg_search_campaign::bigint, where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'usr.id = ' || arg_search_publisher::bigint, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'cap.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'cap.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'cap.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_search_manager::TEXT, 'usr.manager_id = ' || arg_search_manager::bigint, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);
        where_clause := where_clause_build('non public access'::TEXT, 'cmp.access_type > 1', where_clause);
        order_clause := order_clause_build(arg_orderby, 'campaign_id');

        EXECUTE 
            'SELECT
                array_to_json (
                    array_agg(row_to_json(results)))
            FROM (
                SELECT
                    row_to_json (row)
                        FROM (
                            SELECT
                                cap.campaign_id,
                                CONCAT (cmp.name, CHR(1), cap.campaign_id) AS search_campaign,
                                CONCAT (COALESCE(usp.company_name, pg_catalog.concat(con.first_name, CHR(1), con.last_name)::character varying), CHR(1), publisher_id) AS search_publisher,
                                cmp.name as campaign_name, 
                                cap.created_at as date_of_request,
                                cap.publisher_id as publisher_id, 
                                COALESCE(usp.company_name, pg_catalog.concat(con.first_name, CHR(1), con.last_name)::character varying) as publisher_name,
                                usr.manager_id AS manager_id,
                                CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS manager_name, 
                                cap.status as request_status,
                                cap.memo as request_note,
                                usr.primary_contact_id
                            FROM campaign_assigned_publishers cap
                            LEFT JOIN campaigns cmp
                                ON cap.campaign_id = cmp.id
                            LEFT JOIN users usr
                                ON cap.publisher_id = usr.id
                            LEFT JOIN user_profiles usp
                                ON usr.id = usp.user_id
                            LEFT JOIN contacts con
                                ON con.id = usr.primary_contact_id
                            LEFT JOIN users mgr
                                ON mgr.id = usr.manager_id
                            LEFT JOIN contacts mcon
                                ON mcon.id = mgr.primary_contact_id
                            LEFT JOIN user_profiles mup
                                ON mup.user_id = mgr.id '
                            || where_clause
                            || order_clause || '
                            LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                            OFFSET ' || arg_offset || '
                        ) row
            ) results;' 
        INTO ret_val;
        RETURN ret_val;

    END
$_$;


ALTER FUNCTION w4api.campaign_approvals_get_list(arg_search_campaign text, arg_search_publisher text, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_search_manager text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_approvals_get_summary(text, text, text, timestamp with time zone, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_approvals_get_summary(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_search_manager text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';

    BEGIN
        where_clause := where_clause_build(arg_search_campaign::TEXT, '(cmp.name ILIKE $$%' || arg_search_campaign || '%$$ OR cmp.id::text ILIKE $$%' || arg_search_campaign || '%$$)', where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'COALESCE(usp.company_name, pg_catalog.concat(usp.first_name, CHR(1), usp.last_name)) ILIKE $$%' || arg_search_publisher || '%$$'  , where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'cap.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'cap.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'cap.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_search_manager::TEXT, '(pg_catalog.concat(mcon.first_name, CHR(1), mcon.last_name) ILIKE $$%' || arg_search_manager || '%$$ OR usr.manager_id::text ILIKE $$%' || arg_search_manager || '%$$)', where_clause);
        where_clause := where_clause_build('non public access'::TEXT, 'cmp.access_type > 1', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT row_to_json (row)
                FROM (
                    SELECT
                        COALESCE (SUM (CASE WHEN status = $$pending$$ THEN 1 ELSE 0 END), 0) AS pending,
                        ROUND(COALESCE(SUM (CASE WHEN status = $$pending$$ THEN 1 ELSE 0 END)::float / COUNT(1)::float, 0)::numeric, 4) AS pending_percent,
                        COALESCE (SUM (CASE WHEN status = $$approved$$ THEN 1 ELSE 0 END), 0) AS approved,
                        ROUND(COALESCE(SUM (CASE WHEN status = $$approved$$ THEN 1 ELSE 0 END)::float / COUNT(1)::float, 0)::numeric, 4) AS approved_percent,
                        COALESCE (SUM (CASE WHEN status = $$denied$$ THEN 1 ELSE 0 END), 0) AS denied,
                        ROUND(COALESCE(SUM (CASE WHEN status = $$denied$$ THEN 1 ELSE 0 END)::float / COUNT(1)::float, 0)::numeric, 4) AS denied_percent
                    FROM (
                        SELECT
                            DISTINCT ON (cap.campaign_id, cap.publisher_id)
                            cap.status AS status
                        FROM campaign_assigned_publishers cap
                        LEFT JOIN campaigns cmp
                            ON cap.campaign_id = cmp.id
                        LEFT JOIN users usr
                            ON cap.publisher_id = usr.id
                        LEFT JOIN user_profiles usp
                            ON (usr.id = usp.user_id)
                        LEFT JOIN contacts con
                            ON con.id = usr.primary_contact_id
                        LEFT JOIN users mgr
                            ON mgr.id = usr.manager_id
                        LEFT JOIN contacts mcon
                            ON mcon.id = mgr.primary_contact_id '
                        || where_clause || '
                    ) the_results
                ) row;'
        INTO ret_val;
        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.campaign_approvals_get_summary(arg_search_campaign text, arg_search_publisher text, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_search_manager text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_approvals_update(bigint, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_approvals_update(arg_campaign_id bigint, arg_publisher_id bigint, arg_status text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM campaign_id FROM campaign_assigned_publishers WHERE campaign_id = arg_campaign_id AND publisher_id = arg_publisher_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified campaign (%) and publisher (%) pair in the campaign approvals.', arg_campaign_id, arg_publisher_id;
        END IF;
        UPDATE campaign_assigned_publishers SET status = arg_status, updated_at = CURRENT_TIMESTAMP WHERE campaign_id = arg_campaign_id AND publisher_id = arg_publisher_id;
        RETURN campaign_approvals_get_list(arg_campaign_id::text, arg_publisher_id::text);
    END;
$$;


ALTER FUNCTION w4api.campaign_approvals_update(arg_campaign_id bigint, arg_publisher_id bigint, arg_status text) OWNER TO w4;

--
-- Name: campaign_banned_publisher_create(bigint, bigint, bigint, text, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_banned_publisher_create(arg_advertiser_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM * FROM advertisers WHERE id = arg_advertiser_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No advertiser found with the id: %', arg_advertiser_id;
        END IF;
        
        PERFORM * FROM users WHERE id = arg_publisher_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No publisher found with the id: %', arg_publisher_id;
        END IF;

        PERFORM * FROM campaigns WHERE id = arg_campaign_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No campaign found with the id: %', arg_campaign_id;
        END IF;

        INSERT INTO advertiser_banned_publishers
            (advertiser_id, publisher_id, campaign_id, sub_id_1, sub_id_2, sub_id_3, sub_id_4, status)
            VALUES (arg_advertiser_id, arg_publisher_id, arg_campaign_id, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, 'active');

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_banned_publisher_create(arg_advertiser_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) OWNER TO w4;

--
-- Name: campaign_banned_publisher_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_banned_publisher_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM advertiser_banned_publishers WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher advertiser banned publisher (%).', arg_id;
        END IF;

        UPDATE advertiser_banned_publishers SET
            status = 'inactive'
        WHERE id = arg_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_banned_publisher_delete(arg_id bigint) OWNER TO w4;

--
-- Name: campaign_banned_publisher_get(bigint, text, text, text, text, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_banned_publisher_get(arg_campaign_id bigint, arg_search_publisher text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (campaign_banned_publisher_get_count(arg_campaign_id, arg_search_publisher, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || campaign_banned_publisher_get_list(arg_campaign_id, arg_search_publisher, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.campaign_banned_publisher_get(arg_campaign_id bigint, arg_search_publisher text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_banned_publisher_get_count(bigint, text, text, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_banned_publisher_get_count(arg_campaign_id bigint, arg_search_publisher text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        var_advertiser_id bigint;

    BEGIN
        SELECT advertiser_id FROM campaigns WHERE id = arg_campaign_id INTO var_advertiser_id;

        where_clause := where_clause_build(arg_campaign_id::TEXT, '(abp.campaign_id = ' || arg_campaign_id || ' OR  (abp.advertiser_id =  ' || var_advertiser_id || ' AND abp.campaign_id IS NULL))', where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'abp.publisher_id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_sub_id_1::TEXT, 'abp.sub_id_1 = $$' || arg_sub_id_1 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_2::TEXT, 'abp.sub_id_2 = $$' || arg_sub_id_2 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_3::TEXT, 'abp.sub_id_3 = $$' || arg_sub_id_3 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_4::TEXT, 'abp.sub_id_4 = $$' || arg_sub_id_4 || '$$', where_clause);        
        where_clause := where_clause_build('active', 'abp.status = $$active$$', where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0)
                FROM advertiser_banned_publishers abp
                LEFT JOIN advertisers ad ON abp.advertiser_id = ad.id
                LEFT JOIN users u ON abp.publisher_id = u.id
                LEFT JOIN user_profiles up ON (u.id = up.user_id)
                LEFT JOIN campaigns c ON abp.campaign_id = c.id '
                || where_clause ||
            ' LIMIT 1; '
        INTO retval;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.campaign_banned_publisher_get_count(arg_campaign_id bigint, arg_search_publisher text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) OWNER TO w4;

--
-- Name: campaign_banned_publisher_get_list(bigint, text, text, text, text, text, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_banned_publisher_get_list(arg_campaign_id bigint, arg_search_publisher text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        order_clause TEXT;
        var_advertiser_id bigint;

    BEGIN
        SELECT advertiser_id FROM campaigns WHERE id = arg_campaign_id INTO var_advertiser_id;

        where_clause := where_clause_build(arg_campaign_id::TEXT, '(abp.campaign_id = ' || arg_campaign_id || ' OR  (abp.advertiser_id =  ' || var_advertiser_id || ' AND abp.campaign_id IS NULL))', where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'abp.publisher_id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_sub_id_1::TEXT, 'abp.sub_id_1 = $$' || arg_sub_id_1 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_2::TEXT, 'abp.sub_id_2 = $$' || arg_sub_id_2 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_3::TEXT, 'abp.sub_id_3 = $$' || arg_sub_id_3 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_4::TEXT, 'abp.sub_id_4 = $$' || arg_sub_id_4 || '$$', where_clause);        
        where_clause := where_clause_build('active', 'abp.status = $$active$$', where_clause);

        order_clause := order_clause_build(arg_orderby, 'abp.id');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                               SELECT
                                    abp.id AS id,
                                    abp.advertiser_id AS advertiser_id,
                                    ad.name AS advertiser_name,
                                    abp.publisher_id AS publisher_id, 
                                    COALESCE(up.company_name, pg_catalog.concat(up.first_name, CHR(1), up.last_name)::character varying) AS publisher_name, 
                                    abp.campaign_id AS campaign_id,
                                    c.name AS campaign_name,
                                    abp.sub_id_1 AS sub_id_1,
                                    abp.sub_id_2 AS sub_id_2, 
                                    abp.sub_id_3 AS sub_id_3,
                                    abp.sub_id_4 AS sub_id_4
                                FROM advertiser_banned_publishers abp
                                LEFT JOIN advertisers ad ON abp.advertiser_id = ad.id
                                LEFT JOIN users u ON abp.publisher_id = u.id
                                LEFT JOIN user_profiles up ON (u.id = up.user_id)
                                LEFT JOIN campaigns c ON abp.campaign_id = c.id'
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' ||arg_offset || '
                            ) row
                    ) results;'
        INTO retval;
        RETURN retval;
    END
$_$;


ALTER FUNCTION w4api.campaign_banned_publisher_get_list(arg_campaign_id bigint, arg_search_publisher text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_banned_publisher_update(bigint, bigint, bigint, bigint, text, text, text, text, public.status_entity); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_banned_publisher_update(arg_id bigint, arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_status public.status_entity DEFAULT NULL::public.status_entity) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM advertiser_banned_publishers WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher advertiser banned publisher (%).', arg_id;
        END IF;

        UPDATE advertiser_banned_publishers SET            
            campaign_id     = COALESCE (arg_campaign_id, campaign_id),
            publisher_id    = COALESCE (arg_publisher_id, publisher_id),
            sub_id_1        = COALESCE (arg_sub_id_1, sub_id_1),
            sub_id_2        = COALESCE (arg_sub_id_2, sub_id_2),
            sub_id_3        = COALESCE (arg_sub_id_3, sub_id_3),
            sub_id_4        = COALESCE (arg_sub_id_4, sub_id_4),
            status          = COALESCE (arg_status, status)
        WHERE id = arg_id;

        RETURN advertiser_banned_publisher_get_list(arg_id);
    END;
$$;


ALTER FUNCTION w4api.campaign_banned_publisher_update(arg_id bigint, arg_advertiser_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_status public.status_entity) OWNER TO w4;

--
-- Name: campaign_cap_summary_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_cap_summary_get(arg_campaign_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        currency_filter text;
        cap_type int; --by publisher =  1, network = 3
        cap_period int; -- hourly2, daily3,weekly4,monthly5,yearly6
        cap_unit_type text; --conversions/currency
        capval record;
        --min_doy integer := make_doy(arg_min_date);
        --max_doy integer := make_doy(arg_max_date);
	--COALESCE(sum(rd.total_pay_in)::numeric::double precision / (COALESCE(max(cmp_cap.units)*50,(SELECT COUNT(*) from users where access = ''publisher''))) * 100::double precision, 0::double precision) AS cap_percent_utilized
	
    BEGIN
	SELECT unit_type,units,period,type FROM campaign_caps WHERE campaign_id=arg_campaign_id INTO capval;
        IF NOT FOUND THEN
            select * from campaigns where id = 8 INTO capval;
        ELSE
         
	END IF;
	
        EXECUTE
	     'SELECT row_to_json (row)
                            FROM (
                                SELECT
        cmp_cap.unit_type,
        cmp_cap.period,
        cmp_cap.type,
        cmp_cap.units,
	sum(rd.total_pay_in),
	max(ad.credit_limit)AS credits,
	CASE 
		WHEN ad.credit_limit::numeric > 0 THEN 
			(COALESCE(sum(rd.total_pay_in)::numeric,0) / (ad.credit_limit)) * 100
		ELSE 0.01
	END AS cap_percent_utilized
	FROM campaigns cmp
	LEFT JOIN reporting.reports_daily rd ON rd.campaign_id = cmp.id
	LEFT JOIN advertisers ad ON rd.advertiser_id = ad.id
	LEFT JOIN campaign_caps cmp_cap ON cmp_cap.campaign_id = cmp.id
	WHERE cmp.id = ' ||arg_campaign_id||'
	GROUP BY cmp_cap.unit_type,cmp_cap.type,cmp_cap.period,ad.credit_limit,cmp_cap.units
                            ) row;'
        INTO retval;
        RETURN  retval;
       
    END
$$;


ALTER FUNCTION w4api.campaign_cap_summary_get(arg_campaign_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_categories_get_list(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_categories_get_list(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'cc.campaign_id = ' || arg_campaign_id, where_clause);
        order_clause := order_clause_build(null, 'c.name');
        EXECUTE
            'SELECT
                array_to_json (array_agg(category_name))
                    FROM (
                                SELECT
                                    c.name AS category_name
                                FROM campaign_categories cc
                                LEFT JOIN categories c
                                    ON cc.category_id = c.id'
                                || where_clause
                                || order_clause || '
                    ) AS result '
        INTO ret_val;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.campaign_categories_get_list(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: campaign_channels_get_list(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_channels_get_list(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'cc.campaign_id = ' || arg_campaign_id, where_clause);
        order_clause := order_clause_build(null, 'c.name');
        EXECUTE
            'SELECT
                array_to_json (array_agg(channel_name))
                    FROM (
                                SELECT
                                    c.name AS channel_name
                                FROM campaign_channels cc
                                LEFT JOIN channels c
                                    ON cc.channel_id = c.id'
                                || where_clause
                                || order_clause || '
                    ) AS result '
        INTO ret_val;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.campaign_channels_get_list(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: campaign_compliance_get(text, text, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_compliance_get(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            summary json;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (campaign_compliance_get_count(arg_search_campaign, arg_search_publisher, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || campaign_compliance_get_list(arg_search_campaign, arg_search_publisher, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.campaign_compliance_get(arg_search_campaign text, arg_search_publisher text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_compliance_get_count(text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_compliance_get_count(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';

    BEGIN
        where_clause :=
            'WHERE
                (clk.campaign_id IN (
                    SELECT DISTINCT c.campaign_id
                    FROM creative_emails ce
                    LEFT JOIN creatives c ON ce.creative_id = c.id
                ))
                AND w4_application_functions.make_doy(clk.created_date) > to_char(now() - $$10 days$$::interval, $$YYYYmmdd$$::text)::integer';

        where_clause := where_clause_build(arg_search_publisher::TEXT, 'COALESCE(pup.company_name, (pup.first_name || $$ $$::text) || pup.last_name, $$$$) ILIKE $$' || arg_search_publisher || '$$ OR clk.publisher_id::text ILIKE $$' || arg_search_publisher || '$$', where_clause);
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'cmp.name ILIKE $$' || arg_search_campaign || '$$ OR clk.campaign_id::text ILIKE $$' || arg_search_campaign || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM (
                SELECT
                    clk.publisher_id, 
                    COALESCE(max(pup.company_name::text), (max(pup.first_name::text) || $$ $$::text) || max(pup.last_name::text), $$$$::text) AS publisher_name, 
                    clk.campaign_id, 
                    max(cmp.name::text) AS campaign_name, 
                    COALESCE(max(cd.downloaded_ts)) AS last_downloaded, 
                    max(v7dtl.total_clk_trend) AS trending, 
                    max(mcct.unique_clicks) AS today_clicks, 
                    mcct.doy,
                    max(cmp.currency_id) AS currency_id
                FROM engine_clicks clk
                LEFT JOIN cmpl_downloaded cd ON clk.publisher_id = cd.publisher_id AND clk.campaign_id = cd.campaign_id
                LEFT JOIN campaigns cmp ON cmp.id = clk.campaign_id
                LEFT JOIN users pusr ON clk.publisher_id = pusr.id
                LEFT JOIN user_profiles pup ON (pusr.id = pup.user_id)
                LEFT JOIN tvw_7_day_trend_line v7dtl ON v7dtl.campaign_id = clk.campaign_id
                LEFT JOIN reports_daily mcct ON mcct.campaign_id = clk.campaign_id AND mcct.doy = to_char(now(), $$YYYYmmdd$$::text)::integer '
                || where_clause || '
                GROUP BY clk.publisher_id, clk.campaign_id, mcct.doy
            ) AS the_count ' 
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_compliance_get_count(arg_search_campaign text, arg_search_publisher text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_compliance_get_list(text, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_compliance_get_list(arg_search_campaign text DEFAULT NULL::text, arg_search_publisher text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;

    BEGIN
        where_clause :=
            'WHERE
                (clk.campaign_id IN (
                    SELECT DISTINCT c.campaign_id
                    FROM creative_emails ce
                    LEFT JOIN creatives c ON ce.creative_id = c.id
                ))
                AND w4_application_functions.make_doy(clk.created_date) > to_char(now() - $$10 days$$::interval, $$YYYYmmdd$$::text)::integer';

        where_clause := where_clause_build(arg_search_publisher::TEXT, 'COALESCE(pup.company_name, (pup.first_name || $$ $$::text) || pup.last_name, $$$$) ILIKE $$' || arg_search_publisher || '$$ OR clk.publisher_id::text ILIKE $$' || arg_search_publisher || '$$', where_clause);
        where_clause := where_clause_build(arg_search_campaign::TEXT, 'cmp.name ILIKE $$' || arg_search_campaign || '$$ OR clk.campaign_id::text ILIKE $$' || arg_search_campaign || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'publisher_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    clk.publisher_id, 
                                    COALESCE(max(pup.company_name::text), (max(pup.first_name::text) || $$ $$::text) || max(pup.last_name::text), $$$$::text) AS publisher_name, 
                                    clk.campaign_id, 
                                    max(cmp.name::text) AS campaign_name, 
                                    COALESCE(max(cd.downloaded_ts)) AS last_downloaded, 
                                    max(v7dtl.total_clk_trend) AS trending, 
                                    max(mcct.unique_clicks) AS today_clicks, 
                                    mcct.doy,
                                    max(cmp.currency_id) AS currency_id
                                FROM engine_clicks clk
                                LEFT JOIN cmpl_downloaded cd ON clk.publisher_id = cd.publisher_id AND clk.campaign_id = cd.campaign_id
                                LEFT JOIN campaigns cmp ON cmp.id = clk.campaign_id
                                LEFT JOIN users pusr ON clk.publisher_id = pusr.id
                                LEFT JOIN user_profiles pup ON (pusr.id = pup.user_id)
                                LEFT JOIN tvw_7_day_trend_line v7dtl ON v7dtl.campaign_id = clk.campaign_id
                                LEFT JOIN reports_daily mcct ON mcct.campaign_id = clk.campaign_id AND mcct.doy = to_char(now(), $$YYYYmmdd$$::text)::integer '
                                || where_clause || '
                                GROUP BY clk.publisher_id, clk.campaign_id, mcct.doy '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_compliance_get_list(arg_search_campaign text, arg_search_publisher text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_conversion_create(bigint, bigint, timestamp with time zone, money, money, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_conversion_create(arg_publisher_id bigint, arg_campaign_id bigint, arg_created_date timestamp with time zone, arg_payin money, arg_payout money, arg_conversion_count bigint, arg_admin_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        created_count integer := 0;
        var_doy integer := make_doy(arg_created_date);
        var_advertiser_id bigint;
        var_rollup_results boolean;
        var_conversion_id bigint;

    BEGIN
        IF ((arg_payin < '0.00') OR (arg_payout < '0.00') OR (arg_conversion_count < 0)) THEN
            RAISE EXCEPTION 'Payin, payout and number of conversion must be zero or more.';
        END IF;

        PERFORM * FROM campaigns WHERE id = arg_campaign_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No campaign found with the id: %', arg_campaign_id;
        END IF;
        
        PERFORM * FROM users WHERE id = arg_publisher_id AND access = 'publisher';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No publisher found with the id: %', arg_publisher_id;
        END IF;

        PERFORM * FROM acct_invoices_publisher WHERE publisher_id = arg_publisher_id AND var_doy BETWEEN min_doy AND max_doy;
        IF (FOUND) THEN
            RAISE EXCEPTION 'Invoice has already been paid for the creation date that you are requesting.';
        END IF;

        WHILE created_count < arg_conversion_count LOOP
            SELECT advertiser_id FROM campaigns WHERE id = arg_campaign_id INTO var_advertiser_id;

            INSERT INTO engine_conversions
                (publisher_id, campaign_id, payin, payout, parent_publisher_id, ip_address, continent, country, region, region_name, city, postal_code, latitude, longitude, metro_code, area_code, status, channel, modified_date, created_date)
                VALUES (arg_publisher_id, arg_campaign_id, arg_payin, arg_payout, null, '127.0.0.1', 'NA', 'US', 'CA', 'California', 'Santa Monica', '90405', 34.0194, -118.4903, 0, 310, 1, 0, arg_created_date, arg_created_date)
                RETURNING id
                INTO var_conversion_id;

            INSERT INTO engine_conversions_manual
                (conversion_id, admin_id, manual_type)
                VALUES (var_conversion_id, arg_admin_id, 'create');

            var_rollup_results := conversion_rollup_queue_create(var_conversion_id, arg_publisher_id, arg_campaign_id, var_advertiser_id, arg_payin, arg_payout, arg_created_date, null, 'California', 'Santa Monica', 'US', null, null, '127.0.0.1', null, null, null, null, 0);

            created_count := created_count + 1;
        END LOOP;

        RETURN true;
    END;
$$;


ALTER FUNCTION w4api.campaign_conversion_create(arg_publisher_id bigint, arg_campaign_id bigint, arg_created_date timestamp with time zone, arg_payin money, arg_payout money, arg_conversion_count bigint, arg_admin_id bigint) OWNER TO w4;

--
-- Name: campaign_conversion_get(bigint, timestamp with time zone, timestamp with time zone, bigint, money, money, money, money, bigint, text, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_conversion_get(arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_payin money DEFAULT NULL::money, arg_max_payin money DEFAULT NULL::money, arg_min_payout money DEFAULT NULL::money, arg_max_payout money DEFAULT NULL::money, arg_currency_id bigint DEFAULT NULL::bigint, arg_ip_address text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
                DECLARE
                        ret_val json;
                        count_total bigint;
                        summary json;

                BEGIN

                        IF arg_count THEN
                            SELECT INTO count_total (campaign_conversion_get_list(
                                                arg_campaign_id:=arg_campaign_id, 
                                                arg_min_date:=arg_min_date, 
                                                arg_max_date:=arg_max_date,
                                                arg_publisher_id:=arg_publisher_id, 
                                                arg_min_payin:=arg_min_payin, 
                                                arg_max_payin:=arg_max_payin, 
                                                arg_min_payout:=arg_min_payout, 
                                                arg_max_payout:=arg_max_payout, 
                                                arg_currency_id:=arg_currency_id,
                                                arg_ip_address:=arg_ip_address,
                                                arg_count:=TRUE
                                                )
                                            );
                        ELSE
                            count_total := -1;
                        END IF;

                        IF arg_summary THEN
                            summary := campaign_conversion_get_summary(
                                        arg_campaign_id:=arg_campaign_id, 
                                        arg_min_date:=arg_min_date, 
                                        arg_max_date:=arg_max_date,
                                        arg_publisher_id:=arg_publisher_id, 
                                        arg_min_payin:=arg_min_payin, 
                                        arg_max_payin:=arg_max_payin, 
                                        arg_min_payout:=arg_min_payout, 
                                        arg_max_payout:=arg_max_payout, 
                                        arg_currency_id:=arg_currency_id
                                        );
                        ELSE
                            summary := '{}';
                        END IF;

                        ret_val := 
                        (
                                '{' || 
                                        '"results": ' || COALESCE(campaign_conversion_get_list(
                                        arg_campaign_id:=arg_campaign_id, 
                                        arg_min_date:=arg_min_date, 
                                        arg_max_date:=arg_max_date,
                                        arg_publisher_id:=arg_publisher_id, 
                                        arg_min_payin:=arg_min_payin, 
                                        arg_max_payin:=arg_max_payin, 
                                        arg_min_payout:=arg_min_payout, 
                                        arg_max_payout:=arg_max_payout, 
                                        arg_currency_id:=arg_currency_id,
                                        arg_ip_address:=arg_ip_address,
                                        arg_orderby:=arg_orderby, 
                                        arg_limit:=arg_limit, 
                                        arg_offset:=arg_offset
                                ), '{}') ||
                                        ', "summary": ' || summary ||
                                        ', "count": ' || count_total
                                || '}'
                        )::json;

                        RETURN ret_val;
                  END
            $$;


ALTER FUNCTION w4api.campaign_conversion_get(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_publisher_id bigint, arg_min_payin money, arg_max_payin money, arg_min_payout money, arg_max_payout money, arg_currency_id bigint, arg_ip_address text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: campaign_conversion_get_count(bigint, timestamp with time zone, timestamp with time zone, bigint, money, money, money, money, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_conversion_get_count(arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_payin money DEFAULT NULL::money, arg_max_payin money DEFAULT NULL::money, arg_min_payout money DEFAULT NULL::money, arg_max_payout money DEFAULT NULL::money, arg_currency_id bigint DEFAULT NULL::bigint, arg_ip_address text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
                DECLARE
                    ret_val bigint;
                    where_clause text := '';
                BEGIN
                ------ Need to check other dependencies, but should be completely replaced
                    RETURN (campaign_conversion_get_list(
                                    arg_campaign_id:=arg_campaign_id, 
                                    arg_min_date:=arg_min_date, 
                                    arg_max_date:=arg_max_date,
                                    arg_publisher_id:=arg_publisher_id, 
                                    arg_min_payin:=arg_min_payin, 
                                    arg_max_payin:=arg_max_payin, 
                                    arg_min_payout:=arg_min_payout, 
                                    arg_max_payout:=arg_max_payout, 
                                    arg_currency_id:=arg_currency_id,
                                    arg_ip_address:=arg_ip_address,
                                    arg_count:=TRUE
                                    ));

                END
            $$;


ALTER FUNCTION w4api.campaign_conversion_get_count(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_publisher_id bigint, arg_min_payin money, arg_max_payin money, arg_min_payout money, arg_max_payout money, arg_currency_id bigint, arg_ip_address text) OWNER TO w4;

--
-- Name: campaign_conversion_get_list(bigint, timestamp with time zone, timestamp with time zone, bigint, money, money, money, money, bigint, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_conversion_get_list(arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_payin money DEFAULT NULL::money, arg_max_payin money DEFAULT NULL::money, arg_min_payout money DEFAULT NULL::money, arg_max_payout money DEFAULT NULL::money, arg_currency_id bigint DEFAULT NULL::bigint, arg_ip_address text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $_$
                DECLARE
                    ret_val json;
                    where_clause text := '';
                    order_clause text;
                    from_clause text;
                BEGIN
                                          
                    where_clause := where_clause_build(arg_campaign_id::TEXT, 'campaign_id = ' || arg_campaign_id, where_clause);
                    where_clause := where_clause_build(arg_min_date::TEXT, 'con.created_date >= $$' || arg_min_date || '$$', where_clause);
                    where_clause := where_clause_build(arg_max_date::TEXT, 'con.created_date < $$' || arg_max_date || '$$', where_clause);
                    where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
                    where_clause := where_clause_build(arg_min_payin::TEXT, 'con.payin >= $$' || arg_min_payin || '$$', where_clause);
                    where_clause := where_clause_build(arg_max_payin::TEXT, 'con.payin <= $$' || arg_max_payin || '$$', where_clause);
                    where_clause := where_clause_build(arg_min_payout::TEXT, 'con.payout >= $$' || arg_min_payout || '$$', where_clause);
                    where_clause := where_clause_build(arg_max_payout::TEXT, 'con.payout <= $$' || arg_max_payout || '$$', where_clause);
                    where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);
                    where_clause := where_clause_build(arg_ip_address::TEXT, 'con.ip_address = (''' || arg_ip_address||''')::inet', where_clause);

                from_clause :=   ' FROM engine_conversions con
                            LEFT JOIN campaigns cmp ON (con.campaign_id = cmp.id)
                                            LEFT JOIN users usr ON (con.publisher_id = usr.id)
                                            LEFT JOIN user_profiles usp ON (usr.id = usp.user_id)
                                            LEFT JOIN user_agent_browser_lookup uabl ON (con.browser_id = uabl.id)
                                            LEFT JOIN user_agent_platform_lookup uapl ON (con.platform_id = uapl.id)';       

                IF(arg_count)THEN
                            EXECUTE
                            'SELECT
                            COALESCE (COUNT(1), 0)'
                              || from_clause
                              || where_clause || ';'
                        INTO ret_val;
                    RETURN ret_val;
                    
                ELSE
                     order_clause := order_clause_build(arg_orderby, 'click_date DESC');
                    EXECUTE
                        'SELECT
                            array_to_json (array_agg(row_to_json (results)))
                                FROM (
                                    SELECT row_to_json (row)
                                        FROM (
                                            SELECT
                                                con.id AS conversion_id, 
                                                con.campaign_id, 
                                                cmp.advertiser_id, 
                                                con.publisher_id,
                                                con.click_id, 
                                                COALESCE(usp.company_name, pg_catalog.concat(usp.first_name, CHR(1), usp.last_name)::character varying, CHR(1)::character varying) AS publisher_name, 
                                                con.created_date AS click_date, 
                                                host(con.ip_address)::character(15) AS ip_address, 
                                                con.referral_url, 
                                                COALESCE(NULLIF((uapl.platform_name::text || CHR(1)::text) || uapl.platform_version::text, CHR(1)::text), $$Unknown$$::text) AS os, 
                                                COALESCE(NULLIF((uabl.browser_name::text || CHR(1)::text) || uabl.browser_version::text, CHR(1)::text), $$Unknown$$::text) AS browser, 
                                                COALESCE(
                                                    CASE
                                                        WHEN con.status < 50 THEN con.payin
                                                        ELSE 0::money
                                                    END, 0::money)::numeric AS pay_in_amt, 
                                                COALESCE(
                                                    CASE
                                                        WHEN con.status < 50 THEN con.payout
                                                        ELSE 0::money
                                                    END, 0::money)::numeric AS pay_out_amt, 
                                                    CASE
                                                        WHEN con.status < 50 THEN $$approved$$::text
                                                        WHEN con.status > 50 THEN $$rejected$$::text
                                                        ELSE $$null$$::text
                                                    END AS status,
                                                cmp.currency_id'
                                            || from_clause
                                            || where_clause
                                            || order_clause 
                                            || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
                                            || ' OFFSET ' || arg_offset 
                                            || ' ) row
                        ) results;'
                    INTO ret_val;        
                    RETURN COALESCE(ret_val, '{}');
                    END IF;
                END
            $_$;


ALTER FUNCTION w4api.campaign_conversion_get_list(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_publisher_id bigint, arg_min_payin money, arg_max_payin money, arg_min_payout money, arg_max_payout money, arg_currency_id bigint, arg_ip_address text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_conversion_get_summary(bigint, timestamp with time zone, timestamp with time zone, bigint, money, money, money, money, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_conversion_get_summary(arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_payin money DEFAULT NULL::money, arg_max_payin money DEFAULT NULL::money, arg_min_payout money DEFAULT NULL::money, arg_max_payout money DEFAULT NULL::money, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
                DECLARE
                    ret_val json;
                    where_clause text := '';
                    min_doy integer := make_doy(arg_min_date);
                    max_doy integer := make_doy(arg_max_date);

                BEGIN
                    where_clause := where_clause_build(arg_campaign_id::TEXT, 'rwd.campaign_id = ' || arg_campaign_id, where_clause);
                    where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
                    where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
                    where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
                    where_clause := where_clause_build(arg_min_payin::TEXT, 'pay_in_amount >= ' || arg_min_payin::numeric, where_clause);
                    where_clause := where_clause_build(arg_max_payin::TEXT, 'pay_in_amount <= ' || arg_max_payin::numeric, where_clause);
                    where_clause := where_clause_build(arg_min_payout::TEXT, 'pay_out_amount >= ' || arg_min_payout::numeric, where_clause);
                    where_clause := where_clause_build(arg_max_payout::TEXT, 'pay_out_amount <= ' || arg_max_payout::numeric, where_clause);
                    where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);
                      EXECUTE
                        'SELECT
                            array_to_json (array_agg(row_to_json (results)))
                                FROM (
                                    SELECT row_to_json (row)
                                        FROM (
                                            SELECT
                                                SUM(rwd.unique_clicks) AS clicks,
                                                SUM(rwd.total_conversions) AS conversions,
                                                ROUND(COALESCE(SUM( rwd.total_conversions ) / NULLIF( SUM( rwd.unique_clicks ), 0), 0)::numeric, 4) AS conversion_percent,
                                                COALESCE( SUM( rwd.total_pay_out ) / NULLIF( SUM( rwd.unique_clicks ), 0 ), 0 )::numeric(11,2) AS pepc,
                                                SUM( rwd.total_pay_in ) AS total_in,
                                                SUM( rwd.total_pay_out ) AS total_out,
                                                SUM(rwd.total_pay_in) - SUM(rwd.total_pay_out) AS total_profit,
                                                ROUND(COALESCE(1 -SUM( rwd.total_pay_out ) / NULLIF( SUM( rwd.total_pay_in ), 0), 0)::numeric, 4) AS profit_percent,
                                                MAX(rwd.doy) AS doy,
                                                MAX(rwd.pay_in_amount) AS pay_in_amount,
                                                MAX(rwd.pay_out_amount) AS pay_out_amount,
                                                MAX(cam.currency_id) AS currency_id
                                            FROM reports_wide_daily rwd
                                            LEFT JOIN campaigns cam ON cam.id = rwd.campaign_id '
                                            || where_clause || '
                                        ) row
                                ) results;'
                    INTO ret_val;
                    RETURN ret_val;
                END
            $$;


ALTER FUNCTION w4api.campaign_conversion_get_summary(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_publisher_id bigint, arg_min_payin money, arg_max_payin money, arg_min_payout money, arg_max_payout money, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_conversion_update(json, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_conversion_update(arg_changes json, arg_admin_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        conversion_id bigint;
        approve boolean;
        status_change smallint;
        conversion_ids bigint[];
        ret_val json;
        ret_str text := '{';
        var_update_results boolean;

    BEGIN
        FOR conversion_id, approve IN SELECT * FROM json_populate_recordset(NULL::conversion_approve, arg_changes->'changes') LOOP
            PERFORM * FROM engine_conversions WHERE id = conversion_id;
            IF (FOUND) THEN
                IF (approve::boolean) THEN
                    status_change := 10; -- approved
                ELSE
                    status_change := 50; -- declined
                END IF;
                var_update_results := conversion_update(conversion_id, null, null, status_change, arg_admin_id);
                conversion_ids = array_append(conversion_ids, conversion_id);
            ELSE
                RAISE EXCEPTION 'No conversion found with the id: %', conversion_id;
            END IF;
        END LOOP;

        IF (array_length(conversion_ids, 1) > 0) THEN
            ret_str := ret_str || '"results": ';
            ret_str := ret_str || campaign_conversion_update_get_list(conversion_ids);          
        END IF;
        ret_val := (ret_str || '}')::json;

        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.campaign_conversion_update(arg_changes json, arg_admin_id bigint) OWNER TO w4;

--
-- Name: campaign_conversion_update(bigint, money, money, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_conversion_update(arg_conversion_id bigint, arg_payin money, arg_payout money, arg_admin_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        ret_str text := '{';
        var_update_result boolean;

    BEGIN
        IF ((arg_payin < '0.00') OR (arg_payout < '0.00')) THEN
            RAISE EXCEPTION 'Payin and payout of conversion must be zero or more.';
        END IF;
        
        var_update_result := conversion_update(arg_conversion_id, arg_payin, arg_payout, null, arg_admin_id);
        PERFORM * FROM engine_conversions WHERE id = arg_conversion_id;

        ret_str := ret_str || '"results": ';
        ret_str := ret_str || campaign_conversion_update_get_list(CONCAT('{', arg_conversion_id, '}')::bigint[]);          
        ret_val := (ret_str || '}')::json;

        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.campaign_conversion_update(arg_conversion_id bigint, arg_payin money, arg_payout money, arg_admin_id bigint) OWNER TO w4;

--
-- Name: campaign_conversion_update_get_list(bigint[]); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_conversion_update_get_list(arg_conversion_ids bigint[]) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
	ret_val json;
        conversion_id bigint;
        where_clause text := '';

    BEGIN
        FOREACH conversion_id IN ARRAY arg_conversion_ids LOOP
            IF where_clause != '' THEN
                where_clause := where_clause || ' OR ';
            ELSE
                where_clause := ' WHERE ';
            END IF;
            where_clause := where_clause || 'con.id = ' || conversion_id;            
        END LOOP;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    con.id AS conversion_id, 
                                    con.campaign_id, 
                                    cmp.advertiser_id, 
                                    con.publisher_id,
                                    con.click_id, 
                                    COALESCE(usp.company_name, pg_catalog.concat(usp.first_name, CHR(1), usp.last_name)::character varying, CHR(1)::character varying) AS publisher_name, 
                                    con.created_date AS click_date, 
                                    host(con.ip_address)::character(15) AS ip_address, 
                                    con.referral_url, 
                                    COALESCE(NULLIF((uapl.platform_name::text || CHR(1)::text) || uapl.platform_version::text, CHR(1)::text), $$Unknown$$::text) AS os, 
                                    COALESCE(NULLIF((uabl.browser_name::text || CHR(1)::text) || uabl.browser_version::text, CHR(1)::text), $$Unknown$$::text) AS browser, 
                                    COALESCE(
                                        CASE
                                            WHEN con.status < 50 THEN con.payin
                                            ELSE 0::money
                                        END, 0::money)::numeric AS pay_in_amt, 
                                    COALESCE(
                                        CASE
                                            WHEN con.status < 50 THEN con.payout
                                            ELSE 0::money
                                        END, 0::money)::numeric AS pay_out_amt, 
                                        CASE
                                            WHEN con.status < 50 THEN $$approved$$::text
                                            WHEN con.status >= 50 THEN $$rejected$$::text
                                            ELSE $$null$$::text
                                        END AS status,
                                    cmp.currency_id
                                FROM engine_conversions con
                                LEFT JOIN campaigns cmp ON (con.campaign_id = cmp.id)
                                LEFT JOIN users usr ON (con.publisher_id = usr.id)
                                LEFT JOIN user_profiles usp ON (usr.id = usp.user_id)
                                LEFT JOIN user_agent_browser_lookup uabl ON (con.browser_id = uabl.id)
                                LEFT JOIN user_agent_platform_lookup uapl ON (con.platform_id = uapl.id) '
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_conversion_update_get_list(arg_conversion_ids bigint[]) OWNER TO w4;

--
-- Name: campaign_currency_change_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_currency_change_get(arg_campaign_id bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
	DECLARE
            where_clause text := '';
            var_campaign_id bigint := 0;

	BEGIN

            where_clause := where_clause_build(arg_campaign_id::TEXT, 'id = ' || arg_campaign_id, where_clause);
            where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

            EXECUTE 'SELECT id FROM campaigns ' || where_clause
            INTO var_campaign_id;

            IF (var_campaign_id > 0) THEN
                RETURN TRUE;
            ELSE
                RETURN FALSE;
            END IF;
      END
$$;


ALTER FUNCTION w4api.campaign_currency_change_get(arg_campaign_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_details_geo_get(bigint, timestamp with time zone, timestamp with time zone, bigint, text, text, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_geo_get(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_country_id bigint DEFAULT NULL::bigint, arg_state text DEFAULT NULL::text, arg_city text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            var_country text;

	BEGIN
            IF (arg_country_id IS NOT NULL) THEN
                SELECT iso FROM geo_typeahead_countries WHERE id = arg_country_id INTO var_country;
            END IF;
            IF arg_count THEN
                SELECT INTO count_total COALESCE (campaign_details_geo_get_count(arg_campaign_id, arg_min_date, arg_max_date, var_country, arg_state, arg_city, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || campaign_details_geo_get_list(arg_campaign_id, arg_min_date, arg_max_date, var_country, arg_state, arg_city, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.campaign_details_geo_get(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_country_id bigint, arg_state text, arg_city text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_details_geo_get_count(bigint, timestamp with time zone, timestamp with time zone, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_geo_get_count(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_country text DEFAULT NULL::text, arg_state text DEFAULT NULL::text, arg_city text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'clk.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'clk.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'clk.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_country::TEXT, 'clk.country = $$' || arg_country || '$$', where_clause);
        where_clause := where_clause_build(arg_state::TEXT, 'clk.region_name = $$' || arg_state || '$$', where_clause);
        where_clause := where_clause_build(arg_city::TEXT, 'clk.city_name = $$' || arg_city || '$$', where_clause);
        where_clause := where_clause_build('not null', 'clk.country IS NOT NULL', where_clause);
        where_clause := where_clause_build('not null', 'clk.region_name IS NOT NULL', where_clause);
        where_clause := where_clause_build('not null', 'clk.city_name IS NOT NULL', where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0) FROM (
                                SELECT clk.campaign_id
                                FROM reports_geo_daily clk
                                LEFT JOIN campaigns cmp ON clk.campaign_id = cmp.id '
                                || where_clause ||
                                ' GROUP BY clk.campaign_id, clk.city_name, clk.country, clk.region_name, cmp.status
                ) AS the_count'           
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_details_geo_get_count(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_country text, arg_state text, arg_city text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_details_geo_get_list(bigint, timestamp with time zone, timestamp with time zone, text, text, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_geo_get_list(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_country text DEFAULT NULL::text, arg_state text DEFAULT NULL::text, arg_city text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'clk.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'clk.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'clk.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_country::TEXT, 'clk.country = $$' || arg_country || '$$', where_clause);
        where_clause := where_clause_build(arg_state::TEXT, 'clk.region_name = $$' || arg_state || '$$', where_clause);
        where_clause := where_clause_build(arg_city::TEXT, 'clk.city_name = $$' || arg_city || '$$', where_clause);
        where_clause := where_clause_build('not null', 'clk.country IS NOT NULL', where_clause);
        where_clause := where_clause_build('not null', 'clk.region_name IS NOT NULL', where_clause);
        where_clause := where_clause_build('not null', 'clk.city_name IS NOT NULL', where_clause);

        order_clause := order_clause_build(arg_orderby, 'doy DESC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT cmp.status, 
                                    clk.campaign_id, 
                                    clk.country, 
                                    clk.region_name AS state, 
                                    clk.city_name, 
                                    sum(clk.unique_clicks) AS clicks, 
                                    sum(clk.total_clicks) AS total_clicks, 
                                    sum(clk.total_conversions) AS conversions
                                FROM reports_geo_daily clk
                                LEFT JOIN campaigns cmp ON clk.campaign_id = cmp.id '
                                || where_clause ||
                                ' GROUP BY clk.campaign_id, clk.city_name, clk.country, clk.region_name, cmp.status '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_details_geo_get_list(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_country text, arg_state text, arg_city text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_details_sidebar_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_sidebar_get(arg_campaign_id bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        filter_currency text := '';        
    BEGIN
       
        IF (arg_currency_id IS NOT NULL) THEN
            filter_currency := ' AND cmp.currency_id = ' || arg_currency_id;
        END IF;
                
        EXECUTE
            'SELECT row_to_json (row)
		    FROM (
			SELECT
			max(cmp.id) AS id,
			max(cmp.advertiser_id) AS advertiser_id,
			max(ad.name) AS advertiser_name,
			max(cmp.start_date) AS start_date,
			max(cmp.expiry_date) AS end_date,
			max(cmp.new_until) AS new_until,
			max(cmp.status) AS status,
			max(cmp.access_type) AS access_type,
			max(cmp.description) AS description,
			max(cmp.restrictions) AS restrictions,
			max(cmp.default_payin) AS default_payin,	
			max(cmp.payin_type) AS payin_type,
			(SELECT alias from campaign_conversion_aliases WHERE id=max(cmp.payin_model_id)) AS payin_model_description,
			max(cmp.default_payout) AS default_payout,
			max(cmp.payout_type) AS payout_type,
			max(cmp.failure_redirect_type) AS failure_type,			
			(SELECT alias from campaign_conversion_aliases WHERE id=max(cmp.payout_model_id)) AS payout_model_description,
			max(cmp.default_redirect_url) AS landing_url,			
			CASE max(cmp.failure_redirect_type) WHEN 1 THEN max(cmp.failure_redirect_url) ELSE NULL END AS failure_url,
            		CASE max(cmp.failure_redirect_type) WHEN 2 THEN max(cmp.failure_redirect_campaign_id) ELSE NULL END AS failure_campaign_id,
            		CASE max(cmp.failure_redirect_type) WHEN 2 THEN (SELECT name FROM campaigns WHERE id = max(cmp.failure_redirect_campaign_id)) ELSE NULL END AS failure_campaign_name,
			(SELECT campaign_tracking_get('||arg_campaign_id||')) AS tracking,
			(SELECT campaign_cap_summary_get('||arg_campaign_id||')) AS caps,
			(SELECT campaign_geo_targeting_get_list(arg_campaign_id:='||arg_campaign_id||')) AS geos,
			(SELECT campaign_channels_get_list('||arg_campaign_id||')) AS channels,
			(SELECT campaign_categories_get_list('||arg_campaign_id||')) AS categories
			FROM campaigns cmp
			LEFT JOIN advertisers ad ON ad.id = cmp.advertiser_id
			WHERE cmp.id = '|| arg_campaign_id || ' ' || filter_currency||'	
            ) row;'
        INTO retval;
        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.campaign_details_sidebar_get(arg_campaign_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_details_traffic_create(bigint, bigint, timestamp with time zone, money, money, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_traffic_create(arg_publisher_id bigint, arg_campaign_id bigint, arg_created_date timestamp with time zone, arg_payin money, arg_payout money, arg_conversion_count bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        created_count integer := 0;
        var_doy integer := make_doy(arg_created_date);

    BEGIN
        PERFORM * FROM campaigns WHERE id = arg_campaign_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No campaign found with the id: %', arg_campaign_id;
        END IF;
        
        PERFORM * FROM users WHERE id = arg_publisher_id AND access = 'publisher';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No publisher found with the id: %', arg_publisher_id;
        END IF;

        PERFORM * FROM acct_invoices_publisher WHERE publisher_id = arg_publisher_id AND var_doy BETWEEN min_doy AND max_doy;
        IF (FOUND) THEN
            RAISE EXCEPTION 'Invoice has already been paid for the creation date that you are requesting.';
        END IF;

        WHILE created_count < arg_conversion_count LOOP
            INSERT INTO engine_conversions (publisher_id, campaign_id, payin, payout, created_date) VALUES (arg_publisher_id, arg_campaign_id, arg_payin, arg_payout, arg_created_date);
            created_count := created_count + 1;
        END LOOP;

        RETURN true;
    END;
$$;


ALTER FUNCTION w4api.campaign_details_traffic_create(arg_publisher_id bigint, arg_campaign_id bigint, arg_created_date timestamp with time zone, arg_payin money, arg_payout money, arg_conversion_count bigint) OWNER TO w4;

--
-- Name: campaign_details_traffic_get(bigint, timestamp with time zone, timestamp with time zone, text, text, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_traffic_get(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_search text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            summary json;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (campaign_details_traffic_get_count(arg_campaign_id, arg_min_date, arg_max_date,
                    arg_publisher_search, arg_campaign_status, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            IF arg_summary THEN
                summary := campaign_details_traffic_get_summary(arg_campaign_id, arg_min_date, arg_max_date,
                    arg_publisher_search, arg_campaign_status, arg_currency_id);
            ELSE
                summary := '{}';
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || COALESCE(campaign_details_traffic_get_list(arg_campaign_id, arg_min_date, arg_max_date,
                                arg_publisher_search, arg_campaign_status, arg_currency_id, arg_orderby, arg_limit, arg_offset), '{}') ||
                            ', "summary": ' || summary ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.campaign_details_traffic_get(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_publisher_search text, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: campaign_details_traffic_get_count(bigint, timestamp with time zone, timestamp with time zone, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_traffic_get_count(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_search text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'clk.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_search::TEXT, 'u.id =' || arg_publisher_search, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT COALESCE (COUNT(1), 0) FROM (
                SELECT
                    clk.publisher_id, 
                    COALESCE(max(up.company_name), CONCAT(max(con.first_name), '' '', max(con.last_name))) AS publisher_name,
                    max(cmp.status::text) AS campaign_status, 
                    COALESCE(max(v7dtl.unique_clk_trend), $$0+0+0+0+0+0+0$$::text) AS trending, 
                    sum(clk.total_clicks) AS total_clicks, 
                    sum(clk.unique_clicks) AS unique_clicks, 
                    sum(clk.total_conversions) AS conversions, 
                    ROUND(COALESCE(sum(clk.total_conversions) / NULLIF(sum(clk.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct, 
                    COALESCE(sum(clk.total_pay_in) / NULLIF(sum(clk.unique_clicks), 0::numeric), 0::numeric) AS epc, 
                    sum(clk.total_pay_in) AS total_in, 
                    sum(clk.total_pay_out) AS total_out, 
                    sum(clk.total_pay_in) / NULLIF(sum(clk.total_conversions), 0::numeric) AS average_in, 
                    sum(clk.total_pay_out) / NULLIF(sum(clk.total_conversions), 0::numeric) AS average_out, 
                    sum(clk.profit) AS total_profit,
                    ROUND(COALESCE((1 - sum(clk.total_pay_out) / NULLIF(sum(clk.total_pay_in), 0)), 0)::numeric, 4) AS profit_pct, 
                    max(clk.doy) AS doy
                FROM reports_daily clk
                LEFT JOIN campaigns cmp ON clk.campaign_id = cmp.id
                LEFT JOIN tvw_7_day_trend_line v7dtl ON cmp.id = v7dtl.campaign_id AND v7dtl.publisher_id = clk.publisher_id
                LEFT JOIN users u ON u.id = clk.publisher_id
                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                LEFT JOIN user_profiles up ON up.user_id = u.id'
                || where_clause || '
                GROUP BY clk.publisher_id, clk.campaign_id
            ) the_count'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_details_traffic_get_count(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_publisher_search text, arg_campaign_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_details_traffic_get_list(bigint, timestamp with time zone, timestamp with time zone, text, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_traffic_get_list(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_search text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'clk.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_search::TEXT, 'u.id =' || arg_publisher_search, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'unique_clicks DESC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    clk.publisher_id, 
                                    COALESCE(max(up.company_name), CONCAT(max(con.first_name), '' '', max(con.last_name))) AS publisher_name,
                                    max(cmp.status::text) AS campaign_status, 
                                    COALESCE(max(v7dtl.unique_clk_trend), $$0+0+0+0+0+0+0$$::text) AS trending, 
                                    sum(clk.total_clicks) AS total_clicks, 
                                    sum(clk.unique_clicks) AS unique_clicks, 
                                    sum(clk.total_conversions) AS conversions, 
                                    ROUND(COALESCE(sum(clk.total_conversions) / NULLIF(sum(clk.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct, 
                                    COALESCE(sum(clk.total_pay_out) / NULLIF(sum(clk.unique_clicks), 0::numeric), 0::numeric) AS epc, 
                                    sum(clk.total_pay_in) AS total_in, 
                                    sum(clk.total_pay_out) AS total_out, 
                                    sum(clk.total_pay_in) / NULLIF(sum(clk.total_conversions), 0::numeric) AS average_in, 
                                    sum(clk.total_pay_out) / NULLIF(sum(clk.total_conversions), 0::numeric) AS average_out, 
                                    sum(clk.profit) AS total_profit,
                                    ROUND(COALESCE((1 - sum(clk.total_pay_out) / NULLIF(sum(clk.total_pay_in), 0)), 0)::numeric, 4) AS profit_pct
                                FROM reports_daily clk
                                LEFT JOIN campaigns cmp ON clk.campaign_id = cmp.id
                                LEFT JOIN tvw_7_day_trend_line v7dtl ON cmp.id = v7dtl.campaign_id AND v7dtl.publisher_id = clk.publisher_id
                                LEFT JOIN users u ON u.id = clk.publisher_id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id'
                                || where_clause || '
                                GROUP BY clk.publisher_id, clk.campaign_id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.campaign_details_traffic_get_list(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_publisher_search text, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_details_traffic_get_summary(bigint, timestamp with time zone, timestamp with time zone, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_details_traffic_get_summary(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_publisher_search text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'clk.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_search::TEXT, 'u.id =' || arg_publisher_search, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    COALESCE(SUM(clk.unique_clicks), 0) AS clicks,
                                    COALESCE(SUM(clk.total_conversions), 0) AS conversions,
                                    ROUND(COALESCE(sum(clk.total_conversions) / NULLIF(sum(clk.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct, 
                                    COALESCE(sum(clk.total_pay_out) / NULLIF(sum(clk.unique_clicks), 0::numeric), 0::numeric) AS epc,
                                    COALESCE(SUM(clk.total_pay_out), 0) AS revenue,
                                    COALESCE(SUM(clk.total_pay_out), 0) AS total_out,
                                    COALESCE(SUM(clk.profit), 0) AS total_profit,
                                    ROUND(COALESCE(((SUM(clk.total_pay_in) - SUM(clk.total_pay_out)) / NULLIF(SUM(total_pay_in), 0)), 0)::numeric, 4) AS profit_pct
                                FROM reports_daily clk
                                LEFT JOIN campaigns cmp ON clk.campaign_id = cmp.id
                                LEFT JOIN users u ON u.id = clk.publisher_id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id '
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_details_traffic_get_summary(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_publisher_search text, arg_campaign_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_edit_overview_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_edit_overview_get(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;

    BEGIN
        SELECT
            row_to_json (row)
                FROM (
                    SELECT
                        cmp.id,
                        cmp.advertiser_id,
                        ad.name AS advertiser_name,
                        cmp.start_date,
                        cmp.expiry_date,
                        cmp.status,
                        cmp.description,
                        cmp.restrictions,
                        cmp.default_payin,
                        cmp.payin_type,
                        cmp.payin_model_id,
                        cmp.payout_type,
                        cmp.payout_model_id,
                        cmp.new_until,
                        csl.list_type AS suppression_list_type,
                        COALESCE(csl.suppression_lists_id::text, csl.external_id) AS suppression_list_id
                    FROM campaigns cmp
                    LEFT JOIN advertisers ad ON cmp.advertiser_id = ad.id
                    LEFT JOIN campaign_suppression_lists csl ON cmp.id = csl.campaign_id
                    WHERE cmp.id = arg_campaign_id
                ) row
        INTO ret_val;
        RETURN ret_val;

    END
$$;


ALTER FUNCTION w4api.campaign_edit_overview_get(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: campaign_expiration_get(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_expiration_get() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_publisher_ids_all json;
        var_publisher_ids_not_public json;
        var_publisher_ids json;
        var_campaign_id bigint;
        var_campaign_name text;
        var_expiry_date timestamp with time zone;
        var_days_remaining int;
        var_access_type int;
        var_content text;
        var_messages_success boolean;

    BEGIN
        --Load the publishers to send alerts to.
        SELECT
            array_to_json (array_agg(id))
                FROM (
                    SELECT
                            id
                        FROM users
                        WHERE active = 'active' AND access = 'publisher'
                ) AS result
        INTO var_publisher_ids_all;
        var_publisher_ids_all := '{"recipients":' || var_publisher_ids_all || '}';

        --Look for expired campaign and send out alerts.
        FOR var_campaign_id, var_campaign_name, var_expiry_date, var_days_remaining, var_access_type, var_publisher_ids_not_public IN
            SELECT
                cmp.id AS id,
                MAX(cmp.name) AS name,
                MAX(cmp.expiry_date) AS expiry_date,
                (make_doy(MAX(expiry_date)) - make_doy(CURRENT_TIMESTAMP)) AS days_remaining,
                MAX(cmp.access_type) AS access_type,
                array_to_json(array_agg(cap.publisher_id)) AS publisher_ids
            FROM campaigns cmp
            LEFT JOIN campaign_assigned_publishers cap
                ON cap.campaign_id = cmp.id            
            WHERE
                make_doy(expiry_date) <= make_doy(CURRENT_TIMESTAMP + INTERVAL '7 days') AND
                make_doy(expiry_date) >= make_doy(CURRENT_TIMESTAMP) AND
                (
                    cmp.access_type = 1 OR
                    (cmp.access_type <> 1 AND cap.status = 'approved')
                )
            GROUP BY cmp.id
        LOOP
            IF (var_access_type != 1) THEN
                var_publisher_ids_not_public := '{"recipients":' || var_publisher_ids_not_public || '}';
                var_publisher_ids := var_publisher_ids_not_public;
            ELSE
                var_publisher_ids := var_publisher_ids_all;
            END IF;
            var_content :=  'The campaign "' || var_campaign_name || '" (' || var_campaign_id || ') will expire in ' || var_days_remaining || ' day(s).';
            var_messages_success := messages_create (0, var_publisher_ids, 1, var_content, null, 1, 1);           
        END LOOP;


        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_expiration_get() OWNER TO w4;

--
-- Name: campaign_expiration_update(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_expiration_update() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        UPDATE campaigns SET status = 'disabled' WHERE make_doy(expiry_date) < make_doy(CURRENT_TIMESTAMP);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_expiration_update() OWNER TO w4;

--
-- Name: campaign_geo_get(bigint, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_get(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT NULL::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            var_count text := '';
	BEGIN
		
		IF arg_count THEN
			var_count := ',"count": ' || campaign_geo_get_count( arg_campaign_id, arg_min_date, arg_max_date );
		END IF;

		RETURN 
		(
		    '{' ||
			    '"results": ' || campaign_geo_get_list( arg_campaign_id, arg_min_date, arg_max_date, arg_orderby, arg_limit, arg_offset ) || 
			    var_count ||
		    '}'
		)::json;
      END
$$;


ALTER FUNCTION w4api.campaign_geo_get(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_geo_get_count(bigint, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_get_count(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $$	

BEGIN
	RETURN
		COUNT(*)
		
	FROM
	(
		SELECT
			1 

		FROM
			reports_geo_daily clk
			
		LEFT JOIN
			campaigns cmp ON clk.campaign_id = cmp.id

		WHERE
			campaign_id = COALESCE( arg_campaign_id, campaign_id )
			
		GROUP BY
			clk.campaign_id,
			cmp.status,
			clk.city_name,
			clk.region_name,
			clk.country
	) x;

END;

$$;


ALTER FUNCTION w4api.campaign_geo_get_count(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: campaign_geo_get_list(bigint, timestamp with time zone, timestamp with time zone, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_get_list(arg_campaign_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
DECLARE
	retval json;
BEGIN
	arg_orderby := orderby( COALESCE( arg_orderby, 'country DESC' ) );

	EXECUTE
		'SELECT array_to_json( array_agg( row_to_json( r.* ) ) ) FROM
		(
			SELECT
				cmp.status, 
				clk.city_name AS city,
				clk.region_name AS state, 
				clk.country,
				SUM(clk.unique_clicks) AS clicks, 
				SUM(clk.total_conversions) AS conversions
			FROM
				reports_geo_daily clk
				
			LEFT JOIN
				campaigns cmp ON clk.campaign_id = cmp.id

			WHERE
				campaign_id = COALESCE( $1, campaign_id ) AND 
				( $2 IS NULL OR doy >= make_doy( $2 ) ) AND
				( $3 IS NULL OR doy <  make_doy( $3 ) )
				
			GROUP BY
				clk.campaign_id,
				cmp.status,
				clk.city_name,
				clk.region_name,
				clk.country

			ORDER BY
				' || arg_orderby || '

			LIMIT
				$4

			OFFSET
				$5
		) r;' 
	INTO
		retval
		
	USING
		arg_campaign_id,
		arg_min_date,
		arg_max_date,
		arg_limit,
		arg_offset;
		
	RETURN COALESCE( retval, '[]'::json );
END
$_$;


ALTER FUNCTION w4api.campaign_geo_get_list(arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_geo_targeting_create(bigint, bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_targeting_create(arg_campaign_id bigint, arg_country_id bigint, arg_region text DEFAULT NULL::text, arg_city text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_city_id    bigint;
        var_region_short  text;
        var_country_short text;

    BEGIN
        SELECT country_short, region_short, city_id FROM geo_target_get(arg_country_id, arg_region, arg_city) INTO var_country_short, var_region_short, var_city_id;

        PERFORM * FROM campaign_geotargeting WHERE
            campaign_id = arg_campaign_id AND
            country = var_country_short AND
            (region = var_region_short OR var_region_short IS NULL) AND
            (city = arg_city OR arg_city IS NULL) AND
            (city_id = var_city_id OR var_city_id IS NULL);

        IF (FOUND) THEN
            RAISE EXCEPTION 'Geo targeting alreadys exists for that combo.';
        END IF;

        INSERT INTO campaign_geotargeting
            (campaign_id, country, region, city, city_id)
            VALUES (arg_campaign_id, var_country_short, var_region_short, arg_city, var_city_id);

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_geo_targeting_create(arg_campaign_id bigint, arg_country_id bigint, arg_region text, arg_city text) OWNER TO w4;

--
-- Name: campaign_geo_targeting_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_targeting_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM campaign_geotargeting WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified campaign geo targeting (%).', arg_id;
        END IF;

        DELETE FROM campaign_geotargeting WHERE id = arg_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_geo_targeting_delete(arg_id bigint) OWNER TO w4;

--
-- Name: campaign_geo_targeting_get(bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_targeting_get(arg_campaign_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (campaign_geo_targeting_get_count(null, arg_campaign_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || campaign_geo_targeting_get_list(null, arg_campaign_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.campaign_geo_targeting_get(arg_campaign_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_geo_targeting_get_count(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_targeting_get_count(arg_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_id::TEXT, 'geo.id = ' || arg_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'campaign_id = ' || arg_campaign_id, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM campaign_geotargeting geo
            LEFT JOIN geo_target_countries country ON country.iso = geo.country
            LEFT JOIN geo_target_region region ON region.admin1_code = geo.country AND region.local_name = geo.region
            LEFT JOIN geo_target_cities city ON city.id = geo.city_id '
            || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.campaign_geo_targeting_get_count(arg_id bigint, arg_campaign_id bigint) OWNER TO w4;

--
-- Name: campaign_geo_targeting_get_list(bigint, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_targeting_get_list(arg_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
        where_clause := where_clause_build(arg_id::TEXT, 'geo.id = ' || arg_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'campaign_id = ' || arg_campaign_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'country ASC, region ASC, city ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT DISTINCT geo.campaign_id, 
                                    COALESCE(country.country, $$$$::character varying) AS country, 
                                    COALESCE(country.id, 0) AS country_id, 
                                    COALESCE(region.local_name, $$$$::character varying) AS region, 
                                    COALESCE(region.id, 0) AS region_id, 
                                    COALESCE(city.place_name, $$$$::character varying) AS city, 
                                    COALESCE(city.id, 0) AS city_id, 
                                    geo.id AS geo_id
                                FROM campaign_geotargeting geo
                                LEFT JOIN geo_target_countries country ON country.iso = geo.country
                                LEFT JOIN geo_target_region region ON region.country = geo.country AND region.admin1_code = geo.region
                                LEFT JOIN geo_target_cities city ON city.id = geo.city_id '
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_geo_targeting_get_list(arg_id bigint, arg_campaign_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_geo_targeting_update(bigint, bigint, bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_geo_targeting_update(arg_geo_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_country_id bigint DEFAULT NULL::bigint, arg_region text DEFAULT NULL::text, arg_city text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_city_id    bigint;
        var_region_short  text;
        var_country_short text;

    BEGIN
        PERFORM id FROM campaign_geotargeting WHERE id = arg_geo_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the specified campaign geo targeting (%).', arg_geo_id;
        END IF;

        SELECT country_short, region_short, city_id FROM geo_target_get(arg_country_id, arg_region, arg_city) INTO var_country_short, var_region_short, var_city_id;

        UPDATE campaign_geotargeting SET            
            campaign_id     = COALESCE (arg_campaign_id, campaign_id),
            country         = COALESCE (var_country_short, country),
            region          = var_region_short,
            city            = arg_city,
            city_id         = var_city_id
        WHERE id = arg_geo_id;

        RETURN campaign_geo_targeting_get_list(arg_geo_id);
    END;
$$;


ALTER FUNCTION w4api.campaign_geo_targeting_update(arg_geo_id bigint, arg_campaign_id bigint, arg_country_id bigint, arg_region text, arg_city text) OWNER TO w4;

--
-- Name: campaign_get(text, json, json, json, json, boolean, text, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_get(arg_traffic_search text DEFAULT NULL::text, arg_campaign_ids json DEFAULT NULL::json, arg_advertiser_ids json DEFAULT NULL::json, arg_category_ids json DEFAULT NULL::json, arg_channel_ids json DEFAULT NULL::json, arg_is_new boolean DEFAULT NULL::boolean, arg_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (campaign_get_count(arg_traffic_search, arg_campaign_ids, arg_advertiser_ids, arg_category_ids, arg_channel_ids, arg_is_new, arg_status, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || campaign_get_list(arg_traffic_search, arg_campaign_ids, arg_advertiser_ids, arg_category_ids, arg_channel_ids, arg_is_new, arg_status, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.campaign_get(arg_traffic_search text, arg_campaign_ids json, arg_advertiser_ids json, arg_category_ids json, arg_channel_ids json, arg_is_new boolean, arg_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_get_count(text, json, json, json, json, boolean, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_get_count(arg_traffic_search text DEFAULT NULL::text, arg_campaign_ids json DEFAULT NULL::json, arg_advertiser_ids json DEFAULT NULL::json, arg_category_ids json DEFAULT NULL::json, arg_channel_ids json DEFAULT NULL::json, arg_is_new boolean DEFAULT NULL::boolean, arg_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        var_campaign_ids bigint[];
        var_advertiser_ids bigint[];
	var_category_ids bigint[];
	var_channel_ids bigint[];

    BEGIN
	IF arg_campaign_ids IS NOT NULL THEN
		var_campaign_ids := json_array_convert( arg_campaign_ids )::bigint[];
	END IF;

	IF arg_advertiser_ids IS NOT NULL THEN
		var_advertiser_ids := json_array_convert( arg_advertiser_ids )::bigint[];
	END IF;

	IF arg_channel_ids IS NOT NULL THEN
		var_channel_ids := json_array_convert( arg_channel_ids )::bigint[];
	END IF;

	IF arg_category_ids IS NOT NULL THEN
		var_category_ids := json_array_convert( arg_category_ids )::bigint[];
	END IF;

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0)
                FROM campaigns cmp
                LEFT JOIN advertisers ad ON (ad.id = cmp.advertiser_id)
                LEFT JOIN users aum ON (aum.id = ad.manager_id)
                LEFT JOIN contacts acm ON (acm.id = aum.primary_contact_id)
                LEFT JOIN campaign_conversion_aliases cca ON (cmp.payout_model_id = cca.id)
                LEFT JOIN vw_campaign_categories_json cct ON cct.campaign_id = cmp.id
                LEFT JOIN vw_campaign_channels_json   cch ON cch.campaign_id = cmp.id
                WHERE
                    ($1 IS NULL OR ARRAY[cmp.id] && $1) AND
                    ($2 IS NULL OR ARRAY[cmp.advertiser_id] && $2) AND
                    ($7 IS NULL OR cmp.currency_id = $7) AND
                    ($3 IS NULL OR cct.category_ids @> $3) AND
                    ($4 IS NULL OR cch.channel_ids  @> $4) AND
                    ($5 IS NULL OR $5 IS FALSE OR cmp.new_until >= CURRENT_TIMESTAMP) AND
                    ($6 IS NULL OR cmp.status = $6) AND
                      ($8 IS NULL OR ((LOWER(cmp.name) ILIKE ''%''||LOWER($8)||''%'' )OR(cmp.id::text ILIKE ''%''||$8||''%'' ))
                    )
             LIMIT 1; '
        INTO retval
        USING var_campaign_ids, var_advertiser_ids, var_category_ids, var_channel_ids, arg_is_new, arg_status, arg_currency_id, arg_traffic_search;

        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.campaign_get_count(arg_traffic_search text, arg_campaign_ids json, arg_advertiser_ids json, arg_category_ids json, arg_channel_ids json, arg_is_new boolean, arg_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_get_list(text, json, json, json, json, boolean, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_get_list(arg_traffic_search text DEFAULT NULL::text, arg_campaign_ids json DEFAULT NULL::json, arg_advertiser_ids json DEFAULT NULL::json, arg_category_ids json DEFAULT NULL::json, arg_channel_ids json DEFAULT NULL::json, arg_is_new boolean DEFAULT NULL::boolean, arg_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        var_campaign_ids bigint[];
        var_advertiser_ids bigint[];
	var_category_ids bigint[];
	var_channel_ids bigint[];

    BEGIN
	IF arg_campaign_ids IS NOT NULL THEN
		var_campaign_ids := json_array_convert( arg_campaign_ids )::bigint[];
	END IF;

	IF arg_advertiser_ids IS NOT NULL THEN
		var_advertiser_ids := json_array_convert( arg_advertiser_ids )::bigint[];
	END IF;

	IF arg_channel_ids IS NOT NULL THEN
		var_channel_ids := json_array_convert( arg_channel_ids )::bigint[];
	END IF;

	IF arg_category_ids IS NOT NULL THEN
		var_category_ids := json_array_convert( arg_category_ids )::bigint[];
	END IF;

        order_clause := order_clause_build(arg_orderby, 'campaign_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    cmp.id AS campaign_id,
                                    cmp.name AS campaign_name,
                                    cmp.advertiser_id AS advertiser_id,
                                    ad.name AS advertiser_name,
                                    ad.manager_id AS manager_id,
                                    pg_catalog.concat(COALESCE(acm.first_name, mup.first_name), '' '', COALESCE(acm.last_name, mup.last_name))::text AS manager_name,
                                    cmp.default_payout AS payout,
                                    cmp.payout_type AS payout_type,
                                    cmp.default_payin AS payin,
                                    cmp.payin_type AS payin_type,
                                    cca.alias AS conversion_alias,
                                    cmp.status AS status,
                                    (CASE cmp.access_type WHEN 1 THEN ''Public'' WHEN 2 THEN ''Private'' WHEN 3 THEN ''By Approval'' END) AS access_type
                                FROM campaigns cmp
                                LEFT JOIN advertisers ad ON (ad.id = cmp.advertiser_id)
                                LEFT JOIN users aum ON (aum.id = ad.manager_id)
                                LEFT JOIN contacts acm ON (acm.id = aum.primary_contact_id)
                                LEFT JOIN user_profiles mup ON (mup.user_id = aum.id)
                                LEFT JOIN campaign_conversion_aliases cca ON (cmp.payout_model_id = cca.id)
                                LEFT JOIN vw_campaign_categories_json cct ON cct.campaign_id = cmp.id
                                LEFT JOIN vw_campaign_channels_json   cch ON cch.campaign_id = cmp.id
                                WHERE
                                    ($1 IS NULL OR ARRAY[cmp.id] && $1) AND
                                    ($2 IS NULL OR ARRAY[cmp.advertiser_id] && $2) AND
                                    ($7 IS NULL OR cmp.currency_id = $7) AND
                                    ($3 IS NULL OR cct.category_ids @> $3) AND
                                    ($4 IS NULL OR cch.channel_ids  @> $4) AND
                                    ($5 IS NULL OR $5 IS FALSE OR cmp.new_until >= CURRENT_TIMESTAMP) AND
                                    ($6 IS NULL OR cmp.status = $6) AND
                                    ($8 IS NULL OR ((LOWER(cmp.name) ILIKE ''%''||LOWER($8)||''%'' )OR(cmp.id::text ILIKE ''%''||$8||''%'' ))
                                    ) '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val
        USING var_campaign_ids, var_advertiser_ids, var_category_ids, var_channel_ids, arg_is_new, arg_status, arg_currency_id, arg_traffic_search;

        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.campaign_get_list(arg_traffic_search text, arg_campaign_ids json, arg_advertiser_ids json, arg_category_ids json, arg_channel_ids json, arg_is_new boolean, arg_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_id_update(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_id_update(arg_campaign_id_current bigint, arg_campaign_id_requested bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM campaigns WHERE id = arg_campaign_id_current;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the specified campaign (%).', arg_campaign_id_current;
        END IF;

        PERFORM id FROM campaigns WHERE id = arg_campaign_id_requested;
        IF (FOUND) THEN
            RAISE EXCEPTION 'Requested campaign id already exists (%).', arg_campaign_id_requested;
        END IF;

        UPDATE campaigns SET            
            id = arg_campaign_id_requested
        WHERE id = arg_campaign_id_current;

        UPDATE campaign_suppression_lists SET
            campaign_id = arg_campaign_id_requested
        WHERE campaign_id = arg_campaign_id_current;

        UPDATE campaign_channels SET
            campaign_id = arg_campaign_id_requested
        WHERE campaign_id = arg_campaign_id_current;

        UPDATE campaign_categories SET
            campaign_id = arg_campaign_id_requested
        WHERE campaign_id = arg_campaign_id_current;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_id_update(arg_campaign_id_current bigint, arg_campaign_id_requested bigint) OWNER TO w4;

--
-- Name: campaign_landing_pages_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_landing_pages_get(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;

    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    landing_pages
                FROM campaigns
                WHERE id = arg_campaign_id
            ) row
        INTO ret_val;

        RETURN COALESCE(ret_val, '{}');
    END
$$;


ALTER FUNCTION w4api.campaign_landing_pages_get(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: campaign_list_traffic_get(text, text, text, numeric, numeric, bigint, bigint, bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, timestamp with time zone, boolean, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_list_traffic_get(arg_search_campaign text DEFAULT NULL::text, arg_search_advertiser text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_pepc_min numeric DEFAULT NULL::numeric, arg_pepc_max numeric DEFAULT NULL::numeric, arg_category_id bigint DEFAULT NULL::bigint, arg_channel_id bigint DEFAULT NULL::bigint, arg_clicks_min bigint DEFAULT NULL::bigint, arg_clicks_max bigint DEFAULT NULL::bigint, arg_conversions_min bigint DEFAULT NULL::bigint, arg_conversions_max bigint DEFAULT NULL::bigint, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_date_min timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_date_max timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_is_new boolean DEFAULT NULL::boolean, arg_expires_date_min timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_expires_date_max timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT NULL::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS TABLE(id bigint, name text, status text, advertiser_id bigint, advertiser_name text, channel_names_json json, category_names_json json, expires timestamp with time zone, is_new boolean, has_cap boolean, clicks bigint, conversions bigint, conversion_percent numeric, pepc numeric, total_in numeric, total_out numeric, profit_percent numeric, count_total integer)
    LANGUAGE plpgsql
    AS $_$
	DECLARE
            sort TEXT;
            direction TEXT;
            count_total int;
	BEGIN
            sort      := COALESCE( arg_orderby, 'campaign_id' );
            direction := '';
            direction := CASE direction = '' AND sort ~* '\s+ASC$'  WHEN TRUE THEN 'ASC'  ELSE direction END;
            direction := CASE direction = '' AND sort ~* '\s+DESC$' WHEN TRUE THEN 'DESC' ELSE direction END;
            sort      := regexp_replace( sort, '\s+(' || direction || ')$', '', 'i' );
            arg_search_advertiser := '%' || arg_search_advertiser || '%';
            count_total = NULL;
            IF arg_count THEN
                EXECUTE
                    'SELECT
                        COUNT(1) OVER()
                    FROM vw_campaigns_traffic_list_view
                    WHERE
                            ( advertiser_name ILIKE COALESCE( $3, advertiser_name ) OR advertiser_id::text ILIKE COALESCE( $3, advertiser_id::text ) ) AND
                            ( campaign_name ILIKE COALESCE( $4, campaign_name ) OR campaign_id::text ILIKE COALESCE( $4, campaign_id::text ) ) AND
                            ( is_new = ''Yes'' ) = COALESCE( $5, is_new = ''Yes'' ) AND
                            campaign_status = COALESCE( $6, campaign_status ) AND
                            currency_id = COALESCE( $23, currency_id ) AND
                            COALESCE( doy >= make_doy( $17 ), TRUE ) AND
                            COALESCE( doy < make_doy( $18 ), TRUE ) AND
                            COALESCE( doy < make_doy( $19 ), TRUE ) AND
                            COALESCE( doy < make_doy( $20 ), TRUE ) AND
                            ( $21 IS NULL OR ARRAY[$21]::bigint[] <@ ( SELECT array_agg( trim( hack ) )::bigint[] FROM unnest( string_to_array( channel_ids, '','' ) ) as hack WHERE trim( hack ) != '''' ) ) AND
                            ( $22 IS NULL OR ARRAY[$22]::bigint[] <@ ( SELECT array_agg( trim( hack ) )::bigint[] FROM unnest( string_to_array( category_ids, '','' ) ) as hack WHERE trim( hack ) != '''' ) ) AND
                            TRUE
                    GROUP BY campaign_id'
                INTO count_total
                USING
                    arg_limit,
                    arg_offset,
                    arg_search_advertiser,
                    arg_search_campaign,
                    arg_is_new,
                    arg_status,
                    arg_pepc_min,
                    arg_pepc_max,
                    arg_profit_percent_min,
                    arg_profit_percent_max,
                    arg_conversion_percent_min,
                    arg_conversion_percent_max,
                    arg_clicks_min,
                    arg_clicks_max,
                    arg_conversions_min,
                    arg_conversions_max,
                    arg_date_min,
                    arg_date_max,
                    arg_expires_date_min,
                    arg_expires_date_max,
                    arg_channel_id,
                    arg_category_id,
                    arg_currency_id;
            END IF;
            RETURN QUERY EXECUTE
                'SELECT
                    campaign_id AS id,
                    MAX( campaign_name ) AS name,
                    MAX( campaign_status ) AS status,
                    MAX( advertiser_id ) AS advertiser_id,
                    MAX( advertiser_name ) AS advertiser_name,

                    ( SELECT json_encode( COALESCE( array_agg( trim( hack ) ), ARRAY[]::text[] ) ) FROM unnest( string_to_array( MAX( channels ), '','' ) ) as hack WHERE trim( hack ) != '''' ) AS channel_names_json,

                    ( SELECT json_encode( COALESCE( array_agg( trim( hack ) ), ARRAY[]::text[] ) ) FROM unnest( string_to_array( MAX( categories ), '','' ) ) as hack WHERE trim( hack ) != '''' ) AS category_names_json,
                    MAX( expires ) AS expires,
                    MAX( is_new ) = ''Yes'' AS is_new,

                    EVERY( campaign_cap > 0 ) AS has_cap,
                    SUM( total_clicks )::bigint AS clicks,
                    SUM( total_conversions )::bigint AS conversions,
                    COALESCE( SUM( total_conversions ) / NULLIF( SUM( total_clicks ), 0 ) * 100, 0 ) AS conversion_percent,
                    COALESCE( SUM( total_out ) / NULLIF( SUM( total_clicks ), 0 ), 0 ) AS pepc,
                    SUM( total_in ) AS total_in,
                    SUM( total_out ) AS total_out,
                    COALESCE( 100 - SUM( total_out ) / NULLIF( SUM( total_in ), 0 ) * 100, 0 ) AS profit_percent, '
                    || count_total || '
                FROM vw_campaigns_traffic_list_view
                WHERE
                        ( advertiser_name ILIKE COALESCE( $3, advertiser_name ) OR advertiser_id::text ILIKE COALESCE( $3, advertiser_id::text ) ) AND
                        ( campaign_name ILIKE COALESCE( $4, campaign_name ) OR campaign_id::text ILIKE COALESCE( $4, campaign_id::text ) ) AND
                        ( is_new = ''Yes'' ) = COALESCE( $5, is_new = ''Yes'' ) AND
                        campaign_status = COALESCE( $6, campaign_status ) AND
                        currency_id = COALESCE( $23, currency_id ) AND
                        COALESCE( doy >= make_doy( $17 ), TRUE ) AND
                        COALESCE( doy < make_doy( $18 ), TRUE ) AND
                        COALESCE( doy < make_doy( $19 ), TRUE ) AND
                        COALESCE( doy < make_doy( $20 ), TRUE ) AND
                        ( $21 IS NULL OR ARRAY[$21]::bigint[] <@ ( SELECT array_agg( trim( hack ) )::bigint[] FROM unnest( string_to_array( channel_ids, '','' ) ) as hack WHERE trim( hack ) != '''' ) ) AND
                        ( $22 IS NULL OR ARRAY[$22]::bigint[] <@ ( SELECT array_agg( trim( hack ) )::bigint[] FROM unnest( string_to_array( category_ids, '','' ) ) as hack WHERE trim( hack ) != '''' ) ) AND
                        TRUE
                GROUP BY campaign_id
                HAVING
                        COALESCE( COALESCE( SUM( total_out ) / NULLIF( SUM( total_clicks ), 0 ), 0 ) >= $7, TRUE ) AND
                        COALESCE( COALESCE( SUM( total_out ) / NULLIF( SUM( total_clicks ), 0 ), 0 ) < $8, TRUE ) AND
                        COALESCE( COALESCE( 100 - SUM( total_out ) / NULLIF( SUM( total_in ), 0 ) * 100, 0 ) >= $9, TRUE ) AND
                        COALESCE( COALESCE( 100 - SUM( total_out ) / NULLIF( SUM( total_in ), 0 ) * 100, 0 ) < $10, TRUE ) AND
                        COALESCE( COALESCE( SUM( total_conversions ) / NULLIF( SUM( total_clicks ), 0 ) * 100, 0 ) >= $11, TRUE ) AND
                        COALESCE( COALESCE( SUM( total_conversions ) / NULLIF( SUM( total_clicks ), 0 ) * 100, 0 ) < $12, TRUE ) AND
                        COALESCE( SUM( total_clicks ) >= $13, TRUE ) AND
                        COALESCE( SUM( total_clicks ) < $14, TRUE ) AND
                        COALESCE( SUM( total_conversions ) >= $15, TRUE ) AND
                        COALESCE( SUM( total_conversions ) < $16, TRUE ) AND
                        TRUE
                ORDER BY ' || quote_ident( sort ) || ' ' || direction || '
                LIMIT $1
                OFFSET $2;'
            USING
                arg_limit,
                arg_offset,
                arg_search_advertiser,
                arg_search_campaign,
                arg_is_new,
                arg_status,
                arg_pepc_min,
                arg_pepc_max,
                arg_profit_percent_min,
                arg_profit_percent_max,
                arg_conversion_percent_min,
                arg_conversion_percent_max,
                arg_clicks_min,
                arg_clicks_max,
                arg_conversions_min,
                arg_conversions_max,
                arg_date_min,
                arg_date_max,
                arg_expires_date_min,
                arg_expires_date_max,
                arg_channel_id,
                arg_category_id,
                arg_currency_id;
      END
$_$;


ALTER FUNCTION w4api.campaign_list_traffic_get(arg_search_campaign text, arg_search_advertiser text, arg_status text, arg_pepc_min numeric, arg_pepc_max numeric, arg_category_id bigint, arg_channel_id bigint, arg_clicks_min bigint, arg_clicks_max bigint, arg_conversions_min bigint, arg_conversions_max bigint, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_date_min timestamp with time zone, arg_date_max timestamp with time zone, arg_is_new boolean, arg_expires_date_min timestamp with time zone, arg_expires_date_max timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_list_traffic_summary(text, text, text, numeric, numeric, bigint, bigint, bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, timestamp with time zone, boolean, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_list_traffic_summary(arg_search_campaign text DEFAULT NULL::text, arg_search_advertiser text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_min_pepc numeric DEFAULT NULL::numeric, arg_max_pepc numeric DEFAULT NULL::numeric, arg_category_id bigint DEFAULT NULL::bigint, arg_channel_id bigint DEFAULT NULL::bigint, arg_min_clicks bigint DEFAULT NULL::bigint, arg_max_clicks bigint DEFAULT NULL::bigint, arg_min_conversions bigint DEFAULT NULL::bigint, arg_max_conversions bigint DEFAULT NULL::bigint, arg_min_conversion_percent numeric DEFAULT NULL::numeric, arg_max_conversion_percent numeric DEFAULT NULL::numeric, arg_min_profit_percent numeric DEFAULT NULL::numeric, arg_max_profit_percent numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_is_new boolean DEFAULT NULL::boolean, arg_min_expires_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_expires_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
	BEGIN
		RETURN
			json_encode( summary.* )
		FROM
		(
			SELECT
				COUNT( 1 ) AS count,
				SUM( clicks ) AS clicks,
				SUM( conversions ) AS conversions,
				COALESCE( SUM( clicks ) / SUM( conversions ), 0 ) AS conversion_percent,
				SUM( total_in ) AS total_in,
				COALESCE( SUM( total_in ) / SUM( clicks ), 0 ) AS pepc,
				SUM( total_in ) - SUM( total_out ) AS total_profit,
				COALESCE( 100 - SUM( total_out ) / NULLIF( SUM( total_in ), 0 ) * 100, 0 ) AS profit_percent
			FROM
				campaign_list_traffic_get
				(
					"arg_search_campaign" := arg_search_campaign,
					"arg_search_advertiser" := arg_search_advertiser,
					"arg_status" := arg_status,
					"arg_min_pepc" := arg_min_pepc,
					"arg_max_pepc" := arg_max_pepc,
					"arg_category_id" := arg_category_id,
					"arg_channel_id" := arg_channel_id,
					"arg_min_clicks" := arg_min_clicks,
					"arg_max_clicks" := arg_max_clicks,
					"arg_min_conversions" := arg_min_conversions,
					"arg_max_conversions" := arg_max_conversions,
					"arg_min_conversion_percent" := arg_min_conversion_percent,
					"arg_max_conversion_percent" := arg_max_conversion_percent,
					"arg_min_profit_percent" := arg_min_profit_percent,
					"arg_max_profit_percent" := arg_max_profit_percent,
					"arg_min_date" := arg_min_date,
					"arg_max_date" := arg_max_date,
					"arg_is_new" := arg_is_new,
					"arg_min_expires_date" := arg_min_expires_date,
					"arg_max_expires_date" := arg_max_expires_date,
					"arg_currency_id" := arg_currency_id
				)
		) summary;
	END
$$;


ALTER FUNCTION w4api.campaign_list_traffic_summary(arg_search_campaign text, arg_search_advertiser text, arg_status text, arg_min_pepc numeric, arg_max_pepc numeric, arg_category_id bigint, arg_channel_id bigint, arg_min_clicks bigint, arg_max_clicks bigint, arg_min_conversions bigint, arg_max_conversions bigint, arg_min_conversion_percent numeric, arg_max_conversion_percent numeric, arg_min_profit_percent numeric, arg_max_profit_percent numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_is_new boolean, arg_min_expires_date timestamp with time zone, arg_max_expires_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_overview_update(bigint, bigint, timestamp with time zone, text, bigint, timestamp with time zone, bigint, text, text, text, numeric, bigint, bigint, numeric, bigint, bigint, timestamp with time zone, boolean, json, json, public.suppression, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_overview_update(arg_id bigint, arg_admin_id bigint, arg_expiry_date timestamp with time zone, arg_name text DEFAULT NULL::text, arg_advertiser_id bigint DEFAULT NULL::bigint, arg_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_access_type bigint DEFAULT NULL::bigint, arg_status text DEFAULT NULL::text, arg_description text DEFAULT NULL::text, arg_restrictions text DEFAULT NULL::text, arg_default_payin numeric DEFAULT NULL::numeric, arg_payin_type bigint DEFAULT NULL::bigint, arg_payin_model_id bigint DEFAULT NULL::bigint, arg_default_payout numeric DEFAULT NULL::numeric, arg_payout_type bigint DEFAULT NULL::bigint, arg_payout_model_id bigint DEFAULT NULL::bigint, arg_new_until timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_allow_postback_payin boolean DEFAULT false, arg_channel_ids json DEFAULT NULL::json, arg_category_ids json DEFAULT NULL::json, arg_suppression_type public.suppression DEFAULT NULL::public.suppression, arg_suppression_id text DEFAULT NULL::text, arg_suppression_external_name text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_payout numeric;
        var_channel_ids bigint[];
        var_category_ids bigint[];
        var_channel_id bigint;
        var_category_id bigint;
        var_suppression_result json;
        var_suppression_id bigint;
        var_suppression_internal_id bigint := NULL;
        var_suppression_external_id text := NULL;

    BEGIN
        SELECT default_payout FROM campaigns WHERE id = arg_id INTO var_payout;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified campaign (%).', arg_id;
        END IF;

        IF (arg_default_payout IS NOT NULL AND arg_default_payout != var_payout) THEN
            PERFORM * FROM campaign_payout_changes_create(arg_id, arg_default_payout, arg_admin_id);
        END IF;

        IF (arg_start_date > arg_expiry_date) THEN
            RAISE EXCEPTION 'Campaign expires on % before it begins on %.', arg_expiry_date, arg_start_date;
        END IF;

        UPDATE campaigns SET            
            name                = COALESCE (arg_name, name),
            advertiser_id       = COALESCE (arg_advertiser_id, advertiser_id),
            start_date          = COALESCE (arg_start_date, start_date),
            expiry_date         = arg_expiry_date,
            access_type         = COALESCE (arg_access_type, access_type),
            status              = COALESCE (arg_status::text, status),
            description         = COALESCE (arg_description, description),
            restrictions        = COALESCE (arg_restrictions, restrictions),
            default_payin       = COALESCE (arg_default_payin, default_payin),
            default_payout      = COALESCE (arg_default_payout, default_payout),
            payin_type          = COALESCE (arg_payin_type, payin_type),
            payin_model_id      = COALESCE (arg_payin_model_id, payin_model_id),
            payout_type         = COALESCE (arg_payout_type, payout_type),
            payout_model_id     = COALESCE (arg_payout_model_id, payout_model_id),
            new_until           = arg_new_until,
            allow_postback_payin = COALESCE (arg_allow_postback_payin, allow_postback_payin)
        WHERE id = arg_id;

        var_channel_ids  := json_array_convert( arg_channel_ids  )::bigint[];
        var_category_ids := json_array_convert( arg_category_ids )::bigint[];
        DELETE FROM campaign_channels WHERE campaign_id = arg_id;
        DELETE FROM campaign_categories WHERE campaign_id = arg_id;
        FOREACH var_channel_id IN ARRAY var_channel_ids LOOP
            INSERT INTO campaign_channels (campaign_id, channel_id) VALUES (arg_id, var_channel_id);
        END LOOP;
        FOREACH var_category_id IN ARRAY var_category_ids LOOP
            INSERT INTO campaign_categories (campaign_id, category_id) VALUES (arg_id, var_category_id);
        END LOOP;

        IF ((arg_suppression_type IS NOT NULL) AND (arg_suppression_id IS NOT NULL)) THEN
            DELETE FROM campaign_suppression_lists WHERE campaign_id = arg_id;
            IF (arg_suppression_type = 'internal') THEN
                var_suppression_internal_id = arg_suppression_id;
            ELSE
                var_suppression_external_id = arg_suppression_id;
            END IF;

            var_suppression_result := campaign_suppression_lists_create(arg_id, arg_suppression_type, arg_admin_id, 'active'::status_entity, var_suppression_internal_id, var_suppression_external_id, arg_suppression_external_name);
        END IF;
        IF (arg_suppression_type IS NULL) THEN
            DELETE FROM campaign_suppression_lists WHERE campaign_id = arg_id;
        END IF;

        RETURN campaign_edit_overview_get(arg_id);
    END;
$$;


ALTER FUNCTION w4api.campaign_overview_update(arg_id bigint, arg_admin_id bigint, arg_expiry_date timestamp with time zone, arg_name text, arg_advertiser_id bigint, arg_start_date timestamp with time zone, arg_access_type bigint, arg_status text, arg_description text, arg_restrictions text, arg_default_payin numeric, arg_payin_type bigint, arg_payin_model_id bigint, arg_default_payout numeric, arg_payout_type bigint, arg_payout_model_id bigint, arg_new_until timestamp with time zone, arg_allow_postback_payin boolean, arg_channel_ids json, arg_category_ids json, arg_suppression_type public.suppression, arg_suppression_id text, arg_suppression_external_name text) OWNER TO w4;

--
-- Name: campaign_payout_changes_create(bigint, numeric, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_payout_changes_create(arg_campaign_id bigint, arg_payout numeric, arg_admin_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        var_publisher_ids json;
        var_content text;
        var_campaign_name text;
        var_prev_payout numeric;
        var_messages_success boolean;

    BEGIN
        SELECT name, default_payout FROM campaigns WHERE id = arg_campaign_id INTO var_campaign_name, var_prev_payout;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified campaign (%).', arg_campaign_id;
        END IF;

        DELETE FROM campaign_payout_changes WHERE status = 'pending' AND campaign_id = arg_campaign_id;

        INSERT INTO campaign_payout_changes
            (campaign_id, payout, created_at, status, admin_id)
            VALUES (arg_campaign_id, arg_payout, CURRENT_TIMESTAMP, 'pending', arg_admin_id);

        SELECT
            array_to_json (array_agg(id))
                FROM (
                    SELECT
                            pub.id
                        FROM users pub
                        LEFT JOIN reports_daily rd ON pub.id = rd.publisher_id AND rd.campaign_id = arg_campaign_id
                        LEFT JOIN publisher_overrides po ON po.publisher_id = rd.publisher_id AND po.campaign_id = arg_campaign_id
                        WHERE pub.active = 'active' AND pub.access = 'publisher' AND po.id IS NOT NULL
                        GROUP BY pub.id
                ) AS result
        INTO var_publisher_ids;

        var_publisher_ids := '{"recipients":' || var_publisher_ids || '}';
        var_content :=  'The campaign "' || var_campaign_name || '" (' || arg_campaign_id || ') payout will change from $' || var_prev_payout || ' to $' || arg_payout || ' in 24 hours.';
        var_messages_success := messages_create (arg_admin_id, var_publisher_ids, 1, var_content, null, 1, 1);
        RETURN TRUE;
    END;
$_$;


ALTER FUNCTION w4api.campaign_payout_changes_create(arg_campaign_id bigint, arg_payout numeric, arg_admin_id bigint) OWNER TO w4;

--
-- Name: campaign_payout_changes_update(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_payout_changes_update() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_payout_id bigint;
        var_campaign_id bigint;
        var_payout numeric;

    BEGIN
        FOR var_payout_id, var_campaign_id, var_payout IN SELECT id, campaign_id, payout FROM campaign_payout_changes WHERE status = 'pending' AND created_at <= (CURRENT_TIMESTAMP - INTERVAL '1 day')  LOOP
            UPDATE campaigns SET default_payout = var_payout WHERE id = var_campaign_id;
            UPDATE campaign_payout_changes SET status = 'accepted' WHERE id = var_payout_id;
        END LOOP;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_payout_changes_update() OWNER TO w4;

--
-- Name: campaign_piggyback_pixel_create(bigint, bigint, bigint, bigint, text, public.status_entity, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_piggyback_pixel_create(arg_campaign_id bigint, arg_publisher_id bigint, arg_user_id bigint, arg_tracking_type_id bigint DEFAULT NULL::bigint, arg_code text DEFAULT NULL::text, arg_status public.status_entity DEFAULT 'active'::public.status_entity, arg_currency_id integer DEFAULT 1) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val status_entity := NULL; 
        var_id integer := NULL; 
    BEGIN
        -- CREATE PIXEL for arg_campaign_id & arg_publisher_id combo
        ---- NOTNULL to CREATE: arg_code
        ---- Default arg_tracking_type_id = postback
        IF arg_code IS NULL  THEN
          RAISE EXCEPTION 'Piggyback pixel creation failed: No URL provided.';
        END IF;
        INSERT INTO campaign_piggyback_pixels
            (campaign_id, publisher_id, code, type, status, user_id, last_updated, created)
            VALUES(
              arg_campaign_id, 
              arg_publisher_id, 
              arg_code, 
              COALESCE(arg_tracking_type_id,4),
              COALESCE(arg_status, 'active')::status_entity, 
              arg_user_id, 
              CURRENT_TIMESTAMP, 
              CURRENT_TIMESTAMP)
            RETURNING id INTO var_id; 

        RETURN  ('{' || '"new": ' || (SELECT w4api.campaign_piggyback_pixel_get_list(var_id))|| '}')::json;
    END;
  $$;


ALTER FUNCTION w4api.campaign_piggyback_pixel_create(arg_campaign_id bigint, arg_publisher_id bigint, arg_user_id bigint, arg_tracking_type_id bigint, arg_code text, arg_status public.status_entity, arg_currency_id integer) OWNER TO w4;

--
-- Name: campaign_piggyback_pixel_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_piggyback_pixel_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
   DECLARE
        ret_val json;     
    BEGIN
        PERFORM * FROM campaign_piggyback_pixels WHERE id = arg_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find piggyback pixel with id (%).', arg_id;
        END IF;
        DELETE FROM campaign_piggyback_pixels  WHERE id = arg_id;
        RETURN true;
    END;
$$;


ALTER FUNCTION w4api.campaign_piggyback_pixel_delete(arg_id bigint) OWNER TO w4;

--
-- Name: campaign_piggyback_pixel_get(bigint, bigint, bigint, integer, text, bigint, text, text, text, text, integer, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_piggyback_pixel_get(arg_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_tracking_type_id integer DEFAULT NULL::integer, arg_status text DEFAULT NULL::text, arg_user_id bigint DEFAULT NULL::bigint, arg_last_updated_max text DEFAULT NULL::text, arg_last_updated_min text DEFAULT NULL::text, arg_created_max text DEFAULT NULL::text, arg_created_min text DEFAULT NULL::text, arg_currency_id integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
      DECLARE
    ret_val json;
    var_count_json text :='';
      BEGIN         
    IF arg_count THEN
         var_count_json:= ', "count": ' || (SELECT w4api.campaign_piggyback_pixel_get_list(
           arg_id:=arg_id
          ,arg_publisher_id:=arg_publisher_id
          ,arg_campaign_id:=arg_campaign_id
          ,arg_tracking_type_id:=arg_tracking_type_id
          ,arg_status:=arg_status
          ,arg_user_id:=arg_user_id
          ,arg_currency_id:=arg_currency_id   
          ,arg_last_updated_max:=arg_last_updated_max
          ,arg_last_updated_min:=arg_last_updated_min
          ,arg_created_max:=arg_created_max
          ,arg_created_min:=arg_created_min
          ,arg_count:=true))::text;
    END IF;
    ret_val := ('{"results": ' || (SELECT w4api.campaign_piggyback_pixel_get_list(
           arg_id:=arg_id
          ,arg_publisher_id:=arg_publisher_id
          ,arg_campaign_id:=arg_campaign_id
          ,arg_tracking_type_id:=arg_tracking_type_id
          ,arg_status:=arg_status
          ,arg_user_id:=arg_user_id 
          ,arg_currency_id:=arg_currency_id   
          ,arg_last_updated_max:=arg_last_updated_max
          ,arg_last_updated_min:=arg_last_updated_min
          ,arg_created_max:=arg_created_max
          ,arg_created_min:=arg_created_min
          ,arg_orderby:=arg_orderby
          ,arg_limit:=arg_limit
          ,arg_offset:=arg_offset)) || var_count_json  || '}')::json;
  RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.campaign_piggyback_pixel_get(arg_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_tracking_type_id integer, arg_status text, arg_user_id bigint, arg_last_updated_max text, arg_last_updated_min text, arg_created_max text, arg_created_min text, arg_currency_id integer, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_piggyback_pixel_get_list(bigint, bigint, bigint, integer, text, bigint, text, text, text, text, integer, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_piggyback_pixel_get_list(arg_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_tracking_type_id integer DEFAULT NULL::integer, arg_status text DEFAULT NULL::text, arg_user_id bigint DEFAULT NULL::bigint, arg_last_updated_max text DEFAULT NULL::text, arg_last_updated_min text DEFAULT NULL::text, arg_created_max text DEFAULT NULL::text, arg_created_min text DEFAULT NULL::text, arg_currency_id integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
   ret_val json;
   where_clause text := ''; 
   order_clause text := '';

    BEGIN
    where_clause := where_clause_build (arg_id::TEXT, 'cpp.id = ' ||  arg_id, where_clause);
    where_clause := where_clause_build (arg_publisher_id::TEXT, 'cpp.publisher_id = ' ||  arg_publisher_id, where_clause);
    where_clause := where_clause_build (arg_campaign_id::TEXT, 'cpp.campaign_id = ' ||  arg_campaign_id, where_clause);
    where_clause := where_clause_build (arg_tracking_type_id::TEXT, 'cpp.type = ' ||  arg_tracking_type_id, where_clause);
    where_clause := where_clause_build (arg_status::TEXT, 'cpp.status = (''' ||  arg_status||''')::status_entity', where_clause);
    where_clause := where_clause_build (arg_user_id::TEXT, 'cpp.user_id =''' ||  arg_user_id||'''', where_clause);
    where_clause := where_clause_build (arg_currency_id::TEXT, 'c.currency_id =''' ||  arg_currency_id||'''', where_clause);
    where_clause := where_clause_build (arg_last_updated_min::TEXT, 'cpp.last_updated >= $$' || arg_last_updated_min || '$$', where_clause);
    where_clause := where_clause_build (arg_last_updated_max::TEXT, 'cpp.last_updated < $$' || arg_last_updated_max || '$$', where_clause);
    where_clause := where_clause_build (arg_created_min::TEXT, 'cpp.created >= $$' || arg_created_min || '$$', where_clause);
    where_clause := where_clause_build (arg_created_max::TEXT, 'cpp.created < $$' || arg_created_max || '$$', where_clause);
    order_clause := order_clause_build(''||arg_orderby, ' campaign_id DESC');

  IF(arg_count) THEN  
       EXECUTE
    'SELECT COALESCE (COUNT(1), 0) 
      FROM ( SELECT cpp.id FROM campaign_piggyback_pixels cpp
         LEFT JOIN campaign_tracking_type_lookup cttl ON cttl.id = cpp.type
        LEFT JOIN campaigns c ON c.id = cpp.campaign_id
        LEFT JOIN user_profiles up_pub ON up_pub.user_id = cpp.publisher_id
        LEFT JOIN user_profiles up_manager ON up_manager.user_id = cpp.user_id' 
         || where_clause ||' ) AS count' 
    INTO ret_val;     
   ELSE 
       EXECUTE
    'SELECT array_to_json (array_agg(row_to_json (results)))
        FROM (        
      SELECT row_to_json (row)
          FROM ( 
	SELECT
        cpp.id,
        cpp.campaign_id,
        c.name AS campaign_name,
        cpp.publisher_id,
        CONCAT(up_pub.first_name,'' '',up_pub.last_name) AS publisher_name,
        cpp.code,
        cpp.status,
        cpp.type AS tracking_type_id,
        cttl.tracking_type_name,
        cpp.user_id AS user_id,
        CONCAT(up_manager.first_name,'' '',up_manager.last_name) AS user_name, 
        c.currency_id,      
        cpp.last_updated,
        cpp.created
        FROM campaign_piggyback_pixels cpp
        LEFT JOIN campaign_tracking_type_lookup cttl ON cttl.id = cpp.type
        LEFT JOIN campaigns c ON c.id = cpp.campaign_id
        LEFT JOIN user_profiles up_pub ON up_pub.user_id = cpp.publisher_id
        LEFT JOIN user_profiles up_manager ON up_manager.user_id = cpp.user_id'
        	|| where_clause
		|| order_clause
		|| ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
		|| ' OFFSET ' || arg_offset || '
          ) row
      ) results'
    INTO ret_val;
  END IF;
  RETURN ret_val;
    END;
$_$;


ALTER FUNCTION w4api.campaign_piggyback_pixel_get_list(arg_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_tracking_type_id integer, arg_status text, arg_user_id bigint, arg_last_updated_max text, arg_last_updated_min text, arg_created_max text, arg_created_min text, arg_currency_id integer, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_piggyback_pixel_status_get(bigint, bigint, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_piggyback_pixel_status_get(arg_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_tracking_type_id bigint DEFAULT NULL::bigint, arg_show_err boolean DEFAULT true) RETURNS public.status_entity
    LANGUAGE plpgsql
    AS $$
  ----- Test if piggyback pixel should be active or not active
    -- campaign exists
    -- publisher exists
    -- valid tracking type
    -- campaign isn't image-pixel tracked
    -- campaign is active
    -- publisher is active
    -- if campaign is not public, publisher has been approved
    -- *** Add check for Advertiser banned-global and banned-campaign-wide publishers 
  
    DECLARE
        ret_val status_entity := NULL;
        valid_check record; 
        var_campaign_id bigint;
        var_publisher_id bigint;
        var_tracking_type_id bigint;       
    BEGIN
    if(arg_id NOTNULL)THEN
    SELECT campaign_id,publisher_id,type FROM campaign_piggyback_pixels WHERE id = arg_id INTO var_campaign_id,var_publisher_id,var_tracking_type_id;
  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'Piggyback pixel with id:% not found.', arg_campaign_id;
    ELSE
    arg_publisher_id := COALESCE(arg_publisher_id, var_publisher_id);
    arg_campaign_id := COALESCE(arg_campaign_id, var_campaign_id);
    arg_tracking_type_id := COALESCE(arg_tracking_type_id, var_tracking_type_id);
  END IF;

    END IF;

    SELECT cttl.tracking_type_name as c_ttype_name, --- CAMPAIGN: tracking_type
         cttl.id as c_ttype_id, --- CAMPAIGN: tracking_type_id
         (SELECT active FROM users WHERE id = arg_publisher_id) AS pub_chk, --- PUBLISHER: status = active/pending/suspended/disabled
         cmp.status AS cmp_chk, --- CAMPAIGN: status = active/suspended/disabled
         CASE cmp.access_type --- CAMPAIGN: status = public/by approval
      WHEN 1 THEN true  
      WHEN 3 THEN -- if by approval, check if publisher has been approved
        CASE (SELECT status FROM campaign_assigned_publishers WHERE publisher_id = arg_publisher_id AND campaign_id = arg_campaign_id)
        WHEN 'approved' THEN true
        END
      ELSE false
    END AS pub_cmp_chk
    FROM campaigns cmp
    LEFT JOIN campaign_tracking_type_lookup cttl ON cttl.id = cmp.tracking_type_id
    WHERE cmp.id =  arg_campaign_id
    INTO valid_check;   
-- Checking terminal errors:    
     --- Check that campaign exists
    IF NOT FOUND THEN 
   IF(arg_show_err) THEN
    RAISE EXCEPTION 'Campaign (id = %) not found', arg_campaign_id;
    ELSE
          ret_val = 'inactive';
          END IF;
    --- Check that publisher exists
    ELSIF valid_check.pub_chk ISNULL THEN 
   IF(arg_show_err) THEN
    RAISE EXCEPTION 'Publisher (id = %) not found', arg_publisher_id;
   ELSE
          ret_val = 'inactive';
          END IF;
    ---- Enforce no piggybacking for image tracked campaigns. 
    ELSIF (valid_check.c_ttype_id = 1) THEN 
       IF(arg_show_err) THEN
    RAISE EXCEPTION 'This campaign uses "%" tracking and therefore does not support piggyback pixels.', valid_check.c_ttype_name; 
  ELSE
  ret_val = 'inactive';
  END IF;     
    ---Checks if publishers piggyback pixel tracking type id is valid
    ELSIF arg_tracking_type_id NOTNULL THEN  
       PERFORM * FROM campaign_tracking_type_lookup WHERE id = arg_tracking_type_id;
       IF NOT FOUND THEN
    IF(arg_show_err) THEN
          RAISE EXCEPTION 'Pixel tracking type (id = %) not found.', arg_tracking_type_id;
          ELSE
          ret_val = 'inactive';
          END IF;
       END IF;
    END IF;
   IF ((valid_check.pub_chk<>'active') OR (valid_check.cmp_chk<>'active') OR (valid_check.pub_cmp_chk IS NOT TRUE)) THEN 
        ret_val = 'inactive'; 
   END IF;    

   RETURN ret_val;
    END;
  $$;


ALTER FUNCTION w4api.campaign_piggyback_pixel_status_get(arg_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_tracking_type_id bigint, arg_show_err boolean) OWNER TO w4;

--
-- Name: campaign_piggyback_pixel_update(bigint, bigint, bigint, bigint, bigint, text, public.status_entity, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_piggyback_pixel_update(arg_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_user_id bigint DEFAULT NULL::bigint, arg_tracking_type_id bigint DEFAULT NULL::bigint, arg_code text DEFAULT NULL::text, arg_status public.status_entity DEFAULT NULL::public.status_entity, arg_currency_id integer DEFAULT 1) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN     
        PERFORM * FROM campaign_piggyback_pixels WHERE id = arg_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No piggyback pixel found with id: %.', arg_id;
        END IF;

        UPDATE campaign_piggyback_pixels SET 
            publisher_id  = COALESCE(arg_publisher_id, publisher_id),
            campaign_id  = COALESCE(arg_campaign_id, campaign_id),
            code = COALESCE(arg_code, code),
            status = COALESCE(arg_status, status)::status_entity,
            user_id = arg_user_id,
            type = COALESCE(arg_tracking_type_id,type),
            last_updated = CURRENT_TIMESTAMP
        WHERE id = arg_id;

        RETURN campaign_piggyback_pixel_get_list(arg_id);
    END;
  $$;


ALTER FUNCTION w4api.campaign_piggyback_pixel_update(arg_id bigint, arg_campaign_id bigint, arg_publisher_id bigint, arg_user_id bigint, arg_tracking_type_id bigint, arg_code text, arg_status public.status_entity, arg_currency_id integer) OWNER TO w4;

--
-- Name: campaign_piggyback_pixels_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_piggyback_pixels_get(arg_campaign_id bigint, arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_ret_val json;

    BEGIN
        SELECT array_to_json (array_agg(row_to_json (results))) FROM (
            SELECT
                code,
                type
            FROM campaign_piggyback_pixels
            WHERE
                campaign_id = arg_campaign_id AND
                publisher_id = arg_publisher_id AND
                status = 'active'
        ) results
        INTO var_ret_val;

        RETURN COALESCE(var_ret_val, '{}');
    END
$$;


ALTER FUNCTION w4api.campaign_piggyback_pixels_get(arg_campaign_id bigint, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: campaign_pixels_legacy_code_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_pixels_legacy_code_get(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;
    BEGIN
        SELECT row_to_json (row) FROM (SELECT code, tracking_type_id FROM campaign_pixels_legacy WHERE campaign_id = arg_campaign_id) row INTO var_results;
        RETURN COALESCE(var_results, null);
    END
$$;


ALTER FUNCTION w4api.campaign_pixels_legacy_code_get(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: campaign_pixels_legacy_create(bigint, bigint, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_pixels_legacy_create(arg_campaign_id bigint, arg_tracking_type_id bigint, arg_code text DEFAULT NULL::text, arg_modified_by_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
        var_results json;

    BEGIN
        PERFORM * FROM campaign_pixels_legacy WHERE campaign_id = arg_campaign_id;
        IF (FOUND) THEN
            RAISE EXCEPTION 'Legacy pixel already exists for the campaign id (%).', arg_campaign_id;
        END IF;

        INSERT INTO campaign_pixels_legacy
            (campaign_id, tracking_type_id, code, modified_by_id, last_modified)
            VALUES (arg_campaign_id, arg_tracking_type_id, arg_code, arg_modified_by_id, CURRENT_TIMESTAMP)
            RETURNING id
            INTO var_id;

        SELECT row_to_json (row)
            FROM (
                SELECT
                    cpl.id AS id,
                    cpl.tracking_type_id AS tracking_type_id,
                    cpl.code AS code,
                    cpl.campaign_id AS campaign_id,
                    cpl.modified_by_id AS modified_by_id,
                    COALESCE(CONCAT(c.first_name, ' ', c.last_name), CONCAT(up.first_name, ' ', up.last_name)) AS modified_by_name,
                    cpl.last_modified AS last_modified
                FROM campaign_pixels_legacy cpl
                LEFT JOIN users u ON cpl.modified_by_id = u.id
                LEFT JOIN contacts c ON u.primary_contact_id = c.id
                LEFT JOIN user_profiles up ON u.id = up.user_id
                WHERE cpl.id = var_id
            ) row
        INTO var_results;
        RETURN var_results;
    END;
$$;


ALTER FUNCTION w4api.campaign_pixels_legacy_create(arg_campaign_id bigint, arg_tracking_type_id bigint, arg_code text, arg_modified_by_id bigint) OWNER TO w4;

--
-- Name: campaign_pixels_legacy_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_pixels_legacy_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM * FROM campaign_pixels_legacy WHERE id = arg_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No legacy pixel with the id (%).', arg_id;
        END IF;

        DELETE FROM campaign_pixels_legacy WHERE id = arg_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_pixels_legacy_delete(arg_id bigint) OWNER TO w4;

--
-- Name: campaign_pixels_legacy_get(text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_pixels_legacy_get(arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (campaign_pixels_legacy_get_count(), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || campaign_pixels_legacy_get_list(arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.campaign_pixels_legacy_get(arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_pixels_legacy_get_count(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_pixels_legacy_get_count() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
    BEGIN


        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0)
                                FROM campaign_pixels_legacy cpl
                                LEFT JOIN users u ON cpl.modified_by_id = u.id
                                LEFT JOIN contacts c ON u.primary_contact_id = c.id
                                LEFT JOIN user_profiles up ON u.id = up.user_id '
                                || where_clause ||
            ' LIMIT 1; '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.campaign_pixels_legacy_get_count() OWNER TO w4;

--
-- Name: campaign_pixels_legacy_get_list(text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_pixels_legacy_get_list(arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        order_clause TEXT;
    BEGIN

        order_clause := order_clause_build(arg_orderby, 'campaign_id asc');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    cpl.id AS id,
                                    cpl.tracking_type_id AS tracking_type_id,
                                    cpl.code AS code,
                                    cpl.campaign_id AS campaign_id,
                                    cpl.modified_by_id AS modified_by_id,
                                    COALESCE(CONCAT(c.first_name, '' '', c.last_name), CONCAT(up.first_name, '' '', up.last_name)) AS modified_by_name,
                                    cpl.last_modified AS last_modified
                                FROM campaign_pixels_legacy cpl
                                LEFT JOIN users u ON cpl.modified_by_id = u.id
                                LEFT JOIN contacts c ON u.primary_contact_id = c.id
                                LEFT JOIN user_profiles up ON u.id = up.user_id'
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' ||arg_offset || '
                            ) row
                    ) results;'
        INTO retval;
        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.campaign_pixels_legacy_get_list(arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_pixels_legacy_update(bigint, bigint, bigint, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_pixels_legacy_update(arg_id bigint, arg_campaign_id bigint, arg_tracking_type_id bigint, arg_code text DEFAULT NULL::text, arg_modified_by_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;

    BEGIN
        PERFORM id FROM campaign_pixels_legacy WHERE id = arg_id;

        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No legacy pixel with the id (%).', arg_id;
        END IF;

        UPDATE campaign_pixels_legacy SET            
            campaign_id         = COALESCE (arg_campaign_id, campaign_id),
            tracking_type_id    = COALESCE (arg_tracking_type_id, tracking_type_id),
            code                = arg_code,
            modified_by_id      = COALESCE (arg_modified_by_id, modified_by_id)
        WHERE id = arg_id;

        SELECT row_to_json (row)
            FROM (
                SELECT
                    cpl.id AS id,
                    cpl.tracking_type_id AS tracking_type_id,
                    cpl.code AS code,
                    cpl.campaign_id AS campaign_id,
                    cpl.modified_by_id AS modified_by_id,
                    COALESCE(CONCAT(c.first_name, ' ', c.last_name), CONCAT(up.first_name, ' ', up.last_name)) AS modified_by_name,
                    cpl.last_modified AS last_modified
                FROM campaign_pixels_legacy cpl
                LEFT JOIN users u ON cpl.modified_by_id = u.id
                LEFT JOIN contacts c ON u.primary_contact_id = c.id
                LEFT JOIN user_profiles up ON u.id = up.user_id
                WHERE cpl.id = arg_id
            ) row
        INTO var_results;
        RETURN var_results;
    END;
$$;


ALTER FUNCTION w4api.campaign_pixels_legacy_update(arg_id bigint, arg_campaign_id bigint, arg_tracking_type_id bigint, arg_code text, arg_modified_by_id bigint) OWNER TO w4;

--
-- Name: campaign_recommendations_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_delete(arg_recommended_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        delete_count bigint;
    BEGIN
        DELETE FROM publisher_campaign_recommendations WHERE id = arg_recommended_id;
        IF FOUND THEN
            RETURN true;
        ELSE
            RETURN false;
        END IF;
    END;
$$;


ALTER FUNCTION w4api.campaign_recommendations_delete(arg_recommended_id bigint) OWNER TO w4;

--
-- Name: campaign_recommendations_get(bigint, bigint, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_get(arg_campaign_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (campaign_recommendations_get_count(arg_campaign_id, arg_publisher_id, arg_recommended_by, arg_min_date, arg_max_date), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || campaign_recommendations_get_list(arg_campaign_id, arg_publisher_id, arg_recommended_by, arg_min_date, arg_max_date) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.campaign_recommendations_get(arg_campaign_id bigint, arg_publisher_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_recommendations_get_count(bigint, bigint, text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_get_count(arg_campaign_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'pcr.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pcr.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, 'pcr.user_id = ' || arg_recommended_by , where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM publisher_campaign_recommendations pcr
            LEFT JOIN users u ON u.id = pcr.publisher_id
            LEFT JOIN contacts con ON con.id = u.account_contact_id
            LEFT JOIN user_profiles up ON up.user_id = u.id
            LEFT JOIN users adm ON adm.id = pcr.user_id
            LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id '                                
           || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_recommendations_get_count(arg_campaign_id bigint, arg_publisher_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: campaign_recommendations_get_list(bigint, bigint, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_get_list(arg_campaign_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'pcr.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pcr.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, 'pcr.user_id = ' || arg_recommended_by , where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);

        order_clause := order_clause_build(arg_orderby, 'recommended_date DESC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    pcr.id AS recommended_id,
                                    pcr.publisher_id,
                                    pcr.campaign_id,
                                    COALESCE (up.company_name, CONCAT (con.first_name, CHR(1), con.last_name)) AS publisher_name,
                                    pcr.created_at AS recommended_date,
                                    pcr.user_id AS recommended_by_id,
                                    CONCAT (COALESCE(acon.first_name, mup.first_name), '' '', COALESCE(acon.last_name, mup.last_name)) AS recommended_by_name                                    
                                FROM publisher_campaign_recommendations pcr
                                LEFT JOIN users u ON u.id = pcr.publisher_id
                                LEFT JOIN contacts con ON con.id = u.account_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users adm ON adm.id = pcr.user_id
                                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id
                                LEFT JOIN user_profiles mup ON mup.user_id = adm.id '                                
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_recommendations_get_list(arg_campaign_id bigint, arg_publisher_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_recommendations_potential_get(bigint, bigint, text, bigint, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_potential_get(arg_campaign_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_status text DEFAULT NULL::text, arg_manager_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (campaign_recommendations_potential_get_count(arg_campaign_id, arg_publisher_id, arg_status, arg_manager_id, arg_recommended_by, arg_min_date, arg_max_date), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || campaign_recommendations_potential_get_list(arg_campaign_id, arg_publisher_id, arg_status, arg_manager_id, arg_recommended_by, arg_min_date, arg_max_date, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.campaign_recommendations_potential_get(arg_campaign_id bigint, arg_publisher_id bigint, arg_status text, arg_manager_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_recommendations_potential_get_count(bigint, bigint, text, bigint, text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_potential_get_count(arg_campaign_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_status text DEFAULT NULL::text, arg_manager_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        join_clause text := '';

    BEGIN
        where_clause := where_clause_build(arg_status::TEXT, '(CASE WHEN pcr.id IS NULL THEN $$available$$ ELSE $$recommended$$ END) = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'u.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'u.manager_id = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, 'pcr.user_id = ' || arg_recommended_by , where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build('publisher', 'u.access = $$publisher$$'  , where_clause);
        where_clause := where_clause_build('active', 'u.active = $$active$$'  , where_clause);

        IF (arg_campaign_id IS NOT NULL) THEN
            join_clause := ' AND pcr.campaign_id = ' || arg_campaign_id;
        END IF;

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0) FROM (
                    SELECT
                        u.id AS publisher_id,
                        pcr.id AS recommended_id,
                        pcr.campaign_id AS campaign_id,
                        COALESCE (up.company_name, CONCAT (ct.first_name, CHR(1), ct.last_name)) AS publisher_name,
                        pcr.created_at AS recommended_date,
                        pcr.user_id AS recommended_by_id,
                        (CASE
                            WHEN pcr.id IS NULL
                            THEN $$available$$ ELSE $$recommended$$
                        END) AS status,
                        CONCAT (COALESCE(acon.first_name, aup.first_name), '' '', COALESCE(acon.last_name, aup.last_name)) AS recommended_by_name 
                    FROM users u
                    LEFT JOIN user_profiles up ON up.user_id = u.id
                    LEFT JOIN contacts ct ON ct.id = u.account_contact_id
                    LEFT JOIN (SELECT id, campaign_id, created_at, user_id, publisher_id FROM publisher_campaign_recommendations prc WHERE campaign_id IN(SELECT DISTINCT id FROM campaigns)) pcr ON pcr.publisher_id=u.id ' || join_clause || '
                    LEFT JOIN (SELECT u.id, acon.first_name, acon.last_name FROM users u LEFT JOIN contacts acon ON acon.id = u.primary_contact_id WHERE u.access=$$admin$$) acon ON acon.id = pcr.user_id
                    LEFT JOIN user_profiles aup ON aup.user_id = pcr.user_id '
                    || where_clause || '
                ) AS the_count '
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_recommendations_potential_get_count(arg_campaign_id bigint, arg_publisher_id bigint, arg_status text, arg_manager_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: campaign_recommendations_potential_get_list(bigint, bigint, text, bigint, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_potential_get_list(arg_campaign_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_status text DEFAULT NULL::text, arg_manager_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        join_clause text := '';

    BEGIN
        where_clause := where_clause_build(arg_status::TEXT, '(CASE WHEN pcr.id IS NULL THEN $$available$$ ELSE $$recommended$$ END) = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'u.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'u.manager_id = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, 'pcr.user_id = ' || arg_recommended_by , where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build('publisher', 'u.access = $$publisher$$'  , where_clause);
        where_clause := where_clause_build('active', 'u.active = $$active$$'  , where_clause);

        order_clause := order_clause_build(arg_orderby, 'publisher_name ASC');
        
        IF (arg_campaign_id IS NOT NULL) THEN
            join_clause := ' AND pcr.campaign_id = ' || arg_campaign_id;
        END IF;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    u.id AS publisher_id,
                                    pcr.id AS recommended_id,
                                    pcr.campaign_id AS campaign_id,
                                    COALESCE (up.company_name, CONCAT (ct.first_name, CHR(1), ct.last_name)) AS publisher_name,
                                    pcr.created_at AS recommended_date,
                                    pcr.user_id AS recommended_by_id,
                                    (CASE
                                        WHEN pcr.id IS NULL
                                        THEN $$available$$ ELSE $$recommended$$
                                    END) AS status,
                                    CONCAT (COALESCE(acon.first_name, aup.first_name), '' '', COALESCE(acon.last_name, aup.last_name)) AS recommended_by_name 
                                FROM users u
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN contacts ct ON ct.id = u.account_contact_id
                                LEFT JOIN (SELECT id, campaign_id, created_at, user_id, publisher_id FROM publisher_campaign_recommendations prc WHERE campaign_id IN(SELECT DISTINCT id FROM campaigns)) pcr ON pcr.publisher_id=u.id ' || join_clause || '
                                LEFT JOIN (SELECT u.id, acon.first_name, acon.last_name FROM users u LEFT JOIN contacts acon ON acon.id = u.primary_contact_id WHERE u.access=$$admin$$) acon ON acon.id = pcr.user_id
                                LEFT JOIN user_profiles aup ON aup.user_id = pcr.user_id '
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_recommendations_potential_get_list(arg_campaign_id bigint, arg_publisher_id bigint, arg_status text, arg_manager_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_recommendations_potential_update(json, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_potential_update(arg_changes json, arg_admin_id bigint, arg_orderby text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        pub_id bigint;
        cam_id bigint;
        recommended boolean;
        ret_val json;
        pcr_id bigint;
        pcr_ids bigint[];
        delete_ids bigint[];
        ret_str text;        

    BEGIN
        FOR pub_id, cam_id, recommended IN SELECT * FROM json_populate_recordset(NULL::campaign_recommendation,arg_changes->'changes') LOOP
            IF recommended::boolean THEN
		SELECT id FROM publisher_campaign_recommendations WHERE publisher_id = pub_id AND campaign_id = cam_id INTO pcr_id;
		IF(NOT FOUND) THEN
		    INSERT INTO publisher_campaign_recommendations
			(publisher_id, campaign_id, user_id, created_at, updated_at)
			VALUES (pub_id, cam_id, arg_admin_id, NOW(), NOW())
			RETURNING id
			INTO pcr_id; 
				   
		END IF;
		pcr_ids = array_append(pcr_ids, pcr_id);
            ELSE
		SELECT id FROM publisher_campaign_recommendations WHERE publisher_id = pub_id AND campaign_id = cam_id INTO pcr_id;
		IF(FOUND) THEN
		delete_ids = array_append(delete_ids, pcr_id);
		END IF;
            END IF;               
        END LOOP;
        
        ret_str := '{';
        IF array_length(delete_ids, 1) > 0 THEN
            ret_str := ret_str || '"available": ';
            ret_str := ret_str ||  campaign_recommendations_update_get_list(delete_ids, true, arg_orderby);
            FOREACH pcr_id IN ARRAY delete_ids LOOP
                DELETE FROM publisher_campaign_recommendations WHERE id = pcr_id;
            END LOOP;
        END IF;

        IF array_length(pcr_ids, 1) > 0 THEN
            IF array_length(delete_ids, 1) > 0 THEN
                ret_str := ret_str || ', ';
            END IF;
            ret_str := ret_str || '"recommended": ';
            ret_str := ret_str || campaign_recommendations_update_get_list(pcr_ids, false, arg_orderby);
        END IF;
        ret_val := (ret_str || '}')::json;

        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.campaign_recommendations_potential_update(arg_changes json, arg_admin_id bigint, arg_orderby text) OWNER TO w4;

--
-- Name: campaign_recommendations_update_get_list(bigint[], boolean, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_recommendations_update_get_list(arg_recommended_ids bigint[], arg_delete boolean DEFAULT NULL::boolean, arg_orderby text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        recommended_id bigint;
        where_clause text := '';
        status_clause text := 'WHEN pcr.id IS NULL';
        order_clause text := '';
    BEGIN
	order_clause := order_clause_build(arg_orderby, 'pcr.updated_at DESC');
        FOREACH recommended_id IN ARRAY arg_recommended_ids LOOP
            IF where_clause != '' THEN
                where_clause := where_clause || ' OR ';
            ELSE
                where_clause := ' WHERE ';
            END IF;
            where_clause := where_clause || 'pcr.id = ' || recommended_id;            
        END LOOP;

        IF (arg_delete IS NOT NULL) THEN
            status_clause := 'WHEN ' || arg_delete;
        END IF;

        IF (where_clause IS NULL) THEN
            where_clause := ' ';
        END IF;

         
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    max(pcr.publisher_id) AS publisher_id,
                                    max(pcr.campaign_id) as campaign_id,
                                    MAX(pcr.id) AS recommended_id,
                                    COALESCE (MAX(up.company_name), CONCAT (MAX(con.first_name), CHR(1), MAX(con.last_name))) AS publisher_name,
                                    MAX(pcr.created_at) AS recommended_date,
                                    MAX(pcr.user_id) AS recommended_by_id,
                                    (CASE
                                   ' || status_clause || '
                                        THEN $$available$$ ELSE $$recommended$$
                                    END) AS status,
                                    CONCAT (COALESCE(MAX(acon.first_name), MAX(aup.first_name)), '' '', COALESCE(MAX(acon.last_name), MAX(aup.last_name))) AS recommended_by_name                                    
                                FROM users u
                                LEFT JOIN publisher_campaign_recommendations pcr ON u.id = pcr.publisher_id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users adm ON adm.id = pcr.user_id
                                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id
                                LEFT JOIN user_profiles aup ON aup.user_id = adm.id                            
                                '|| where_clause ||'
                                 GROUP BY pcr.id 
                                 '|| order_clause ||'
                                
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_recommendations_update_get_list(arg_recommended_ids bigint[], arg_delete boolean, arg_orderby text) OWNER TO w4;

--
-- Name: campaign_suppression_lists_create(bigint, public.suppression, bigint, public.status_entity, bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_suppression_lists_create(arg_campaign_id bigint, arg_type public.suppression, arg_manager_id bigint DEFAULT NULL::bigint, arg_status public.status_entity DEFAULT 'active'::public.status_entity, arg_internal_id bigint DEFAULT NULL::bigint, arg_external_id text DEFAULT NULL::text, arg_external_name text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_new_id bigint;
        var_suppression_lists_id bigint;

    BEGIN
        IF (arg_internal_id IS NULL) AND (arg_external_id IS NULL) THEN
            RAISE EXCEPTION 'Must have an external or internal id.';
        END IF;

        IF (arg_type = 'internal') THEN
            PERFORM * FROM suppression_upload_files WHERE id = arg_internal_id AND status = 'active';
            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Internal suppression id does not match any active internal suppression list id.';
            END IF;
        END IF;

        INSERT INTO campaign_suppression_lists
            (campaign_id, list_type, suppression_lists_id, external_id, external_name, modified_by, modified_date, status)
            VALUES (arg_campaign_id, arg_type, arg_internal_id, arg_external_id, arg_external_name, arg_manager_id, CURRENT_TIMESTAMP, arg_status)
            RETURNING id
            INTO var_new_id;
        RETURN campaign_suppression_lists_create_get(var_new_id);
    END;
$$;


ALTER FUNCTION w4api.campaign_suppression_lists_create(arg_campaign_id bigint, arg_type public.suppression, arg_manager_id bigint, arg_status public.status_entity, arg_internal_id bigint, arg_external_id text, arg_external_name text) OWNER TO w4;

--
-- Name: campaign_suppression_lists_create_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_suppression_lists_create_get(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';

    BEGIN
        where_clause := where_clause_build(arg_id::TEXT, 'csl.id = ' || arg_id, where_clause);

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    csl.id AS id,
                                    COALESCE(csl.external_id, suf.id::text) AS list_id,
                                    csl.status AS status,
                                    COALESCE(csl.external_name, suf.list_name) AS list_name,
                                    csl.modified_by AS modified_by_id,
                                    COALESCE(CONCAT(c.first_name, '' '', c.last_name), CONCAT(up.first_name, '' '', up.last_name)) AS modified_by,
                                    csl.modified_date AS modified_date,
                                    csl.list_type AS list_type
                                FROM campaign_suppression_lists csl
                                LEFT JOIN suppression_upload_files suf ON csl.suppression_lists_id = suf.id
                                LEFT JOIN users u ON csl.modified_by = u.id
                                LEFT JOIN contacts c ON u.primary_contact_id = c.id
                                LEFT JOIN user_profiles up ON u.id = up.user_id'
                                || where_clause || '
                            ) row
                    ) results;'
        INTO retval;
        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.campaign_suppression_lists_create_get(arg_id bigint) OWNER TO w4;

--
-- Name: campaign_suppression_lists_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_suppression_lists_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM * FROM campaign_suppression_lists WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the campaign suppression list with id (%).', arg_id;
        END IF;

        DELETE FROM campaign_suppression_lists WHERE id = arg_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.campaign_suppression_lists_delete(arg_id bigint) OWNER TO w4;

--
-- Name: campaign_suppression_lists_get(bigint, bigint, bigint, public.status_entity, public.suppression, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_suppression_lists_get(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_manager_id bigint DEFAULT NULL::bigint, arg_status public.status_entity DEFAULT NULL::public.status_entity, arg_type public.suppression DEFAULT NULL::public.suppression, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        summary json;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (campaign_suppression_lists_get_count(arg_advertiser_id, arg_campaign_id, arg_manager_id, arg_status, arg_type, arg_min_date, arg_max_date), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || campaign_suppression_lists_get_list(arg_advertiser_id, arg_campaign_id, arg_manager_id, arg_status, arg_type, arg_min_date, arg_max_date, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.campaign_suppression_lists_get(arg_advertiser_id bigint, arg_campaign_id bigint, arg_manager_id bigint, arg_status public.status_entity, arg_type public.suppression, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: campaign_suppression_lists_get_count(bigint, bigint, bigint, public.status_entity, public.suppression, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_suppression_lists_get_count(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_manager_id bigint DEFAULT NULL::bigint, arg_status public.status_entity DEFAULT NULL::public.status_entity, arg_type public.suppression DEFAULT NULL::public.suppression, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'c.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'csl.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'csl.modified_date >= ' || arg_min_date, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'csl.modified_date < ' || arg_max_date, where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'csl.modified_by = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'csl.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_type::TEXT, 'csl.type = $$' || arg_type || '$$', where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    csl.id AS id,
                    csl.campaign_id AS campaign_id,
                    c.advertiser_id AS advertiser_id,
                    COALESCE(csl.external_id, sul.id::text) AS list_id,
                    csl.status AS status,
                    COALESCE(csl.external_name, sul.list_name) AS list_name,
                    csl.modified_by AS modified_by_id,
                    COALESCE(CONCAT(con.first_name, '' '', con.last_name), CONCAT(up.first_name, '' '', up.last_name)) AS modified_by,
                    csl.modified_date AS modified_date,
                    csl.list_type AS list_type
                FROM campaign_suppression_lists csl
                LEFT JOIN campaigns c ON csl.campaign_id = c.id
                LEFT JOIN suppression_upload_files sul ON csl.suppression_lists_id = sul.id
                LEFT JOIN users u ON csl.modified_by = u.id
                LEFT JOIN contacts con ON u.primary_contact_id = con.id
                LEFT JOIN user_profiles up ON u.id = up.user_id'
                || where_clause || '
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.campaign_suppression_lists_get_count(arg_advertiser_id bigint, arg_campaign_id bigint, arg_manager_id bigint, arg_status public.status_entity, arg_type public.suppression, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: campaign_suppression_lists_get_list(bigint, bigint, bigint, public.status_entity, public.suppression, timestamp with time zone, timestamp with time zone, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_suppression_lists_get_list(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_manager_id bigint DEFAULT NULL::bigint, arg_status public.status_entity DEFAULT NULL::public.status_entity, arg_type public.suppression DEFAULT NULL::public.suppression, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        order_clause TEXT;

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'c.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'csl.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'csl.modified_date >= ' || arg_min_date, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'csl.modified_date < ' || arg_max_date, where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'csl.modified_by = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'csl.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_type::TEXT, 'csl.type = $$' || arg_type || '$$', where_clause);

        order_clause := order_clause_build(arg_orderby, 'csl.modified_date DESC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    csl.id AS id,
                                    csl.campaign_id AS campaign_id,
                                    c.advertiser_id AS advertiser_id,
                                    COALESCE(csl.external_id, sul.id::text) AS list_id,
                                    csl.status AS status,
                                    COALESCE(csl.external_name, sul.list_name) AS list_name,
                                    csl.modified_by AS modified_by_id,
                                    COALESCE(CONCAT(con.first_name, '' '', con.last_name), CONCAT(up.first_name, '' '', up.last_name)) AS modified_by,
                                    csl.modified_date AS modified_date,
                                    csl.list_type AS list_type
                                FROM campaign_suppression_lists csl
                                LEFT JOIN campaigns c ON csl.campaign_id = c.id
                                LEFT JOIN suppression_upload_files sul ON csl.suppression_lists_id = sul.id
                                LEFT JOIN users u ON csl.modified_by = u.id
                                LEFT JOIN contacts con ON u.primary_contact_id = con.id
                                LEFT JOIN user_profiles up ON u.id = up.user_id'
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' ||arg_offset || '
                            ) row
                    ) results;'
        INTO retval;
        RETURN retval;
    END
$_$;


ALTER FUNCTION w4api.campaign_suppression_lists_get_list(arg_advertiser_id bigint, arg_campaign_id bigint, arg_manager_id bigint, arg_status public.status_entity, arg_type public.suppression, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_suppression_lists_update_get_list(bigint[]); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_suppression_lists_update_get_list(arg_conversion_ids bigint[]) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
	ret_val json;
        conversion_id bigint;
        where_clause text := '';

    BEGIN
        FOREACH conversion_id IN ARRAY arg_conversion_ids LOOP
            IF where_clause != '' THEN
                where_clause := where_clause || ' OR ';
            ELSE
                where_clause := ' WHERE ';
            END IF;
            where_clause := where_clause || 'con.id = ' || conversion_id;            
        END LOOP;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    con.id AS conversion_id, 
                                    con.campaign_id, 
                                    cmp.advertiser_id, 
                                    con.publisher_id,
                                    con.click_id, 
                                    COALESCE(usp.company_name, pg_catalog.concat(usp.first_name, CHR(1), usp.last_name)::character varying, CHR(1)::character varying) AS publisher_name, 
                                    con.created_date AS click_date, 
                                    host(con.ip_address)::character(15) AS ip_address, 
                                    con.referral_url, 
                                    COALESCE(NULLIF((uapl.platform_name::text || CHR(1)::text) || uapl.platform_version::text, CHR(1)::text), $$Unknown$$::text) AS os, 
                                    COALESCE(NULLIF((uabl.browser_name::text || CHR(1)::text) || uabl.browser_version::text, CHR(1)::text), $$Unknown$$::text) AS browser, 
                                    COALESCE(
                                        CASE
                                            WHEN con.status < 50 THEN con.payin
                                            ELSE 0::money
                                        END, 0::money)::numeric AS pay_in_amt, 
                                    COALESCE(
                                        CASE
                                            WHEN con.status < 50 THEN con.payout
                                            ELSE 0::money
                                        END, 0::money)::numeric AS pay_out_amt, 
                                        CASE
                                            WHEN con.status < 50 THEN $$approved$$::text
                                            WHEN con.status >= 50 THEN $$rejected$$::text
                                            ELSE $$null$$::text
                                        END AS status,
                                    cmp.currency_id
                                FROM engine_conversions con
                                LEFT JOIN campaigns cmp ON (con.campaign_id = cmp.id)
                                LEFT JOIN users usr ON (con.publisher_id = usr.id)
                                LEFT JOIN user_profiles usp ON (usr.id = usp.user_id)
                                LEFT JOIN user_agent_browser_lookup uabl ON (con.browser_id = uabl.id)
                                LEFT JOIN user_agent_platform_lookup uapl ON (con.platform_id = uapl.id) '
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.campaign_suppression_lists_update_get_list(arg_conversion_ids bigint[]) OWNER TO w4;

--
-- Name: campaign_tracking_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_tracking_get(arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
	ret_val json;
    BEGIN
	SELECT row_to_json (row)
                            FROM (                                
                                SELECT
                                    cmp.cookie_duration_time,
				    cmp.cookie_duration_unit,
				    initcap((SELECT duration_name from duration_type_lookup where id = cmp.cookie_duration_unit)||'s') AS cookie_duration_unit_description, 
                                    cmp.tracking_type_id, 
                                    (SELECT tracking_type_name from campaign_tracking_type_lookup where id = cmp.tracking_type_id) AS tracking_type_description,                                    
			  	     cmp.tracking_secure::boolean
				FROM campaigns cmp  WHERE cmp.id=arg_campaign_id          
			) row  INTO ret_val;
        RETURN COALESCE(ret_val, '{}');
    END
$$;


ALTER FUNCTION w4api.campaign_tracking_get(arg_campaign_id bigint) OWNER TO w4;

--
-- Name: campaign_tracking_update(bigint, boolean, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_tracking_update(arg_campaign_id bigint, arg_tracking_secure boolean DEFAULT NULL::boolean, arg_tracking_type_id bigint DEFAULT NULL::bigint, arg_tracking_type text DEFAULT NULL::text, arg_cookie_duration_unit bigint DEFAULT NULL::bigint, arg_cookie_duration_time bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM campaigns WHERE id = arg_campaign_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified campaign (%).', arg_campaign_id;
        END IF;
        IF (arg_tracking_type NOTNULL) THEN --If tracking type name sent in, find id.
		SELECT id from campaign_tracking_type_lookup WHERE tracking_type_name = arg_tracking_type INTO arg_tracking_type_id;
		IF NOT FOUND THEN  --- If not found initially, clean up to the string and try again
			SELECT id from campaign_tracking_type_lookup WHERE lower(regexp_replace(tracking_type_name, E'[^A-Za-z]','', 'g')) = lower(regexp_replace(arg_tracking_type, E'[^A-Za-z]','', 'g')) INTO arg_tracking_type_id;
		END IF;
        END IF;
        UPDATE campaigns SET            
            tracking_secure =  COALESCE(arg_tracking_secure,tracking_secure::boolean),
            tracking_type_id = COALESCE(arg_tracking_type_id, tracking_type_id),
            tracking_type = COALESCE((SELECT tracking_type_name from campaign_tracking_type_lookup WHERE id = arg_tracking_type_id), tracking_type),
            cookie_duration_unit = COALESCE (arg_cookie_duration_unit, cookie_duration_unit),
            cookie_duration_time = COALESCE (arg_cookie_duration_time, cookie_duration_time)
        WHERE id = arg_campaign_id;
        RETURN campaign_tracking_get(arg_campaign_id);
    END;
$$;


ALTER FUNCTION w4api.campaign_tracking_update(arg_campaign_id bigint, arg_tracking_secure boolean, arg_tracking_type_id bigint, arg_tracking_type text, arg_cookie_duration_unit bigint, arg_cookie_duration_time bigint) OWNER TO w4;

--
-- Name: campaign_traffic_get(text, text, json, json, timestamp with time zone, timestamp with time zone, money, money, bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, boolean, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_traffic_get(arg_status text DEFAULT NULL::text, arg_search_advertiser text DEFAULT NULL::text, arg_category_ids json DEFAULT NULL::json, arg_channel_ids json DEFAULT NULL::json, arg_expires_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_expires_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_pepc_min money DEFAULT NULL::money, arg_pepc_max money DEFAULT NULL::money, arg_unique_clicks_min bigint DEFAULT NULL::bigint, arg_unique_clicks_max bigint DEFAULT NULL::bigint, arg_conversions_min bigint DEFAULT NULL::bigint, arg_conversions_max bigint DEFAULT NULL::bigint, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_search_campaign text DEFAULT NULL::text, arg_campaign_id bigint DEFAULT NULL::bigint, arg_new boolean DEFAULT NULL::boolean, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT NULL::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            retval json;
            count_total bigint;
            summary json;

            var_count text := '';
            var_summary text := '';
            
	BEGIN

            IF arg_count THEN
		var_count := ',"count": ' || campaign_traffic_get_count
		(
			arg_status,
			arg_search_advertiser,
			arg_category_ids,
			arg_channel_ids,
			arg_expires_min_date,
			arg_expires_max_date,
			arg_pepc_min,
			arg_pepc_max,

			arg_unique_clicks_min,
			arg_unique_clicks_max,

			arg_conversions_min,
			arg_conversions_max,
			arg_conversion_percent_min,
			arg_conversion_percent_max,
			arg_profit_percent_min,
			arg_profit_percent_max,

			arg_min_date,
			arg_max_date,

			arg_search_campaign,
			arg_campaign_id,
			arg_new,

			arg_currency_id
		);
            END IF;
            
            IF arg_summary THEN
		var_summary := ',"summary": ' || campaign_traffic_get_summary
		(
			arg_status,
			arg_search_advertiser,
			arg_category_ids,
			arg_channel_ids,
			arg_expires_min_date,
			arg_expires_max_date,
			arg_pepc_min,
			arg_pepc_max,

			arg_unique_clicks_min,
			arg_unique_clicks_max,

			arg_conversions_min,
			arg_conversions_max,
			arg_conversion_percent_min,
			arg_conversion_percent_max,
			arg_profit_percent_min,
			arg_profit_percent_max,

			arg_min_date,
			arg_max_date,

			arg_search_campaign,
			arg_campaign_id,
			arg_new,

			arg_currency_id
		);
            END IF;

            RETURN
            (
		'{' || 
                            '"results": ' || campaign_traffic_get_list
                            (
				arg_status,
				arg_search_advertiser,
				arg_category_ids,
				arg_channel_ids,
				arg_expires_min_date,
				arg_expires_max_date,
				arg_pepc_min,
				arg_pepc_max,

				arg_unique_clicks_min,
				arg_unique_clicks_max,

				arg_conversions_min,
				arg_conversions_max,
				arg_conversion_percent_min,
				arg_conversion_percent_max,
				arg_profit_percent_min,
				arg_profit_percent_max,

				arg_min_date,
				arg_max_date,

				arg_search_campaign,
				arg_campaign_id,
				arg_new,

				arg_currency_id,
				arg_orderby,
				arg_limit,
				arg_offset
                            ) ||
                            var_summary ||
                            var_count   ||
		'}'
            )::json;

      END
$$;


ALTER FUNCTION w4api.campaign_traffic_get(arg_status text, arg_search_advertiser text, arg_category_ids json, arg_channel_ids json, arg_expires_min_date timestamp with time zone, arg_expires_max_date timestamp with time zone, arg_pepc_min money, arg_pepc_max money, arg_unique_clicks_min bigint, arg_unique_clicks_max bigint, arg_conversions_min bigint, arg_conversions_max bigint, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_search_campaign text, arg_campaign_id bigint, arg_new boolean, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: campaign_traffic_get_count(text, text, json, json, timestamp with time zone, timestamp with time zone, money, money, bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, boolean, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_traffic_get_count(arg_status text DEFAULT NULL::text, arg_search_advertiser text DEFAULT NULL::text, arg_category_ids json DEFAULT NULL::json, arg_channel_ids json DEFAULT NULL::json, arg_expires_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_expires_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_pepc_min money DEFAULT NULL::money, arg_pepc_max money DEFAULT NULL::money, arg_unique_clicks_min bigint DEFAULT NULL::bigint, arg_unique_clicks_max bigint DEFAULT NULL::bigint, arg_conversions_min bigint DEFAULT NULL::bigint, arg_conversions_max bigint DEFAULT NULL::bigint, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_search_campaign text DEFAULT NULL::text, arg_campaign_id bigint DEFAULT NULL::bigint, arg_new boolean DEFAULT NULL::boolean, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE

	retval json;
	var_category_ids bigint[];
	var_channel_ids bigint[];

    BEGIN

	IF arg_channel_ids IS NOT NULL THEN
		var_channel_ids := json_array_convert( arg_channel_ids )::bigint[];
	END IF;

	IF arg_category_ids IS NOT NULL THEN
		var_category_ids := json_array_convert( arg_category_ids )::bigint[];
	END IF;
	
	RETURN COUNT(1) FROM
	(
		SELECT
			1

		FROM campaigns c
		LEFT JOIN advertisers a ON c.advertiser_id = a.id
		LEFT JOIN reports_daily rd ON rd.campaign_id = c.id AND -- ugh has to go here or campaign dropped if no traffic in date range
			( arg_min_date IS NULL OR rd.doy IS NULL OR rd.doy >= make_doy( arg_min_date ) ) AND
			( arg_max_date IS NULL OR rd.doy IS NULL OR rd.doy <  make_doy( arg_max_date ) )
		LEFT JOIN vw_campaign_categories_json cca ON cca.campaign_id = c.id
		LEFT JOIN vw_campaign_channels_json   cch ON cch.campaign_id = c.id
		WHERE
			( arg_currency_id IS NULL            OR c.currency_id = arg_currency_id ) AND
			( arg_campaign_id IS NULL            OR c.id = arg_campaign_id ) AND
			( arg_status IS NULL                 OR c.status = arg_status ) AND
			( arg_search_advertiser IS NULL      OR a.id::text = arg_search_advertiser ) AND
			( arg_search_campaign IS NULL        OR c.id::text = arg_search_campaign ) AND
			( var_category_ids IS NULL           OR cca.category_ids @> var_category_ids ) AND
			( var_channel_ids IS NULL            OR cch.channel_ids  @> var_channel_ids ) AND
			( arg_expires_min_date IS NULL       OR c.expiry_date >= arg_expires_min_date ) AND
			( arg_expires_max_date IS NULL       OR c.expiry_date <  arg_expires_max_date ) AND
			( arg_new IS NULL                    OR ( arg_new = TRUE  AND NOW() <  COALESCE( c.new_until, '-infinity'::timestamptz ) )
			                                     OR ( arg_new = FALSE AND NOW() >= COALESCE( c.new_until, '-infinity'::timestamptz ) ) ) AND
                        ( rd.total_conversions > 0 OR rd.total_clicks > 0 )

		GROUP BY
			c.id, c.name, c.advertiser_id, a.name, cca.category_ids, cch.channel_ids

		HAVING
			( arg_pepc_min IS NULL               OR COALESCE( SUM( rd.total_pay_out ) / NULLIF( SUM( rd.unique_clicks ), 0 ), 0 )::money >= arg_pepc_min ) AND
			( arg_pepc_max IS NULL               OR COALESCE( SUM( rd.total_pay_out ) / NULLIF( SUM( rd.unique_clicks ), 0 ), 0 )::money  < arg_pepc_max ) AND
			( arg_unique_clicks_min IS NULL      OR COALESCE( SUM( rd.unique_clicks ), 0 ) >= arg_unique_clicks_min ) AND
			( arg_unique_clicks_max IS NULL      OR COALESCE( SUM( rd.unique_clicks ), 0 ) <  arg_unique_clicks_max ) AND
			( arg_conversions_min IS NULL        OR COALESCE( SUM( rd.total_conversions ), 0 ) >= arg_conversions_min ) AND
			( arg_conversions_max IS NULL        OR COALESCE( SUM( rd.total_conversions ), 0 ) <  arg_conversions_max ) AND
			( arg_conversion_percent_min IS NULL OR COALESCE( SUM( rd.total_conversions ) / NULLIF( SUM( rd.unique_clicks ), 0 ) * 100, 0 ) >= arg_conversion_percent_min ) AND
			( arg_conversion_percent_max IS NULL OR COALESCE( SUM( rd.total_conversions ) / NULLIF( SUM( rd.unique_clicks ), 0 ) * 100, 0 ) <  arg_conversion_percent_max ) AND
			( arg_profit_percent_min IS NULL     OR COALESCE( 100 - SUM( rd.total_pay_out ) / NULLIF( SUM( rd.total_pay_in ), 0 ) * 100, 0 ) >= arg_profit_percent_min ) AND
			( arg_profit_percent_max IS NULL     OR COALESCE( 100 - SUM( rd.total_pay_out ) / NULLIF( SUM( rd.total_pay_in ), 0 ) * 100, 0 ) <  arg_profit_percent_max )
			
	) r;
	
    END
$$;


ALTER FUNCTION w4api.campaign_traffic_get_count(arg_status text, arg_search_advertiser text, arg_category_ids json, arg_channel_ids json, arg_expires_min_date timestamp with time zone, arg_expires_max_date timestamp with time zone, arg_pepc_min money, arg_pepc_max money, arg_unique_clicks_min bigint, arg_unique_clicks_max bigint, arg_conversions_min bigint, arg_conversions_max bigint, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_search_campaign text, arg_campaign_id bigint, arg_new boolean, arg_currency_id bigint) OWNER TO w4;

--
-- Name: campaign_traffic_get_list(text, text, json, json, timestamp with time zone, timestamp with time zone, money, money, bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, boolean, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_traffic_get_list(arg_status text DEFAULT NULL::text, arg_search_advertiser text DEFAULT NULL::text, arg_category_ids json DEFAULT NULL::json, arg_channel_ids json DEFAULT NULL::json, arg_expires_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_expires_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_pepc_min money DEFAULT NULL::money, arg_pepc_max money DEFAULT NULL::money, arg_unique_clicks_min bigint DEFAULT NULL::bigint, arg_unique_clicks_max bigint DEFAULT NULL::bigint, arg_conversions_min bigint DEFAULT NULL::bigint, arg_conversions_max bigint DEFAULT NULL::bigint, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_search_campaign text DEFAULT NULL::text, arg_campaign_id bigint DEFAULT NULL::bigint, arg_new boolean DEFAULT NULL::boolean, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE

	retval json;
	var_category_ids bigint[];
	var_channel_ids bigint[];

    BEGIN

	IF arg_channel_ids IS NOT NULL THEN
		var_channel_ids := json_array_convert( arg_channel_ids )::bigint[];
	END IF;

	IF arg_category_ids IS NOT NULL THEN
		var_category_ids := json_array_convert( arg_category_ids )::bigint[];
	END IF;
	
        arg_orderby := orderby( COALESCE( arg_orderby, 'campaign_id DESC' ) );
	
	EXECUTE 'SELECT array_to_json( array_agg( row_to_json( r.* ) ) ) FROM
		(
			SELECT
				r.*
			FROM
			(
				SELECT
					c.status                    AS campaign_status,
					c.id                        AS campaign_id,
					c.name                      AS campaign_name,
					c.advertiser_id             AS advertiser_id,
					a.name                      AS advertiser_name,
					COALESCE( SUM( rd.unique_clicks ), 0 )     AS unique_clicks,
					COALESCE( SUM( rd.total_clicks ), 0 )     AS total_clicks,
					COALESCE( SUM( rd.total_conversions ), 0 ) AS conversions,
					ROUND(COALESCE( SUM( rd.total_conversions ) / NULLIF( SUM( rd.unique_clicks ), 0 ), 0 )::numeric, 4) AS conversion_percent,
					COALESCE( SUM( rd.total_pay_out ) / NULLIF( SUM( rd.unique_clicks ), 0 ), 0 ) AS pepc,
					COALESCE( SUM( rd.total_pay_in ), 0 )      AS total_in,
					COALESCE( SUM( rd.total_pay_out ), 0 )     AS total_out,
					ROUND(COALESCE( 1 - SUM( rd.total_pay_out ) / NULLIF( SUM( rd.total_pay_in ), 0 ), 0 )::numeric, 4) AS profit_percent,
					c.expiry_date AS expires,
					COUNT( cc.id ) > 0 AS has_cap,
					COALESCE( MAX( cca.category_names_json::text ), ''[]'' )::json AS category_names,
					COALESCE( MAX( cch.channel_names_json::text ), ''[]'' )::json  AS channel_names
					
				FROM campaigns c
				LEFT JOIN advertisers a ON c.advertiser_id = a.id
				LEFT JOIN reports_daily rd ON rd.campaign_id = c.id AND
					( $10 IS NULL OR rd.doy IS NULL OR rd.doy >= make_doy( $10 ) ) AND
					( $11 IS NULL OR rd.doy IS NULL OR rd.doy <  make_doy( $11 ) )
				LEFT JOIN campaign_caps cc ON cc.campaign_id = c.id
				LEFT JOIN vw_campaign_categories_json cca ON cca.campaign_id = c.id
				LEFT JOIN vw_campaign_channels_json   cch ON cch.campaign_id = c.id
				WHERE
					(  $1 IS NULL OR c.currency_id = $1 ) AND
					(  $2 IS NULL OR c.id = $2 ) AND
					(  $3 IS NULL OR c.status = $3 ) AND
					(  $4 IS NULL OR a.id::text = $4 ) AND
					(  $5 IS NULL OR c.id::text = $5 ) AND
					(  $8 IS NULL OR c.expiry_date >= $8 ) AND
					(  $9 IS NULL OR c.expiry_date <  $9 ) AND
					( $22 IS NULL OR ( $22 = TRUE  AND NOW() <  COALESCE( c.new_until, ''-infinity''::timestamptz ) ) 
					              OR ( $22 = FALSE AND NOW() >= COALESCE( c.new_until, ''-infinity''::timestamptz ) ) ) AND
                                        ( rd.total_conversions > 0 OR rd.total_clicks > 0 )

				GROUP BY
					c.id, c.name, c.advertiser_id, a.name, cca.category_ids, cch.channel_ids

				HAVING
					(  $6 IS NULL OR cca.category_ids @> $6 ) AND
					(  $7 IS NULL OR cch.channel_ids  @> $7 ) AND
					( $12 IS NULL OR COALESCE( SUM( rd.total_pay_out ) / NULLIF( SUM( rd.unique_clicks ), 0 ), 0 )::money >= $12 ) AND
					( $13 IS NULL OR COALESCE( SUM( rd.total_pay_out ) / NULLIF( SUM( rd.unique_clicks ), 0 ), 0 )::money  < $13 ) AND
					( $14 IS NULL OR COALESCE( SUM( rd.unique_clicks ), 0 ) >= $14 ) AND
					( $15 IS NULL OR COALESCE( SUM( rd.unique_clicks ), 0 ) <  $15 ) AND
					( $16 IS NULL OR COALESCE( SUM( rd.total_conversions ), 0 ) >= $16 ) AND
					( $17 IS NULL OR COALESCE( SUM( rd.total_conversions ), 0 ) <  $17 ) AND
					( $18 IS NULL OR COALESCE( SUM( rd.total_conversions ) / NULLIF( SUM( rd.unique_clicks ), 0 ) * 100, 0 ) >= $18 ) AND
					( $19 IS NULL OR COALESCE( SUM( rd.total_conversions ) / NULLIF( SUM( rd.unique_clicks ), 0 ) * 100, 0 ) <  $19 ) AND
					( $20 IS NULL OR COALESCE( 100 - SUM( rd.total_pay_out ) / NULLIF( SUM( rd.total_pay_in ), 0 ) * 100, 0 ) >= $20 ) AND
					( $21 IS NULL OR COALESCE( 100 - SUM( rd.total_pay_out ) / NULLIF( SUM( rd.total_pay_in ), 0 ) * 100, 0 ) <  $21 )
			) r
			
			ORDER BY
				' || arg_orderby || '

			LIMIT
				$23
				
			OFFSET
				$24
		) r;'

	INTO
		retval

	USING
		arg_currency_id,
		arg_campaign_id,
		arg_status,
		arg_search_advertiser,
		arg_search_campaign,
		var_category_ids,
		var_channel_ids,
		arg_expires_min_date,
		arg_expires_max_date,
		arg_min_date,
		arg_max_date,
		arg_pepc_min,
		arg_pepc_max,
		arg_unique_clicks_min,
		arg_unique_clicks_max,
		arg_conversions_min,
		arg_conversions_max,
		arg_conversion_percent_min,
		arg_conversion_percent_max,
		arg_profit_percent_min,
		arg_profit_percent_max,
		arg_new,
		arg_limit,
		arg_offset;

        retval := COALESCE( retval, '[]' );
        RETURN retval;
    END
$_$;


ALTER FUNCTION w4api.campaign_traffic_get_list(arg_status text, arg_search_advertiser text, arg_category_ids json, arg_channel_ids json, arg_expires_min_date timestamp with time zone, arg_expires_max_date timestamp with time zone, arg_pepc_min money, arg_pepc_max money, arg_unique_clicks_min bigint, arg_unique_clicks_max bigint, arg_conversions_min bigint, arg_conversions_max bigint, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_search_campaign text, arg_campaign_id bigint, arg_new boolean, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: campaign_traffic_get_summary(text, text, json, json, timestamp with time zone, timestamp with time zone, money, money, bigint, bigint, bigint, bigint, numeric, numeric, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, boolean, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION campaign_traffic_get_summary(arg_status text DEFAULT NULL::text, arg_search_advertiser text DEFAULT NULL::text, arg_category_ids json DEFAULT NULL::json, arg_channel_ids json DEFAULT NULL::json, arg_expires_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_expires_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_pepc_min money DEFAULT NULL::money, arg_pepc_max money DEFAULT NULL::money, arg_unique_clicks_min bigint DEFAULT NULL::bigint, arg_unique_clicks_max bigint DEFAULT NULL::bigint, arg_conversions_min bigint DEFAULT NULL::bigint, arg_conversions_max bigint DEFAULT NULL::bigint, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_search_campaign text DEFAULT NULL::text, arg_campaign_id bigint DEFAULT NULL::bigint, arg_new boolean DEFAULT NULL::boolean, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
	retval json;
	var_category_ids bigint[];
	var_channel_ids bigint[];

    BEGIN
	IF arg_channel_ids IS NOT NULL THEN
		var_channel_ids := json_array_convert( arg_channel_ids )::bigint[];
	END IF;

	IF arg_category_ids IS NOT NULL THEN
		var_category_ids := json_array_convert( arg_category_ids )::bigint[];
	END IF;
	
	RETURN row_to_json( s.* ) FROM
	(
		SELECT
			COUNT( 1 ) AS count,
			SUM( r.clicks ) AS unique_clicks,
			SUM( r.total_clicks ) AS total_clicks,
			SUM( r.conversions ) AS conversions,

			ROUND(SUM( r.conversions ) / NULLIF( SUM( r.clicks ), 0 )::numeric, 4) AS rate,
			
			SUM( r.payout ) / NULLIF( SUM( r.clicks ), 0 ) AS epc,
			SUM( r.payin ) AS revenue,
			ROUND(1 - SUM( r.payout ) / NULLIF( SUM( r.payin ), 0 )::numeric, 4) AS margin,
			SUM( r.payin - r.payout ) AS profit
		FROM
		(
			SELECT
				SUM( rd.unique_clicks ) AS clicks,
				SUM( rd.total_clicks ) AS total_clicks,
				SUM( rd.total_conversions ) AS conversions,			
				SUM( rd.total_pay_in ) AS payin,
				SUM( rd.total_pay_out ) AS payout

			FROM campaigns c
			LEFT JOIN advertisers a ON c.advertiser_id = a.id
			LEFT JOIN reports_daily rd ON rd.campaign_id = c.id AND 				
				( arg_min_date IS NULL               OR rd.doy IS NULL OR rd.doy >= make_doy( arg_min_date ) ) AND
				( arg_max_date IS NULL               OR rd.doy IS NULL OR rd.doy <  make_doy( arg_max_date ) )
			LEFT JOIN vw_campaign_categories_json cca ON cca.campaign_id = c.id
			LEFT JOIN vw_campaign_channels_json   cch ON cch.campaign_id = c.id
			WHERE
				( arg_currency_id IS NULL            OR c.currency_id = arg_currency_id ) AND
				( arg_campaign_id IS NULL            OR c.id = arg_campaign_id ) AND
				( arg_status IS NULL                 OR c.status = arg_status ) AND
				( arg_search_advertiser IS NULL      OR a.id::text = arg_search_advertiser ) AND
				( arg_search_campaign IS NULL        OR c.id::text = arg_search_campaign ) AND
				( var_category_ids IS NULL           OR cca.category_ids @> var_category_ids ) AND
				( var_channel_ids IS NULL            OR cch.channel_ids  @> var_channel_ids ) AND
				( arg_expires_min_date IS NULL       OR c.expiry_date >= arg_expires_min_date ) AND
				( arg_expires_max_date IS NULL       OR c.expiry_date <  arg_expires_max_date ) AND
				( arg_new IS NULL                    OR ( arg_new = TRUE  AND NOW() <  COALESCE( c.new_until, '-infinity'::timestamptz ) )
								     OR ( arg_new = FALSE AND NOW() >= COALESCE( c.new_until, '-infinity'::timestamptz ) ) )

			GROUP BY
				c.id, c.name, c.advertiser_id, a.name, cca.category_ids, cch.channel_ids

			HAVING
				( arg_pepc_min IS NULL               OR COALESCE( SUM( rd.total_pay_out ) / NULLIF( SUM( rd.unique_clicks ), 0 ), 0 )::money >= arg_pepc_min ) AND
				( arg_pepc_max IS NULL               OR COALESCE( SUM( rd.total_pay_out ) / NULLIF( SUM( rd.unique_clicks ), 0 ), 0 )::money  < arg_pepc_max ) AND
				( arg_unique_clicks_min IS NULL      OR COALESCE( SUM( rd.unique_clicks ), 0 ) >= arg_unique_clicks_min ) AND
				( arg_unique_clicks_max IS NULL      OR COALESCE( SUM( rd.unique_clicks ), 0 ) <  arg_unique_clicks_max ) AND
				( arg_conversions_min IS NULL        OR COALESCE( SUM( rd.total_conversions ), 0 ) >= arg_conversions_min ) AND
				( arg_conversions_max IS NULL        OR COALESCE( SUM( rd.total_conversions ), 0 ) <  arg_conversions_max ) AND
				( arg_conversion_percent_min IS NULL OR COALESCE( SUM( rd.total_conversions ) / NULLIF( SUM( rd.unique_clicks ), 0 ) * 100, 0 ) >= arg_conversion_percent_min ) AND
				( arg_conversion_percent_max IS NULL OR COALESCE( SUM( rd.total_conversions ) / NULLIF( SUM( rd.unique_clicks ), 0 ) * 100, 0 ) <  arg_conversion_percent_max ) AND
				( arg_profit_percent_min IS NULL     OR COALESCE( 100 - SUM( rd.total_pay_out ) / NULLIF( SUM( rd.total_pay_in ), 0 ) * 100, 0 ) >= arg_profit_percent_min ) AND
				( arg_profit_percent_max IS NULL     OR COALESCE( 100 - SUM( rd.total_pay_out ) / NULLIF( SUM( rd.total_pay_in ), 0 ) * 100, 0 ) <  arg_profit_percent_max )
				
		) r WHERE (r.conversions > 0 OR r.clicks > 0)
	) s;
	
    END
$$;


ALTER FUNCTION w4api.campaign_traffic_get_summary(arg_status text, arg_search_advertiser text, arg_category_ids json, arg_channel_ids json, arg_expires_min_date timestamp with time zone, arg_expires_max_date timestamp with time zone, arg_pepc_min money, arg_pepc_max money, arg_unique_clicks_min bigint, arg_unique_clicks_max bigint, arg_conversions_min bigint, arg_conversions_max bigint, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_search_campaign text, arg_campaign_id bigint, arg_new boolean, arg_currency_id bigint) OWNER TO w4;

--
-- Name: categories_check(text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION categories_check(arg_name text, arg_parent_id bigint, arg_id bigint DEFAULT (- (1)::bigint)) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id_valid boolean := true;
     BEGIN
       PERFORM id FROM categories WHERE lower(name) = lower(arg_name) AND id != arg_id;
           IF(FOUND) THEN
		RAISE EXCEPTION 'A Category called % already exists.', arg_name;
		RETURN false;
	   END IF;
           PERFORM id FROM categories WHERE id = arg_parent_id;
           IF(NOT FOUND) THEN
		RAISE EXCEPTION 'Invalid parent id: %.', arg_parent_id;
		RETURN false;
	    END IF;
     RETURN var_id_valid;
    END;
$$;


ALTER FUNCTION w4api.categories_check(arg_name text, arg_parent_id bigint, arg_id bigint) OWNER TO w4;

--
-- Name: categories_create(text, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION categories_create(arg_name text, arg_parent_id bigint, arg_description text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json; 
        var_new_id integer;       
     BEGIN
	IF((SELECT w4api.categories_check(arg_name,arg_parent_id))<> true) THEN 
		RETURN ('{}');
	 END IF;
	       INSERT INTO categories(name,parent_id,description)VALUES(arg_name,arg_parent_id, arg_description) RETURNING id INTO var_new_id;
     RETURN  ('{' || '"new": ' || (SELECT w4api.categories_get_list(arg_id:=var_new_id)) || '}')::json;
    END;
$$;


ALTER FUNCTION w4api.categories_create(arg_name text, arg_parent_id bigint, arg_description text) OWNER TO w4;

--
-- Name: categories_get(bigint, bigint, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION categories_get(arg_id bigint DEFAULT NULL::bigint, arg_parent_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
		var_count_json text :='';
	    BEGIN	        
		IF arg_count THEN
		     var_count_json:= ', "count": ' || (SELECT w4api.categories_get_list(arg_id:=arg_id,arg_name:=arg_name,arg_count:=arg_count))::text;
		END IF;
		ret_val := ('{"results": ' || (SELECT w4api.categories_get_list(arg_id:=arg_id,arg_parent_id:=arg_parent_id,arg_name:=arg_name,arg_orderby:=arg_orderby, arg_limit:=arg_limit, arg_offset:=arg_offset))|| var_count_json  || '}')::json;
	RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.categories_get(arg_id bigint, arg_parent_id bigint, arg_name text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: categories_get_list(bigint, bigint, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION categories_get_list(arg_id bigint DEFAULT NULL::bigint, arg_parent_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
   ret_val json;
   where_clause text := ''; 
   order_clause text := ''; 
    BEGIN
  where_clause := w4_automatic_functions.where_clause_build(arg_id::TEXT, 'id = ' || arg_id, where_clause);
    where_clause := w4_automatic_functions.where_clause_build(arg_parent_id::TEXT, 'parent_id = ' || arg_parent_id, where_clause);
  where_clause := w4_automatic_functions.where_clause_build(arg_name::TEXT, 'lower(name) = lower(''' || arg_name||''')', where_clause);
  order_clause := order_clause_build('cat.'||arg_orderby, 'cat.name ASC');
  IF(arg_count) THEN  
       EXECUTE 'SELECT COALESCE (COUNT(1), 0) FROM ( SELECT id FROM categories '|| where_clause ||') AS count' INTO ret_val;     
   ELSE 
       EXECUTE
	'SELECT array_to_json (array_agg(row_to_json (results)))
		FROM (        
			SELECT row_to_json (row)
				FROM ( 
					SELECT 
					cat.id, 
					cat.name, 
					cat.parent_id,
					(SELECT pcat.name from categories pcat WHERE pcat.id = cat.parent_id) AS parent_name,
					description                         
					FROM categories cat' 
					|| where_clause
					|| order_clause
					|| ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
					|| ' OFFSET ' || arg_offset || '
					) row
			) results'
	INTO ret_val;
      END IF;
  RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.categories_get_list(arg_id bigint, arg_parent_id bigint, arg_name text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: categories_update(bigint, bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION categories_update(arg_id bigint, arg_parent_id bigint DEFAULT (1)::bigint, arg_name text DEFAULT NULL::text, arg_description text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
     BEGIN
	IF((SELECT w4api.categories_check(arg_name:=arg_name,arg_parent_id:=arg_parent_id,arg_id:=arg_id))<> true) THEN RETURN 
		('{}');
	 END IF;
         PERFORM name FROM categories WHERE id = arg_id;   
           IF(FOUND)THEN 							---- if id found, change name at id
		UPDATE categories SET 
			name=COALESCE(arg_name,name),
			parent_id=COALESCE(arg_parent_id,parent_id),
			description=COALESCE(arg_description,description)
							WHERE id = arg_id;               
	   ELSE  								---- if id not found:
		SELECT id FROM categories WHERE lower(name) = lower(arg_name) INTO arg_id; 		     -- if name exists and return that id.
		   IF(NOT FOUND) THEN			
			INSERT INTO categories(name,parent_id,description)VALUES(arg_name,arg_parent_id, arg_description) RETURNING id INTO arg_id; -- if name doesnt exist, create new name at new id and return that
		  END IF;
	  END IF;	
     RETURN (SELECT w4api.categories_get(arg_id:=arg_id));
    END;
$$;


ALTER FUNCTION w4api.categories_update(arg_id bigint, arg_parent_id bigint, arg_name text, arg_description text) OWNER TO w4;

--
-- Name: channels_create(text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION channels_create(arg_name text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json; 
        var_new_id integer;       
     BEGIN
           PERFORM id FROM channels WHERE name = arg_name;
           IF(FOUND) THEN
		RAISE EXCEPTION 'A Channel called % already exists.', arg_name;                 
	   ELSIF (arg_name NOTNULL) THEN
	     INSERT INTO channels(name)VALUES(arg_name) RETURNING id INTO var_new_id;
           END IF;
     RETURN  ('{' || '"new": ' || (SELECT w4api.channels_get_list(arg_id:=var_new_id)) || '}')::json;
    END;
$$;


ALTER FUNCTION w4api.channels_create(arg_name text) OWNER TO w4;

--
-- Name: channels_get(bigint, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION channels_get(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
		var_count_json text :='';
	    BEGIN	        
		IF arg_count THEN
		     var_count_json:= ', "count": ' || (SELECT w4api.channels_get_list(arg_id:=arg_id,arg_name:=arg_name,arg_count:=arg_count))::text;
		END IF;
		ret_val := ('{"results": ' || (SELECT w4api.channels_get_list(arg_id,arg_name,arg_orderby, arg_limit, arg_offset))|| var_count_json  || '}')::json;
	RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.channels_get(arg_id bigint, arg_name text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: channels_get_list(bigint, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION channels_get_list(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
   ret_val json;
   where_clause text := ''; 
   order_clause text := ''; 
    BEGIN
  where_clause := w4_automatic_functions.where_clause_build(arg_id::TEXT, 'id = ' || arg_id, where_clause);
  where_clause := w4_automatic_functions.where_clause_build(arg_name::TEXT, 'name = ''' || arg_name||'''', where_clause);
  order_clause := order_clause_build(arg_orderby, 'name ASC');
  IF(arg_count) THEN  
       EXECUTE
    'SELECT COALESCE (COUNT(1), 0) 
      FROM ( SELECT 
         id                        
        FROM channels '
        || where_clause ||') AS count'
    INTO ret_val;     
   ELSE 
       EXECUTE
    'SELECT array_to_json (array_agg(row_to_json (results)))
        FROM (        
      SELECT row_to_json (row)
          FROM ( 
        SELECT 
           id, name                         
        FROM channels' 
        || where_clause
        || order_clause
        || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
        || ' OFFSET ' || arg_offset || '
          ) row
      ) results'
    INTO ret_val;
      END IF;
  RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.channels_get_list(arg_id bigint, arg_name text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: channels_update(bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION channels_update(arg_id bigint, arg_name text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
     BEGIN
         PERFORM name FROM channels WHERE id = arg_id;   
           IF(FOUND)THEN 							---- if id found, change name at id
		UPDATE channels SET name =arg_name WHERE id = arg_id;               
	   ELSE  								---- if id not found:
		SELECT id FROM channels WHERE name = arg_name INTO arg_id; 		     -- if name exists and return that id.
		   IF(NOT FOUND) THEN			
			INSERT INTO channels(name)VALUES(arg_name) RETURNING id INTO arg_id; -- if name doesnt exist, create new name at new id and return that
		  END IF;
	  END IF;	
     RETURN (SELECT w4api.channels_get(arg_id:=arg_id));
    END;
$$;


ALTER FUNCTION w4api.channels_update(arg_id bigint, arg_name text) OWNER TO w4;

--
-- Name: click_base_call_create(text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_base_call_create(arg_url_path text, arg_url_args text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN     
        INSERT INTO engine_clicks_calls
            (url_path, url_args, created_date)
            VALUES (arg_url_path, arg_url_args, CURRENT_TIMESTAMP)
            RETURNING id
            INTO var_id;
        RETURN var_id;
    END;
$$;


ALTER FUNCTION w4api.click_base_call_create(arg_url_path text, arg_url_args text) OWNER TO w4;

--
-- Name: click_base_call_update(bigint, bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_base_call_update(arg_id bigint, arg_click_id bigint, arg_click_ip text, arg_cookie text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN     
        INSERT INTO engine_clicks_calls_success
            (click_call_id, click_id, click_ip, cookie, created_date)
            VALUES (arg_id, arg_click_id, arg_click_ip, arg_cookie, CURRENT_TIMESTAMP);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.click_base_call_update(arg_id bigint, arg_click_id bigint, arg_click_ip text, arg_cookie text) OWNER TO w4;

--
-- Name: click_recover_subset_load(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_recover_subset_load() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_click_id bigint;
        clkcampaign_id bigint;
        clkpublisher_id bigint;
        clkparent_publisher_id bigint;
        clkredirect_url_id integer;
        clkconsumer_id bigint;
        clkcreative_id integer;
        clkip_address inet;
        clkcontinent character varying;
        clkcountry character varying;
        clkregion character varying;
        clkregion_name character varying;
        clkcity character varying;
        clkpostal_code character varying;
        clklatitude double precision;
        clklongitude double precision;
        clkmetro_code integer;
        clkarea_code integer;
        clkbrowser_id integer;
        clkplatform_id integer;
        clkchannel bigint;
        clksub_id_1 text;
        clksub_id_2 text;
        clksub_id_3 text;
        clksub_id_4 text;
        clkbase_uri character varying;
        clkreferral_url text;
        clknb_dupes bigint;
        clkcreated_date timestamp with time zone;
        clkstatus int;
        clkadvertiser_id bigint;

    BEGIN

        FOR var_click_id, clkcampaign_id, clkpublisher_id, clkparent_publisher_id, clkredirect_url_id, clkconsumer_id, clkcreative_id, clkip_address, clkcontinent, clkcountry,
                     clkregion, clkregion_name, clkcity, clkpostal_code, clklatitude, clklongitude, clkmetro_code, clkarea_code, clkbrowser_id, clkplatform_id, clkchannel, clksub_id_1,
                     clksub_id_2, clksub_id_3, clksub_id_4, clkbase_uri, clkreferral_url, clknb_dupes, clkcreated_date, clkstatus IN
            SELECT
                id, campaign_id, publisher_id, parent_publisher_id, redirect_url_id, consumer_id, creative_id, ip_address, continent, country, region, region_name, city, postal_code,
                    latitude, longitude, metro_code, area_code, browser_id, platform_id, channel, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, referral_url, nb_dupes, created_date,
                    status
            FROM engine_clicks_tmp
            ORDER BY id ASC
        LOOP
            select advertiser_id from campaigns where id = clkcampaign_id INTO clkadvertiser_id;
            INSERT INTO engine_clicks
                (id, campaign_id, publisher_id, parent_publisher_id, redirect_url_id, consumer_id, creative_id, ip_address, continent, country, region, region_name, city, postal_code,
                    latitude, longitude, metro_code, area_code, browser_id, platform_id, channel, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, referral_url, nb_dupes, created_date,
                    status)
                VALUES (var_click_id, clkcampaign_id, clkpublisher_id, clkparent_publisher_id, clkredirect_url_id, clkconsumer_id, clkcreative_id, clkip_address, clkcontinent, clkcountry,
                     clkregion, clkregion_name, clkcity, clkpostal_code, clklatitude, clklongitude, clkmetro_code, clkarea_code, clkbrowser_id, clkplatform_id, clkchannel, clksub_id_1,
                     clksub_id_2, clksub_id_3, clksub_id_4, clkbase_uri, clkreferral_url, clknb_dupes, clkcreated_date, clkstatus);

            INSERT INTO engine_clicks_rollup_queue
                (click_id, campaign_id, advertiser_id, publisher_id, parent_publisher_id, creative_id, country, region_name, city, browser_id, platform_id, unique_click,
                    nb_dupes, sub_id_1, sub_id_2, sub_id_3, sub_id_4, created_date, base_uri, rollup_id)
                VALUES (var_click_id, clkcampaign_id, clkadvertiser_id, clkpublisher_id, clkparent_publisher_id, clkcreative_id, clkcountry, clkregion_name, clkcity,
                    clkbrowser_id, clkplatform_id, true, 0, clksub_id_1, clksub_id_2, clksub_id_3, clksub_id_4,
                    clkcreated_date, clkbase_uri, NULL);

        END LOOP;



        RETURN true;
    END
$$;


ALTER FUNCTION w4api.click_recover_subset_load() OWNER TO w4;

--
-- Name: click_rollup(bigint, bigint, bigint, timestamp with time zone, bigint, text, text, text, bigint, bigint, text, text, text, text, text, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_created_date timestamp with time zone, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_browser_id bigint DEFAULT NULL::bigint, arg_platform_id bigint DEFAULT NULL::bigint, arg_base_uri text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_creative_id bigint DEFAULT (0)::bigint, arg_unique_click boolean DEFAULT true, arg_delete boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_click_delta bigint := 1;
        var_unique_click_delta bigint := 0;
        var_doy bigint := make_doy(arg_created_date);

    BEGIN
        IF (arg_unique_click) THEN
            var_unique_click_delta := 1;
        END IF;

        IF (arg_delete) THEN
            var_click_delta := -1;
        END IF;

        --Click Rollup Daily Aggregate
        SELECT
            id
        FROM reports_clicks_rollup_daily
        WHERE
            (doy = var_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reports_clicks_rollup_daily SET
                total_clicks = total_clicks + var_click_delta,
                unique_clicks = unique_clicks + var_unique_click_delta
            WHERE id = var_rollup_id;
        ELSE
            IF (NOT arg_delete) THEN
                INSERT INTO reports_clicks_rollup_daily
                    (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, doy)
                    VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, var_click_delta, var_unique_click_delta, var_doy);
            END IF;
        END IF;

        --Click Geo Rollup Daily Aggregate
        SELECT
            id
        FROM reports_clicks_geo_rollup_daily
        WHERE
            (doy = var_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, ''))
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reports_clicks_geo_rollup_daily SET
                total_clicks = total_clicks + var_click_delta,
                unique_clicks = unique_clicks + var_unique_click_delta
            WHERE id = var_rollup_id;
        ELSE
            IF (NOT arg_delete) THEN
                INSERT INTO reports_clicks_geo_rollup_daily
                    (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, country, region_name, city_name, doy)
                    VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, var_click_delta, var_unique_click_delta, arg_country, arg_region_name, arg_city_name, var_doy);
            END IF;
        END IF;

        --Click Subid Rollup Daily Aggregate
        SELECT
            id
        FROM reports_clicks_subid_rollup_daily
        WHERE
            (doy = var_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, ''))
        INTO var_rollup_id;
        
        IF (FOUND) THEN
            UPDATE reports_clicks_subid_rollup_daily SET
                total_clicks = total_clicks + var_click_delta,
                unique_clicks = unique_clicks + var_unique_click_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_subid_rollup_daily
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, sub_id_1, sub_id_2, sub_id_3, sub_id_4, doy)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, var_click_delta, var_unique_click_delta, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, var_doy);
        END IF;

        --Click Wide Rollup Daily Aggregate
        SELECT
            id
        FROM reports_clicks_wide_rollup_daily
        WHERE
            (doy = var_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(browser_name, '') = COALESCE(arg_browser_id::text,'')) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (COALESCE(platform_name, '') = COALESCE(arg_platform_id::text, '')) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (COALESCE(base_uri, '') = COALESCE(arg_base_uri, '')) AND
            (COALESCE(creative_id, 0) = COALESCE(arg_creative_id, 0))
        INTO var_rollup_id;
        
        IF (FOUND) THEN
            UPDATE reports_clicks_wide_rollup_daily SET
                total_clicks = total_clicks + var_click_delta,
                unique_clicks = unique_clicks + var_unique_click_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_wide_rollup_daily
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, browser_name, platform_name, country, region_name, city_name, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, doy, creative_id)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, var_click_delta, var_unique_click_delta, arg_browser_id::text, arg_platform_id::text, arg_country, arg_region_name, arg_city_name, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_base_uri, var_doy, arg_creative_id);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_created_date timestamp with time zone, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text, arg_browser_id bigint, arg_platform_id bigint, arg_base_uri text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_creative_id bigint, arg_unique_click boolean, arg_delete boolean) OWNER TO w4;

--
-- Name: click_rollup_batch_create(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_batch_create() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        --Find any non-rolled up clicks and assign them the current rollup id
        PERFORM * FROM engine_clicks_rollup WHERE status = 'pending';
        IF (NOT FOUND) THEN
            var_rollup_id := nextval( 'engine_clicks_rollup_id_seq' );
            UPDATE engine_clicks_rollup_queue SET rollup_id = var_rollup_id WHERE id IN (SELECT id FROM engine_clicks_rollup_queue WHERE rollup_id IS NULL LIMIT 20000);
            IF (FOUND) THEN
                INSERT INTO engine_clicks_rollup
                    (id, start_time, status)
                    VALUES (var_rollup_id, CURRENT_TIMESTAMP, 'pending');
                RETURN TRUE;
            END IF;
        END IF;
     
        RETURN FALSE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_batch_create() OWNER TO w4;

--
-- Name: click_rollup_batch_get(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_batch_get() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_publisher_id bigint;
        var_campaign_id bigint;
        var_advertiser_id bigint;
        var_hoy bigint;
        var_publisher_pid bigint;
        var_region_name text;
        var_city_name text;
        var_country text;
        var_browser_id bigint;
        var_platform_id bigint;
        var_sub_id_1 text;
        var_creative_id bigint;
        var_clicks bigint;
        var_unique_clicks bigint;
        var_click_id bigint;
        var_nb_dupes bigint;

    BEGIN
        var_rollup_id := nextval( 'engine_clicks_rollup_id_seq' );
        UPDATE engine_clicks_rollup_queue SET rollup_id = var_rollup_id WHERE rollup_id IS NULL AND make_hoy(created_date) <= make_hoy(CURRENT_TIMESTAMP - INTERVAL '1 hour');
        IF (FOUND) THEN
            INSERT INTO engine_clicks_rollup
                (id, start_time, status)
                VALUES (var_rollup_id, CURRENT_TIMESTAMP, 'pending');
        END IF;

        SELECT id FROM engine_clicks_rollup WHERE status='pending' ORDER BY start_time ASC LIMIT 1 INTO var_rollup_id;
        IF (FOUND) THEN
            UPDATE engine_clicks_rollup SET status = 'processing' WHERE id = var_rollup_id;
            --Store clicks in temporay table to make aggregates from
            DROP TABLE IF EXISTS click_rollup_temp;            
            CREATE TEMPORARY TABLE click_rollup_temp ON COMMIT DROP AS
                SELECT
                    publisher_id,
                    campaign_id,
                    advertiser_id,
                    make_hoy(created_date) AS hoy,
                    parent_publisher_id,
                    region_name,
                    city,
                    country,
                    browser_id,
                    platform_id,
                    sub_id_1,
                    creative_id,
                    nb_dupes,
                    unique_click
                FROM engine_clicks_rollup_queue
                WHERE rollup_id = var_rollup_id;
            CREATE INDEX click_rollup_temp_publisher_id_idx ON click_rollup_temp (publisher_id);
            CREATE INDEX click_rollup_temp_campaign_id_idx ON click_rollup_temp (campaign_id);
            CREATE INDEX click_rollup_temp_advertiser_id_idx ON click_rollup_temp (advertiser_id);
            CREATE INDEX click_rollup_temp_hoy_idx ON click_rollup_temp (hoy);
            CREATE INDEX click_rollup_temp_parent_publisher_id_idx ON click_rollup_temp (parent_publisher_id);
            CREATE INDEX click_rollup_temp_region_name_idx ON click_rollup_temp (region_name);
            CREATE INDEX click_rollup_temp_city_idx ON click_rollup_temp (city);
            CREATE INDEX click_rollup_temp_country_idx ON click_rollup_temp (country);
            CREATE INDEX click_rollup_temp_browser_id_idx ON click_rollup_temp (browser_id);
            CREATE INDEX click_rollup_temp_platform_id_idx ON click_rollup_temp (platform_id);
            CREATE INDEX click_rollup_temp_sub_id_1_idx ON click_rollup_temp (sub_id_1);
            CREATE INDEX click_rollup_temp_creative_id_idx ON click_rollup_temp (creative_id);

            --Entity Rollup
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    sum(nb_dupes) + sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS clicks,
                    sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS unique_clicks
                FROM click_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy
            LOOP
                INSERT INTO reports_clicks_rollup_hourly
                    (publisher_id, campaign_id, advertiser_id, publisher_pid, total_clicks, unique_clicks, hoy)
                    VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_publisher_pid, var_clicks, var_unique_clicks, var_hoy);                
            END LOOP;

            --Geo rollup
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_region_name, var_city_name, var_country IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    sum(nb_dupes) + sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS clicks,
                    sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS unique_clicks,
                    region_name,
                    city,
                    country
                FROM click_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, region_name, city, country
            LOOP
                INSERT INTO reports_clicks_geo_rollup_hourly
                    (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, country, region_name, city_name, hoy)
                    VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, var_country, var_region_name, var_city_name, var_hoy);
            END LOOP;

            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_country IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    sum(nb_dupes) + sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS clicks,
                    sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS unique_clicks,
                    country
                FROM click_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, country
            LOOP
                INSERT INTO reports_clicks_geo_country_rollup_hourly
                    (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, country, hoy)
                    VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, var_country, var_hoy);
            END LOOP;

            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_region_name, var_country IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    sum(nb_dupes) + sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS clicks,
                    sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS unique_clicks,
                    region_name,
                    country
                FROM click_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, region_name, country
            LOOP
                INSERT INTO reports_clicks_geo_region_rollup_hourly
                    (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, country, region_name, hoy)
                    VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, var_country, var_region_name, var_hoy);
            END LOOP;

            --Sub id rollup
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_sub_id_1 IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    sum(nb_dupes) + sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS clicks,
                    sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS unique_clicks,
                    sub_id_1
                FROM click_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, sub_id_1
            LOOP
                INSERT INTO reports_clicks_subid_rollup_hourly
                    (publisher_id, campaign_id, advertiser_id, publisher_pid, total_clicks, unique_clicks, sub_id_1, sub_id_2, sub_id_3, sub_id_4, hoy)
                    VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_publisher_pid, var_clicks, var_unique_clicks, var_sub_id_1, null, null, null, var_hoy);
            END LOOP;

            --User agent rollup
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_browser_id, var_platform_id IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    sum(nb_dupes) + sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS clicks,
                    sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS unique_clicks,
                    browser_id,
                    platform_id
                FROM click_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, browser_id, platform_id
            LOOP
                INSERT INTO reports_clicks_ua_rollup_hourly
                    (publisher_id, publisher_pid, campaign_id, advertiser_id, total_clicks, unique_clicks, browser_name, platform_name, hoy)
                    VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, var_browser_id, var_platform_id, var_hoy);
            END LOOP;

            --Wide rollup, just creative now
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_creative_id IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    sum(nb_dupes) + sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS clicks,
                    sum(CASE WHEN unique_click THEN 1 ELSE 0 END) AS unique_clicks,
                    creative_id
                FROM click_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, creative_id
            LOOP
                INSERT INTO reports_clicks_wide_rollup_hourly
                    (publisher_id, publisher_pid, campaign_id, advertiser_id, total_clicks, unique_clicks, browser_name, platform_name, country, region_name, city_name, sub_id_1,
                        sub_id_2, sub_id_3, sub_id_4, base_uri, hoy, creative_id)
                    VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, null, null,
                         null, null, null, null, null, null, null, null, var_hoy, var_creative_id);
            END LOOP;

            DELETE FROM engine_clicks_rollup_queue WHERE rollup_id = var_rollup_id;
            UPDATE engine_clicks_rollup SET status = 'complete', stop_time = CURRENT_TIMESTAMP WHERE id = var_rollup_id;
        END IF;
     
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_batch_get() OWNER TO w4;

--
-- Name: click_rollup_entity(bigint, bigint, bigint, bigint, bigint, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_entity(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_rollup_daily
        WHERE
            (doy = arg_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reports_clicks_rollup_daily SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_rollup_daily
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, doy)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, arg_clicks, arg_unique_clicks, arg_doy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_entity(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint) OWNER TO w4;

--
-- Name: click_rollup_entity_hourly(bigint, bigint, bigint, bigint, bigint, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_entity_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_rollup_hourly
        WHERE
            (hoy = arg_hoy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reports_clicks_rollup_hourly SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_rollup_hourly
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, hoy)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, arg_clicks, arg_unique_clicks, arg_hoy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_entity_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint) OWNER TO w4;

--
-- Name: click_rollup_entity_monthly(bigint, bigint, bigint, bigint, bigint, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_entity_monthly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_moy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_rollup_monthly
        WHERE
            (moy = arg_moy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reports_clicks_rollup_monthly SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_rollup_monthly
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, moy)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, arg_clicks, arg_unique_clicks, arg_moy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_entity_monthly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_moy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint) OWNER TO w4;

--
-- Name: click_rollup_entity_yearly(bigint, bigint, bigint, bigint, bigint, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_entity_yearly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_y bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_rollup_yearly
        WHERE
            (y = arg_y) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reports_clicks_rollup_yearly SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_rollup_yearly
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, y)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, arg_clicks, arg_unique_clicks, arg_y);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_entity_yearly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_y bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint) OWNER TO w4;

--
-- Name: click_rollup_geo(bigint, bigint, bigint, bigint, bigint, bigint, bigint, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_geo(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_geo_rollup_daily
        WHERE
            (doy = arg_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, ''))
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reports_clicks_geo_rollup_daily SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_geo_rollup_daily
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, country, region_name, city_name, doy)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, arg_clicks, arg_unique_clicks, arg_country, arg_region_name, arg_city_name, arg_doy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_geo(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text) OWNER TO w4;

--
-- Name: click_rollup_geo_hourly(bigint, bigint, bigint, bigint, bigint, bigint, bigint, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_geo_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_geo_rollup_hourly
        WHERE
            (hoy = arg_hoy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, ''))
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reports_clicks_geo_rollup_hourly SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_geo_rollup_hourly
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, country, region_name, city_name, hoy)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, arg_clicks, arg_unique_clicks, arg_country, arg_region_name, arg_city_name, arg_hoy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_geo_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text) OWNER TO w4;

--
-- Name: click_rollup_geo_redo(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_geo_redo() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_publisher_id bigint;
        var_campaign_id bigint;
        var_advertiser_id bigint;
        var_hoy bigint;
        var_publisher_pid bigint;
        var_region_name text;
        var_country text;
        var_clicks bigint;
        var_unique_clicks bigint;
        var_click_id bigint;

    BEGIN

        DROP TABLE IF EXISTS click_re_rollup_temp;            
        CREATE TEMPORARY TABLE click_re_rollup_temp ON COMMIT DROP AS
            SELECT
                e.publisher_id,
                e.campaign_id,
                c.advertiser_id,
                make_hoy(e.created_date) AS hoy,
                e.parent_publisher_id,
                e.region_name,
                e.country,
                e.nb_dupes
            FROM engine_clicks e
            LEFT JOIN campaigns c ON e.campaign_id=c.id;
        CREATE INDEX click_re_rollup_temp_publisher_id_idx ON click_re_rollup_temp (publisher_id);
        CREATE INDEX click_re_rollup_temp_campaign_id_idx ON click_re_rollup_temp (campaign_id);
        CREATE INDEX click_re_rollup_temp_advertiser_id_idx ON click_re_rollup_temp (advertiser_id);
        CREATE INDEX click_re_rollup_temp_hoy_idx ON click_re_rollup_temp (hoy);
        CREATE INDEX click_re_rollup_temp_parent_publisher_id_idx ON click_re_rollup_temp (parent_publisher_id);
        CREATE INDEX click_re_rollup_temp_region_name_idx ON click_re_rollup_temp (region_name);
        CREATE INDEX click__rerollup_temp_country_idx ON click_re_rollup_temp (country);

        --Geo rollup
        TRUNCATE reports_clicks_geo_region_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_region_name, var_country IN
            SELECT 
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                sum(nb_dupes) + sum(1) AS clicks,
                sum(1) AS unique_clicks,
                region_name,
                country
            FROM click_re_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, region_name, country
        LOOP
            IF (var_publisher_id IS NOT NULL) THEN
                INSERT INTO reports_clicks_geo_region_rollup_hourly
                    (publisher_id, publisher_pid, campaign_id, advertiser_id, total_clicks, unique_clicks, country, region_name, hoy)
                    VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, var_country, var_region_name, var_hoy);
                END IF;
        END LOOP;

        TRUNCATE reports_clicks_geo_country_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_country IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                sum(nb_dupes) + sum(1) AS clicks,
                sum(1) AS unique_clicks,
                country
            FROM click_re_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, country
        LOOP
            IF (var_publisher_id IS NOT NULL) THEN
                INSERT INTO reports_clicks_geo_country_rollup_hourly
                    (publisher_id, publisher_pid, campaign_id, advertiser_id, total_clicks, unique_clicks, country, hoy)
                    VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, var_country, var_hoy);
            END IF;
        END LOOP;

        RETURN true;
    END
$$;


ALTER FUNCTION w4api.click_rollup_geo_redo() OWNER TO w4;

--
-- Name: click_rollup_queue_create(bigint, bigint, bigint, bigint, timestamp with time zone, bigint, text, text, text, bigint, bigint, text, text, text, text, text, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_queue_create(arg_click_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_created_date timestamp with time zone, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_browser_id bigint DEFAULT NULL::bigint, arg_platform_id bigint DEFAULT NULL::bigint, arg_base_uri text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_creative_id bigint DEFAULT (0)::bigint, arg_unique_click boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN
        IF (
            arg_click_id < 1 OR
            arg_publisher_id < 1 OR
            arg_campaign_id < 1 OR
            arg_advertiser_id < 1 OR
            arg_click_id IS NULL OR
            arg_publisher_id IS NULL OR
            arg_campaign_id IS NULL OR
            arg_advertiser_id IS NULL
        ) THEN
            RAISE EXCEPTION 'All the following values must be set. click_id: %, publisher_id %, campaign_id %, and advertiser_id %.', arg_click_id, arg_publisher_id, arg_campaign_id, arg_advertiser_id; 
        END IF;

        UPDATE engine_clicks_rollup_queue
            SET nb_dupes = nb_dupes + (CASE WHEN arg_unique_click THEN 0 ELSE 1 END)
            WHERE click_id = arg_click_id AND rollup_id IS NULL;
        IF (NOT FOUND) THEN
            INSERT INTO engine_clicks_rollup_queue
                (click_id, campaign_id, advertiser_id, publisher_id, parent_publisher_id, creative_id, country, region_name, city, browser_id, platform_id, unique_click,
                    nb_dupes, sub_id_1, sub_id_2, sub_id_3, sub_id_4, created_date, base_uri, rollup_id)
                VALUES (arg_click_id, arg_campaign_id, arg_advertiser_id, arg_publisher_id, arg_publisher_pid, arg_creative_id, arg_country, arg_region_name, arg_city_name,
                    arg_browser_id, arg_platform_id, arg_unique_click, (CASE WHEN arg_unique_click THEN 0 ELSE 1 END), arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4,
                    arg_created_date, arg_base_uri, NULL);
        END IF;
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_queue_create(arg_click_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_created_date timestamp with time zone, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text, arg_browser_id bigint, arg_platform_id bigint, arg_base_uri text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_creative_id bigint, arg_unique_click boolean) OWNER TO w4;

--
-- Name: click_rollup_redo(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_redo() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_publisher_id bigint;
        var_campaign_id bigint;
        var_advertiser_id bigint;
        var_hoy bigint;
        var_publisher_pid bigint;
        var_region_name text;
        var_city_name text;
        var_country text;
        var_browser_id bigint;
        var_platform_id bigint;
        var_sub_id_1 text;
        var_creative_id bigint;
        var_clicks bigint;
        var_unique_clicks bigint;
        var_click_id bigint;

    BEGIN

        DROP TABLE IF EXISTS click_rollup_temp;            
        CREATE TEMPORARY TABLE click_rollup_temp ON COMMIT DROP AS
            SELECT
                e.publisher_id,
                e.campaign_id,
                c.advertiser_id,
                make_hoy(e.created_date) AS hoy,
                e.parent_publisher_id,
                e.region_name,
                e.city,
                e.country,
                e.browser_id,
                e.platform_id,
                e.sub_id_1,
                e.creative_id,
                e.nb_dupes
                --SUM(1) AS unique_clicks,
                --SUM(e.nb_dupes) + SUM(1) AS total_clicks
            FROM engine_clicks e
            LEFT JOIN campaigns c ON e.campaign_id=c.id;
        CREATE INDEX click_rollup_temp_publisher_id_idx ON click_rollup_temp (publisher_id);
        CREATE INDEX click_rollup_temp_campaign_id_idx ON click_rollup_temp (campaign_id);
        CREATE INDEX click_rollup_temp_advertiser_id_idx ON click_rollup_temp (advertiser_id);
        CREATE INDEX click_rollup_temp_hoy_idx ON click_rollup_temp (hoy);
        CREATE INDEX click_rollup_temp_parent_publisher_id_idx ON click_rollup_temp (parent_publisher_id);
        CREATE INDEX click_rollup_temp_region_name_idx ON click_rollup_temp (region_name);
        CREATE INDEX click_rollup_temp_city_idx ON click_rollup_temp (city);
        CREATE INDEX click_rollup_temp_country_idx ON click_rollup_temp (country);
        CREATE INDEX click_rollup_temp_browser_id_idx ON click_rollup_temp (browser_id);
        CREATE INDEX click_rollup_temp_platform_id_idx ON click_rollup_temp (platform_id);
        CREATE INDEX click_rollup_temp_sub_id_1_idx ON click_rollup_temp (sub_id_1);
        CREATE INDEX click_rollup_temp_creative_id_idx ON click_rollup_temp (creative_id);

        TRUNCATE engine_clicks_rollup_queue;
        UPDATE engine_clicks_rollup SET status = 'complete', stop_time = CURRENT_TIMESTAMP;


        TRUNCATE reports_clicks_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                sum(nb_dupes) + sum(1) AS clicks,
                sum(1) AS unique_clicks
            FROM click_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy
        LOOP
            INSERT INTO reports_clicks_rollup_hourly
                (publisher_id, campaign_id, advertiser_id, publisher_pid, total_clicks, unique_clicks, hoy)
                VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_publisher_pid, var_clicks, var_unique_clicks, var_hoy);                
        END LOOP;

        --Geo rollup
        TRUNCATE reports_clicks_geo_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_region_name, var_city_name, var_country IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                sum(nb_dupes) + sum(1) AS clicks,
                sum(1) AS unique_clicks,
                region_name,
                city,
                country
            FROM click_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, region_name, city, country
        LOOP
            INSERT INTO reports_clicks_geo_rollup_hourly
                (publisher_id, campaign_id, advertiser_id, total_clicks, unique_clicks, country, region_name, city_name, hoy)
                VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, var_country, var_region_name, var_city_name, var_hoy);
        END LOOP;

        --Sub id rollup
        TRUNCATE reports_clicks_subid_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_sub_id_1 IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                sum(nb_dupes) + sum(1) AS clicks,
                sum(1) AS unique_clicks,
                sub_id_1
            FROM click_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, sub_id_1
        LOOP
            INSERT INTO reports_clicks_subid_rollup_hourly
                (publisher_id, campaign_id, advertiser_id, publisher_pid, total_clicks, unique_clicks, sub_id_1, sub_id_2, sub_id_3, sub_id_4, hoy)
                VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_publisher_pid, var_clicks, var_unique_clicks, var_sub_id_1, null, null, null, var_hoy);
        END LOOP;

        --User agent rollup
        TRUNCATE reports_clicks_ua_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_browser_id, var_platform_id IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                sum(nb_dupes) + sum(1) AS clicks,
                sum(1) AS unique_clicks,
                browser_id,
                platform_id
            FROM click_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, browser_id, platform_id
        LOOP
            INSERT INTO reports_clicks_ua_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_clicks, unique_clicks, browser_name, platform_name, hoy)
                VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, var_browser_id, var_platform_id, var_hoy);
        END LOOP;

        --Wide rollup, just creative now
        TRUNCATE reports_clicks_wide_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_creative_id IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                sum(nb_dupes) + sum(1) AS clicks,
                sum(1) AS unique_clicks,
                creative_id
            FROM click_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, creative_id
        LOOP
            INSERT INTO reports_clicks_wide_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_clicks, unique_clicks, browser_name, platform_name, country, region_name, city_name, sub_id_1,
                    sub_id_2, sub_id_3, sub_id_4, base_uri, hoy, creative_id)
                VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_clicks, var_unique_clicks, null, null,
                     null, null, null, null, null, null, null, null, var_hoy, var_creative_id);
        END LOOP;

        RETURN true;
    END
$$;


ALTER FUNCTION w4api.click_rollup_redo() OWNER TO w4;

--
-- Name: click_rollup_reindex(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_reindex() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_publisher_id bigint;
        var_campaign_id bigint;
        var_advertiser_id bigint;
        var_y bigint;
        var_moy bigint;
        var_doy bigint;
        var_hoy bigint;
        var_publisher_pid bigint;
        var_region_name text;
        var_city_name text;
        var_country text;
        var_browser_id bigint;
        var_platform_id bigint;
        var_sub_id_1 text;
        var_creative_id bigint;
        var_clicks bigint;
        var_unique_clicks bigint;
        var_click_id bigint;
        var_nb_dupes bigint;
        var_count bigint;

    BEGIN
        DELETE FROM reporting.reports_clicks_wide_rollup_hourly_temp;
        UPDATE reporting.reports_clicks_wide_rollup_hourly SET region_name = null, city_name = null, country = null, sub_id_1 = null;

        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks,
                var_browser_id, var_platform_id, var_creative_id IN
            SELECT
                publisher_id,
                MAX(publisher_pid) AS publisher_pid,
                campaign_id,
                advertiser_id,
                hoy,
                sum(total_clicks) AS clicks,
                sum(unique_clicks) AS unique_clicks,
                browser_name,
                platform_name,
                creative_id
            FROM reporting.reports_clicks_wide_rollup_hourly
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, browser_name, platform_name, creative_id
        LOOP
            var_count := var_count + 1;
            INSERT INTO reporting.reports_clicks_wide_rollup_hourly_temp
                (publisher_id, campaign_id, advertiser_id, hoy, total_clicks, unique_clicks, publisher_pid, region_name, city_name, country, browser_name, platform_name, sub_id_1, sub_id_2,
                    sub_id_3, sub_id_4)
                VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_publisher_pid, null, null, null,
                    var_browser_id, var_platform_id, null, null, null, null);
        END LOOP;

        DELETE FROM reporting.reports_clicks_wide_rollup_hourly;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_region_name, var_city_name, var_country,
                var_browser_id, var_platform_id, var_sub_id_1, var_creative_id IN
            SELECT
                publisher_id,
                publisher_pid,
                campaign_id,
                advertiser_id,
                hoy,
                total_clicks,
                unique_clicks,
                region_name,
                city_name,
                country,
                browser_name,
                platform_name,
                sub_id_1,
                creative_id
            FROM reporting.reports_clicks_wide_rollup_hourly_temp
        LOOP
            var_count := var_count + 1;
            INSERT INTO reporting.reports_clicks_wide_rollup_hourly
                (publisher_id, campaign_id, advertiser_id, hoy, total_clicks, unique_clicks, publisher_pid, region_name, city_name, country, browser_name, platform_name, sub_id_1, sub_id_2,
                    sub_id_3, sub_id_4)
                VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_clicks, var_unique_clicks, var_publisher_pid, var_region_name, var_city_name, var_country,
                    var_browser_id, var_platform_id, var_sub_id_1, null, null, null);
        END LOOP;


        DELETE FROM reporting.reports_clicks_wide_rollup_daily_temp;
        UPDATE reporting.reports_clicks_wide_rollup_daily SET region_name = null, city_name = null, country = null, sub_id_1 = null;

        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_doy, var_clicks, var_unique_clicks,
                var_browser_id, var_platform_id, var_creative_id IN
            SELECT
                publisher_id,
                MAX(publisher_pid) AS publisher_pid,
                campaign_id,
                advertiser_id,
                doy,
                sum(total_clicks) AS clicks,
                sum(unique_clicks) AS unique_clicks,
                browser_name,
                platform_name,
                creative_id
            FROM reporting.reports_clicks_wide_rollup_daily
            GROUP BY publisher_id, campaign_id, advertiser_id, doy, browser_name, platform_name, creative_id
        LOOP
            var_count := var_count + 1;
            INSERT INTO reporting.reports_clicks_wide_rollup_daily_temp
                (publisher_id, campaign_id, advertiser_id, doy, total_clicks, unique_clicks, publisher_pid, region_name, city_name, country, browser_name, platform_name, sub_id_1, sub_id_2,
                    sub_id_3, sub_id_4)
                VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_clicks, var_unique_clicks, var_publisher_pid, null, null, null,
                    var_browser_id, var_platform_id, null, null, null, null);
        END LOOP;

        DELETE FROM reporting.reports_clicks_wide_rollup_daily;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_doy, var_clicks, var_unique_clicks, var_region_name, var_city_name, var_country,
                var_browser_id, var_platform_id, var_sub_id_1, var_creative_id IN
            SELECT
                publisher_id,
                publisher_pid,
                campaign_id,
                advertiser_id,
                doy,
                total_clicks,
                unique_clicks,
                region_name,
                city_name,
                country,
                browser_name,
                platform_name,
                sub_id_1,
                creative_id
            FROM reporting.reports_clicks_wide_rollup_daily_temp
        LOOP
            var_count := var_count + 1;
            INSERT INTO reporting.reports_clicks_wide_rollup_daily
                (publisher_id, campaign_id, advertiser_id, doy, total_clicks, unique_clicks, publisher_pid, region_name, city_name, country, browser_name, platform_name, sub_id_1, sub_id_2,
                    sub_id_3, sub_id_4)
                VALUES(var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_clicks, var_unique_clicks, var_publisher_pid, var_region_name, var_city_name, var_country,
                    var_browser_id, var_platform_id, var_sub_id_1, null, null, null);
        END LOOP;

        RETURN var_count;
    END
$$;


ALTER FUNCTION w4api.click_rollup_reindex() OWNER TO w4;

--
-- Name: click_rollup_subid(bigint, bigint, bigint, bigint, bigint, bigint, bigint, text, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_subid(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_subid_rollup_daily
        WHERE
            (doy = arg_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, ''))
        INTO var_rollup_id;
        
        IF (FOUND) THEN
            UPDATE reports_clicks_subid_rollup_daily SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_subid_rollup_daily
                (publisher_id, campaign_id, advertiser_id, publisher_pid, total_clicks, unique_clicks, sub_id_1, sub_id_2, sub_id_3, sub_id_4, doy)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, arg_publisher_pid, arg_clicks, arg_unique_clicks, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_doy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_subid(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) OWNER TO w4;

--
-- Name: click_rollup_subid_hourly(bigint, bigint, bigint, bigint, bigint, bigint, bigint, text, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_subid_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_subid_rollup_hourly
        WHERE
            (hoy = arg_hoy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, ''))
        INTO var_rollup_id;
        
        IF (FOUND) THEN
            UPDATE reports_clicks_subid_rollup_hourly SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_subid_rollup_hourly
                (publisher_id, campaign_id, advertiser_id, publisher_pid, total_clicks, unique_clicks, sub_id_1, sub_id_2, sub_id_3, sub_id_4, hoy)
                VALUES(arg_publisher_id, arg_campaign_id, arg_advertiser_id, arg_publisher_pid, arg_clicks, arg_unique_clicks, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_hoy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_subid_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) OWNER TO w4;

--
-- Name: click_rollup_wide(bigint, bigint, bigint, bigint, bigint, bigint, bigint, text, text, text, bigint, bigint, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_wide(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_browser_id bigint DEFAULT NULL::bigint, arg_platform_id bigint DEFAULT NULL::bigint, arg_base_uri text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_creative_id bigint DEFAULT (0)::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_wide_rollup_daily
        WHERE
            (doy = arg_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(browser_name, '') = COALESCE(arg_browser_id::text,'')) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (COALESCE(platform_name, '') = COALESCE(arg_platform_id::text, '')) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (COALESCE(base_uri, '') = COALESCE(arg_base_uri, '')) AND
            (COALESCE(creative_id, 0) = COALESCE(arg_creative_id, 0))
        INTO var_rollup_id;
        
        IF (FOUND) THEN
            UPDATE reports_clicks_wide_rollup_daily SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_wide_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_clicks, unique_clicks, browser_name, platform_name, country, region_name, city_name, sub_id_1,
                    sub_id_2, sub_id_3, sub_id_4, base_uri, doy, creative_id)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_clicks, arg_unique_clicks, arg_browser_id::text, arg_platform_id::text,
                     arg_country, arg_region_name, arg_city_name, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_base_uri, arg_doy, arg_creative_id);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_wide(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text, arg_browser_id bigint, arg_platform_id bigint, arg_base_uri text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_creative_id bigint) OWNER TO w4;

--
-- Name: click_rollup_wide_hourly(bigint, bigint, bigint, bigint, bigint, bigint, bigint, text, text, text, bigint, bigint, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_rollup_wide_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_browser_id bigint DEFAULT NULL::bigint, arg_platform_id bigint DEFAULT NULL::bigint, arg_base_uri text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_creative_id bigint DEFAULT (0)::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;

    BEGIN
        SELECT
            id
        FROM reports_clicks_wide_rollup_hourly
        WHERE
            (hoy = arg_hoy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(browser_name, '') = COALESCE(arg_browser_id::text,'')) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (COALESCE(platform_name, '') = COALESCE(arg_platform_id::text, '')) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (COALESCE(base_uri, '') = COALESCE(arg_base_uri, '')) AND
            (COALESCE(creative_id, 0) = COALESCE(arg_creative_id, 0))
        INTO var_rollup_id;
        
        IF (FOUND) THEN
            UPDATE reports_clicks_wide_rollup_hourly SET
                total_clicks = total_clicks + arg_clicks,
                unique_clicks = unique_clicks + arg_unique_clicks
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reports_clicks_wide_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_clicks, unique_clicks, browser_name, platform_name, country, region_name, city_name, sub_id_1,
                    sub_id_2, sub_id_3, sub_id_4, base_uri, hoy, creative_id)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_clicks, arg_unique_clicks, arg_browser_id::text, arg_platform_id::text,
                     arg_country, arg_region_name, arg_city_name, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_base_uri, arg_hoy, arg_creative_id);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.click_rollup_wide_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_clicks bigint, arg_unique_clicks bigint, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text, arg_browser_id bigint, arg_platform_id bigint, arg_base_uri text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_creative_id bigint) OWNER TO w4;

--
-- Name: click_test_create(text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_test_create(arg_url text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN     
        INSERT INTO engine_click_tests
            (url)
            VALUES (arg_url)
            RETURNING id
            INTO var_id;
        RETURN var_id;
    END;
$$;


ALTER FUNCTION w4api.click_test_create(arg_url text) OWNER TO w4;

--
-- Name: click_test_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_test_get(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_result json;
    BEGIN     
        SELECT result FROM engine_click_tests WHERE id = arg_id INTO var_result;
        RETURN var_result;
    END;
$$;


ALTER FUNCTION w4api.click_test_get(arg_id bigint) OWNER TO w4;

--
-- Name: click_test_update(bigint, json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_test_update(arg_id bigint, arg_result json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN     
        UPDATE engine_click_tests SET result = arg_result where id = arg_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.click_test_update(arg_id bigint, arg_result json) OWNER TO w4;

--
-- Name: click_validation_get(bigint, bigint, text, text, text, text, text, text, text, text, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION click_validation_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_ip text, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_testing boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_campaign vw_engine_campaign;
        var_campaign_caps campaign_caps;
        var_publisher json;
        var_total_payout NUMERIC;
        var_total_convs BIGINT;
        var_int_convs BIGINT;
        var_int_payout NUMERIC;
        var_sub_id_1 text;
        var_sub_id_2 text;
        var_sub_id_3 text;
        var_sub_id_4 text;
        var_error_messages text[];
        var_error_message text;
        var_ret_val json;

    BEGIN
        PERFORM * FROM banned_ips WHERE ip = arg_ip::inet;
        IF (FOUND) THEN
            var_error_message = '{"code": "ipBanned", "message": "IP address is banned for ' || arg_ip || '."}';
            var_error_messages := array_append(var_error_messages, var_error_message);
            IF (NOT arg_testing) THEN
                RETURN ('{"error_messages": ' || array_to_json(var_error_messages) || '}')::json;
            END IF;
        END IF;

        SELECT * FROM vw_engine_campaign WHERE id = arg_campaign_id INTO var_campaign;
        IF (NOT FOUND) THEN
            var_error_message = '{"code": "noCampaignMatch", "message": "No campaign found for ' || arg_campaign_id || '."}';
            var_error_messages := array_append(var_error_messages, var_error_message);
            IF (NOT arg_testing) THEN
                RETURN ('{"error_messages": ' || array_to_json(var_error_messages) || '}')::json;
            END IF;
        ELSE
            IF (var_campaign.status != 'active') THEN
                var_error_message = '{"code": "campaignNotActive", "message": "Campaign is not active for ' || arg_campaign_id || '."}';
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_testing) THEN
                    RETURN (
                        '{' ||
                            '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                            ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                        || '}'
                    )::json;
                END IF;
            END IF;

            IF (var_campaign.start_date > CURRENT_TIMESTAMP) THEN
                var_error_message = '{"code": "campaignNotStarted", "message": "The campaign has not started yet."}';
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_testing) THEN
                    RETURN (
                        '{' ||
                            '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                            ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                        || '}'
                    )::json;
                END IF;
            END IF;

            IF (var_campaign.expiry_date < CURRENT_TIMESTAMP) THEN
                var_error_message = '{"code": "campaignExpired", "message": "The campaign has expired."}';
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_testing) THEN
                    RETURN (
                        '{' ||
                            '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                            ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                        || '}'
                    )::json;
                END IF;
            END IF;

            PERFORM * FROM advertisers WHERE id = var_campaign.advertiser_id AND status = 'active';
            IF (NOT FOUND) THEN
                var_error_message = '{"code": "noActiveAdvertiser", "message": "No active advertiser exists for ' || var_campaign.advertiser_id || '."}';
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_testing) THEN
                    RETURN (
                        '{' ||
                            '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                            ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                        || '}'
                    )::json;
                END IF;
            END IF;            

            IF (var_campaign.access_type != 1) THEN
                PERFORM * FROM campaign_assigned_publishers WHERE campaign_id = arg_campaign_id AND publisher_id = arg_publisher_id AND status = 'approved';
                IF (var_campaign.access_type = 2) THEN
                    IF (NOT FOUND) THEN
                        var_error_message = '{"code": "noPubAccess", "message": "Publisher does not have access to this private campaign."}';
                        var_error_messages := array_append(var_error_messages, var_error_message);
                        IF (NOT arg_testing) THEN
                            RETURN (
                                '{' ||
                                    '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                                    ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                                || '}'
                            )::json;
                        END IF;
                    END IF;
                ELSE
                    IF (NOT FOUND) THEN
                        var_error_message = '{"code": "noPubAccess", "message": "Publisher does not have access to this by approval campaign."}';
                        var_error_messages := array_append(var_error_messages, var_error_message);
                        IF (NOT arg_testing) THEN
                            RETURN (
                                '{' ||
                                    '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                                    ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                                || '}'
                            )::json;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END IF;
        SELECT row_to_json(row) FROM (
            SELECT
                u.id, u.access, u.active, u.parent_id, up.tier_id
            FROM users u
            LEFT JOIN user_profiles up ON (u.id = up.user_id)
            WHERE u.id = arg_publisher_id AND access = 'publisher' AND active = 'active' LIMIT 1
        ) row INTO var_publisher;
        IF (NOT FOUND) THEN
            --@todo remove: temp catch for all unknown publisher ids to be used during hitpath transition
            arg_publisher_id = 100001;
            SELECT row_to_json(row) FROM (
                SELECT
                    u.id, u.access, u.active, u.parent_id, up.tier_id
                FROM users u
                LEFT JOIN user_profiles up ON (u.id = up.user_id)
                WHERE u.id = arg_publisher_id AND access = 'publisher' AND active = 'active' LIMIT 1
            ) row INTO var_publisher;
            IF (NOT FOUND) THEN
                var_error_message = '{"code": "noPubMatch", "message": "Publisher not found for ID ' || arg_publisher_id || '."}';
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_testing) THEN
                    RETURN (
                        '{' ||
                            '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                            ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                        || '}'
                    )::json;
                END IF;
            END IF;
        END IF;

        IF (var_campaign.advertiser_id IS NOT NULL) THEN
            PERFORM
                id
            FROM advertiser_banned_publishers
            WHERE
                (advertiser_id = var_campaign.advertiser_id) AND
                (publisher_id = arg_publisher_id) AND
                (campaign_id = arg_campaign_id OR COALESCE(campaign_id,0) = 0) AND
                ((COALESCE(sub_id_1, '') = '') OR (sub_id_1 = arg_sub_id_1)) AND
                ((COALESCE(sub_id_2, '') = '') OR (sub_id_2 = arg_sub_id_2)) AND
                ((COALESCE(sub_id_3, '') = '') OR (sub_id_3 = arg_sub_id_3)) AND
                ((COALESCE(sub_id_4, '') = '') OR (sub_id_4 = arg_sub_id_4));

            IF (FOUND) THEN
                var_error_message = '{"code": "pubBanned", "message": "The publisher ID ' || arg_publisher_id || ' is banned by the advertiser ID ' || var_campaign.advertiser_id || '."}';
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_testing) THEN
                    RETURN (
                        '{' ||
                            '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                            ', "publisher": ' || COALESCE(var_publisher, '{}') ||                
                            ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                        || '}'
                    )::json;
                END IF;
            END IF;
        END IF;

        PERFORM * FROM campaign_geotargeting WHERE campaign_id = arg_campaign_id;
        IF (FOUND) THEN
            PERFORM * FROM campaign_geotargeting WHERE
                campaign_id = arg_campaign_id AND
                country = arg_country AND
                (region IS NULL OR region = arg_region_name) AND
                (city IS NULL OR city = arg_city_name);
            IF (NOT FOUND) THEN
                var_error_message = '{"code": "geoTargetMiss", "message": "There is no geo targeting for the country ' || COALESCE(arg_country, '') || ', region ' || COALESCE(arg_region_name, '') || ', and city ' || 
                    COALESCE(arg_city_name, '') || '."}';
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_testing) THEN
                    RETURN (
                        '{' ||
                            '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                            ', "publisher": ' || COALESCE(var_publisher, '{}') ||                
                            ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
                        || '}'
                    )::json;
                END IF;
            END IF;
        END IF;
 
        var_ret_val := (
            '{' ||
                '"campaign": ' || COALESCE(row_to_json(var_campaign), '{}') ||
                ', "publisher": ' || COALESCE(var_publisher, '{}') ||                
                ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
            || '}'
        )::json;

        RETURN var_ret_val;
    END
$$;


ALTER FUNCTION w4api.click_validation_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_ip text, arg_region_name text, arg_city_name text, arg_country text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_testing boolean) OWNER TO w4;

--
-- Name: contacts_create_missing(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION contacts_create_missing() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
        var_email text;
        var_first_name text;
        var_last_name text;
        var_address_1 text;
        var_address_2 text;
        var_city text;
        var_state text;
        var_zip text;
        var_country text;
        var_phone text;
        var_cell text;
        var_messenger_id text;
        var_messenger_type text;
        var_primary_contact_id bigint;

    BEGIN
        FOR var_id, var_email, var_first_name, var_last_name, var_address_1, var_address_2, var_city, var_state, var_zip, var_country, var_phone, var_cell, var_messenger_id, var_messenger_type
            IN select u.id, u.email, up.first_name, up.last_name, up.address_1, up.address_2, up.city, up.state, up.zip, up.country, up.phone, up.cell, up.messenger_id, up.messenger_type
            from users u left join user_profiles up on (u.id=up.user_id) where u.primary_contact_id is null LOOP
                INSERT INTO contacts
                    (first_name, last_name, address_1, address_2, city_name, postal_code, messenger_name,
                        messenger_type, primary_phone, secondary_phone, email_address)
                    VALUES (var_first_name, var_last_name, var_address_1, var_address_2, var_city, var_zip, var_messenger_id,
                        var_messenger_type, var_phone, var_cell, var_email)
                    RETURNING id
                    INTO var_primary_contact_id;
                UPDATE users SET primary_contact_id=var_primary_contact_id WHERE id=var_id;
                    
        END LOOP;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.contacts_create_missing() OWNER TO w4;

--
-- Name: conversion_advertiser_cap_get(bigint, numeric); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_advertiser_cap_get(arg_campaign_id bigint, arg_payin numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_advertiser_id bigint;
        var_advertiser_name text;
        var_credit_limit double precision;
        var_credit_limit_per text;
        var_manager_id bigint;
        var_credit_used numeric := 0;
        var_oy int;
        /*var_receiver json;
        var_content text;
        var_message_return boolean;
        var_notification_where text := '';*/

    BEGIN
        SELECT advertiser_id FROM campaigns WHERE id = arg_campaign_id INTO var_advertiser_id;
        SELECT name, credit_limit, credit_limit_per, manager_id
            FROM advertisers
            WHERE id = var_advertiser_id AND credit_limit >= .01 AND allow_over_limit = 'no'
            INTO var_advertiser_name, var_credit_limit, var_credit_limit_per, var_manager_id;
        IF (FOUND) THEN
            CASE var_credit_limit_per
                WHEN 'hour' THEN
                    var_oy := make_hoy(CURRENT_TIMESTAMP);
                    SELECT SUM(payin) FROM (
                        SELECT SUM(total_pay_in) AS payin FROM reports_conversions_rollup_hourly WHERE advertiser_id = var_advertiser_id AND hoy = var_oy
                        UNION SELECT SUM(payin) AS payin FROM engine_conversions_rollup_queue WHERE advertiser_id = var_advertiser_id AND make_hoy(created_date) = var_oy
                    ) AS ag_and_new
                    INTO var_credit_used;
                    --var_notification_where := where_clause_build('notification date', 'make_hoy(notification_date) = ' || var_oy, var_notification_where);
                WHEN 'day' THEN
                    var_oy := make_doy(CURRENT_TIMESTAMP);
                    SELECT COALESCE(SUM(payin)::numeric, 0) FROM (
                        SELECT SUM(total_pay_in) AS payin FROM reports_conversions_rollup_daily WHERE advertiser_id = var_advertiser_id AND doy = var_oy
                        UNION SELECT SUM(payin) AS payin FROM engine_conversions_rollup_queue WHERE advertiser_id = var_advertiser_id AND make_doy(created_date) = var_oy
                    ) AS ag_and_new
                    INTO var_credit_used;
                    --var_notification_where := where_clause_build('notification date', 'make_doy(notification_date) = ' || var_oy, var_notification_where);
                WHEN 'week' THEN
                    var_oy := make_doy(CURRENT_TIMESTAMP);
                    SELECT SUM(payin) FROM (
                        SELECT SUM(total_pay_in) AS payin
                            FROM reports_conversions_rollup_daily
                            WHERE
                                advertiser_id = var_advertiser_id AND
                                doy >= make_doy(date_trunc('week', CURRENT_TIMESTAMP)::date) AND
                                doy <= make_doy((date_trunc('week', CURRENT_TIMESTAMP) + '6 days'::interval)::date)
                        UNION SELECT SUM(payin) AS payin FROM engine_conversions_rollup_queue WHERE advertiser_id = var_advertiser_id AND make_doy(created_date) = var_oy
                    ) AS ag_and_new
                    INTO var_credit_used;
                    --var_notification_where := where_clause_build('notification date', 'make_doy(notification_date) >= make_doy(date_trunc(''week'', CURRENT_TIMESTAMP)::date) AND make_doy(notification_date) <= make_doy((date_trunc(''week'', CURRENT_TIMESTAMP) + ''6 days''::interval)::date)', var_notification_where);
                WHEN 'month' THEN
                    var_oy := make_moy(CURRENT_TIMESTAMP);
                    SELECT SUM(payin) FROM (
                        SELECT SUM(total_pay_in) AS payin FROM reports_conversions_rollup_monthly WHERE advertiser_id = var_advertiser_id AND doy = var_oy
                        UNION SELECT SUM(payin) AS payin FROM engine_conversions_rollup_queue WHERE advertiser_id = var_advertiser_id AND make_moy(created_date) = var_oy
                    ) AS ag_and_new
                    INTO var_credit_used;
                    --var_notification_where := where_clause_build('notification date', 'make_moy(notification_date) = ' || var_oy, var_notification_where);
                WHEN 'year' THEN
                    var_oy := make_y(CURRENT_TIMESTAMP);
                    SELECT SUM(payin) FROM (
                        SELECT SUM(total_pay_in) AS payin FROM reports_conversions_rollup_yearly WHERE advertiser_id = var_advertiser_id AND doy = var_oy
                        UNION SELECT SUM(payin) AS payin FROM engine_conversions_rollup_queue WHERE advertiser_id = var_advertiser_id AND make_y(created_date) = var_oy
                    ) AS ag_and_new
                    INTO var_credit_used;
                    --var_notification_where := where_clause_build('notification date', 'make_y(notification_date) = ' || var_oy, var_notification_where);
                WHEN 'alltime' THEN
                    SELECT SUM(total_pay_in) FROM reports_conversions_rollup_yearly WHERE advertiser_id = var_advertiser_id INTO var_credit_used;
            END CASE;

            /*IF (var_credit_limit / (var_credit_used + arg_payin) >= .8) THEN
                var_notification_where := where_clause_build('advertiser id', 'advertiser_id = ' || var_advertiser_id, var_notification_where);
                EXECUTE 'PERFORM * FROM advertiser_cap_notification ' || var_notification_where;
                IF (NOT FOUND) THEN
                    var_receiver := '{"recipients": [' || var_manager_id || ']}';
                    var_content := '<p>Advertiser <a target=''_blank'' href=''http://app.w4dev.net/advertisers/view/id/' || var_advertiser_id || '''>' || var_advertiser_name || '</a> is
                        at 80% of their credit limit of ' || var_credit_limit::money || ' per ' || var_credit_limit_per || '.</p>';
                    var_message_return := messages_create(0, var_receiver, 4, var_content, 'Advertiser Credit Limit', 1, 4);

                    INSERT INTO advertiser_cap_notification (advertiser_id, notification_date) VALUES (var_advertiser_id, CURRENT_TIMESTAMP);
                END IF;
            END IF;*/
            IF ((var_credit_used + arg_payin) > var_credit_limit) THEN
                RETURN TRUE; --over credit limit
            END IF;
        END IF;

        RETURN FALSE; --not over credit limit

    END
$$;


ALTER FUNCTION w4api.conversion_advertiser_cap_get(arg_campaign_id bigint, arg_payin numeric) OWNER TO w4;

--
-- Name: conversion_aliases_check(bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_aliases_check(arg_id bigint DEFAULT (- (1)::bigint), arg_name text DEFAULT NULL::text, arg_type text DEFAULT 'CPA'::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		var_valid_alias_types text[];
	    BEGIN
		var_valid_alias_types:= ARRAY['CPA','CPC','CPL','CPM'];

		IF((select upper(arg_type) != ALL(var_valid_alias_types))) THEN
			RAISE EXCEPTION 'Invalid Campaign Conversion Alias Type: %. Must be CPA,CPC,CPL, or CPM.', arg_type; 
		END IF;

  	        PERFORM id FROM campaign_conversion_aliases WHERE lower(alias) = lower(arg_name) AND id != arg_id;  ---- CHECK IF alias ALREADY EXISTS 
		IF(FOUND) THEN
			RAISE EXCEPTION 'A Campaign Conversion Alias named "%" already exists.', arg_name; 
		END IF;  
	
		RETURN true;	  
    END;
$$;


ALTER FUNCTION w4api.conversion_aliases_check(arg_id bigint, arg_name text, arg_type text) OWNER TO w4;

--
-- Name: conversion_aliases_create(text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_aliases_create(arg_name text, arg_type text) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		var_new_id integer;
	    BEGIN
	    IF((SELECT w4api.conversion_aliases_check(arg_name:=arg_name,arg_type:=arg_type))<> true) THEN RETURN ('{}'); END IF;
	    INSERT INTO campaign_conversion_aliases(
	        alias
		,alias_type
		)
	    VALUES(
	        arg_name 
		,upper(arg_type)    
		) RETURNING id INTO var_new_id;
	RETURN  ('{' || '"new": ' || (SELECT w4api.conversion_aliases_get_list(var_new_id)) || '}')::json;
    END;
$$;


ALTER FUNCTION w4api.conversion_aliases_create(arg_name text, arg_type text) OWNER TO w4;

--
-- Name: conversion_aliases_get(bigint, text, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_aliases_get(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_type text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
		var_count_json text :='';
	    BEGIN	        
		IF arg_count THEN
		     var_count_json:= ', "count": ' || (SELECT w4api.conversion_aliases_get_list(
			arg_id:=arg_id,
			arg_name:=arg_name,
			arg_type:=arg_type,
			arg_count:=true))::text;
		END IF;
		ret_val := ('{"results": ' || (SELECT w4api.conversion_aliases_get_list(
			arg_id:=arg_id,
			arg_name:=arg_name,
			arg_orderby:=arg_orderby,
			arg_limit:=arg_limit,
			arg_offset:=arg_offset)) || var_count_json  || '}')::json;
	RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.conversion_aliases_get(arg_id bigint, arg_name text, arg_type text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: conversion_aliases_get_list(bigint, text, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_aliases_get_list(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_type text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
   ret_val json;
   where_clause text := ''; 
   order_clause text := ''; 
    BEGIN
	where_clause := w4_automatic_functions.where_clause_build(arg_id::TEXT, ' id = ' || arg_id, where_clause);
	where_clause := w4_automatic_functions.where_clause_build(arg_name::TEXT, ' alias = ''' || arg_name||'''', where_clause);
	where_clause := w4_automatic_functions.where_clause_build(arg_name::TEXT, ' alias_type = ''' || arg_type||'''', where_clause);
	order_clause := order_clause_build(arg_orderby,'name asc');
	IF(arg_count) THEN  
	     EXECUTE
		'SELECT COALESCE (COUNT(1), 0) 
			FROM ( SELECT id FROM campaign_conversion_aliases' 
		     || where_clause ||' ) AS count'
		INTO ret_val;			
	 ELSE 
	     EXECUTE
		'SELECT array_to_json (array_agg(row_to_json (results)))
		    FROM (        
			SELECT row_to_json (row)
			    FROM ( 
				SELECT 
				   id 
				  ,alias AS name
				  ,alias_type AS type                          
				FROM campaign_conversion_aliases' 
				|| where_clause
				|| order_clause
				|| ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
				|| ' OFFSET ' || arg_offset || '
			    ) row
			) results'
		INTO ret_val;
	    END IF;
	RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.conversion_aliases_get_list(arg_id bigint, arg_name text, arg_type text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: conversion_aliases_update(bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_aliases_update(arg_id bigint, arg_name text DEFAULT NULL::text, arg_type text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
	    BEGIN

	IF((SELECT w4api.conversion_aliases_check(arg_id,arg_name,arg_type))<> true) THEN RETURN ('{}');
	END IF;
	PERFORM alias FROM campaign_conversion_aliases WHERE id = arg_id;    ----- CHECK IF VALID ID
	 IF(NOT FOUND) THEN
		RAISE EXCEPTION 'A Campaign Conversion Alias was not found for id:%.', arg_id; 
	   ELSE      
		UPDATE campaign_conversion_aliases SET
			  alias = COALESCE(arg_name,alias),
			  alias_type = COALESCE(upper(arg_type),alias_type,'CPA')
			WHERE id = arg_id;
		END IF;
			ret_val := ('{ "results": ' || (SELECT w4api.conversion_aliases_get_list(arg_id := arg_id)) || '}')::json;
		RETURN ret_val;	  
    END;
$$;


ALTER FUNCTION w4api.conversion_aliases_update(arg_id bigint, arg_name text, arg_type text) OWNER TO w4;

--
-- Name: conversion_base_call_create(text, text, text, text, bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_base_call_create(arg_url_path text, arg_url_args text, arg_ip text DEFAULT NULL::text, arg_cookie text DEFAULT NULL::text, arg_click_id bigint DEFAULT NULL::bigint, arg_ref_id text DEFAULT NULL::text, arg_failure text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN     
        INSERT INTO engine_conversions_calls
            (url_path, url_args, cookie, created_date, failure, click_id, conversion_ip, hitpath_ref_id)
            VALUES (arg_url_path, arg_url_args, arg_cookie, CURRENT_TIMESTAMP, arg_failure, arg_click_id, arg_ip, arg_ref_id)
            RETURNING id
            INTO var_id;
        RETURN var_id;
    END;
$$;


ALTER FUNCTION w4api.conversion_base_call_create(arg_url_path text, arg_url_args text, arg_ip text, arg_cookie text, arg_click_id bigint, arg_ref_id text, arg_failure text) OWNER TO w4;

--
-- Name: conversion_base_call_update(bigint, bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_base_call_update(arg_id bigint, arg_conversion_id bigint DEFAULT NULL::bigint, arg_ip text DEFAULT NULL::text, arg_failure text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        INSERT INTO engine_conversions_calls_success
            (conversion_call_id, conversion_id, failure, created_date)
            VALUES (arg_id, arg_conversion_id, arg_failure, CURRENT_TIMESTAMP);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.conversion_base_call_update(arg_id bigint, arg_conversion_id bigint, arg_ip text, arg_failure text) OWNER TO w4;

--
-- Name: conversion_recover_subset_load(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_recover_subset_load() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_conversion_id bigint;
        convclickid bigint;
        convpayin money;
        convpayout money;
        convparentpayout money;
        convcampaignid bigint;
        convpublisherid bigint;
        convparentpublisherid bigint;
        convreferralurl text;
        convcreativeid integer;
        convipaddress inet;
        convcontinent character varying;
        convcountry character varying;
        convregion character varying;
        convregionname character varying;
        convcity character varying;
        convpostalcode character varying;
        convlatitude double precision;
        convlongitude double precision;
        convmetrocode integer;
        convareacode integer;
        convbrowserid integer;
        convplatformid integer;
        convchannel integer;
        convrefid text;
        convcreateddate timestamp with time zone;
        convmodifieddate timestamp with time zone;
        clkstatus int;
        var_advertiser_id bigint;
        var_sub_id_1 text;
        var_sub_id_2 text;
        var_sub_id_3 text;
        var_sub_id_4 text;

    BEGIN

        FOR convclickid, convpayin, convpayout, convparentpayout, convcampaignid, convpublisherid, convparentpublisherid, convreferralurl, convcreativeid,
                    convipaddress, convcontinent, convcountry, convregion, convregionname, convcity, convpostalcode, convlatitude, convlongitude, convmetrocode, convareacode,
                    convbrowserid, convplatformid, convchannel, convmodifieddate, convcreateddate, convrefid IN
            SELECT
                click_id, payin, payout, parent_payout, campaign_id, publisher_id, parent_publisher_id, referral_url, creative_id, ip_address, continent, country,
                    region, region_name, city, postal_code, latitude, longitude, metro_code, area_code, browser_id, platform_id, channel, modified_date, created_date, advertiser_refid
            FROM engine_conversions_tmp
            ORDER BY id ASC
        LOOP
            select advertiser_id from campaigns where id = convcampaignid INTO var_advertiser_id;
            select sub_id_1, sub_id_2, sub_id_3, sub_id_4 from engine_clicks where id=convclickid INTO var_sub_id_1, var_sub_id_2, var_sub_id_3, var_sub_id_4;
            INSERT INTO engine_conversions
                (click_id, payin, payout, parent_payout, campaign_id, publisher_id, parent_publisher_id, referral_url, creative_id, ip_address, continent, country,
                    region, region_name, city, postal_code, latitude, longitude, metro_code, area_code, browser_id, platform_id, status, channel, modified_date, created_date, advertiser_refid)
                VALUES (convclickid, convpayin, convpayout, convparentpayout, convcampaignid, convpublisherid, convparentpublisherid, convreferralurl, convcreativeid,
                    convipaddress, convcontinent, convcountry, convregion, convregionname, convcity, convpostalcode, convlatitude, convlongitude, convmetrocode, convareacode,
                    convbrowserid, convplatformid, 1, convchannel, convmodifieddate, convcreateddate, convrefid)
                RETURNING id
                INTO var_conversion_id;

            INSERT INTO engine_conversions_rollup_queue
                (conversion_id, campaign_id, advertiser_id, publisher_id, parent_publisher_id, creative_id, country, region_name, city, browser_id, platform_id, payin,
                    payout, sub_id_1, sub_id_2, sub_id_3, sub_id_4, created_date, base_uri, rollup_id)
                VALUES (var_conversion_id, convcampaignid, var_advertiser_id, convpublisherid, convparentpublisherid, convcreativeid, convcountry, convregionname, convcity,
                    convbrowserid, convplatformid, convpayin, convpayout, var_sub_id_1, var_sub_id_2, var_sub_id_3, var_sub_id_4, convcreateddate, convreferralurl, NULL);

        END LOOP;



        RETURN true;
    END
$$;


ALTER FUNCTION w4api.conversion_recover_subset_load() OWNER TO w4;

--
-- Name: conversion_rollup(bigint, bigint, bigint, timestamp with time zone, money, money, bigint, text, text, text, bigint, bigint, text, text, text, text, text, bigint, bigint, money, money); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_created_date timestamp with time zone, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_browser_id bigint DEFAULT NULL::bigint, arg_platform_id bigint DEFAULT NULL::bigint, arg_base_uri text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_creative_id bigint DEFAULT (0)::bigint, arg_conversion_delta bigint DEFAULT (1)::bigint, arg_payin_delta money DEFAULT NULL::money, arg_payout_delta money DEFAULT NULL::money) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := COALESCE(arg_payin_delta, arg_payin);
        var_payout_delta money := COALESCE(arg_payout_delta, arg_payout);
        var_profit_delta money := var_payin_delta - var_payout_delta;
        var_doy bigint := make_doy(arg_created_date);

    BEGIN
        --Click Rollup Daily Aggregate
        SELECT
            id
        FROM reporting.reports_conversions_rollup_daily
        WHERE
            (doy = var_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_rollup_daily SET
                total_conversions = total_conversions + arg_conversion_delta,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, doy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversion_delta, arg_payin, arg_payout, arg_payin,
                    arg_payout, var_profit_delta, var_doy);
        END IF;

        --Conversion Geo Rollup Daily Aggregate
        SELECT
            id
        FROM reporting.reports_conversions_geo_rollup_daily
        WHERE
            (doy = var_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_geo_rollup_daily SET
                total_conversions = total_conversions + arg_conversion_delta,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_geo_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, country,
                    region_name, city_name, doy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversion_delta, arg_payin, arg_payout, arg_payin,
                    arg_payout, var_profit_delta, arg_country, arg_region_name, arg_city_name, var_doy);
        END IF;

        --Conversion Subid Rollup Daily Aggregate
        SELECT
            id
        FROM reporting.reports_conversions_subid_rollup_daily
        WHERE
            (doy = var_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_id, -1)) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_subid_rollup_daily SET
                total_conversions = total_conversions + arg_conversion_delta,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_subid_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, sub_id_1,
                    sub_id_2, sub_id_3, sub_id_4, doy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversion_delta, arg_payin, arg_payout, arg_payin,
                    arg_payout, var_profit_delta, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, var_doy);
        END IF;

        --Conversion Wide Rollup Daily Aggregate
        SELECT
            id
        FROM reporting.reports_conversions_wide_rollup_daily
        WHERE
            (doy = var_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(browser_name, '') = COALESCE(arg_browser_id, -1)::text)  AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name,'') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (COALESCE(platform_name, '') = COALESCE(arg_platform_id, 0)::text) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (COALESCE(base_uri, '') = COALESCE(arg_base_uri, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout) AND
            (COALESCE(creative_id, 0) = COALESCE(arg_creative_id, 0))
        INTO var_rollup_id;
        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_wide_rollup_daily SET
                total_conversions = total_conversions + arg_conversion_delta,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_wide_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, browser_name,
                    platform_name, country, region_name, city_name, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, doy, creative_id)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversion_delta, arg_payin, arg_payout, arg_payin,
                    arg_payout, var_profit_delta, arg_browser_id, arg_platform_id, arg_country, arg_region_name, arg_city_name, arg_sub_id_1, arg_sub_id_2,
                    arg_sub_id_3, arg_sub_id_4, arg_base_uri, var_doy, arg_creative_id);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_created_date timestamp with time zone, arg_payin money, arg_payout money, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text, arg_browser_id bigint, arg_platform_id bigint, arg_base_uri text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_creative_id bigint, arg_conversion_delta bigint, arg_payin_delta money, arg_payout_delta money) OWNER TO w4;

--
-- Name: conversion_rollup_batch_create(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_batch_create() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_publisher_id bigint;
        var_campaign_id bigint;
        var_advertiser_id bigint;
        var_hoy bigint;
        var_publisher_pid bigint;
        var_region_name text;
        var_city_name text;
        var_country text;
        var_browser_id bigint;
        var_platform_id bigint;
        var_base_uri text;
        var_sub_id_1 text;
        var_creative_id bigint;
        var_payin money;
        var_payout money;
        var_conversions bigint;
        var_payin_delta money;
        var_payout_delta money;
        var_profit_delta money;


    BEGIN
        --Find any non-rolled up conversions and assign them the current rollup id
        var_rollup_id := nextval( 'engine_conversions_rollup_id_seq' );
        UPDATE engine_conversions_rollup_queue SET rollup_id = var_rollup_id WHERE rollup_id IS NULL AND make_hoy(created_date) <= make_hoy(CURRENT_TIMESTAMP - INTERVAL '1 hour');
        IF (FOUND) THEN
            INSERT INTO engine_conversions_rollup
                (id, start_time, status)
                VALUES (var_rollup_id, CURRENT_TIMESTAMP, 'pending');
        END IF;

        SELECT id FROM engine_conversions_rollup WHERE status='pending' ORDER BY start_time ASC LIMIT 1 INTO var_rollup_id;
        IF (FOUND) THEN
            UPDATE engine_conversions_rollup SET status = 'processing' WHERE id = var_rollup_id;
            --Store conversions in temporay table to make aggregates from
            DROP TABLE IF EXISTS conversion_rollup_temp;            
            CREATE TEMPORARY TABLE conversion_rollup_temp ON COMMIT DROP AS
                SELECT
                    conversion_id,
                    publisher_id,
                    campaign_id,
                    advertiser_id,
                    make_hoy(created_date) AS hoy,
                    parent_publisher_id,
                    region_name,
                    city,
                    country,
                    browser_id,
                    platform_id,
                    base_uri,
                    sub_id_1,
                    creative_id,
                    payin,
                    payout
                FROM engine_conversions_rollup_queue
                WHERE rollup_id = var_rollup_id;
            CREATE INDEX conversion_rollup_temp_publisher_id_idx ON conversion_rollup_temp (publisher_id);
            CREATE INDEX conversion_rollup_temp_campaign_id_idx ON conversion_rollup_temp (campaign_id);
            CREATE INDEX conversion_rollup_temp_advertiser_id_idx ON conversion_rollup_temp (advertiser_id);
            CREATE INDEX conversion_rollup_temp_hoy_idx ON conversion_rollup_temp (hoy);
            CREATE INDEX conversion_rollup_temp_parent_publisher_id_idx ON conversion_rollup_temp (parent_publisher_id);
            CREATE INDEX conversion_rollup_temp_region_name_idx ON conversion_rollup_temp (region_name);
            CREATE INDEX conversion_rollup_temp_city_idx ON conversion_rollup_temp (city);
            CREATE INDEX conversion_rollup_temp_country_idx ON conversion_rollup_temp (country);
            CREATE INDEX conversion_rollup_temp_browser_id_idx ON conversion_rollup_temp (browser_id);
            CREATE INDEX conversion_rollup_temp_platform_id_idx ON conversion_rollup_temp (platform_id);
            CREATE INDEX conversion_rollup_temp_sub_id_1_idx ON conversion_rollup_temp (sub_id_1);
            CREATE INDEX conversion_rollup_temp_creative_id_idx ON conversion_rollup_temp (creative_id);
            CREATE INDEX conversion_rollup_temp_payin_idx ON conversion_rollup_temp (payin);
            CREATE INDEX conversion_rollup_temp_payout_idx ON conversion_rollup_temp (payout);

            --Entity Rollup
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_payin, var_payout, var_conversions IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    payin,
                    payout,
                    count(conversion_id) AS conversions
                FROM conversion_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, payin, payout
            LOOP
                var_payin_delta := var_payin * var_conversions;
                var_payout_delta := var_payout * var_conversions;
                var_profit_delta := var_payin_delta - var_payout_delta;
                INSERT INTO reporting.reports_conversions_rollup_hourly
                    (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, hoy)
                    VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_conversions, var_payin_delta, var_payout_delta, var_payin,
                        var_payout, var_profit_delta, var_hoy);
            END LOOP;
 
            --Geo rollup
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_payin, var_payout, var_conversions, var_region_name, var_city_name, var_country IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    payin,
                    payout,
                    count(conversion_id) AS conversions,
                    region_name,
                    city,
                    country
                FROM conversion_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, payin, payout, region_name, city, country
            LOOP
                var_payin_delta := var_payin * var_conversions;
                var_payout_delta := var_payout * var_conversions;
                var_profit_delta := var_payin_delta - var_payout_delta;
                INSERT INTO reporting.reports_conversions_geo_rollup_hourly
                    (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, country,
                        region_name, city_name, hoy)
                    VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_conversions, var_payin_delta, var_payout_delta, var_payin,
                        var_payout, var_profit_delta, var_country, var_region_name, var_city_name, var_hoy);
            END LOOP;

            --Sub id rollup
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_payin, var_payout, var_conversions, var_sub_id_1 IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    payin,
                    payout,
                    count(conversion_id) AS conversions,
                    sub_id_1
                FROM conversion_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, payin, payout, sub_id_1
            LOOP
                var_payin_delta := var_payin * var_conversions;
                var_payout_delta := var_payout * var_conversions;
                var_profit_delta := var_payin_delta - var_payout_delta;
                INSERT INTO reporting.reports_conversions_subid_rollup_hourly
                    (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, sub_id_1, hoy)
                    VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_conversions, var_payin_delta, var_payout_delta, var_payin,
                        var_payout, var_profit_delta, var_sub_id_1, var_hoy);
            END LOOP;

            --Wide rollup
            FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_payin, var_payout, var_conversions, var_creative_id IN
                SELECT
                    publisher_id,
                    MAX(parent_publisher_id) AS parent_publisher_id,
                    campaign_id,
                    advertiser_id,
                    hoy,
                    payin,
                    payout,
                    count(conversion_id) AS conversions,
                    creative_id
                FROM conversion_rollup_temp
                GROUP BY publisher_id, campaign_id, advertiser_id, hoy, payin, payout, creative_id
            LOOP
                var_payin_delta := var_payin * var_conversions;
                var_payout_delta := var_payout * var_conversions;
                var_profit_delta := var_payin_delta - var_payout_delta;
                INSERT INTO reporting.reports_conversions_wide_rollup_hourly
                    (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, hoy, creative_id)
                    VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_conversions, var_payin_delta, var_payout_delta, var_payin,
                        var_payout, var_profit_delta, var_hoy, var_creative_id);

            END LOOP;

            DELETE FROM engine_conversions_rollup_queue WHERE rollup_id = var_rollup_id;
            UPDATE engine_conversions_rollup SET status = 'complete', stop_time = CURRENT_TIMESTAMP WHERE id = var_rollup_id;
        END IF;
     
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_batch_create() OWNER TO w4;

--
-- Name: conversion_rollup_entity(bigint, bigint, bigint, bigint, bigint, money, money, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_entity(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_rollup_daily
        WHERE
            (doy = arg_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_rollup_daily SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, doy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_doy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_entity(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint) OWNER TO w4;

--
-- Name: conversion_rollup_entity_hourly(bigint, bigint, bigint, bigint, bigint, money, money, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_entity_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_rollup_hourly
        WHERE
            (hoy = arg_hoy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_rollup_hourly SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, hoy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_hoy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_entity_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint) OWNER TO w4;

--
-- Name: conversion_rollup_entity_monthly(bigint, bigint, bigint, bigint, bigint, money, money, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_entity_monthly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_moy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_rollup_monthly
        WHERE
            (moy = arg_moy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_rollup_monthly SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_rollup_monthly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, moy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_moy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_entity_monthly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_moy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint) OWNER TO w4;

--
-- Name: conversion_rollup_entity_yearly(bigint, bigint, bigint, bigint, bigint, money, money, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_entity_yearly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_y bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_rollup_yearly
        WHERE
            (y = arg_y) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_rollup_yearly SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_rollup_yearly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, y)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_y);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_entity_yearly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_y bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint) OWNER TO w4;

--
-- Name: conversion_rollup_geo(bigint, bigint, bigint, bigint, bigint, money, money, bigint, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_geo(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_geo_rollup_daily
        WHERE
            (doy = arg_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_geo_rollup_daily SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_geo_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, country,
                    region_name, city_name, doy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_country, arg_region_name, arg_city_name, arg_doy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_geo(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text) OWNER TO w4;

--
-- Name: conversion_rollup_geo_hourly(bigint, bigint, bigint, bigint, bigint, money, money, bigint, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_geo_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_geo_rollup_hourly
        WHERE
            (hoy = arg_hoy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name, '') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_geo_rollup_hourly SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_geo_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, country,
                    region_name, city_name, hoy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_country, arg_region_name, arg_city_name, arg_hoy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_geo_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text) OWNER TO w4;

--
-- Name: conversion_rollup_queue_create(bigint, bigint, bigint, bigint, money, money, timestamp with time zone, bigint, text, text, text, bigint, bigint, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_queue_create(arg_conversion_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_payin money, arg_payout money, arg_created_date timestamp with time zone, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_browser_id bigint DEFAULT NULL::bigint, arg_platform_id bigint DEFAULT NULL::bigint, arg_base_uri text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_creative_id bigint DEFAULT (0)::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        IF (
            arg_conversion_id < 1 OR
            arg_publisher_id < 1 OR
            arg_campaign_id < 1 OR
            arg_advertiser_id < 1 OR
            arg_conversion_id IS NULL OR
            arg_publisher_id IS NULL OR
            arg_campaign_id IS NULL OR
            arg_advertiser_id IS NULL
        ) THEN
            RAISE EXCEPTION 'All the following values must be set. conversion id: %, publisher id %, campaign id %, and advertiser id %.', arg_conversion_id, arg_publisher_id, arg_campaign_id, arg_advertiser_id; 
        END IF;

        INSERT INTO engine_conversions_rollup_queue
            (conversion_id, campaign_id, advertiser_id, publisher_id, parent_publisher_id, creative_id, country, region_name, city, browser_id, platform_id, payin,
                payout, sub_id_1, sub_id_2, sub_id_3, sub_id_4, created_date, base_uri, rollup_id)
            VALUES (arg_conversion_id, arg_campaign_id, arg_advertiser_id, arg_publisher_id, arg_publisher_pid, arg_creative_id, arg_country, arg_region_name, arg_city_name,
                arg_browser_id, arg_platform_id, arg_payin, arg_payout, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_created_date, arg_base_uri, NULL);
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_queue_create(arg_conversion_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_payin money, arg_payout money, arg_created_date timestamp with time zone, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text, arg_browser_id bigint, arg_platform_id bigint, arg_base_uri text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_creative_id bigint) OWNER TO w4;

--
-- Name: conversion_rollup_redo(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_redo() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_publisher_id bigint;
        var_campaign_id bigint;
        var_advertiser_id bigint;
        var_hoy bigint;
        var_publisher_pid bigint;
        var_region_name text;
        var_city_name text;
        var_country text;
        var_browser_id bigint;
        var_platform_id bigint;
        var_base_uri text;
        var_sub_id_1 text;
        var_creative_id bigint;
        var_payin money;
        var_payout money;
        var_conversions bigint;
        var_payin_delta money;
        var_payout_delta money;
        var_profit_delta money;

    BEGIN

        DROP TABLE IF EXISTS conversion_rollup_temp;            
        CREATE TEMPORARY TABLE conversion_rollup_temp ON COMMIT DROP AS
            SELECT
                e.id AS conversion_id,
                e.publisher_id,
                e.campaign_id,
                c.advertiser_id,
                make_hoy(e.created_date) AS hoy,
                e.parent_publisher_id,
                e.region_name,
                e.city,
                e.country,
                e.browser_id,
                e.platform_id,
                e.referral_url AS base_uri,
                ec.sub_id_1,
                e.creative_id,
                e.payin,
                e.payout
            FROM engine_conversions e
            LEFT JOIN engine_clicks ec ON e.click_id = ec.id
            LEFT JOIN campaigns c ON e.campaign_id=c.id
            WHERE e.status = 1;
        CREATE INDEX conversion_rollup_temp_publisher_id_idx ON conversion_rollup_temp (publisher_id);
        CREATE INDEX conversion_rollup_temp_campaign_id_idx ON conversion_rollup_temp (campaign_id);
        CREATE INDEX conversion_rollup_temp_advertiser_id_idx ON conversion_rollup_temp (advertiser_id);
        CREATE INDEX conversion_rollup_temp_hoy_idx ON conversion_rollup_temp (hoy);
        CREATE INDEX conversion_rollup_temp_parent_publisher_id_idx ON conversion_rollup_temp (parent_publisher_id);
        CREATE INDEX conversion_rollup_temp_region_name_idx ON conversion_rollup_temp (region_name);
        CREATE INDEX conversion_rollup_temp_city_idx ON conversion_rollup_temp (city);
        CREATE INDEX conversion_rollup_temp_country_idx ON conversion_rollup_temp (country);
        CREATE INDEX conversion_rollup_temp_browser_id_idx ON conversion_rollup_temp (browser_id);
        CREATE INDEX conversion_rollup_temp_platform_id_idx ON conversion_rollup_temp (platform_id);
        CREATE INDEX conversion_rollup_temp_sub_id_1_idx ON conversion_rollup_temp (sub_id_1);
        CREATE INDEX conversion_rollup_temp_creative_id_idx ON conversion_rollup_temp (creative_id);
        CREATE INDEX conversion_rollup_temp_payin_idx ON conversion_rollup_temp (payin);
        CREATE INDEX conversion_rollup_temp_payout_idx ON conversion_rollup_temp (payout);

        TRUNCATE engine_conversions_rollup_queue;
        UPDATE engine_conversions_rollup SET status = 'complete', stop_time = CURRENT_TIMESTAMP;

        --Entity Rollup
        TRUNCATE reports_conversions_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_payin, var_payout, var_conversions IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                payin,
                payout,
                count(conversion_id) AS conversions
            FROM conversion_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, payin, payout
        LOOP
            var_payin_delta := var_payin * var_conversions;
            var_payout_delta := var_payout * var_conversions;
            var_profit_delta := var_payin_delta - var_payout_delta;
            INSERT INTO reporting.reports_conversions_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, hoy)
                VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_conversions, var_payin_delta, var_payout_delta, var_payin,
                    var_payout, var_profit_delta, var_hoy);
        END LOOP;

        --Geo rollup
        TRUNCATE reports_conversions_geo_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_payin, var_payout, var_conversions, var_region_name, var_city_name, var_country IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                payin,
                payout,
                count(conversion_id) AS conversions,
                region_name,
                city,
                country
            FROM conversion_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, payin, payout, region_name, city, country
        LOOP
            var_payin_delta := var_payin * var_conversions;
            var_payout_delta := var_payout * var_conversions;
            var_profit_delta := var_payin_delta - var_payout_delta;
            INSERT INTO reporting.reports_conversions_geo_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, country,
                    region_name, city_name, hoy)
                VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_conversions, var_payin_delta, var_payout_delta, var_payin,
                    var_payout, var_profit_delta, var_country, var_region_name, var_city_name, var_hoy);
        END LOOP;

        --Sub id rollup
        TRUNCATE reports_conversions_subid_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_payin, var_payout, var_conversions, var_sub_id_1 IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                payin,
                payout,
                count(conversion_id) AS conversions,
                sub_id_1
            FROM conversion_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, payin, payout, sub_id_1
        LOOP
            var_payin_delta := var_payin * var_conversions;
            var_payout_delta := var_payout * var_conversions;
            var_profit_delta := var_payin_delta - var_payout_delta;
            INSERT INTO reporting.reports_conversions_subid_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, sub_id_1, hoy)
                VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_conversions, var_payin_delta, var_payout_delta, var_payin,
                    var_payout, var_profit_delta, var_sub_id_1, var_hoy);
        END LOOP;

        --Wide rollup
        TRUNCATE reports_conversions_wide_rollup_hourly RESTART IDENTITY;
        FOR var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_hoy, var_payin, var_payout, var_conversions, var_creative_id IN
            SELECT
                publisher_id,
                MAX(parent_publisher_id) AS parent_publisher_id,
                campaign_id,
                advertiser_id,
                hoy,
                payin,
                payout,
                count(conversion_id) AS conversions,
                creative_id
            FROM conversion_rollup_temp
            GROUP BY publisher_id, campaign_id, advertiser_id, hoy, payin, payout, creative_id
        LOOP
            var_payin_delta := var_payin * var_conversions;
            var_payout_delta := var_payout * var_conversions;
            var_profit_delta := var_payin_delta - var_payout_delta;
            INSERT INTO reporting.reports_conversions_wide_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, hoy, creative_id)
                VALUES(var_publisher_id, var_publisher_pid, var_campaign_id, var_advertiser_id, var_conversions, var_payin_delta, var_payout_delta, var_payin,
                    var_payout, var_profit_delta, var_hoy, var_creative_id);

        END LOOP;


     
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_redo() OWNER TO w4;

--
-- Name: conversion_rollup_subid(bigint, bigint, bigint, bigint, bigint, money, money, bigint, text, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_subid(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_subid_rollup_daily
        WHERE
            (doy = arg_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_id, -1)) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_subid_rollup_daily SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_subid_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, sub_id_1,
                    sub_id_2, sub_id_3, sub_id_4, doy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_doy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_subid(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) OWNER TO w4;

--
-- Name: conversion_rollup_subid_hourly(bigint, bigint, bigint, bigint, bigint, money, money, bigint, text, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_subid_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_subid_rollup_hourly
        WHERE
            (hoy = arg_hoy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_id, -1)) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout)
        INTO var_rollup_id;

        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_subid_rollup_hourly SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_subid_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, sub_id_1,
                    sub_id_2, sub_id_3, sub_id_4, hoy)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3, arg_sub_id_4, arg_hoy);
        END IF;

        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_subid_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) OWNER TO w4;

--
-- Name: conversion_rollup_wide(bigint, bigint, bigint, bigint, bigint, money, money, bigint, text, text, text, bigint, bigint, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_wide(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_browser_id bigint DEFAULT NULL::bigint, arg_platform_id bigint DEFAULT NULL::bigint, arg_base_uri text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_creative_id bigint DEFAULT (0)::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_wide_rollup_daily
        WHERE
            (doy = arg_doy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(browser_name, '') = COALESCE(arg_browser_id, -1)::text)  AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name,'') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (COALESCE(platform_name, '') = COALESCE(arg_platform_id, 0)::text) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (COALESCE(base_uri, '') = COALESCE(arg_base_uri, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout) AND
            (COALESCE(creative_id, 0) = COALESCE(arg_creative_id, 0))
        INTO var_rollup_id;
        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_wide_rollup_daily SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_wide_rollup_daily
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, browser_name,
                    platform_name, country, region_name, city_name, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, doy, creative_id)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_browser_id, arg_platform_id, arg_country, arg_region_name, arg_city_name, arg_sub_id_1, arg_sub_id_2,
                    arg_sub_id_3, arg_sub_id_4, arg_base_uri, arg_doy, arg_creative_id);
        END IF;
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_wide(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_doy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text, arg_browser_id bigint, arg_platform_id bigint, arg_base_uri text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_creative_id bigint) OWNER TO w4;

--
-- Name: conversion_rollup_wide_hourly(bigint, bigint, bigint, bigint, bigint, money, money, bigint, text, text, text, bigint, bigint, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_rollup_wide_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_country text DEFAULT NULL::text, arg_browser_id bigint DEFAULT NULL::bigint, arg_platform_id bigint DEFAULT NULL::bigint, arg_base_uri text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_creative_id bigint DEFAULT (0)::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_rollup_id bigint;
        var_payin_delta money := arg_payin * arg_conversions;
        var_payout_delta money := arg_payout * arg_conversions;
        var_profit_delta money := var_payin_delta - var_payout_delta;

    BEGIN
        SELECT
            id
        FROM reporting.reports_conversions_wide_rollup_hourly
        WHERE
            (hoy = arg_hoy) AND
            (advertiser_id = arg_advertiser_id) AND
            (campaign_id = arg_campaign_id) AND
            (publisher_id = arg_publisher_id) AND
            (COALESCE(publisher_pid, -1) = COALESCE(arg_publisher_pid, -1)) AND
            (COALESCE(browser_name, '') = COALESCE(arg_browser_id, -1)::text)  AND
            (COALESCE(country, '') = COALESCE(arg_country, '')) AND
            (COALESCE(region_name,'') = COALESCE(arg_region_name, '')) AND
            (COALESCE(city_name, '') = COALESCE(arg_city_name, '')) AND
            (COALESCE(platform_name, '') = COALESCE(arg_platform_id, 0)::text) AND
            (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, '')) AND
            (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, '')) AND
            (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, '')) AND
            (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')) AND
            (COALESCE(base_uri, '') = COALESCE(arg_base_uri, '')) AND
            (payin_amount = arg_payin) AND
            (payout_amount = arg_payout) AND
            (COALESCE(creative_id, 0) = COALESCE(arg_creative_id, 0))
        INTO var_rollup_id;
        IF (FOUND) THEN
            UPDATE reporting.reports_conversions_wide_rollup_hourly SET
                total_conversions = total_conversions + arg_conversions,
                total_pay_in = total_pay_in + var_payin_delta,
                total_pay_out = total_pay_out + var_payout_delta,
                profit = profit + var_profit_delta
            WHERE id = var_rollup_id;
        ELSE
            INSERT INTO reporting.reports_conversions_wide_rollup_hourly
                (publisher_id, publisher_pid, campaign_id, advertiser_id, total_conversions, total_pay_in, total_pay_out, payin_amount, payout_amount, profit, browser_name,
                    platform_name, country, region_name, city_name, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, hoy, creative_id)
                VALUES(arg_publisher_id, arg_publisher_pid, arg_campaign_id, arg_advertiser_id, arg_conversions, var_payin_delta, var_payout_delta, arg_payin,
                    arg_payout, var_profit_delta, arg_browser_id, arg_platform_id, arg_country, arg_region_name, arg_city_name, arg_sub_id_1, arg_sub_id_2,
                    arg_sub_id_3, arg_sub_id_4, arg_base_uri, arg_hoy, arg_creative_id);
        END IF;
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.conversion_rollup_wide_hourly(arg_publisher_id bigint, arg_campaign_id bigint, arg_advertiser_id bigint, arg_hoy bigint, arg_conversions bigint, arg_payin money, arg_payout money, arg_publisher_pid bigint, arg_region_name text, arg_city_name text, arg_country text, arg_browser_id bigint, arg_platform_id bigint, arg_base_uri text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_creative_id bigint) OWNER TO w4;

--
-- Name: conversion_update(bigint, money, money, smallint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_update(arg_conversion_id bigint, arg_payin money DEFAULT NULL::money, arg_payout money DEFAULT NULL::money, arg_status smallint DEFAULT NULL::smallint, arg_admin_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_publisher_id bigint;
        var_campaign_id bigint;
        var_advertiser_id bigint;
        var_hoy bigint;
        var_doy bigint;
        var_moy bigint;
        var_yoy bigint;
        var_payin money;
        var_payout money;
        var_publisher_pid bigint;
        var_region_name text;
        var_city_name text;
        var_country text;
        var_browser_id bigint;
        var_platform_id bigint;
        var_base_uri text;
        var_sub_id_1 text;
        var_sub_id_2 text;
        var_sub_id_3 text;
        var_sub_id_4 text;
        var_creative_id bigint;
        var_payin_delta money;
        var_payout_delta money;
        var_conversion_delta bigint := 0;
        var_rollup_results boolean;
        var_status smallint;


    BEGIN
        SELECT
            con.publisher_id,
            con.campaign_id,
            cmp.advertiser_id,
            make_hoy(con.created_date) AS hoy,
            make_doy(con.created_date) AS doy,
            make_moy(con.created_date) AS moy,
            make_y(con.created_date) AS yoy,
            con.payin,
            con.payout,
            con.parent_publisher_id,
            con.region_name,
            con.city,
            con.country,
            con.browser_id,
            con.platform_id,
            con.ip_address,
            clk.sub_id_1,
            clk.sub_id_2,
            clk.sub_id_3,
            clk.sub_id_4,
            con.creative_id,
            con.status
        FROM engine_conversions con
        LEFT JOIN engine_clicks clk ON clk.id = con.click_id 
        LEFT JOIN campaigns cmp ON cmp.id = con.campaign_id
        WHERE con.id = arg_conversion_id
        INTO var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_doy, var_moy, var_yoy, var_payin, var_payout, var_publisher_pid, var_region_name, var_city_name, var_country,
            var_browser_id, var_platform_id, var_base_uri, var_sub_id_1, var_sub_id_2, var_sub_id_3, var_sub_id_4, var_creative_id, var_status;

        IF (FOUND) THEN
            PERFORM * FROM acct_invoices_publisher WHERE publisher_id = var_publisher_id AND var_doy BETWEEN min_doy AND max_doy;
            IF (FOUND) THEN
                RAISE EXCEPTION 'Invoice has already been paid for the conversion that you are attempting to change.';
            END IF;

            UPDATE engine_conversions SET
                payin = COALESCE(arg_payin, payin),
                payout = COALESCE(arg_payout, payout),
                status = COALESCE(arg_status, status)
            WHERE id = arg_conversion_id;

            INSERT INTO engine_conversions_manual
                (conversion_id, admin_id, status, payin, payout, manual_type)
                VALUES (arg_conversion_id, arg_admin_id, arg_status, arg_payin, arg_payout, 'update');

            --Do we have a change in status?
            IF (arg_status IS NOT NULL AND arg_status != var_status) THEN
                var_payin_delta := var_payin;
                var_payout_delta := var_payout;
                --An accept on a former reject.
                IF (arg_status < 50 AND var_status >= 50) THEN
                    var_conversion_delta := 1;
                --A reject on a former accept.
                ELSEIF (arg_status >= 50 AND var_status < 50) THEN
                    var_conversion_delta := -1;
                END IF;
            ELSE
                IF (arg_payin != var_payin OR arg_payout != var_payout) THEN
                    var_payin_delta := var_payin;
                    var_payout_delta := var_payout;
                    var_conversion_delta := -1;
                    PERFORM conversion_rollup_entity (var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid);
                    PERFORM conversion_rollup_entity_hourly (var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid);
                    PERFORM conversion_rollup_entity_monthly (var_publisher_id, var_campaign_id, var_advertiser_id, var_moy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid);
                    PERFORM conversion_rollup_entity_yearly (var_publisher_id, var_campaign_id, var_advertiser_id, var_yoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid);
                    PERFORM conversion_rollup_geo (var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid, var_region_name, var_city_name, var_country);
                    PERFORM conversion_rollup_geo_hourly (var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid, var_region_name, var_city_name, var_country);
                    PERFORM conversion_rollup_subid (var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid, var_sub_id_1, var_sub_id_2, var_sub_id_3, var_sub_id_4);
                    PERFORM conversion_rollup_subid_hourly (var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid, var_sub_id_1, var_sub_id_2, var_sub_id_3, var_sub_id_4);
                    PERFORM conversion_rollup_wide (var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid, var_region_name, var_city_name, var_country, var_browser_id, var_platform_id, var_base_uri, var_sub_id_1, var_sub_id_2, var_sub_id_3,
                        var_sub_id_4, var_creative_id);
                    PERFORM conversion_rollup_wide_hourly (var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                        var_publisher_pid, var_region_name, var_city_name, var_country, var_browser_id, var_platform_id, var_base_uri, var_sub_id_1, var_sub_id_2, var_sub_id_3,
                        var_sub_id_4, var_creative_id);

                    var_payin_delta := arg_payin;
                    var_payout_delta := arg_payout;
                    var_conversion_delta := 1;
                ELSE
                    --No change
                    RETURN TRUE;
                END IF;
            END IF;

            PERFORM conversion_rollup_entity (var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid);
            PERFORM conversion_rollup_entity_hourly (var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid);
            PERFORM conversion_rollup_entity_monthly (var_publisher_id, var_campaign_id, var_advertiser_id, var_moy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid);
            PERFORM conversion_rollup_entity_yearly (var_publisher_id, var_campaign_id, var_advertiser_id, var_yoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid);
            PERFORM conversion_rollup_geo (var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid, var_region_name, var_city_name, var_country);
            PERFORM conversion_rollup_geo_hourly (var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid, var_region_name, var_city_name, var_country);
            PERFORM conversion_rollup_subid (var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid, var_sub_id_1, var_sub_id_2, var_sub_id_3, var_sub_id_4);
            PERFORM conversion_rollup_subid_hourly (var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid, var_sub_id_1, var_sub_id_2, var_sub_id_3, var_sub_id_4);
            PERFORM conversion_rollup_wide (var_publisher_id, var_campaign_id, var_advertiser_id, var_doy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid, var_region_name, var_city_name, var_country, var_browser_id, var_platform_id, var_base_uri, var_sub_id_1, var_sub_id_2, var_sub_id_3,
                var_sub_id_4, var_creative_id);
            PERFORM conversion_rollup_wide_hourly (var_publisher_id, var_campaign_id, var_advertiser_id, var_hoy, var_conversion_delta, var_payin_delta, var_payout_delta,
                var_publisher_pid, var_region_name, var_city_name, var_country, var_browser_id, var_platform_id, var_base_uri, var_sub_id_1, var_sub_id_2, var_sub_id_3,
                var_sub_id_4, var_creative_id);
     
        ELSE
            RAISE EXCEPTION 'No conversion found with the id: %', arg_conversion_id;
        END IF;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.conversion_update(arg_conversion_id bigint, arg_payin money, arg_payout money, arg_status smallint, arg_admin_id bigint) OWNER TO w4;

--
-- Name: conversion_validation_get(bigint, text, text, boolean, boolean, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_validation_get(arg_click_id bigint, arg_ip text, arg_ref_id text DEFAULT NULL::text, arg_pixel_test boolean DEFAULT false, arg_performance boolean DEFAULT false, arg_campaign_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_click_id bigint;
        var_campaign_id bigint;
        var_publisher_id bigint;
        var_parent_publisher_id bigint;
        var_creative_id bigint;
        var_sub_id_1 text;
        var_sub_id_2 text;
        var_sub_id_3 text;
        var_sub_id_4 text;
        var_ip text;
        var_click json;
        var_campaign json;
        var_publisher json;
        var_error_messages text[];
        var_error_message text;
        var_ret_val json;

    BEGIN
        PERFORM * FROM banned_ips WHERE ip = arg_ip::inet;
        IF (FOUND) THEN
            var_error_message = 'IP address is banned for ' || arg_ip;
            var_error_messages := array_append(var_error_messages, var_error_message);
            IF (NOT arg_performance) THEN
                RETURN array_to_json(var_error_messages);
            END IF;
        END IF;

        IF (arg_pixel_test) THEN
            var_campaign_id := arg_campaign_id;
            var_publisher_id := arg_publisher_id;
        ELSE
            SELECT
                id, campaign_id, publisher_id, parent_publisher_id, creative_id, sub_id_1, sub_id_2, sub_id_3, sub_id_4, ip_address
            FROM engine_clicks
            WHERE id = arg_click_id OR (hitpath_ref_id = arg_ref_id AND hitpath_ref_id IS NOT NULL)
            INTO var_click_id, var_campaign_id, var_publisher_id, var_parent_publisher_id, var_creative_id, var_sub_id_1, var_sub_id_2, var_sub_id_3, var_sub_id_4, var_ip;
            IF (NOT FOUND) THEN
                var_error_message = 'No click found for ID ' || arg_click_id;
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_performance) THEN
                    RETURN array_to_json(var_error_messages);
                END IF;
            ELSE
                SELECT row_to_json(row) FROM (SELECT var_click_id AS click_id, var_campaign_id AS campaign_id, var_publisher_id AS publisher_id, var_parent_publisher_id AS parent_publisher_id, var_creative_id AS creative_id,
                    var_sub_id_1 AS sub_id_1, var_sub_id_2 AS sub_id_2, var_sub_id_3 AS sub_id_3, var_sub_id_4 AS sub_id_4, var_ip AS ip) row INTO var_click;
            END IF;
        END IF;

        SELECT row_to_json(row) FROM (
            SELECT default_payout, payout_type, default_payin, payin_type, advertiser_id, tracking_type, allow_postback_payin, tracking_secure FROM campaigns WHERE id = var_campaign_id AND status = 'active'
        ) row INTO var_campaign;
        IF (NOT FOUND) THEN
            var_error_message = 'No campaign found for ' || var_campaign_id;
            var_error_messages := array_append(var_error_messages, var_error_message);
            IF (NOT arg_performance) THEN
                RETURN array_to_json(var_error_messages);
            END IF;
        END IF;

        SELECT row_to_json(row) FROM (
            SELECT
                u.id, u.access, u.active, u.parent_id, up.tier_id
            FROM users u
            LEFT JOIN user_profiles up ON (u.id = up.user_id)
            WHERE u.id = var_publisher_id AND access = 'publisher' AND active = 'active' LIMIT 1
        ) row INTO var_publisher;
        IF (NOT FOUND) THEN
            --@todo remove: temp catch for all unknown publisher ids to be used during hitpath transition
            var_publisher_id := 100001;
            SELECT row_to_json(row) FROM (
                SELECT
                    u.id, u.access, u.active, u.parent_id, up.tier_id
                FROM users u
                LEFT JOIN user_profiles up ON (u.id = up.user_id)
                WHERE u.id = arg_publisher_id AND access = 'publisher' AND active = 'active' LIMIT 1
            ) row INTO var_publisher;
            IF (NOT FOUND) THEN
                var_error_message = 'Publisher not found for ID ' || arg_publisher_id;
                var_error_messages := array_append(var_error_messages, var_error_message);
                IF (NOT arg_performance) THEN
                    RETURN array_to_json(var_error_messages);
                END IF;
            END IF;
        END IF;
 
        var_ret_val := (
            '{' ||
                '"click": ' || COALESCE(var_click, '{}') ||
                ', "campaign": ' || COALESCE(var_campaign, '{}') ||
                ', "publisher": ' || COALESCE(var_publisher, '{}') ||                
                ', "error_messages": ' || COALESCE(array_to_json(var_error_messages), '[]')
            || '}'
        )::json;

        RETURN var_ret_val;
    END
$$;


ALTER FUNCTION w4api.conversion_validation_get(arg_click_id bigint, arg_ip text, arg_ref_id text, arg_pixel_test boolean, arg_performance boolean, arg_campaign_id bigint, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: conversion_wait_create(public.conversion_wait_reasons, bigint, money, money, money, bigint, bigint, bigint, text, integer, inet, character varying, character varying, character varying, character varying, character varying, character varying, double precision, double precision, integer, integer, integer, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_wait_create(arg_reason public.conversion_wait_reasons, arg_clickid bigint, arg_payin money, arg_payout money, arg_parentpayout money, arg_campaignid bigint, arg_publisherid bigint, arg_parentpublisherid bigint, arg_referralurl text, arg_creativeid integer, arg_ipaddress inet, arg_continent character varying, arg_country character varying, arg_region character varying, arg_regionname character varying, arg_city character varying, arg_postalcode character varying, arg_latitude double precision, arg_longitude double precision, arg_metrocode integer, arg_areacode integer, arg_browserid integer, arg_platformid integer, arg_channel integer, arg_date timestamp with time zone DEFAULT now()) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val BIGINT;
        rows_mod INTEGER;
        adv advertisers;
        adv_balance NUMERIC;
        camp campaigns;
        ccap campaign_caps;
        clks BIGINT;
        clkscnt BIGINT;

    BEGIN
        ret_val := check_campaign_eligible(arg_campaignid, arg_publisherid, arg_creativeid);
        IF (ret_val < 0) THEN
            RETURN ('{"conversion_id": ' || ret_val || '}')::json;
        END IF;

        IF (arg_clickid > 1) THEN
            SELECT INTO clkscnt count(*) FROM engine_conversions WHERE click_id = arg_clickid;
            IF (clkscnt > 0) THEN
                RETURN ('{"conversion_id": -5}')::json;
            END IF;
	END IF;

        SELECT INTO adv * FROM advertisers av WHERE av.id = (SELECT advertiser_id FROM campaigns cmp WHERE cmp.id = arg_campaignid);
        SELECT INTO adv_balance SUM(total_credit_used) FROM vw_adv_cpg_balances WHERE advertiser_id = adv.id GROUP BY advertiser_id;
        IF (adv.credit_limit::numeric > 0.01) THEN
            IF ((arg_payin::numeric + adv_balance::numeric) > adv.credit_limit::numeric) AND adv.allow_over_limit = 'no' THEN
                RETURN ('{"conversion_id": -6}')::json;
            END IF;
        END IF;

        ret_val:=nextval('public.engine_conversions_id_seq');
        INSERT INTO engine_conversions_waiting
            (id, click_id, payin, payout, parent_payout, campaign_id, publisher_id, parent_publisher_id, referral_url, creative_id, ip_address, continent, country,
                region, region_name, city, postal_code, latitude, longitude, metro_code, area_code, browser_id, platform_id, status, channel, modified_date, created_date)
            VALUES (ret_val,arg_clickid, arg_payin, arg_payout, arg_parentpayout, arg_campaignid, arg_publisherid, arg_parentpublisherid, arg_referralurl, arg_creativeid,
                arg_ipaddress, arg_continent, arg_country, arg_region, arg_regionname, arg_city, arg_postalcode, arg_latitude, arg_longitude, arg_metrocode, arg_areacode,
                arg_browserid, arg_platformid, 1, arg_channel,arg_date,arg_date);
        RETURN ('{"conversion_id": ' || ret_val || ', "created_date": "' || arg_date || '"}')::json;
    END;
$$;


ALTER FUNCTION w4api.conversion_wait_create(arg_reason public.conversion_wait_reasons, arg_clickid bigint, arg_payin money, arg_payout money, arg_parentpayout money, arg_campaignid bigint, arg_publisherid bigint, arg_parentpublisherid bigint, arg_referralurl text, arg_creativeid integer, arg_ipaddress inet, arg_continent character varying, arg_country character varying, arg_region character varying, arg_regionname character varying, arg_city character varying, arg_postalcode character varying, arg_latitude double precision, arg_longitude double precision, arg_metrocode integer, arg_areacode integer, arg_browserid integer, arg_platformid integer, arg_channel integer, arg_date timestamp with time zone) OWNER TO w4;

--
-- Name: conversion_wait_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION conversion_wait_get(arg_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;

    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    click_id,
                    payin::numeric,
                    payout::numeric,
                    parent_payout,
                    campaign_id,
                    publisher_id,
                    parent_publisher_id,
                    referral_url,
                    creative_id,
                    ip_address,
                    continent,
                    country,
                    region,
                    region_name,
                    city,
                    postal_code,
                    latitude,
                    longitude,
                    metro_code,
                    area_code,
                    browser_id,
                    platform_id,
                    status,
                    channel
                FROM engine_conversions_waiting
                WHERE click_id = arg_id
            ) row
        INTO retval;
        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.conversion_wait_get(arg_id bigint) OWNER TO w4;

--
-- Name: creative_redirect_url_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION creative_redirect_url_get(arg_creative_id bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_redirect_url text;

    BEGIN

        SELECT redirect_url FROM creatives WHERE id = arg_creative_id INTO var_redirect_url;

        RETURN var_redirect_url;
    END
$$;


ALTER FUNCTION w4api.creative_redirect_url_get(arg_creative_id bigint) OWNER TO w4;

--
-- Name: dashboard_leaderboard_get(timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION dashboard_leaderboard_get(arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT NULL::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            var_count text := '';
	BEGIN
		
		IF arg_count THEN
			var_count := ',"count": ' || dashboard_leaderboard_get_count( arg_min_date, arg_max_date, arg_currency_id );
		END IF;

		RETURN 
		(
		    '{' ||
			    '"results": ' || dashboard_leaderboard_get_list( arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset ) || 
			    var_count ||
		    '}'
		)::json;
      END
$$;


ALTER FUNCTION w4api.dashboard_leaderboard_get(arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: dashboard_leaderboard_get_count(timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION dashboard_leaderboard_get_count(arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
	BEGIN

		RETURN
			COUNT(*)
			
		FROM
		(
			SELECT
				1
				
			FROM
				reports_daily rd
				
			LEFT JOIN
				campaigns c ON rd.campaign_id = c.id
				
			WHERE
				c.currency_id = arg_currency_id AND
				( arg_min_date IS NULL OR rd.doy >= make_doy( arg_min_date ) ) AND
				( arg_max_date IS NULL OR rd.doy <  make_doy( arg_max_date ) )

			GROUP BY
				rd.campaign_id, c.name
		) x;

	END;
$$;


ALTER FUNCTION w4api.dashboard_leaderboard_get_count(arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: dashboard_leaderboard_get_list(timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION dashboard_leaderboard_get_list(arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
	DECLARE
	
		retval json;
		
	BEGIN

		arg_orderby := orderby( COALESCE( arg_orderby, 'revenue DESC' ) );

		EXECUTE 
			'SELECT array_to_json( array_agg( row_to_json( r.* ) ) ) FROM
			(
				SELECT
					row_number() OVER () as row,
					s.*
				FROM
				(
					SELECT
						s.*
					FROM
					(
						SELECT
							rd.campaign_id, 
							c.name AS campaign_name, 
							COALESCE( SUM( total_pay_in - total_pay_out ), 0 )AS revenue
						FROM
							reports_daily rd
							
						LEFT JOIN
							campaigns c ON rd.campaign_id = c.id

						WHERE
							c.currency_id = $3 AND
							( $1 IS NULL OR rd.doy >= make_doy( $1 ) ) AND
							( $2 IS NULL OR rd.doy <  make_doy( $2 ) )

						GROUP BY
							rd.campaign_id, c.name

					) s
							
					ORDER BY
						' || arg_orderby || ', campaign_id ASC

					LIMIT
						$4

					OFFSET
						$5
				) s
			) r;'

		INTO
			retval
			
		USING
			arg_min_date,
			arg_max_date,
			arg_currency_id,
			arg_limit,
			arg_offset;

		RETURN COALESCE( retval, '[]'::json );

	END;
$_$;


ALTER FUNCTION w4api.dashboard_leaderboard_get_list(arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: dashboard_overview_get(timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION dashboard_overview_get(arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        var_total_clicks bigint := 0;
        var_unique_clicks bigint := 0;
        var_conversions bigint := 0;
        var_rate numeric := 0;
        var_total_in numeric := 0;
        var_total_out numeric := 0;
        var_profit numeric := 0;
        var_margin numeric := 0;
        var_epc numeric := 0;
        

    BEGIN	
        
        SELECT
            COALESCE( SUM( total_clicks ), 0 ) AS total_clicks,
            COALESCE( SUM( unique_clicks ), 0 ) AS unique_clicks,
            COALESCE( SUM( total_conversions ), 0 ) AS conversions,
            COALESCE( SUM( total_conversions ) / NULLIF(SUM(unique_clicks), 0) * 100, 0 ) AS rate,
            COALESCE( SUM( total_pay_in ), 0 ) AS total_in,
            COALESCE( SUM( total_pay_out ), 0 ) AS total_out,
            COALESCE( SUM( total_pay_in - total_pay_out ), 0 ) AS profit,
            COALESCE( 1 - SUM( total_pay_out ) / NULLIF(SUM( total_pay_in ), 0 ), 0) * 100 AS margin,
            COALESCE( SUM( total_pay_out ) / NULLIF(SUM( unique_clicks ), 0 ), 0)AS epc
        FROM
            reports_daily rd

        LEFT JOIN
            campaigns c ON c.id = rd.campaign_id
        WHERE
            c.currency_id = arg_currency_id AND
            ( arg_min_date IS NULL OR doy >= make_doy( arg_min_date ) ) AND 
            ( arg_max_date IS NULL OR doy <  make_doy( arg_max_date ) )
        INTO var_total_clicks, var_unique_clicks, var_conversions, var_rate, var_total_in, var_total_out, var_profit, var_margin, var_epc;

        retval :=
            ('{"results": [' ||
                '{"name": "total_clicks", "value": ' || var_total_clicks || ', "type": "count"}, '
                '{"name": "unique_clicks", "value": ' || var_unique_clicks || ', "type": "count"}, '
                '{"name": "conversions", "value": ' || var_conversions || ', "type": "count"}, '
                '{"name": "rate", "value": ' || var_rate || ', "type": "percent"}, '
                '{"name": "total_in", "value": "' || var_total_in || '", "type": "currency"}, '
                '{"name": "total_out", "value": "' || var_total_out || '", "type": "currency"}, '
                '{"name": "profit", "value": "' || var_profit || '", "type": "currency"}, '
                '{"name": "margin", "value": "' || var_margin || '", "type": "percent"}, '
                '{"name": "pepc", "value": "' || var_epc || '", "type": "currency"}]}'
            )::json;

        RETURN retval;		
    END
$$;


ALTER FUNCTION w4api.dashboard_overview_get(arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: email_queue_get(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION email_queue_get() RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_batch_id bigint;
        var_results json;
        var_queue json;

    BEGIN
        PERFORM * FROM email_queue WHERE batch_id IS NULL;
        IF (FOUND) THEN
            var_batch_id := nextval( 'email_batches_id_seq' );
            UPDATE email_queue SET batch_id = var_batch_id, status = 'processing' WHERE batch_id IS NULL;
            INSERT INTO email_batches
                (id, start_time, status)
                VALUES (var_batch_id, CURRENT_TIMESTAMP, 'processing');

            SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row) FROM (
                            SELECT
                                id AS queue_id,
                                message_id,
                                subject,
                                content,
                                sender,
                                receiver
                            FROM email_queue
                            WHERE batch_id = var_batch_id
                        ) row
                    ) results
            INTO var_queue;
            var_results := '{"batch_id": ' || var_batch_id || ', "queue": ' || var_queue || '}';
        END IF;
     
        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4api.email_queue_get() OWNER TO w4;

--
-- Name: email_queue_update(bigint, public.status_batch); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION email_queue_update(arg_batch_id bigint, arg_status public.status_batch) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        UPDATE email_batches SET status = arg_status, stop_time = CURRENT_TIMESTAMP WHERE id = arg_batch_id;
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.email_queue_update(arg_batch_id bigint, arg_status public.status_batch) OWNER TO w4;

--
-- Name: email_update(bigint, bigint, public.status_batch); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION email_update(arg_queue_id bigint, arg_message_id bigint, arg_batch_status public.status_batch) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        UPDATE email_queue SET status= arg_batch_status WHERE id = arg_queue_id;
        UPDATE messages SET message_status = 2 WHERE id = arg_message_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.email_update(arg_queue_id bigint, arg_message_id bigint, arg_batch_status public.status_batch) OWNER TO w4;

--
-- Name: engine_click_test_id_get(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION engine_click_test_id_get() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        new_id bigint;
    BEGIN
        select MAX(id) + 1 FROM engine_clicks into new_id;
        RETURN new_id;
    END;
$$;


ALTER FUNCTION w4api.engine_click_test_id_get() OWNER TO w4;

--
-- Name: engine_conversion_test_id_get(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION engine_conversion_test_id_get() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        new_id bigint;
    BEGIN
        select MAX(id) + 1 FROM engine_conversions into new_id;
        RETURN new_id;
    END;
$$;


ALTER FUNCTION w4api.engine_conversion_test_id_get() OWNER TO w4;

--
-- Name: engine_redirect_decision_create(bigint, bigint, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION engine_redirect_decision_create(arg_campaign_id bigint, arg_publisher_id bigint, arg_redirect text DEFAULT NULL::text, arg_pixel text DEFAULT NULL::text, arg_failed_reason text DEFAULT NULL::text, arg_click_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN     
        INSERT INTO engine_redirect_decisions
            (click_id, campaign_id, publisher_id, redirect, pixel, failed_reason)
            VALUES (arg_click_id, arg_campaign_id, arg_publisher_id, arg_redirect, arg_pixel, arg_failed_reason);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.engine_redirect_decision_create(arg_campaign_id bigint, arg_publisher_id bigint, arg_redirect text, arg_pixel text, arg_failed_reason text, arg_click_id bigint) OWNER TO w4;

--
-- Name: engine_test_create(bigint, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION engine_test_create(arg_campaign_id bigint, arg_publisher_id bigint, arg_manager_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN
        PERFORM * FROM engine_tests WHERE
            campaign_id = arg_campaign_id AND
            publisher_id = arg_publisher_id AND
            status = 'active' AND
            (created_date + '5 minute'::interval) >= CURRENT_TIMESTAMP AND
            manager_id != arg_manager_id;
        IF (FOUND) THEN
            RAISE EXCEPTION 'Test already in progress.  Please wait for current test to complete.';
        END IF;
        UPDATE engine_tests SET status='inactive' WHERE campaign_id = arg_campaign_id AND publisher_id = arg_publisher_id;

        INSERT INTO engine_tests
            (campaign_id, publisher_id, manager_id, status, created_date)
            VALUES (arg_campaign_id, arg_publisher_id, arg_manager_id, 'active', CURRENT_TIMESTAMP)
            RETURNING id
            INTO var_id;
        RETURN var_id;
    END;
$$;


ALTER FUNCTION w4api.engine_test_create(arg_campaign_id bigint, arg_publisher_id bigint, arg_manager_id bigint) OWNER TO w4;

--
-- Name: engine_test_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION engine_test_get(arg_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;

    BEGIN
        SELECT
            array_to_json (array_agg(row_to_json (results)))
                FROM (
                    SELECT row_to_json (row)
                        FROM (
                            SELECT
                                id,
                                click_results,
                                conversion_results
                            FROM engine_tests
                            WHERE id = arg_id
                        ) row
                ) results
        INTO retval;
        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.engine_test_get(arg_id bigint) OWNER TO w4;

--
-- Name: engine_test_get_active(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION engine_test_get_active(arg_campaign_id bigint, arg_publisher_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint := null;
    BEGIN
        SELECT id FROM engine_tests WHERE
            campaign_id = arg_campaign_id AND
            publisher_id = arg_publisher_id AND
            (created_date + '5 minute'::interval) >= CURRENT_TIMESTAMP AND
            status = 'active'
        INTO var_id;

        RETURN var_id;

    END;
$$;


ALTER FUNCTION w4api.engine_test_get_active(arg_campaign_id bigint, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: engine_test_update(bigint, bigint, json, json, public.status_entity); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION engine_test_update(arg_campaign_id bigint, arg_publisher_id bigint, arg_click_results json DEFAULT NULL::json, arg_conversion_results json DEFAULT NULL::json, arg_status public.status_entity DEFAULT 'active'::public.status_entity) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN
        SELECT id FROM engine_tests WHERE
            campaign_id = arg_campaign_id AND
            publisher_id = arg_publisher_id AND
            (created_date + '5 minute'::interval) >= CURRENT_TIMESTAMP AND
            status = 'active'
        INTO var_id;

        IF (NOT FOUND) THEN
            RETURN false;
        END IF;

        UPDATE engine_tests SET
            click_results = COALESCE(arg_click_results, click_results),
            conversion_results = COALESCE(arg_conversion_results, conversion_results),
            status = arg_status
        WHERE id = var_id;

        RETURN true;
    END;
$$;


ALTER FUNCTION w4api.engine_test_update(arg_campaign_id bigint, arg_publisher_id bigint, arg_click_results json, arg_conversion_results json, arg_status public.status_entity) OWNER TO w4;

--
-- Name: geo_get(bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION geo_get(arg_country_id bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text) RETURNS TABLE(country_name text, country_short text, region_id bigint, region_short text, city_id bigint)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_country_name text;
        var_country_short text;
	var_region_id bigint;
        var_region_short text;
        var_region_search text;
        var_city_id bigint;
        var_city_search text;
        where_clause text := '';

    BEGIN
        IF (arg_country_id IS NOT NULL) THEN
            SELECT country, iso FROM geo_typeahead_countries WHERE id = arg_country_id INTO var_country_name, var_country_short;
            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Unable to find the specified country (%).', arg_country_id;
            END IF;
        END IF;

        IF (arg_region_name IS NOT NULL) THEN
            SELECT
                id,
                local_name
            FROM geo_typeahead_region
            WHERE
                (ascii_name = arg_region_name) AND
                (admin1_code = COALESCE(var_country_short, admin1_code))
            INTO var_region_id, var_region_short;
            IF (NOT FOUND) THEN
                IF (var_country_short IS NULL) THEN
                    RAISE EXCEPTION 'Must have a country id to add new region (%).', arg_region_name;
                END IF;
                var_region_search := arg_region_name || ' ' || LOWER(arg_region_name);
                INSERT INTO geo_typeahead_region
                    (country, admin1_code, local_name, ascii_name, region_search)
                    VALUES (arg_country_id, var_country_short, '', arg_region_name, var_region_search)
                    RETURNING id
                    INTO var_region_id;
            END IF;
        END IF;

        IF (arg_city_name IS NOT NULL) THEN
            SELECT
                id
            FROM geo_typeahead_cities
            WHERE
                (place_name_ascii = arg_city_name) AND
                (admin1_code = COALESCE(var_region_short, admin1_code)) AND
                (country_code = COALESCE(var_country_short, country_code))
            INTO var_city_id;

            IF (NOT FOUND) THEN
                IF (var_country_short IS NULL) THEN
                    RAISE EXCEPTION 'Must have a country id to add new city (%).', arg_city_name;
                END IF;
                var_city_search := arg_city_name || ' ' || LOWER(arg_city_name);
                SELECT MAX(id) + 1 AS next_id FROM geo_typeahead_cities INTO var_city_id;
                INSERT INTO geo_typeahead_cities
                    (id, place_name, place_name_ascii, country_code, admin1_code, search_string, modification_date)
                    VALUES (var_city_id, arg_city_name, arg_city_name, var_country_short, var_region_short, var_city_search, CURRENT_TIMESTAMP);
            END IF;        
        END IF;
        
        RETURN QUERY SELECT var_country_name, var_country_short, var_region_id, var_region_short, var_city_id;
    END
$$;


ALTER FUNCTION w4api.geo_get(arg_country_id bigint, arg_region_name text, arg_city_name text) OWNER TO w4;

--
-- Name: geo_target_cities_get(text, bigint, bigint, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION geo_target_cities_get(arg_city_search text, arg_region_id bigint, arg_country_id bigint, arg_limit_number integer) RETURNS TABLE(id bigint, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        wc TEXT;
        countrycode VARCHAR;
        regioncode VARCHAR;
    BEGIN
        arg_city_search:=replace(arg_city_search,' ','%');
        IF arg_region_id <> -1 AND arg_region_id IS NOT NULL THEN
            SELECT INTO regioncode local_name FROM geo_target_region WHERE geo_target_region.id=arg_region_id;
            IF arg_country_id <> -1 AND arg_country_id IS NOT NULL THEN
                SELECT INTO countrycode iso FROM geo_target_countries WHERE geo_target_countries.id=arg_country_id;
                wc:=$$ AND country_code='$$ || countrycode || $$' AND admin1_code='$$ || regioncode || $$' $$;
            ELSE
                wc:=$$ AND admin1_code='$$ || regioncode || $$' $$;
            END IF;
        ELSE
            IF arg_country_id <> -1 AND arg_country_id IS NOT NULL THEN
                SELECT INTO countrycode iso FROM geo_target_countries WHERE geo_target_countries.id=arg_country_id;
                wc:=$$ AND country_code='$$ || countrycode || $$' $$;
            ELSE
                wc:='';
            END IF;            
        END IF;
        RAISE INFO 'todo: WHERE CLAUSE [%]',wc;
        RETURN QUERY EXECUTE $$SELECT XxX.id::BIGINT, XxX.val::TEXT FROM (SELECT id, place_name_ascii AS val FROM geo_target_cities WHERE search_string ~* '^$$ || arg_city_search || $$%' $$ || wc || $$ UNION SELECT id, place_name_ascii AS val FROM geo_target_cities WHERE search_string ILIKE '%$$ || arg_city_search || $$%' $$ || wc || $$ ORDER BY val ASC LIMIT $$ || arg_limit_number || $$)XxX;$$;
    END;
$_$;


ALTER FUNCTION w4api.geo_target_cities_get(arg_city_search text, arg_region_id bigint, arg_country_id bigint, arg_limit_number integer) OWNER TO w4;

--
-- Name: geo_target_countries_get(text, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION geo_target_countries_get(arg_country_search text, arg_limit_number integer) RETURNS TABLE(id bigint, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        csa TEXT;
        csb TEXT;
        csc TEXT;
        qry TEXT;
    BEGIN
        arg_country_search:=replace(arg_country_search,' ','%');
        csa:='%' || arg_country_search || '%';
        csb:='^' || arg_country_search || '%';
        csc:='%' || arg_country_search || '%';
        qry:=$$SELECT XxX.id,XxX.val::TEXT FROM (SELECT geo_target_countries.id, country AS val FROM geo_target_countries WHERE country_search ILIKE '$$ || csa || $$'
        UNION
        SELECT geo_target_countries.id, country AS val FROM geo_target_countries WHERE country_search ~* '$$ || csb || $$'
        UNION
        SELECT geo_target_countries.id, country AS val FROM geo_target_countries WHERE country_search ILIKE '$$ || csc || $$') XxX ORDER BY XxX.val ASC LIMIT $$ || arg_limit_number || $$;$$;
        RETURN QUERY EXECUTE qry;                
    END;
$_$;


ALTER FUNCTION w4api.geo_target_countries_get(arg_country_search text, arg_limit_number integer) OWNER TO w4;

--
-- Name: geo_target_get(bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION geo_target_get(arg_country_id bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text) RETURNS TABLE(country_name text, country_short text, region_id bigint, region_short text, city_id bigint)
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_country_name text;
        var_country_short text;
	var_region_id bigint;
        var_region_short text;
        var_city_id bigint;
        where_clause text := '';

    BEGIN
        IF (arg_country_id IS NOT NULL) THEN
            SELECT country, iso FROM geo_target_countries WHERE id = arg_country_id INTO var_country_name, var_country_short;
            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Unable to find the specified country (%).', arg_country_id;
            END IF;
        END IF;

        IF (arg_region_name IS NOT NULL) THEN
            SELECT
                id,
                admin1_code
            FROM geo_target_region
            WHERE
                (local_name = arg_region_name) AND
                (country = COALESCE(var_country_short, country))
            INTO var_region_id, var_region_short;
            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Unable to find the specified region (%) and country (%) combo.', arg_region_name, var_country_name;
            END IF;
        END IF;

        IF (arg_city_name IS NOT NULL) THEN
            SELECT
                id
            FROM geo_target_cities
            WHERE
                (place_name = arg_city_name) AND
                (admin1_code = COALESCE(var_region_short, admin1_code)) AND
                (country_code = COALESCE(var_country_short, country_code))
            INTO var_city_id;

            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Unable to find the specified city (%), region (%), and country (%) combo.', arg_city_name, arg_region_name, var_country_name;
            END IF;        
        END IF;
        
        RETURN QUERY SELECT var_country_name, var_country_short, var_region_id, var_region_short, var_city_id;
    END
$$;


ALTER FUNCTION w4api.geo_target_get(arg_country_id bigint, arg_region_name text, arg_city_name text) OWNER TO w4;

--
-- Name: geo_target_regions_get(text, bigint, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION geo_target_regions_get(arg_region_search text, arg_country_id bigint, arg_limit_number integer) RETURNS TABLE(id bigint, val text)
    LANGUAGE plpgsql STABLE
    AS $_$
    DECLARE
        wc TEXT;
        cty VARCHAR;
        qry TEXT;
    BEGIN
        IF arg_country_id IS NOT NULL AND arg_country_id <> -1 THEN
	    SELECT INTO cty geo_target_countries.iso FROM geo_target_countries WHERE geo_target_countries.id=arg_country_id;
            wc:=$$ AND admin1_code='$$ || cty || $$' $$;
        ELSE
            wc:='';
        END IF;
        arg_region_search:=replace(arg_region_search,' ','%');
        qry:=$$SELECT XxX.id::BIGINT, XxX.val::TEXT FROM (
            SELECT id, ascii_name AS val FROM geo_target_region WHERE region_search ~* '^$$ || arg_region_search || $$%'$$ || wc || $$
            UNION
            SELECT id, ascii_name AS val FROM geo_target_region WHERE region_search ILIKE '%$$ || arg_region_search || $$%'$$ || wc || $$) XxX ORDER BY XxX.val ASC LIMIT $$ || arg_limit_number || $$;$$;
            RETURN QUERY EXECUTE qry;
    END;
$_$;


ALTER FUNCTION w4api.geo_target_regions_get(arg_region_search text, arg_country_id bigint, arg_limit_number integer) OWNER TO w4;

--
-- Name: get_global(text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION get_global(arg_name text) RETURNS text
    LANGUAGE plpgsql
    AS $$

		BEGIN

			RETURN current_setting( 'w4.' || arg_name );

		END;
	$$;


ALTER FUNCTION w4api.get_global(arg_name text) OWNER TO w4;

--
-- Name: get_global(text, anyelement); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION get_global(arg_name text, arg_default anyelement) RETURNS anyelement
    LANGUAGE plpgsql
    AS $$

		BEGIN

			RETURN current_setting( 'w4.' || arg_name )::anyelement;

		EXCEPTION WHEN others THEN
		
			RETURN arg_default;

		END;
	$$;


ALTER FUNCTION w4api.get_global(arg_name text, arg_default anyelement) OWNER TO w4;

--
-- Name: global(text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION global(arg_name text) RETURNS text
    LANGUAGE plpgsql
    AS $$

	BEGIN

		RETURN current_setting( 'w4.' || arg_name );

	END;
$$;


ALTER FUNCTION w4api.global(arg_name text) OWNER TO w4;

--
-- Name: global(text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION global(arg_name text, arg_value text) RETURNS void
    LANGUAGE plpgsql
    AS $$

	BEGIN

		PERFORM set_config( 'w4.' || arg_name,  arg_value, false );
	END;
$$;


ALTER FUNCTION w4api.global(arg_name text, arg_value text) OWNER TO w4;

--
-- Name: global_redirect_url_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION global_redirect_url_get(arg_type bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_redirect_url text;

    BEGIN

        SELECT value FROM global_settings WHERE id = 1 INTO var_redirect_url;

        RETURN var_redirect_url;
    END
$$;


ALTER FUNCTION w4api.global_redirect_url_get(arg_type bigint) OWNER TO w4;

--
-- Name: image_url_create(text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION image_url_create(arg_url text, arg_campaign_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_file_id bigint;
    BEGIN
        INSERT INTO files
            (status, last_modified, user_id)
            VALUES ('pending', CURRENT_TIMESTAMP, 0)
            RETURNING id
            INTO var_file_id;

        INSERT INTO image_url_queue
            (file_id, campaign_id, url, status)
            VALUES (var_file_id, arg_campaign_id, arg_url, 'pending');
        RETURN var_file_id;
    END;
$$;


ALTER FUNCTION w4api.image_url_create(arg_url text, arg_campaign_id bigint) OWNER TO w4;

--
-- Name: image_url_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION image_url_get(arg_file_id bigint) RETURNS json
    LANGUAGE plpgsql STABLE
    AS $$
    DECLARE
        var_results json;

    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    status
                FROM image_url_queue
                WHERE file_id = arg_file_id
            ) row
        INTO var_results;

        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4api.image_url_get(arg_file_id bigint) OWNER TO w4;

--
-- Name: image_url_queue_get(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION image_url_queue_get() RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;
        var_queue json;
        var_batch_id bigint;

    BEGIN
        PERFORM * FROM image_url_queue WHERE batch_id IS NULL;
        IF (FOUND) THEN
            var_batch_id := nextval( 'image_url_batches_id_seq' );
            UPDATE image_url_queue SET batch_id = var_batch_id, status = 'processing' WHERE batch_id IS NULL;
            IF (FOUND) THEN
                INSERT INTO image_url_batches
                    (id, start_time, status)
                    VALUES (var_batch_id, CURRENT_TIMESTAMP, 'processing');

                SELECT
                    array_to_json (array_agg(row_to_json (results)))
                        FROM (
                            SELECT row_to_json (row)
                                FROM (
                                    SELECT
                                        id,
                                        file_id,
                                        campaign_id,
                                        url
                                    FROM image_url_queue
                                    WHERE batch_id = var_batch_id
                            ) row
                    ) results
                INTO var_queue;
                var_results := '{"batch_id": ' || var_batch_id || ', "queue": ' || var_queue || '}';
            END IF;
        END IF;

        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4api.image_url_queue_get() OWNER TO w4;

--
-- Name: image_url_queue_update(bigint, public.status_batch); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION image_url_queue_update(arg_batch_id bigint, arg_status public.status_batch) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        UPDATE image_url_batches SET status = arg_status, stop_time = CURRENT_TIMESTAMP WHERE id = arg_batch_id;
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.image_url_queue_update(arg_batch_id bigint, arg_status public.status_batch) OWNER TO w4;

--
-- Name: image_url_update(bigint, bigint, public.status_batch, text, text, text, text, numeric, numeric, numeric); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION image_url_update(arg_queue_id bigint, arg_file_id bigint, arg_batch_status public.status_batch, arg_file_name text DEFAULT NULL::text, arg_folder text DEFAULT NULL::text, arg_mime_type text DEFAULT NULL::text, arg_extension text DEFAULT NULL::text, arg_width numeric DEFAULT NULL::numeric, arg_height numeric DEFAULT NULL::numeric, arg_size numeric DEFAULT NULL::numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        UPDATE image_url_queue SET status= arg_batch_status WHERE id = arg_queue_id;
        IF (arg_batch_status = 'complete') THEN
            UPDATE files SET
                file_name = arg_file_name,
                mime_type = arg_mime_type,
                folder = arg_folder,
                width = arg_width,
                height = arg_height,
                status = 'active',
                last_modified = CURRENT_TIMESTAMP,
                user_id = 0,
                extension = arg_extension,
                size = arg_size
            WHERE id = arg_file_id;
        END IF;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.image_url_update(arg_queue_id bigint, arg_file_id bigint, arg_batch_status public.status_batch, arg_file_name text, arg_folder text, arg_mime_type text, arg_extension text, arg_width numeric, arg_height numeric, arg_size numeric) OWNER TO w4;

--
-- Name: json_array_convert(json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION json_array_convert(arg_json_array json) RETURNS text[]
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_array_value text;
        var_array text[];
    BEGIN
        FOR var_array_value IN SELECT json_array_elements(arg_json_array) LOOP
            var_array_value := string_agg(trim(var_array_value, '"'), ', ');
            var_array := array_append(var_array, var_array_value);
        END LOOP;
        RETURN var_array;
    END;
$$;


ALTER FUNCTION w4api.json_array_convert(arg_json_array json) OWNER TO w4;

--
-- Name: match_escape(text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION match_escape(arg_text text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$

    BEGIN

	arg_text := replace( arg_text, '\', '\\' );
	arg_text := replace( arg_text, '%', '\%' );
	arg_text := replace( arg_text, '_', '\_' );
	arg_text := replace( arg_text, ' ', '%' );
	arg_text := '%' || arg_text || '%';

	RETURN arg_text;

    END;
    
$$;


ALTER FUNCTION w4api.match_escape(arg_text text) OWNER TO w4;

--
-- Name: match_escape(text, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION match_escape(arg_text text, arg_spaces boolean, arg_incomplete boolean) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$

    BEGIN

	arg_text := replace( arg_text, '\', '\\' );
	arg_text := replace( arg_text, '%', '\%' );
	arg_text := replace( arg_text, '_', '\_' );

	IF arg_spaces THEN
		arg_text := replace( arg_text, ' ', '%' );
	END IF;

	IF arg_incomplete THEN
		arg_text := '%' || arg_text || '%';
	END IF;

	RETURN arg_text;

    END;
    
$$;


ALTER FUNCTION w4api.match_escape(arg_text text, arg_spaces boolean, arg_incomplete boolean) OWNER TO w4;

--
-- Name: matches(text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION matches(arg_text text, arg_pattern text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$

    BEGIN

	RETURN arg_text ILIKE match_escape( arg_pattern );

    END;
    
$$;


ALTER FUNCTION w4api.matches(arg_text text, arg_pattern text) OWNER TO w4;

--
-- Name: messages_create(bigint, json, integer, text, text, integer, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION messages_create(arg_sender_id bigint, arg_receiver_ids json, arg_type integer, arg_content text, arg_subject text DEFAULT NULL::text, arg_status integer DEFAULT 1, arg_delivery_setting integer DEFAULT 1) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

    DECLARE
        recipient_id bigint;
        var_receiver text;
        var_sender text;
        var_message_id bigint;

    BEGIN
        SELECT
            CONCAT (
                u.email
            ) AS sender
        FROM users u
        WHERE u.id = arg_sender_id
        INTO var_sender;

        IF (NOT FOUND AND arg_sender_id != 0) THEN
            RAISE EXCEPTION 'Unable to find the sender (%) to create message.', arg_sender_id;
        END IF;

        PERFORM id FROM message_status WHERE id = arg_status;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the status (%) to create message.', arg_status;
        END IF;

        PERFORM id FROM message_delivery_settings WHERE id = arg_delivery_setting;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the delivery setting (%) to create message.', arg_delivery_setting;
        END IF;

        FOR recipient_id IN SELECT json_array_elements(arg_receiver_ids->'recipients') LOOP
            SELECT
                COALESCE(contacts.email_address, users.email) AS receiver
            FROM contacts 
            LEFT JOIN users ON contacts.id = users.primary_contact_id 
            WHERE users.id = recipient_id INTO var_receiver;

            IF NOT FOUND THEN
                RAISE EXCEPTION 'Unable to find the recipient (%) to create message.', recipient_id;
            END IF;

            INSERT INTO messages
                (sender_id, receiver_id, message_type, message_status, message_content, message_created_date, message_delivery_setting, message_subject)
                VALUES (arg_sender_id, recipient_id, arg_type, arg_status, arg_content, CURRENT_TIMESTAMP, arg_delivery_setting, arg_subject)
                RETURNING id
                INTO var_message_id;

            IF (arg_delivery_setting > 1 AND arg_delivery_setting < 6) THEN
                INSERT INTO email_queue
                    (message_id, subject, content, sender, receiver, status)
                    VALUES (var_message_id, arg_subject, arg_content, var_sender, var_receiver, 'pending');
            END IF;
        END LOOP;
        RETURN TRUE;
    END;

$$;


ALTER FUNCTION w4api.messages_create(arg_sender_id bigint, arg_receiver_ids json, arg_type integer, arg_content text, arg_subject text, arg_status integer, arg_delivery_setting integer) OWNER TO w4;

--
-- Name: messages_delete(json, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION messages_delete(arg_changes json, arg_status integer DEFAULT 5) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
    
    RETURN (SELECT w4api.messages_status_update(arg_changes, arg_status))::boolean;
    END;
$$;


ALTER FUNCTION w4api.messages_delete(arg_changes json, arg_status integer) OWNER TO w4;

--
-- Name: messages_get(bigint, bigint, integer, integer, text, bigint, bigint, boolean, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION messages_get(arg_sender_id bigint DEFAULT NULL::bigint, arg_receiver_id bigint DEFAULT NULL::bigint, arg_type integer DEFAULT NULL::integer, arg_status integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (messages_get_count(arg_sender_id, arg_receiver_id, arg_type, arg_status, arg_min_date, arg_max_date), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || messages_get_list(arg_sender_id, arg_receiver_id, arg_type, arg_status, arg_orderby, arg_limit, arg_offset, arg_min_date, arg_max_date) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.messages_get(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer, arg_status integer, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: messages_get_count(bigint, bigint, integer, integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION messages_get_count(arg_sender_id bigint DEFAULT NULL::bigint, arg_receiver_id bigint DEFAULT NULL::bigint, arg_type integer DEFAULT NULL::integer, arg_status integer DEFAULT NULL::integer, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_sender_id::TEXT, 'm.sender_id = ' || arg_sender_id, where_clause);
        where_clause := where_clause_build(arg_receiver_id::TEXT, 'm.receiver_id = ' || arg_receiver_id, where_clause);
     
	IF arg_type = 6 OR arg_type = 7 THEN
		where_clause := where_clause_build(arg_type::TEXT, '(m.message_type = ' || arg_type - 5 || ' OR m.message_type = 5)' , where_clause);
	ELSE
		where_clause := where_clause_build(arg_type::TEXT, 'm.message_type = ' || arg_type, where_clause);
	END IF;
	
        where_clause := where_clause_build(arg_status::TEXT, 'm.message_status = ' || arg_status, where_clause);
        where_clause := where_clause_build (arg_min_date::TEXT, 'm.message_created_date::date >= $$' || arg_min_date::date || '$$', where_clause);
        where_clause := where_clause_build (arg_max_date::TEXT, 'm.message_created_date::date < $$' || arg_max_date::date || '$$', where_clause);
   
        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM messages m
            LEFT JOIN message_types mt ON m.message_type = mt.id
            LEFT JOIN message_status ms ON m.message_status = ms.id
            LEFT JOIN users us ON m.sender_id = us.id
            LEFT JOIN contacts cs ON us.primary_contact_id = cs.id
            LEFT JOIN users ur ON m.receiver_id = ur.id
            LEFT JOIN contacts cr ON ur.primary_contact_id = cr.id'
            || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.messages_get_count(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer, arg_status integer, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: messages_get_list(bigint, bigint, integer, integer, text, bigint, bigint, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION messages_get_list(arg_sender_id bigint DEFAULT NULL::bigint, arg_receiver_id bigint DEFAULT NULL::bigint, arg_type integer DEFAULT NULL::integer, arg_status integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
	
        where_clause := where_clause_build(arg_sender_id::TEXT, 'm.sender_id = ' || arg_sender_id, where_clause);
        where_clause := where_clause_build(arg_receiver_id::TEXT, 'm.receiver_id = ' || arg_receiver_id, where_clause);
	IF arg_type = 6 OR arg_type = 7 THEN
		where_clause := where_clause_build(arg_type::TEXT, '(m.message_type = ' || arg_type - 5 || ' OR m.message_type = 5)' , where_clause);
	ELSE
		where_clause := where_clause_build(arg_type::TEXT, 'm.message_type = ' || arg_type, where_clause);
	END IF;

	where_clause := where_clause_build(arg_status::TEXT, 'm.message_status = ' || arg_status, where_clause);
	where_clause := where_clause_build (arg_min_date::TEXT, 'm.message_created_date::date >= $$' || arg_min_date::date || '$$', where_clause);
        where_clause := where_clause_build (arg_max_date::TEXT, 'm.message_created_date::date < $$' || arg_max_date::date || '$$', where_clause);
   
        order_clause := order_clause_build(arg_orderby, 'created_date');
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    m.sender_id,
                                    CONCAT (cs.first_name, CHR(1), cs.last_name) AS sender_name,
                                    m.receiver_id,
                                    CONCAT (cr.first_name, CHR(1), cr.last_name) AS receiver_name,
				    us.access AS sender_access,
				    ur.access AS receiver_access,
                                    m.message_type AS type_id,
                                    mt.type_name,
                                    m.message_status AS status_id,
                                    ms.status_name,
				    m.message_content,
				    m.message_subject,
				    m.id,
                                    m.message_created_date AS created_date
                                FROM messages m
                                LEFT JOIN message_types mt ON m.message_type = mt.id
                                LEFT JOIN message_status ms ON m.message_status = ms.id
                                LEFT JOIN users us ON m.sender_id = us.id
                                LEFT JOIN contacts cs ON us.primary_contact_id = cs.id
                                LEFT JOIN users ur ON m.receiver_id = ur.id
                                LEFT JOIN contacts cr ON ur.primary_contact_id = cr.id'
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.messages_get_list(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer, arg_status integer, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: messages_status_update(json, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION messages_status_update(arg_changes json, arg_status integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_messages_entry_json bigint; 
        var_messages_new_row record;
    BEGIN
    FOR var_messages_entry_json IN SELECT json_array_elements(arg_changes->'changes')
    LOOP
	UPDATE messages SET message_status = arg_status where id = var_messages_entry_json;
    END LOOP;
    RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.messages_status_update(arg_changes json, arg_status integer) OWNER TO w4;

--
-- Name: messages_status_update(bigint, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION messages_status_update(arg_id bigint, arg_status integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM messages WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the message with id of (%).', arg_id;
        END IF;
        PERFORM id FROM message_status WHERE id = arg_status;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the status (%) to update the message.', arg_status;
        END IF;
        UPDATE messages SET
            message_status = arg_status,
            message_last_access_date = CURRENT_TIMESTAMP
        WHERE id = arg_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.messages_status_update(arg_id bigint, arg_status integer) OWNER TO w4;

--
-- Name: messages_update(json, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION messages_update(arg_changes json, arg_status integer DEFAULT 0) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_messages_entry_json bigint; 
        var_messages_logs_entered_success boolean = true;
        var_messages_new_row record;
    BEGIN

    IF arg_status > 0 THEN
	var_messages_logs_entered_success = ((SELECT w4api.messages_status_update( arg_changes, arg_status ) ) AND var_messages_logs_entered_success );      
    ELSE
	    FOR var_messages_entry_json IN SELECT json_array_elements(arg_changes->'changes')
	    LOOP
	    select* from messages where id = var_messages_entry_json INTO var_messages_new_row;
		   var_messages_logs_entered_success = 
		((SELECT w4api.messages_create(
			arg_sender_id:=var_messages_new_row.sender_id, 
			arg_receiver_ids:=('{ "recipients": [' || var_messages_new_row.receiver_id || ']}')::json, 
			arg_type:= var_messages_new_row.message_type,
			arg_content:= var_messages_new_row.message_content,
			arg_subject := var_messages_new_row.message_subject,
			arg_delivery_setting:= var_messages_new_row.message_delivery_setting
			  )
		       ) AND var_messages_logs_entered_success
		);      
	    END LOOP;
    END IF;
    
    RETURN var_messages_logs_entered_success;    
    END;
$$;


ALTER FUNCTION w4api.messages_update(arg_changes json, arg_status integer) OWNER TO w4;

--
-- Name: orderby(text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION orderby(arg_orderby text, arg_default_sort text DEFAULT NULL::text, arg_default_direction text DEFAULT 'ASC'::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
	BEGIN

		RETURN orderby_sort( arg_orderby, arg_default_sort ) || ' ' || orderby_direction( arg_orderby, arg_default_direction );

	END;
$$;


ALTER FUNCTION w4api.orderby(arg_orderby text, arg_default_sort text, arg_default_direction text) OWNER TO w4;

--
-- Name: orderby_direction(text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION orderby_direction(arg_orderby text, arg_default text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		retval text;
	BEGIN

		retval := SUBSTRING( arg_orderby FROM '^(?:(?:[^"\s]+)|(?:"(?:[^"]|"")*"))(?:\s+((?:[Aa]|[Dd][Ee])[Ss][Cc]))?$' );
		retval := COALESCE( upper( retval ), arg_default );

		IF retval IS NULL THEN
			RAISE EXCEPTION 'Error parsing orderby';
		END IF;
	
		RETURN retval;

	END;
$_$;


ALTER FUNCTION w4api.orderby_direction(arg_orderby text, arg_default text) OWNER TO w4;

--
-- Name: orderby_sort(text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION orderby_sort(arg_orderby text, arg_default text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE

		retval text;
	
	BEGIN

		retval := SUBSTRING( arg_orderby FROM '^((?:[^"\s]+)|(?:"(?:[^"]|"")*"))(?:\s+(?:[Aa]|[Dd][Ee])[Ss][Cc])?$' );

		retval := regexp_replace( retval, '^"(.*)"$', '\&', 'g' );
		retval := regexp_replace( retval, '""', '"', 'g' );

		retval := COALESCE( quote_ident( retval ), arg_default );

		IF retval IS NULL THEN
			RAISE EXCEPTION 'Error parsing orderby';
		END IF;

		RETURN retval;

	END;
$_$;


ALTER FUNCTION w4api.orderby_sort(arg_orderby text, arg_default text) OWNER TO w4;

--
-- Name: payment_terms_create(text, integer, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION payment_terms_create(arg_name text, arg_alert_when integer, arg_alert_when_type text, arg_alert_from text, arg_description text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
		var_new_id integer;
	    BEGIN
	    IF(arg_alert_when<=0) THEN
		RAISE EXCEPTION 'Invalid Payment Alert Value: %.', arg_alert_when; 
	    ELSIF(CAST((SELECT w4api.payment_terms_get_list(arg_name:=arg_name,arg_count:=true)::text) AS integer)>0) THEN
		RAISE EXCEPTION 'Payment term % already exists.', arg_name; 
	    END IF;
	    INSERT INTO advertiser_payment_terms(
	        name
		,alert_when
		,alert_when_type
		,alert_from
		,description
		)
	    VALUES(
	        arg_name 
		,arg_alert_when
		,arg_alert_when_type
		,arg_alert_from
		,arg_description	    
		) RETURNING id INTO var_new_id;
	RETURN  ('{' || '"new": ' || (SELECT w4api.payment_terms_get_list(var_new_id)) || '}')::json;
    END;
$$;


ALTER FUNCTION w4api.payment_terms_create(arg_name text, arg_alert_when integer, arg_alert_when_type text, arg_alert_from text, arg_description text) OWNER TO w4;

--
-- Name: payment_terms_get(bigint, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION payment_terms_get(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
		var_count_json text :='';
	    BEGIN	        
		IF arg_count THEN
		     var_count_json:= ', "count": ' || (SELECT w4api.payment_terms_get_list(arg_id,arg_name,arg_orderby, arg_limit, arg_offset,arg_count))::text;
		END IF;
		ret_val := ('{"results": ' || (SELECT w4api.payment_terms_get_list(arg_id,arg_name,arg_orderby,arg_limit,arg_offset)) || var_count_json  || '}')::json;
	RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.payment_terms_get(arg_id bigint, arg_name text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: payment_terms_get_list(bigint, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION payment_terms_get_list(arg_id bigint DEFAULT NULL::bigint, arg_name text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
   ret_val json;
   where_clause text := ''; 
   order_clause text := ''; 
    BEGIN
	where_clause := w4_automatic_functions.where_clause_build(arg_id::TEXT, ' id = ' || arg_id, where_clause);
	where_clause := w4_automatic_functions.where_clause_build(arg_name::TEXT, ' name = ''' || arg_name||'''', where_clause);
	order_clause := order_clause_build(arg_orderby, 'name ASC');
	IF(arg_count) THEN  
	     EXECUTE
		'SELECT COALESCE (COUNT(1), 0) 
			FROM ( SELECT id FROM advertiser_payment_terms' 
		     || where_clause ||' ) AS count'
		INTO ret_val;			
	 ELSE 
	     EXECUTE
		'SELECT array_to_json (array_agg(row_to_json (results)))
		    FROM (        
			SELECT row_to_json (row)
			    FROM ( 
				SELECT 
				   id 
				  ,name
				  ,description
				  ,alert_when
				  ,alert_when_type
				  ,alert_from                             
				FROM advertiser_payment_terms' 
				|| where_clause
				|| order_clause
				|| ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
				|| ' OFFSET ' || arg_offset || '
			    ) row
			) results'
		INTO ret_val;
	    END IF;
	RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.payment_terms_get_list(arg_id bigint, arg_name text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: payment_terms_update(bigint, text, integer, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION payment_terms_update(arg_id bigint, arg_name text DEFAULT NULL::text, arg_alert_when integer DEFAULT NULL::integer, arg_alert_when_type text DEFAULT NULL::text, arg_alert_from text DEFAULT NULL::text, arg_description text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
	    DECLARE
		ret_val json;
	    BEGIN

	    PERFORM name FROM advertiser_payment_terms WHERE id = arg_id;    ----- CHECK IF VALID ID
	    IF(NOT FOUND) THEN
		RAISE EXCEPTION 'An advertiser pyment term was not found for id:%.', arg_id; 
	    END IF;

	    PERFORM id FROM advertiser_payment_terms WHERE name = arg_name AND id != arg_id;  ---- CHECK IF NAME ALREADY EXISTS 
	    IF(FOUND) THEN
		RAISE EXCEPTION 'Payment term % already exists.', arg_name; 
	    END IF;  
			
	    IF((arg_alert_when NOTNULL)AND(arg_alert_when<=0)) THEN  ---- CHECK IF VALID ALERT WHEN VALUE
		RAISE EXCEPTION 'Invalid Payment Alert Value: %.', arg_alert_when; 
	    END IF;
	      
		UPDATE advertiser_payment_terms SET
			name = COALESCE(arg_name,name)
			,alert_when = COALESCE(arg_alert_when,alert_when)
			,alert_when_type = COALESCE(arg_alert_when_type,alert_when_type)
			,alert_from = COALESCE(arg_alert_from,alert_from)
			,description = COALESCE(arg_description,description)
			WHERE id = arg_id;
			ret_val := ('{ "results": ' || (SELECT w4api.payment_terms_get_list(arg_id := arg_id)) || '}')::json;
		RETURN ret_val;	  
    END;
$$;


ALTER FUNCTION w4api.payment_terms_update(arg_id bigint, arg_name text, arg_alert_when integer, arg_alert_when_type text, arg_alert_from text, arg_description text) OWNER TO w4;

--
-- Name: ping_alerts_get(bigint, bigint, integer, integer, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION ping_alerts_get(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer DEFAULT NULL::integer, arg_status integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (ping_alerts_get_count(arg_sender_id, arg_receiver_id, arg_type, arg_status), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || ping_alerts_get_list(arg_sender_id, arg_receiver_id, arg_type, arg_status, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.ping_alerts_get(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer, arg_status integer, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: ping_alerts_get_count(bigint, bigint, integer, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION ping_alerts_get_count(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer DEFAULT NULL::integer, arg_status integer DEFAULT NULL::integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
    	where_clause := ' WHERE ((m.sender_id = '|| arg_sender_id::TEXT ||' AND m.receiver_id = '|| arg_receiver_id::TEXT ||') OR (m.sender_id = '|| arg_receiver_id::TEXT ||' AND m.receiver_id = '|| arg_sender_id::TEXT ||'))';
        where_clause := where_clause_build(arg_type::TEXT, 'm.message_type = ' || arg_type, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'm.message_status = ' || arg_status, where_clause);
        where_clause := where_clause || 'AND m.message_delivery_setting = 7 AND m.message_status != 5';

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM messages m
            LEFT JOIN message_types mt ON m.message_type = mt.id
            LEFT JOIN message_status ms ON m.message_status = ms.id
            LEFT JOIN users us ON m.sender_id = us.id
            LEFT JOIN contacts cs ON us.primary_contact_id = cs.id
            LEFT JOIN users ur ON m.receiver_id = ur.id
            LEFT JOIN contacts cr ON ur.primary_contact_id = cr.id'
            || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.ping_alerts_get_count(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer, arg_status integer) OWNER TO w4;

--
-- Name: ping_alerts_get_list(bigint, bigint, integer, integer, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION ping_alerts_get_list(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer DEFAULT NULL::integer, arg_status integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
	where_clause := ' WHERE ((m.sender_id = '|| arg_sender_id::TEXT ||' AND m.receiver_id = '|| arg_receiver_id::TEXT ||') OR (m.sender_id = '|| arg_receiver_id::TEXT ||' AND m.receiver_id = '|| arg_sender_id::TEXT ||'))';
        where_clause := where_clause_build(arg_type::TEXT, 'm.message_type = ' || arg_type, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'm.message_status = ' || arg_status, where_clause);
        where_clause := where_clause || 'AND m.message_delivery_setting = 7 AND m.message_status != 5';
        order_clause := order_clause_build(arg_orderby, 'created_date');
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    m.sender_id,
                                    CONCAT (cs.first_name, CHR(1), cs.last_name) AS sender_name,
                                    m.receiver_id,
                                    CONCAT (cr.first_name, CHR(1), cr.last_name) AS receiver_name,
                                    m.message_type AS type_id,
                                    mt.type_name,
                                    m.message_status AS status_id,
                                    ms.status_name,
				    m.message_content,
                                    m.message_created_date AS created_date
                                FROM messages m
                                LEFT JOIN message_types mt ON m.message_type = mt.id
                                LEFT JOIN message_status ms ON m.message_status = ms.id
                                LEFT JOIN users us ON m.sender_id = us.id
                                LEFT JOIN contacts cs ON us.primary_contact_id = cs.id
                                LEFT JOIN users ur ON m.receiver_id = ur.id
                                LEFT JOIN contacts cr ON ur.primary_contact_id = cr.id'
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.ping_alerts_get_list(arg_sender_id bigint, arg_receiver_id bigint, arg_type integer, arg_status integer, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pixel_test_create(text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pixel_test_create(arg_url text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN     
        INSERT INTO engine_pixel_tests
            (url)
            VALUES (arg_url)
            RETURNING id
            INTO var_id;
        RETURN var_id;
    END;
$$;


ALTER FUNCTION w4api.pixel_test_create(arg_url text) OWNER TO w4;

--
-- Name: pixel_test_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pixel_test_get(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_result json;
    BEGIN     
        SELECT result FROM engine_pixel_tests WHERE id = arg_id INTO var_result;
        RETURN var_result;
    END;
$$;


ALTER FUNCTION w4api.pixel_test_get(arg_id bigint) OWNER TO w4;

--
-- Name: pixel_test_update(bigint, json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pixel_test_update(arg_id bigint, arg_result json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN     
        UPDATE engine_pixel_tests SET result = arg_result where id = arg_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.pixel_test_update(arg_id bigint, arg_result json) OWNER TO w4;

--
-- Name: publisher_account_changes_approve(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_account_changes_approve(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        manager_id bigint;
        message_success boolean;
        recipients json;
    BEGIN
        SELECT users.manager_id FROM users WHERE id = arg_publisher_id AND access = 'publisher' INTO manager_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher (%).', arg_publisher_id;
        END IF;

        INSERT INTO publisher_account_changes
            (publisher_id, data, changed_at, status, contact_type)
            VALUES (arg_publisher_id, arg_data, CURRENT_TIMESTAMP, 'pending', arg_contact_type);

        recipients := '{"recipients" : [' || manager_id || ']}';
        message_success := messages_create (arg_publisher_id, recipients, 5, 'Publisher has made a change to their account and it needs to be verified.', 1, 2);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_account_changes_approve(arg_id bigint) OWNER TO w4;

--
-- Name: publisher_account_changes_create(bigint, json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_account_changes_create(arg_publisher_id bigint, arg_data json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        manager_id bigint;
        message_success boolean;
    BEGIN
        SELECT users.manager_id FROM users WHERE id = arg_publisher_id AND access = 'publisher' INTO manager_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher (%).', arg_publisher_id;
        END IF;
        INSERT INTO publisher_account_changes
            (publisher_id, data, changed_at, status)
            VALUES (arg_publisher_id, arg_data, CURRENT_TIMESTAMP, 'pending');
        message_success := messages_create (arg_publisher_id, manager_id, 5, 'Publisher has made a change to their account and it needs to be verified.', 1, 1);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_account_changes_create(arg_publisher_id bigint, arg_data json) OWNER TO w4;

--
-- Name: publisher_account_changes_create(bigint, public.contact, json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_account_changes_create(arg_publisher_id bigint, arg_contact_type public.contact, arg_data json) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        manager_id bigint;
        message_success boolean;
        recipients json;
    BEGIN
        SELECT users.manager_id FROM users WHERE id = arg_publisher_id AND access = 'publisher' INTO manager_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher (%).', arg_publisher_id;
        END IF;

        INSERT INTO publisher_account_changes
            (publisher_id, data, changed_at, status, contact_type)
            VALUES (arg_publisher_id, arg_data, CURRENT_TIMESTAMP, 'pending', arg_contact_type);
        recipients := '{"recipients" : [' || manager_id || ']}';
        message_success := messages_create (arg_publisher_id, recipients, 5, 'Publisher has made a change to their account and it needs to be verified.', null, 1, 2);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_account_changes_create(arg_publisher_id bigint, arg_contact_type public.contact, arg_data json) OWNER TO w4;

--
-- Name: publisher_account_changes_get(bigint, text, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_account_changes_get(arg_publisher_id bigint DEFAULT NULL::bigint, arg_search_manager text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            arg_max_date:= arg_max_date + INTERVAL '1 day';
            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_account_changes_get_count(arg_publisher_id, arg_search_manager, arg_status, arg_min_date, arg_max_date), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_account_changes_get_list(arg_publisher_id, arg_search_manager, arg_status, arg_min_date, arg_max_date, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_account_changes_get(arg_publisher_id bigint, arg_search_manager text, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_account_changes_get_count(bigint, text, text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_account_changes_get_count(arg_publisher_id bigint DEFAULT NULL::bigint, arg_search_manager text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pac.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_status, 'pac.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pac.changed_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pac.changed_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_search_manager::TEXT, 'u.manager_id = ' || arg_search_manager, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM publisher_account_changes pac
            LEFT JOIN users u ON u.id = pac.publisher_id
            LEFT JOIN contacts con ON con.id = u.primary_contact_id
            LEFT JOIN user_profiles up ON up.user_id = u.id
            LEFT JOIN users mgr ON mgr.id = u.manager_id
            LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id '                                
            || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_account_changes_get_count(arg_publisher_id bigint, arg_search_manager text, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: publisher_account_changes_get_list(bigint, text, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_account_changes_get_list(arg_publisher_id bigint DEFAULT NULL::bigint, arg_search_manager text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pac.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_status, 'pac.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pac.changed_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pac.changed_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_search_manager::TEXT, 'u.manager_id = ' || arg_search_manager, where_clause);

        order_clause := order_clause_build(arg_orderby, 'publisher_name');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    pac.id,
                                    pac.publisher_id,
                                    COALESCE (up.company_name, CONCAT (con.first_name, CHR(1), con.last_name)) AS publisher_name,
                                    pac.changed_at AS date_changed,
                                    pac.status,
                                    mgr.id AS manager_id,
                                    CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS manager_name
                                FROM publisher_account_changes pac
                                LEFT JOIN users u ON u.id = pac.publisher_id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users mgr ON mgr.id = u.manager_id
                                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                                LEFT JOIN user_profiles mup ON mup.user_id = mgr.id '                                
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_account_changes_get_list(arg_publisher_id bigint, arg_search_manager text, arg_status text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_account_changes_get_update(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_account_changes_get_update(arg_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_id::TEXT, 'pac.id = ' || arg_id, where_clause);

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    pac.id,
                                    pac.publisher_id,
                                    COALESCE (up.company_name, CONCAT (con.first_name, CHR(1), con.last_name)) AS publisher_name,
                                    pac.changed_at AS date_changed,
                                    pac.status,
                                    mgr.id AS manager_id,
                                    CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS manager_name                                   
                                FROM publisher_account_changes pac
                                LEFT JOIN users u ON u.id = pac.publisher_id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users mgr ON mgr.id = u.manager_id
                                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id                               
                                LEFT JOIN user_profiles mup ON mup.user_id = mgr.id '                                
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_account_changes_get_update(arg_id bigint) OWNER TO w4;

--
-- Name: publisher_account_changes_update(bigint, public.status_request); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_account_changes_update(arg_id bigint, arg_status public.status_request) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_ret_val json;
        var_update_result json;
        var_publisher_id bigint;
        var_contact_type text;
        var_image_id bigint;
        var_email text;
        var_primary_phone text;
        var_secondary_phone text;
        var_first_name text;
        var_last_name text;
        var_fax text;
        var_messenger_name text;
        var_messenger_type bigint;
        var_password text;
        var_login_name text;
        var_website_url text;
        var_address_1 text;
        var_address_2 text;
        var_country_id bigint;
        var_region_id bigint;
        var_city_id bigint;
        var_postal_code text;
        var_tax_id text;
        var_payment_method_id bigint;
        var_payment_to text;

    BEGIN
        SELECT
            publisher_id,
            contact_type,
            image_id,
            email,
            primary_phone,
            secondary_phone,
            first_name,
            last_name,
            fax,
            messenger_name,
            messenger_type,
            password,
            login_name,
            website_url,
            address_1,
            address_2,
            country_id,
            region_id,
            city_id,
            postal_code,
            tax_id,
            payment_method_id,
            payment_to
        FROM publisher_account_changes
        WHERE id = arg_id
        INTO var_publisher_id, var_contact_type, var_image_id, var_email, var_primary_phone, var_secondary_phone, var_first_name, var_last_name, var_fax, var_messenger_name, 
            var_messenger_type, var_password, var_login_name, var_website_url, var_address_1, var_address_2, var_country_id, var_region_id, var_city_id, var_postal_code, 
            var_tax_id, var_payment_method_id, var_payment_to;

        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find specied publisher change request: %', arg_id;
        END IF;

        IF (arg_status = 'accepted') THEN
            CASE var_contact_type
                WHEN 'billing' THEN
                    var_update_result := publisher_profile_payment_update(var_publisher_id, var_address_1, var_address_2, var_country_id, var_region_id, var_city_id, var_postal_code,
                                        var_tax_id, var_payment_method_id, var_payment_to);
                WHEN 'primary' THEN
                    var_update_result := publisher_profile_contact_update(var_publisher_id, var_image_id, var_email, var_primary_phone, var_secondary_phone, var_first_name,
                                        var_last_name, var_fax, var_messenger_name, var_messenger_type);
                WHEN 'account' THEN
                    var_update_result := publisher_profile_login_update(var_publisher_id, var_email, var_password, var_login_name, var_website_url, var_address_1, var_address_2,
                                        var_country_id, var_region_id, var_city_id, var_postal_code);
                    
                ELSE RAISE EXCEPTION 'No contact type found. %', var_contact_type;     
            END CASE;
        END IF;
        UPDATE publisher_account_changes SET status = arg_status WHERE id = arg_id;
        var_ret_val := publisher_account_changes_get_update(arg_id);
        RETURN var_ret_val;
    END;
$$;


ALTER FUNCTION w4api.publisher_account_changes_update(arg_id bigint, arg_status public.status_request) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_assoc_get(text, text, boolean, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_assoc_get(arg_publisher_search text DEFAULT NULL::text, arg_recommended_by text DEFAULT NULL::text, arg_status boolean DEFAULT NULL::boolean, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_campaign_recommendations_assoc_get_count(arg_publisher_search, arg_recommended_by, arg_status), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || publisher_campaign_recommendations_assoc_get_list(arg_publisher_search, arg_recommended_by, arg_status, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_assoc_get(arg_publisher_search text, arg_recommended_by text, arg_status boolean, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_assoc_get_count(text, text, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_assoc_get_count(arg_publisher_search text DEFAULT NULL::text, arg_recommended_by text DEFAULT NULL::text, arg_status boolean DEFAULT NULL::boolean) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        pcr_null text := 'NULL';
    BEGIN
        where_clause := where_clause_build('publisher', 'u.access = $$publisher$$'  , where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, 'pcr.user_id =' || arg_recommended_by , where_clause);
        where_clause := where_clause_build(arg_publisher_search::TEXT, 'u.id = ' || arg_publisher_search, where_clause);
        IF arg_status THEN
            pcr_null := 'NOT NULL';
        END IF;            
        where_clause := where_clause_build(arg_status::TEXT, 'pcr.id IS ' || pcr_null, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM users u
            LEFT JOIN publisher_campaign_recommendations pcr ON pcr.publisher_id = u.id
            LEFT JOIN contacts con ON con.id = u.primary_contact_id
            LEFT JOIN user_profiles up ON up.user_id = u.id
            LEFT JOIN users adm ON adm.id = pcr.user_id
            LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id '                                
           || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_assoc_get_count(arg_publisher_search text, arg_recommended_by text, arg_status boolean) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_assoc_get_list(text, text, boolean, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_assoc_get_list(arg_publisher_search text DEFAULT NULL::text, arg_recommended_by text DEFAULT NULL::text, arg_status boolean DEFAULT NULL::boolean, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        pcr_null text := 'NULL';
    BEGIN
        where_clause := where_clause_build('publisher', 'u.access = $$publisher$$'  , where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, 'pcr.user_id =' || arg_recommended_by , where_clause);
        where_clause := where_clause_build(arg_publisher_search::TEXT, 'u.id = ' || arg_publisher_search, where_clause);
        IF arg_status THEN
            pcr_null := 'NOT NULL';
        END IF;            
        where_clause := where_clause_build(arg_status::TEXT, 'pcr.id IS ' || pcr_null, where_clause);


        order_clause := order_clause_build(arg_orderby, 'publisher_name');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    u.id AS publisher_id,
                                    pcr.id,
                                    COALESCE (up.company_name, CONCAT (con.first_name, CHR(1), con.last_name)) AS publisher_name,
                                    pcr.created_at AS recommended_date,
                                    pcr.user_id AS recommended_by_id,
                                    CONCAT (acon.first_name, CHR(1), acon.last_name) AS recommended_by_name,
                                    (CASE
                                        WHEN pcr.id IS NULL
                                        THEN FALSE
                                        ELSE TRUE
                                    END) AS status                                 
                                FROM users u
                                LEFT JOIN publisher_campaign_recommendations pcr ON pcr.publisher_id = u.id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users adm ON adm.id = pcr.user_id
                                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id '                                
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_assoc_get_list(arg_publisher_search text, arg_recommended_by text, arg_status boolean, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_assoc_update(json, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_assoc_update(arg_publisher_ids json, arg_campaign_id bigint, arg_user_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        pub_id bigint;
        publisher_ids bigint[];
        ret_val json;
    BEGIN
        PERFORM id FROM campaigns WHERE id = arg_campaign_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified campaign (%).', arg_campaign_id;
        END IF;
        FOR pub_id IN SELECT json_array_elements(arg_publisher_ids->'publisher_ids') LOOP
            INSERT INTO publisher_campaign_recommendations
                (publisher_id, campaign_id, user_id, created_at, updated_at)
                VALUES (pub_id, arg_campaign_id, arg_user_id, NOW(), NOW());
            publisher_ids := array_append(publisher_ids, pub_id);
        END LOOP;
        IF array_length(publisher_ids, 1) > 1 THEN
            ret_val := publisher_campaign_recommendations_assoc_update_get_list(publisher_ids);
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_assoc_update(arg_publisher_ids json, arg_campaign_id bigint, arg_user_id bigint) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_assoc_update_get_list(bigint[]); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_assoc_update_get_list(arg_publisher_ids bigint[] DEFAULT NULL::bigint[]) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        pub_id bigint;
    BEGIN
        FOREACH pub_id IN ARRAY arg_publisher_ids LOOP
            IF where_clause != '' THEN
                where_clause := where_clause || ' OR ';
            ELSE
                where_clause := ' WHERE ';
            END IF;
            where_clause := where_clause || 'u.id = ' || pub_id;
        END LOOP;
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    u.id AS publisher_id,
                                    pcr.id,
                                    COALESCE (up.company_name, CONCAT (con.first_name, CHR(1), con.last_name)) AS publisher_name,
                                    pcr.created_at AS recommended_date,
                                    pcr.user_id AS recommended_by_id,
                                    CONCAT (acon.first_name, CHR(1), acon.last_name) AS recommended_by_name,
                                    (CASE
                                        WHEN pcr.id IS NULL
                                        THEN FALSE
                                        ELSE TRUE
                                    END) AS status
                                FROM users u
                                LEFT JOIN publisher_campaign_recommendations pcr ON pcr.publisher_id = u.id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users adm ON adm.id = pcr.user_id
                                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id '
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_assoc_update_get_list(arg_publisher_ids bigint[]) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        DELETE FROM publisher_campaign_recommendations WHERE id=arg_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_delete(arg_id bigint) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_get(bigint, bigint, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_get(arg_campaign_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_campaign_recommendations_get_count(arg_campaign_id, arg_publisher_id, arg_recommended_by, arg_min_date, arg_max_date), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || publisher_campaign_recommendations_get_list(arg_campaign_id, arg_publisher_id, arg_recommended_by, arg_min_date, arg_max_date, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_get(arg_campaign_id bigint, arg_publisher_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_get_count(bigint, bigint, text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_get_count(arg_campaign_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'pcr.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'pcr.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, 'pcr.user_id = ' || arg_recommended_by, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM publisher_campaign_recommendations pcr
            LEFT JOIN users u ON u.id = pcr.publisher_id
            LEFT JOIN contacts con ON con.id = u.primary_contact_id
            LEFT JOIN user_profiles up ON up.user_id = u.id
            LEFT JOIN users adm ON adm.id = pcr.user_id
            LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id '                                
           || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_get_count(arg_campaign_id bigint, arg_publisher_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_get_list(bigint, bigint, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_campaign_recommendations_get_list(arg_campaign_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'pcr.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'pcr.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, 'pcr.user_id = ' || arg_recommended_by, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);

        order_clause := order_clause_build(arg_orderby, 'publisher_name');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    pcr.id,
                                    pcr.campaign_id,
                                    pcr.publisher_id,
                                    COALESCE (up.company_name, CONCAT (con.first_name, CHR(1), con.last_name)) AS publisher_name,
                                    pcr.created_at AS recommended_date,
                                    pcr.user_id AS recommended_by_id,
                                    CONCAT (acon.first_name, CHR(1), acon.last_name) AS recommended_by_name                                    
                                FROM publisher_campaign_recommendations pcr
                                LEFT JOIN users u ON u.id = pcr.publisher_id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users adm ON adm.id = pcr.user_id
                                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id '                                
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_campaign_recommendations_get_list(arg_campaign_id bigint, arg_publisher_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_creatives_options_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_creatives_options_get(arg_publisher_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := 'WHERE creatives.type = 1';
    BEGIN
        where_clause := w4_automatic_functions.where_clause_build(arg_publisher_id::TEXT, 'rdw_clicks_and_conversions.publisher_id=' || arg_publisher_id, where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_campaign_id::TEXT, 'rdw_clicks_and_conversions.campaign_id=' || arg_campaign_id, where_clause);
		EXECUTE
            'SELECT array_to_json (array_agg(row_to_json (results)))FROM (
                SELECT row_to_json (row)
                  FROM (
                       SELECT
                          creatives.id,
                          creatives.name
                        FROM (
			  SELECT 
				publisher_id,
				campaign_id
			  FROM reporting.reports_wide_daily											
			)rdw_clicks_and_conversions
                        RIGHT JOIN campaigns campaigns ON rdw_clicks_and_conversions.campaign_id = campaigns.id
                        LEFT JOIN creatives ON rdw_clicks_and_conversions.campaign_id = creatives.campaign_id
			LEFT JOIN creative_banners ON creative_banners.creative_id = creatives.id
                        '|| where_clause || '
                        GROUP BY 
                        	creatives.name,                   	 
                        	creatives.id,
                        	rdw_clicks_and_conversions.campaign_id,
                        	rdw_clicks_and_conversions.publisher_id
			ORDER BY creatives.name asc
                ) row
             ) results;'
        INTO ret_val;
        RETURN ret_val;
     END$$;


ALTER FUNCTION w4api.publisher_creatives_options_get(arg_publisher_id bigint, arg_campaign_id bigint) OWNER TO w4;

--
-- Name: publisher_details_cpa_get(bigint, bigint, timestamp with time zone, timestamp with time zone, text, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_cpa_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            summary json;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_details_cpa_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_status, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            IF arg_summary THEN
                summary := publisher_details_cpa_get_summary(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_status, arg_currency_id);
            ELSE
                summary := '{}';
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_details_cpa_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_status, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "summary": ' || summary ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_details_cpa_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: publisher_details_cpa_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_cpa_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pusr.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rcrd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rcrd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rcrd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'cmp.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM (
                SELECT
                    rcrd.campaign_id, rcrd.pay_in_amount, rcrd.pay_out_amount
                FROM users pusr
                LEFT JOIN user_profiles pup ON (pusr.id = pup.user_id)
                LEFT JOIN reports_daily rcrd ON pusr.id = rcrd.publisher_id
                LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id
                LEFT JOIN vw_publisher_groups vpg ON pusr.id = vpg.publisher_id '
                || where_clause || '
                GROUP BY rcrd.campaign_id, rcrd.pay_in_amount, rcrd.pay_out_amount 
            ) AS the_count ' 
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_cpa_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_details_cpa_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_cpa_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pusr.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rcrd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rcrd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rcrd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'cmp.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'doy DESC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM ( 
                                SELECT
                                    max(pusr.id) AS publisher_id, 
                                    rcrd.campaign_id, 
                                    max(cmp.name::text) AS campaign_name, 
                                    COALESCE(max(pup.company_name::text), concat(max(pup.first_name::text), $$ $$, max(pup.last_name::text))) AS publisher_name, 
                                    max(cmp.status) AS status, 
                                    max(pusr.manager_id) AS manager, 
                                    max(vpg.groups) AS publisher_groups, 
                                    max(rcrd.doy) AS doy, 
                                    COALESCE(sum(rcrd.total_conversions), 0) AS conversions, 
                                    COALESCE(sum(rcrd.total_clicks), 0) AS total_clicks, 
                                    COALESCE(sum(rcrd.unique_clicks), 0) AS unique_clicks, 
                                    COALESCE(sum(rcrd.total_pay_in), 0) AS total_in, 
                                    COALESCE(sum(rcrd.total_pay_out), 0) AS total_out, 
                                    COALESCE(sum(rcrd.profit), 0) AS total_profit,
                                    ROUND(COALESCE((1 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0)), 0)::numeric, 4) AS profit_pct,
                                    ROUND(COALESCE((SUM(rcrd.total_conversions) / NULLIF(SUM(rcrd.unique_clicks), 0)), 0)::numeric, 4) AS conversion_pct,
                                    COALESCE(SUM(rcrd.total_pay_out)/NULLIF(SUM(rcrd.unique_clicks),0),0) AS epc,
                                    rcrd.pay_in_amount AS pay_in, 
                                    rcrd.pay_out_amount AS pay_out
                                FROM users pusr
                                LEFT JOIN user_profiles pup ON (pusr.id = pup.user_id)
                                LEFT JOIN reports_daily rcrd ON pusr.id = rcrd.publisher_id
                                LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id
                                LEFT JOIN vw_publisher_groups vpg ON pusr.id = vpg.publisher_id '
                                || where_clause || '
                                GROUP BY rcrd.campaign_id, rcrd.pay_in_amount, rcrd.pay_out_amount '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.publisher_details_cpa_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_details_cpa_get_summary(bigint, bigint, timestamp with time zone, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_cpa_get_summary(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pusr.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rcrd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rcrd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rcrd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'pusr.active = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM ( 
                                SELECT 
                                    COALESCE(SUM(rcrd.unique_clicks),0) AS clicks,
                                    COALESCE(SUM(rcrd.total_clicks),0) AS total_clicks,
                                    COALESCE(SUM(rcrd.total_conversions),0) AS conversions,
                                    ROUND(COALESCE((SUM(rcrd.total_conversions)/NULLIF(SUM(rcrd.unique_clicks), 0)), 0)::numeric, 4) AS conversion_pct,
                                    COALESCE(SUM(rcrd.total_pay_out)/NULLIF(SUM(rcrd.unique_clicks),0),0) AS pepc,
                                    COALESCE(SUM(rcrd.total_pay_in),0) AS total_in,
                                    COALESCE(SUM(rcrd.total_pay_out),0) AS total_out,
                                    COALESCE(SUM(rcrd.profit),0) AS total_profit,
                                    ROUND(COALESCE(((SUM(rcrd.total_pay_in) - SUM(rcrd.total_pay_out)) / NULLIF(SUM(rcrd.total_pay_in), 0)), 0)::numeric, 4) AS profit_pct
                                FROM users pusr
                                LEFT JOIN user_profiles pup ON (pusr.id = pup.user_id)
                                LEFT JOIN reports_daily rcrd ON pusr.id = rcrd.publisher_id
                                LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id
                                LEFT JOIN vw_publisher_groups vpg ON pusr.id = vpg.publisher_id '
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_cpa_get_summary(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_details_creative_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, text, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_creative_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_creative_id bigint DEFAULT NULL::bigint, arg_creative_name text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT (2)::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            summary json;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_details_creative_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_creative_id, arg_creative_name, arg_campaign_status, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_details_creative_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_creative_id, arg_creative_name, arg_campaign_status, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_details_creative_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_creative_id bigint, arg_creative_name text, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_details_creative_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_creative_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_creative_id bigint DEFAULT NULL::bigint, arg_creative_name text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_creative_id::TEXT, 'creative_id = ' || arg_creative_id, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_creative_name::TEXT, 'creative_name ILIKE $$%' || arg_creative_name || '%$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM (
                SELECT
                    x.publisher_id, 
                    x.campaign_id, 
                    x.creative_id, 
                    x.creative_name, 
                    x.creative_description, 
                    x.creative_image_id, 
                    sum(x.total_clicks) AS total_clicks, 
                    sum(x.unique_clicks) AS unique_clicks, 
                    sum(x.total_conversions) AS total_conversions, 
                    sum(x.payout) AS payout,
                    ROUND(sum(x.total_conversions) / NULLIF(sum(x.unique_clicks), 0)::numeric, 4) AS conversion_pct,
                    max(x.doy) AS doy, 
                    x.campaign_name,
                    x.currency_id,
                    x.status
                FROM (
                    SELECT
                        rd.publisher_id, 
                        rd.campaign_id, 
                        cmp.name AS campaign_name, 
                        rd.creative_id, 
                        cr.name AS creative_name, 
                        cr.description AS creative_description, 
                        cb.image_id AS creative_image_id, 
                        rd.total_clicks, 
                        rd.unique_clicks, 
                        rd.total_conversions, 
                        rd.total_pay_out AS payout, 
                        rd.doy AS doy,
                        cmp.currency_id,
                        cmp.status
                    FROM reports_wide_daily rd
                    RIGHT JOIN campaigns cmp ON rd.campaign_id = cmp.id
                    LEFT JOIN creatives cr ON rd.creative_id = cr.id
                    LEFT JOIN creative_banners cb ON rd.creative_id = cb.creative_id
                    WHERE rd.publisher_id > 0 AND rd.campaign_id > 0
                    GROUP BY cr.name, cr.description, cb.image_id, cmp.name, rd.publisher_id, rd.publisher_pid, rd.creative_id, rd.pay_out_amount, rd.total_pay_in,
                        rd.total_pay_out, rd.profit, rd.advertiser_id, rd.sub_id_1, rd.sub_id_2, rd.sub_id_3, rd.sub_id_4, rd.country, rd.region_name, rd.city_name,
                        rd.browser_name, rd.platform_name, rd.campaign_id, rd.base_uri, rd.total_clicks, rd.total_conversions, rd.unique_clicks, rd.pay_in_amount,
                        cmp.currency_id, cmp.status, rd.doy
                ) x '
                || where_clause || '
                GROUP BY x.publisher_id, x.campaign_id, x.campaign_name, x.creative_id, x.creative_name, x.creative_description, x.creative_image_id, x.currency_id, x.status
            ) AS the_count ' 
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_creative_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_creative_id bigint, arg_creative_name text, arg_campaign_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_details_creative_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_creative_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_creative_id bigint DEFAULT NULL::bigint, arg_creative_name text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_creative_id::TEXT, 'creative_id = ' || arg_creative_id, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_creative_name::TEXT, 'creative_name ILIKE $$%' || arg_creative_name || '%$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'x.doy DESC, x.campaign_id, x.publisher_id');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    x.publisher_id, 
                                    x.campaign_id, 
                                    x.creative_id, 
                                    x.creative_name, 
                                    x.creative_description, 
                                    x.creative_image_id, 
                                    sum(x.total_clicks) AS total_clicks, 
                                    sum(x.unique_clicks) AS unique_clicks, 
                                    sum(x.total_conversions) AS total_conversions, 
                                    sum(x.payout) AS payout,
                                    ROUND(sum(x.total_conversions) / NULLIF(sum(x.unique_clicks), 0)::numeric, 4) AS conversion_pct,
                                    max(x.doy) AS doy, 
                                    x.campaign_name,
                                    x.currency_id,
                                    x.status
                                FROM (
                                    SELECT
                                        rd.publisher_id, 
                                        rd.campaign_id, 
                                        cmp.name AS campaign_name, 
                                        rd.creative_id, 
                                        cr.name AS creative_name, 
                                        cr.description AS creative_description, 
                                        cb.image_id AS creative_image_id, 
                                        rd.total_clicks, 
                                        rd.unique_clicks, 
                                        rd.total_conversions, 
                                        rd.total_pay_out AS payout, 
                                        rd.doy AS doy,
                                        cmp.currency_id,
                                        cmp.status
                                    FROM reports_wide_daily rd
                                    RIGHT JOIN campaigns cmp ON rd.campaign_id = cmp.id
                                    LEFT JOIN creatives cr ON rd.creative_id = cr.id
                                    LEFT JOIN creative_banners cb ON rd.creative_id = cb.creative_id
                                    WHERE rd.publisher_id > 0 AND rd.campaign_id > 0
                                    GROUP BY cr.name, cr.description, cb.image_id, cmp.name, rd.publisher_id, rd.publisher_pid, rd.creative_id, rd.pay_out_amount, rd.total_pay_in,
                                        rd.total_pay_out, rd.profit, rd.advertiser_id, rd.sub_id_1, rd.sub_id_2, rd.sub_id_3, rd.sub_id_4, rd.country, rd.region_name, rd.city_name,
                                        rd.browser_name, rd.platform_name, rd.campaign_id, rd.base_uri, rd.total_clicks, rd.total_conversions, rd.unique_clicks, rd.pay_in_amount,
                                        cmp.currency_id, cmp.status, rd.doy
                                ) x '
                                || where_clause || '
                                GROUP BY x.publisher_id, x.campaign_id, x.campaign_name, x.creative_id, x.creative_name, x.creative_description, x.creative_image_id, x.currency_id, x.status '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_creative_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_creative_id bigint, arg_creative_name text, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_details_referrer_get(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_referrer_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_base_uri text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            summary json;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_details_referrer_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_base_uri, arg_campaign_status, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_details_referrer_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_base_uri, arg_campaign_status, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_details_referrer_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_base_uri text, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_details_referrer_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_referrer_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_base_uri text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= $$' || min_doy || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < $$' || max_doy || '$$', where_clause);
        where_clause := where_clause_build(arg_base_uri::TEXT, 'base_uri = $$' || arg_base_uri || '$$', where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM (
                SELECT rd.publisher_id, rd.campaign_id, rd.base_uri
                FROM reports_wide_daily rd
                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id '
                || where_clause || '
                GROUP BY rd.publisher_id, rd.campaign_id, rd.base_uri
            ) AS the_count ' 
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_referrer_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_base_uri text, arg_campaign_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_details_referrer_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_referrer_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_base_uri text DEFAULT NULL::text, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= $$' || min_doy || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < $$' || max_doy || '$$', where_clause);
        where_clause := where_clause_build(arg_base_uri::TEXT, 'base_uri = $$' || arg_base_uri || '$$', where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    rd.publisher_id, 
                                    rd.base_uri, 
                                    max(cmp.name::text) AS campaign_name, 
                                    rd.campaign_id, 
                                    sum(rd.unique_clicks) AS clicks, 
                                    sum(rd.total_clicks) AS total_clicks, 
                                    sum(rd.total_conversions) AS conversions, 
                                    ROUND(COALESCE(SUM(rd.total_conversions) / NULLIF(SUM(rd.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct,
                                    max(cmp.currency_id) AS currency_id
                                FROM reports_wide_daily rd
                                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id '
                                || where_clause || '
                                GROUP BY rd.publisher_id, rd.campaign_id, rd.base_uri '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_referrer_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_base_uri text, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_details_sidebar_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_sidebar_get(arg_publisher_id bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        join_currency_clause text := '';
        overlapping_where_clause text := '';
        overlapping_invoice RECORD;
        overlapping_date_ranges doy_range[];
        overlapping_date_range doy_range;

    BEGIN
        --@todo should put this into its own sproc
        --get the total owed to publisher
        FOR overlapping_invoice IN 
            SELECT
                id, status, min_doy, max_doy
            FROM acct_invoices_publisher
            WHERE
                publisher_id = arg_publisher_id AND
                currency_id = arg_currency_id
        LOOP
            IF (overlapping_invoice.status = 'paid') THEN
                --Add paid existing ranges to be not included in new overlapping invoice.
                overlapping_date_ranges = array_append(overlapping_date_ranges, (overlapping_invoice.min_doy, overlapping_invoice.max_doy)::doy_range);
            END IF;
        END LOOP;

        IF (array_length(overlapping_date_ranges, 1) > 0) THEN        
            FOREACH overlapping_date_range IN ARRAY overlapping_date_ranges LOOP
                overlapping_where_clause := where_clause_build(overlapping_date_range.min_doy::text, 'NOT (doy BETWEEN ' || overlapping_date_range.min_doy || ' AND ' || overlapping_date_range.max_doy || ')', overlapping_where_clause);
            END LOOP;
        END IF;

        overlapping_where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, overlapping_where_clause);        
        overlapping_where_clause := where_clause_build('always'::TEXT, 'pay_out_amount > $$0$$', overlapping_where_clause);
        overlapping_where_clause := where_clause_build('always'::TEXT, 'total_conversions > 0', overlapping_where_clause);

        where_clause := where_clause_build('publisher', 'pusr.access::text = $$publisher$$', where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pusr.id = ' || arg_publisher_id, where_clause);

        IF (arg_currency_id IS NOT NULL) THEN
            join_currency_clause := ' AND cmp.currency_id = ' || arg_currency_id;
        END IF;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    max(pusr.manager_id) AS manager_id, 
                                    (max(mup.first_name)::text || '' ''::text) || max(mup.last_name)::text AS manager_name, 
                                    COALESCE(max(pup.company_name::text), concat(max(pup.first_name::text), $$ $$, max(pup.last_name::text))) AS publisher_name, 
                                    max(pusr.active) AS account_status, 
                                    (SELECT COALESCE(sum(result.payout)::numeric, 0) FROM (
                                        SELECT
                                            (sum(total_conversions) * pay_out_amount) AS payout
                                        FROM reports_daily '
                                        || overlapping_where_clause ||
                                        ' GROUP BY pay_out_amount) AS result
                                    ) AS debit_balance, 
                                    max(pup.payment_threshold) AS payment_threshold, 
                                    max(pup.payment_schedule) AS payment_terms, 
                                    (max(pc.first_name)::text || '' ''::text) || max(pc.last_name)::text AS contact_name, 
                                    max(pc.primary_phone) AS publisher_phone,
                                    max(pup.payment_to) AS payment_to, 
                                    max(pup.payment_by) AS payment_by, 
                                    max(pup.payment_schedule) AS payment_schedule, 
                                    max(bc.address_1) AS payment_address_1, 
                                    max(bc.address_2) AS payment_address_2, 
                                    max(bcy.place_name_ascii) AS payment_city, 
                                    max(bcr.ascii_name) AS payment_state, 
                                    max(bc.postal_code) AS payment_zip, 
                                    max(bcc.country) AS payment_country, 
                                    max(ac.address_1) AS address_1, 
                                    max(ac.address_2) AS address_2, 
                                    max(acy.place_name_ascii) AS city, 
                                    max(acr.ascii_name) AS state, 
                                    max(ac.postal_code) AS zip, 
                                    max(acc.country) AS country, 
                                    max(pc.email_address) AS email, 
                                    max(pup.website_url) AS website_url,
                                    max(im.description) AS messenger_type,
                                    max(pc.messenger_name) AS messenger_name,
                                    max(pup.notes) AS notes
                                FROM users pusr
                                LEFT JOIN users musr ON pusr.manager_id = musr.id
                                LEFT JOIN user_profiles pup ON pusr.id = pup.user_id
                                LEFT JOIN user_profiles mup ON musr.id = mup.user_id
                                LEFT JOIN reports_daily rd ON pusr.id = rd.publisher_id
                                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id ' || join_currency_clause || '
                                LEFT JOIN contacts bc ON pusr.billing_contact_id = bc.id
                                LEFT JOIN contacts ac ON pusr.account_contact_id = ac.id
                                LEFT JOIN contacts pc ON pusr.primary_contact_id = pc.id
                                LEFT JOIN im_types im ON pc.messenger_type = im.id
                                LEFT JOIN geo_typeahead_countries bcc ON bc.country_id = bcc.id
                                LEFT JOIN geo_typeahead_region bcr ON bc.region_id = bcr.id
                                LEFT JOIN geo_typeahead_cities bcy ON bc.city_id = bcy.id
                                LEFT JOIN geo_typeahead_countries acc ON ac.country_id = acc.id
                                LEFT JOIN geo_typeahead_region acr ON ac.region_id = acr.id
                                LEFT JOIN geo_typeahead_cities acy ON ac.city_id = acy.id '
                                || where_clause || '
                                GROUP BY pusr.id
                                LIMIT 1
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_sidebar_get(arg_publisher_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_details_subid_get(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, text, text, text, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_subid_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            summary json;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_details_subid_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_campaign_status, arg_sub_id_1, arg_sub_id_2,
                    arg_sub_id_3, arg_sub_id_4, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_details_subid_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_campaign_status, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3,
                                arg_sub_id_4, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_details_subid_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_details_subid_get(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, text, text, text, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_subid_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            summary json;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_details_subid_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_campaign_status, arg_sub_id_1, arg_sub_id_2,
                    arg_sub_id_3, arg_sub_id_4, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            IF arg_summary THEN
                summary := publisher_details_subid_get_summary(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_campaign_status, arg_sub_id_1, arg_sub_id_2,
                    arg_sub_id_3, arg_sub_id_4, arg_currency_id);
            ELSE
                summary := '{}';
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_details_subid_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_campaign_status, arg_sub_id_1, arg_sub_id_2, arg_sub_id_3,
                                arg_sub_id_4, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "summary": ' || summary ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_details_subid_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: publisher_details_subid_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_subid_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_sub_id_1::TEXT, 'sub_id_1 = $$' || arg_sub_id_1 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_2::TEXT, 'sub_id_2 = $$' || arg_sub_id_2 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_3::TEXT, 'sub_id_3 = $$' || arg_sub_id_3 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_4::TEXT, 'sub_id_4 = $$' || arg_sub_id_4 || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'camp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0) FROM (
                    SELECT 
                        mvsr.campaign_id,
                        MAX(camp.name) AS campaign_name,
                        mvsr.publisher_id, 
                        COALESCE(MAX(up.company_name), pg_catalog.concat(MAX(up.first_name), $$ $$, MAX(up.last_name))::character varying) AS publisher_name, 
                        MAX(mvsr.advertiser_id),
                        MAX(adv.name) AS advertiser_name,
                        MAX(mvsr.doy),
                        mvsr.sub_id_1, 
                        mvsr.sub_id_2,
                        mvsr.sub_id_3,
                        mvsr.sub_id_4,
                        COALESCE(SUM(mvsr.unique_clicks), 0) AS clicks, 
                        COALESCE(SUM(mvsr.total_conversions), 0) AS conversions,
                        COALESCE(SUM(mvsr.total_pay_in), 0) AS total_in, 
                        COALESCE(SUM(mvsr.total_pay_out), 0) AS total_out,
                        MAX(camp.status) AS campaign_status,
                        COALESCE(SUM(mvsr.total_pay_in) / NULLIF(SUM(mvsr.total_conversions), (0)::numeric), 0) AS average_in,
                        COALESCE(SUM(mvsr.total_pay_out) / NULLIF(SUM(mvsr.total_conversions), (0)::numeric), 0) AS average_out,
                        COALESCE((SUM(mvsr.total_pay_in) - SUM(mvsr.total_pay_out)) / NULLIF(SUM(mvsr.total_pay_in), 0) * 100, 0) AS profit_pct,
                        COALESCE(SUM(mvsr.total_conversions) / NULLIF(SUM(mvsr.unique_clicks), 0)*100,0) AS conversion_pct,
                        COALESCE(SUM(mvsr.total_pay_out) / NULLIF(SUM(mvsr.unique_clicks),0) ,0) AS epc,
                        COALESCE(SUM(mvsr.profit), 0) AS profit
                    FROM reporting.reports_subid_daily mvsr
                    LEFT JOIN users usr ON mvsr.publisher_id = usr.id
                    LEFT JOIN user_profiles up ON usr.id = up.user_id
                    LEFT JOIN advertisers adv ON mvsr.advertiser_id = adv.id
                    LEFT JOIN campaigns camp ON mvsr.campaign_id = camp.id '
                    || where_clause || '
                    GROUP BY publisher_id, campaign_id, sub_id_1, sub_id_2, sub_id_3, sub_id_4
                ) AS the_count '
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_subid_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_details_subid_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, text, text, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_subid_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_sub_id_1::TEXT, 'sub_id_1 = $$' || arg_sub_id_1 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_2::TEXT, 'sub_id_2 = $$' || arg_sub_id_2 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_3::TEXT, 'sub_id_3 = $$' || arg_sub_id_3 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_4::TEXT, 'sub_id_4 = $$' || arg_sub_id_4 || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'camp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'camp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT 
                                    mvsr.campaign_id,
                                    MAX(camp.name) AS campaign_name,
                                    mvsr.publisher_id, 
                                    COALESCE(MAX(up.company_name), pg_catalog.concat(MAX(up.first_name), $$ $$, MAX(up.last_name))::character varying) AS publisher_name, 
                                    MAX(mvsr.advertiser_id),
                                    MAX(adv.name) AS advertiser_name,
                                    MAX(mvsr.doy),
                                    mvsr.sub_id_1, 
                                    mvsr.sub_id_2,
                                    mvsr.sub_id_3,
                                    mvsr.sub_id_4,
                                    COALESCE(SUM(mvsr.unique_clicks), 0) AS clicks, 
                                    COALESCE(SUM(mvsr.total_clicks), 0) AS total_clicks, 
                                    COALESCE(SUM(mvsr.total_conversions), 0) AS conversions,
                                    COALESCE(SUM(mvsr.total_pay_in), 0) AS total_in, 
                                    COALESCE(SUM(mvsr.total_pay_out), 0) AS total_out,
                                    MAX(camp.status) AS campaign_status,
                                    COALESCE(SUM(mvsr.total_pay_in) / NULLIF(SUM(mvsr.total_conversions), (0)::numeric), 0) AS average_in,
                                    COALESCE(SUM(mvsr.total_pay_out) / NULLIF(SUM(mvsr.total_conversions), (0)::numeric), 0) AS average_out,
                                    ROUND(COALESCE(1 - SUM(mvsr.total_pay_out) / NULLIF(SUM(mvsr.total_pay_in), 0), 0)::numeric, 4) AS profit_pct,
                                    ROUND(COALESCE(SUM(mvsr.total_conversions) / NULLIF(SUM(mvsr.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct,
                                    COALESCE(SUM(mvsr.total_pay_out) / NULLIF(SUM(mvsr.unique_clicks),0) ,0) AS epc,
                                    COALESCE(SUM(mvsr.profit), 0) AS profit
                                FROM reporting.reports_subid_daily mvsr
                                LEFT JOIN users usr ON mvsr.publisher_id = usr.id
                                LEFT JOIN user_profiles up ON usr.id = up.user_id
                                LEFT JOIN advertisers adv ON mvsr.advertiser_id = adv.id
                                LEFT JOIN campaigns camp ON mvsr.campaign_id = camp.id '
                                || where_clause || '
                                GROUP BY publisher_id, campaign_id, sub_id_1, sub_id_2, sub_id_3, sub_id_4 '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.publisher_details_subid_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_details_subid_get_summary(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_subid_get_summary(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'mvsr.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'mvsr.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_sub_id_1::TEXT, 'mvsr.sub_id_1 = $$' || arg_sub_id_1 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_2::TEXT, 'mvsr.sub_id_2 = $$' || arg_sub_id_2 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_3::TEXT, 'mvsr.sub_id_3 = $$' || arg_sub_id_3 || '$$', where_clause);
        where_clause := where_clause_build(arg_sub_id_4::TEXT, 'mvsr.sub_id_4 = $$' || arg_sub_id_4 || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'mvsr.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'mvsr.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'camp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'camp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT 
                                    COALESCE(SUM(mvsr.unique_clicks), 0) AS clicks, 
                                    COALESCE(SUM(mvsr.total_clicks), 0) AS total_clicks, 
                                    COALESCE(SUM(mvsr.total_conversions), 0) AS conversions,
                                    COALESCE(SUM(mvsr.total_pay_in), 0) AS total_in, 
                                    COALESCE(SUM(mvsr.total_pay_out), 0) AS total_out,
                                    COALESCE(SUM(mvsr.total_pay_in) / NULLIF(SUM(mvsr.total_conversions), (0)::numeric), 0) AS average_in,
                                    COALESCE(SUM(mvsr.total_pay_out) / NULLIF(SUM(mvsr.total_conversions), (0)::numeric), 0) AS average_out,
                                    ROUND(COALESCE((SUM(mvsr.total_pay_in) - SUM(mvsr.total_pay_out)) / NULLIF(SUM(mvsr.total_pay_in), 0), 0)::numeric, 4) AS profit_pct,
                                    ROUND(COALESCE(SUM(mvsr.total_conversions) / NULLIF(SUM(mvsr.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct,
                                    COALESCE(SUM(mvsr.total_pay_out) / NULLIF(SUM(mvsr.unique_clicks),0) ,0) AS epc,
                                    COALESCE(SUM(mvsr.profit), 0) AS profit
                                FROM reporting.reports_subid_daily mvsr
                                LEFT JOIN users usr ON mvsr.publisher_id = usr.id
                                LEFT JOIN user_profiles up ON usr.id = up.user_id
                                LEFT JOIN advertisers adv ON mvsr.advertiser_id = adv.id
                                LEFT JOIN campaigns camp ON mvsr.campaign_id = camp.id '
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_subid_get_summary(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_details_traffic_get(bigint, bigint, timestamp with time zone, timestamp with time zone, text, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_traffic_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
            summary json;

	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_details_traffic_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_campaign_status, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            IF arg_summary THEN
                summary := publisher_details_traffic_get_summary(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_campaign_status, arg_currency_id);
            ELSE
                summary := '{}';
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_details_traffic_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_campaign_status, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "summary": ' || summary ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_details_traffic_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: publisher_details_traffic_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_traffic_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'clk.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'clk.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM (
                SELECT clk.campaign_id
                FROM reports_daily clk
                LEFT JOIN campaigns cmp ON clk.campaign_id = cmp.id
                LEFT JOIN tvw_7_day_trend_line v7dtl ON cmp.id = v7dtl.campaign_id AND v7dtl.publisher_id = clk.publisher_id '
                || where_clause || '
                GROUP BY clk.publisher_id, clk.campaign_id
            ) AS the_count ' 
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_traffic_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_details_traffic_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_traffic_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;
    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'clk.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'clk.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'doy DESC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT clk.publisher_id, 
                                    clk.campaign_id, 
                                    max(cmp.name::text) AS campaign_name, 
                                    max(clk.advertiser_id) AS advertiser_id, 
                                    max(cmp.status::text) AS campaign_status, 
                                    COALESCE(max(v7dtl.unique_clk_trend), $$0+0+0+0+0+0+0$$::text) AS trending, 
                                    sum(clk.unique_clicks) AS clicks, 
                                    sum(clk.total_clicks) AS total_clicks, 
                                    sum(clk.total_conversions) AS conversions, 
                                    ROUND(COALESCE(sum(clk.total_conversions) / NULLIF(sum(clk.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct, 
                                    COALESCE(sum(clk.total_pay_out) / NULLIF(sum(clk.unique_clicks), 0::numeric), 0::numeric) AS epc, 
                                    sum(clk.total_pay_in) AS total_in, 
                                    sum(clk.total_pay_out) AS total_out, 
                                    sum(clk.total_pay_in) / NULLIF(sum(clk.total_conversions), 0::numeric) AS average_in, 
                                    sum(clk.total_pay_out) / NULLIF(sum(clk.total_conversions), 0::numeric) AS average_out, 
                                    sum(clk.profit) AS total_profit,
                                    ROUND(COALESCE((1 - sum(clk.total_pay_out) / NULLIF(sum(clk.total_pay_in), 0)), 0)::numeric, 4) AS profit_pct, 
                                    max(clk.doy) AS doy,
                                    max(cmp.currency_id) AS currency_id
                                FROM reports_daily clk
                                LEFT JOIN campaigns cmp ON clk.campaign_id = cmp.id
                                LEFT JOIN tvw_7_day_trend_line v7dtl ON cmp.id = v7dtl.campaign_id AND v7dtl.publisher_id = clk.publisher_id '
                                || where_clause || '
                                GROUP BY clk.publisher_id, clk.campaign_id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.publisher_details_traffic_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_details_traffic_get_summary(bigint, bigint, timestamp with time zone, timestamp with time zone, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_details_traffic_get_summary(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_campaign_status text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'clk.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'clk.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_campaign_status::TEXT, 'cmp.status = $$' || arg_campaign_status || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    COALESCE(SUM(clk.unique_clicks), 0) AS clicks,
                                    COALESCE(SUM(clk.total_clicks), 0) AS total_clicks,
                                    COALESCE(SUM(clk.total_conversions), 0) AS conversions,
                                    ROUND(COALESCE(sum(clk.total_conversions) / NULLIF(sum(clk.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct, 
                                    COALESCE(sum(clk.total_pay_out) / NULLIF(sum(clk.unique_clicks), 0::numeric), 0::numeric) AS epc,
                                    COALESCE(SUM(clk.total_pay_out), 0) AS revenue,
                                    COALESCE(SUM(clk.total_pay_out), 0) AS total_out,
                                    COALESCE(SUM(clk.profit), 0) AS total_profit,
                                    ROUND(COALESCE(((SUM(clk.total_pay_in) - SUM(clk.total_pay_out)) / NULLIF(SUM(total_pay_in), 0)), 0)::numeric, 4) AS profit_pct
                                FROM reports_daily clk
                                LEFT JOIN campaigns cmp ON clk.campaign_id = cmp.id '
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_details_traffic_get_summary(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_campaign_status text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_get(text, text, json, json, json, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_get(arg_traffic_search text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_publisher_ids json DEFAULT NULL::json, arg_manager_ids json DEFAULT NULL::json, arg_pub_group_ids json DEFAULT NULL::json, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (publisher_get_count(arg_traffic_search, arg_status, arg_publisher_ids, arg_manager_ids, arg_pub_group_ids), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || publisher_get_list(arg_traffic_search, arg_status, arg_publisher_ids, arg_manager_ids, arg_pub_group_ids, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.publisher_get(arg_traffic_search text, arg_status text, arg_publisher_ids json, arg_manager_ids json, arg_pub_group_ids json, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_get_count(text, text, json, json, json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_get_count(arg_traffic_search text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_publisher_ids json DEFAULT NULL::json, arg_manager_ids json DEFAULT NULL::json, arg_pub_group_ids json DEFAULT NULL::json) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        var_publisher_ids bigint[];
        var_manager_ids bigint[];
	var_pub_group_ids bigint[];

    BEGIN
	IF arg_publisher_ids IS NOT NULL THEN
		var_publisher_ids := json_array_convert( arg_publisher_ids )::bigint[];
	END IF;

	IF arg_manager_ids IS NOT NULL THEN
		var_manager_ids := json_array_convert( arg_manager_ids )::bigint[];
	END IF;

	IF arg_pub_group_ids IS NOT NULL THEN
		var_pub_group_ids := json_array_convert( arg_pub_group_ids )::bigint[];
	END IF;

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0)
            FROM users usr
            LEFT JOIN users musr ON usr.manager_id = musr.id
            LEFT JOIN user_profiles pup ON usr.id = pup.user_id
            LEFT JOIN user_profiles mup ON musr.id = mup.user_id
            LEFT JOIN vw_publisher_groups_assoc vpg ON usr.id = vpg.publisher_id AND vpg.status = ''active''
            WHERE
                (usr.access = ''publisher'') AND
                ($1 IS NULL or usr.active = $1) AND                                    
                ($2 IS NULL OR ARRAY[usr.id] && $2) AND
                ($3 IS NULL OR ARRAY[usr.manager_id] && $3) AND
                ($4 IS NULL OR vpg.groups && $4) AND
                ($5 IS NULL OR (
                    (usr.id::text ILIKE $5) OR
                    (matches(COALESCE(pup.company_name, concat(pup.first_name, $$ $$, pup.last_name)), $5)) OR
                    (usr.manager_id::text ILIKE $5 AND musr.access = ''admin'') OR
                    (matches(mup.first_name || '' '' || mup.last_name, $5)))
                )
             LIMIT 1; '
        INTO retval
        USING arg_status, var_publisher_ids, var_manager_ids, var_pub_group_ids, arg_traffic_search;

        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.publisher_get_count(arg_traffic_search text, arg_status text, arg_publisher_ids json, arg_manager_ids json, arg_pub_group_ids json) OWNER TO w4;

--
-- Name: publisher_get_list(text, text, json, json, json, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_get_list(arg_traffic_search text DEFAULT NULL::text, arg_status text DEFAULT NULL::text, arg_publisher_ids json DEFAULT NULL::json, arg_manager_ids json DEFAULT NULL::json, arg_pub_group_ids json DEFAULT NULL::json, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        var_publisher_ids bigint[];
        var_manager_ids bigint[];
	var_pub_group_ids bigint[];
        var_publisher_id bigint;

    BEGIN
	IF arg_publisher_ids IS NOT NULL THEN
            var_publisher_ids := json_array_convert(arg_publisher_ids)::bigint[];
	END IF;

	IF arg_manager_ids IS NOT NULL THEN
            var_manager_ids := json_array_convert(arg_manager_ids)::bigint[];
	END IF;

	IF arg_pub_group_ids IS NOT NULL THEN
            var_pub_group_ids := json_array_convert(arg_pub_group_ids)::bigint[];
	END IF;

        order_clause := order_clause_build(arg_orderby, 'publisher_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    usr.active AS status,
                                    usr.id AS publisher_id,
                                    COALESCE(pup.company_name, concat(pc.first_name, '' '', pc.last_name)) AS publisher_name, 
                                    usr.manager_id AS manager_id,
                                    mup.first_name || '' '' || mup.last_name AS manager_name
                                FROM users usr
                                LEFT JOIN users musr ON usr.manager_id = musr.id
                                LEFT JOIN user_profiles pup ON usr.id = pup.user_id
                                LEFT JOIN contacts pc ON usr.primary_contact_id = pc.id
                                LEFT JOIN user_profiles mup ON musr.id = mup.user_id
                                LEFT JOIN vw_publisher_groups_assoc vpg ON usr.id = vpg.publisher_id AND vpg.status = ''active''
                                WHERE
                                    (usr.access = ''publisher'') AND
                                    ($1 IS NULL or usr.active = $1) AND                                    
                                    ($2 IS NULL OR ARRAY[usr.id] && $2) AND
                                    ($3 IS NULL OR ARRAY[usr.manager_id] && $3) AND
                                    ($4 IS NULL OR vpg.groups && $4) AND
                                    ($5 IS NULL OR (
                                        (usr.id::text ILIKE $5) OR
                                        (matches(COALESCE(pup.company_name, concat(pup.first_name, $$ $$, pup.last_name)), $5)) OR
                                        (usr.manager_id::text ILIKE $5 AND musr.access = ''admin'') OR
                                        (matches(mup.first_name || '' '' || mup.last_name, $5)))
                                    ) '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val
        USING arg_status, var_publisher_ids, var_manager_ids, var_pub_group_ids, arg_traffic_search;

        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.publisher_get_list(arg_traffic_search text, arg_status text, arg_publisher_ids json, arg_manager_ids json, arg_pub_group_ids json, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_group_members_get(bigint, bigint, text, boolean, bigint, boolean, boolean, boolean, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_group_members_get(arg_publisher_group_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_status text DEFAULT NULL::text, arg_active boolean DEFAULT NULL::boolean, arg_user_id bigint DEFAULT NULL::bigint, arg_pubs_in_group boolean DEFAULT false, arg_pubs_no_group boolean DEFAULT false, arg_pubs_in_any_group boolean DEFAULT false, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_group_members_get_count(arg_publisher_group_id, arg_publisher_id, arg_status, arg_active, arg_user_id, arg_pubs_in_group, arg_pubs_no_group, arg_pubs_in_any_group), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_group_members_get_list(arg_publisher_group_id, arg_publisher_id, arg_status, arg_active, arg_user_id, arg_pubs_in_group, arg_pubs_no_group, arg_pubs_in_any_group, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_group_members_get(arg_publisher_group_id bigint, arg_publisher_id bigint, arg_status text, arg_active boolean, arg_user_id bigint, arg_pubs_in_group boolean, arg_pubs_no_group boolean, arg_pubs_in_any_group boolean, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_group_members_get_count(bigint, bigint, text, boolean, bigint, boolean, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_group_members_get_count(arg_publisher_group_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_status text DEFAULT NULL::text, arg_active boolean DEFAULT NULL::boolean, arg_user_id bigint DEFAULT NULL::bigint, arg_pubs_in_group boolean DEFAULT false, arg_pubs_no_group boolean DEFAULT false, arg_pubs_in_any_group boolean DEFAULT false) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        join_type text := 'LEFT JOIN';
        join_clause text := 'AND pga.group_id = ' || arg_publisher_group_id;
        union_clause text := '';

    BEGIN
        where_clause := where_clause_build('publisher', 'u.access = $$publisher$$'  , where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'u.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'u.active = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_user_id::TEXT, 'u.manager_id = ' || arg_user_id, where_clause);

        IF (arg_pubs_in_any_group) THEN
            join_clause := '';
            join_type := 'INNER JOIN';
        ELSE
            IF (arg_pubs_in_group) THEN
                join_type := 'INNER JOIN';
                IF (arg_pubs_no_group) THEN
                    where_clause := where_clause || ' AND pga.publisher_id IS NULL ';
                    union_clause := '
                        UNION SELECT
                            u.id AS publisher_id,
                            COALESCE (MAX(up.company_name), CONCAT (MAX(mcon.first_name), CHR(1), MAX(mcon.last_name))) AS publisher_name,
                            MAX(mgr.id) AS manager_id,
                            CONCAT (MAX(mcon.first_name), CHR(1), MAX(mcon.last_name)) AS manager_name,
                            (CASE
                                WHEN MAX(pg.id) = ' || arg_publisher_group_id || '
                                THEN TRUE ELSE FALSE
                            END) AS member,
                            MAX(pg.id) AS group_id,
                            MAX(pg.name) AS group_name
                        FROM users u
                        LEFT JOIN contacts con ON con.id = u.primary_contact_id
                        LEFT JOIN user_profiles up ON up.user_id = u.id
                        LEFT JOIN users mgr ON mgr.id = u.manager_id
                        LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                        ' || join_type || ' publisher_groups_assoc pga ON pga.publisher_id = u.id
                        LEFT JOIN publisher_groups pg ON pg.id = pga.group_id AND pg.status = ''active'''
                        || where_clause;
                END IF;
            ELSE
                IF (arg_pubs_no_group) THEN
                    join_clause := '';
                    where_clause := where_clause || ' AND pga.publisher_id IS NULL ';
                ELSE
                    join_clause := '';
                END IF;
            END IF;
        END IF;


        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM (
                SELECT
                    u.id
                FROM users u
                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                LEFT JOIN user_profiles up ON up.user_id = u.id
                LEFT JOIN users mgr ON mgr.id = u.manager_id
                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                ' || join_type || ' publisher_groups_assoc pga ON pga.publisher_id = u.id ' || join_clause || '
                LEFT JOIN publisher_groups pg ON pg.id = pga.group_id AND pg.status = ''active'''
                || where_clause ||
                ' GROUP BY u.id
            ) the_count '
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_group_members_get_count(arg_publisher_group_id bigint, arg_publisher_id bigint, arg_status text, arg_active boolean, arg_user_id bigint, arg_pubs_in_group boolean, arg_pubs_no_group boolean, arg_pubs_in_any_group boolean) OWNER TO w4;

--
-- Name: publisher_group_members_get_list(bigint, bigint, text, boolean, bigint, boolean, boolean, boolean, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_group_members_get_list(arg_publisher_group_id bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_status text DEFAULT NULL::text, arg_active boolean DEFAULT NULL::boolean, arg_user_id bigint DEFAULT NULL::bigint, arg_pubs_in_group boolean DEFAULT false, arg_pubs_no_group boolean DEFAULT false, arg_pubs_in_any_group boolean DEFAULT false, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        join_type text := 'LEFT JOIN';
        join_clause text := ' AND pga.group_id = ' || arg_publisher_group_id;
        union_clause text := '';

    BEGIN
        where_clause := where_clause_build('publisher', 'u.access = $$publisher$$'  , where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'u.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'u.active = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_user_id::TEXT, 'u.manager_id = ' || arg_user_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'publisher_name');

        IF (arg_pubs_in_any_group) THEN
            join_clause := '';
            join_type := 'INNER JOIN';
        ELSE
            IF (arg_pubs_in_group) THEN
                join_type := 'INNER JOIN';
                IF (arg_pubs_no_group) THEN
                    where_clause := where_clause || ' AND pga.publisher_id IS NULL ';
                    union_clause := '
                        UNION SELECT
                            u.id AS publisher_id,
                            COALESCE (MAX(up.company_name), CONCAT (MAX(mcon.first_name), CHR(1), MAX(mcon.last_name))) AS publisher_name,
                            MAX(mgr.id) AS manager_id,
                            CONCAT (COALESCE(MAX(mcon.first_name), MAX(mup.first_name)), '' '', COALESCE(MAX(mcon.last_name), MAX(mup.last_name))) AS manager_name,
                            (CASE
                                WHEN MAX(pga.group_id) = ' || arg_publisher_group_id || '
                                THEN TRUE ELSE FALSE
                            END) AS member,
                            MAX(pg.id) AS group_id,
                            MAX(pg.name) AS group_name
                        FROM users u
                        LEFT JOIN contacts con ON con.id = u.primary_contact_id
                        LEFT JOIN user_profiles up ON up.user_id = u.id
                        LEFT JOIN users mgr ON mgr.id = u.manager_id
                        LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                        ' || join_type || ' publisher_groups_assoc pga ON pga.publisher_id = u.id AND pga.status = ''active''
                        LEFT JOIN publisher_groups pg ON pg.id = pga.group_id
                        LEFT JOIN user_profiles mup ON mup.user_id = mgr.id '
                        || where_clause;
                END IF;
            ELSE
                IF (arg_pubs_no_group) THEN
                    join_clause := '';
                    where_clause := where_clause || ' AND pga.publisher_id IS NULL ';
                ELSE
                    join_clause := '';
                END IF;
            END IF;
        END IF;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    u.id AS publisher_id,
                                    COALESCE (MAX(up.company_name), CONCAT (MAX(mcon.first_name), CHR(1), MAX(mcon.last_name))) AS publisher_name,
                                    MAX(mgr.id) AS manager_id,
                                    CONCAT (COALESCE(MAX(mcon.first_name), MAX(mup.first_name)), '' '', COALESCE(MAX(mcon.last_name), MAX(mup.last_name))) AS manager_name,
                                    (CASE
                                        WHEN MAX(pg.id) = ' || arg_publisher_group_id || '
                                        THEN TRUE ELSE FALSE
                                    END) AS member,
                                    MAX(pg.id) AS group_id,
                                    MAX(pg.name) AS group_name
                                FROM users u
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users mgr ON mgr.id = u.manager_id
                                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                                ' || join_type || ' publisher_groups_assoc pga ON pga.publisher_id = u.id ' || join_clause || '
                                LEFT JOIN publisher_groups pg ON pg.id = pga.group_id AND pg.status = ''active''
                                LEFT JOIN user_profiles mup ON mup.user_id = mgr.id '
                                || where_clause
                                || union_clause ||
                                ' GROUP BY u.id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_group_members_get_list(arg_publisher_group_id bigint, arg_publisher_id bigint, arg_status text, arg_active boolean, arg_user_id bigint, arg_pubs_in_group boolean, arg_pubs_no_group boolean, arg_pubs_in_any_group boolean, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_group_members_update(json); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_group_members_update(arg_member_changes json) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        row RECORD;
        publisher_ids bigint[];
        ret_val json;
    BEGIN
        FOR row IN SELECT pub_id, grp_id, member FROM json_populate_recordset(null::pub_group_members, arg_member_changes->'changes') LOOP
            publisher_ids := array_append(publisher_ids, row.pub_id);
            IF row.member THEN
		PERFORM * FROM publisher_groups_assoc WHERE publisher_id = row.pub_id AND row.grp_id=group_id;
		IF (NOT FOUND) THEN
                INSERT INTO publisher_groups_assoc (publisher_id, group_id) VALUES (row.pub_id, row.grp_id);
                END IF;
                
            ELSE
                DELETE FROM publisher_groups_assoc WHERE publisher_id = row.pub_id AND row.grp_id=group_id;
            END IF;
        END LOOP;
        IF array_length(publisher_ids, 1) > 0 THEN
            ret_val := w4api.publisher_group_members_update_get_list(publisher_ids);
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.publisher_group_members_update(arg_member_changes json) OWNER TO w4;

--
-- Name: publisher_group_members_update_get_list(bigint[]); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_group_members_update_get_list(arg_publisher_ids bigint[] DEFAULT NULL::bigint[]) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        pub_id bigint;
    BEGIN
        FOREACH pub_id IN ARRAY arg_publisher_ids LOOP
            IF where_clause != '' THEN
                where_clause := where_clause || ' OR ';
            ELSE
                where_clause := ' WHERE ';
            END IF;
            where_clause := where_clause || 'u.id = ' || pub_id;            
        END LOOP;
        
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    u.id AS publisher_id,
                                    COALESCE (up.company_name, CONCAT (mcon.first_name, CHR(1), mcon.last_name)) AS publisher_name,
                                    mgr.id AS manager_id,
                                    CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS manager_name,
                                    (CASE
                                        WHEN pg.id IS NULL
                                        THEN FALSE ELSE TRUE
                                    END) AS member
                                FROM users u
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles Up ON up.user_id = u.id
                                LEFT JOIN users mgr ON mgr.id = u.manager_id
                                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                                LEFT JOIN user_profiles mup ON mup.user_id = mgr.id
                                LEFT JOIN publisher_groups_assoc pga ON pga.publisher_id = u.id
                                LEFT JOIN publisher_groups pg ON pg.id = pga.group_id AND pg.status = ''active'''
                                || where_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_group_members_update_get_list(arg_publisher_ids bigint[]) OWNER TO w4;

--
-- Name: publisher_groups_assoc_delete(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_assoc_delete(arg_publisher_id bigint, arg_group_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        delete_count bigint;
    BEGIN
        PERFORM publisher_id FROM publisher_groups_assoc WHERE publisher_id = arg_publisher_id AND group_id = arg_group_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher (%) and group (%) in the publisher groups.', arg_publisher_id, arg_group_id;
        END IF;
        DELETE FROM publisher_groups_assoc WHERE publisher_id = arg_publisher_id AND group_id = arg_group_id;
        IF FOUND THEN
            RETURN true;
        ELSE
            RETURN false;
        END IF;
    END;
$$;


ALTER FUNCTION w4api.publisher_groups_assoc_delete(arg_publisher_id bigint, arg_group_id bigint) OWNER TO w4;

--
-- Name: publisher_groups_assoc_get(bigint, bigint, text, bigint, boolean, boolean, boolean, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_assoc_get(arg_publisher_id bigint DEFAULT NULL::bigint, arg_group_id bigint DEFAULT NULL::bigint, arg_publisher_status text DEFAULT NULL::text, arg_user_id bigint DEFAULT NULL::bigint, arg_pubs_in_group boolean DEFAULT NULL::boolean, arg_pubs_no_group boolean DEFAULT NULL::boolean, arg_pubs_in_other_group boolean DEFAULT NULL::boolean, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_groups_assoc_get_count(arg_publisher_id, arg_group_id, arg_publisher_status, arg_user_id, arg_pubs_in_group, arg_pubs_no_group, arg_pubs_in_other_group), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || publisher_groups_assoc_get_list(arg_publisher_id, arg_group_id, arg_publisher_status, arg_user_id, arg_pubs_in_group, arg_pubs_no_group, arg_pubs_in_other_group, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_groups_assoc_get(arg_publisher_id bigint, arg_group_id bigint, arg_publisher_status text, arg_user_id bigint, arg_pubs_in_group boolean, arg_pubs_no_group boolean, arg_pubs_in_other_group boolean, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_groups_assoc_get_count(bigint, bigint, text, bigint, boolean, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_assoc_get_count(arg_publisher_id bigint DEFAULT NULL::bigint, arg_group_id bigint DEFAULT NULL::bigint, arg_publisher_status text DEFAULT NULL::text, arg_user_id bigint DEFAULT NULL::bigint, arg_pubs_in_group boolean DEFAULT NULL::boolean, arg_pubs_no_group boolean DEFAULT NULL::boolean, arg_pubs_in_other_group boolean DEFAULT NULL::boolean) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        group_assoc_join text := 'LEFT JOIN';
    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pga.publisher_id = ' || arg_publisher_id, where_clause);
        IF (arg_pubs_in_other_group) THEN
            where_clause := where_clause_build(arg_group_id::TEXT, 'pga.group_id != ' || arg_group_id, where_clause);
        ELSE
            where_clause := where_clause_build(arg_group_id::TEXT, 'pga.group_id = ' || arg_group_id, where_clause);
        END IF;
        where_clause := where_clause_build(arg_publisher_status::TEXT, 'usr.active = $$' || arg_publisher_status || '$$', where_clause);
        where_clause := where_clause_build(arg_user_id::TEXT, 'usr.manager_id = ' || arg_user_id, where_clause);
        where_clause := where_clause_build('publisher', 'usr.access = $$publisher$$'  , where_clause);
        where_clause := where_clause_build('data', 'pga.group_id IS NOT NULL', where_clause);

        IF (arg_pubs_in_group) THEN
            group_assoc_join := 'INNER JOIN';
        ELSE
            IF (arg_pubs_no_group) THEN
                where_clause := where_clause || ' AND pga.publisher_id IS NULL ';
            END IF;
        END IF;

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM users usr
            LEFT JOIN contacts con ON con.id = usr.primary_contact_id
            LEFT JOIN users mgr ON mgr.id = usr.manager_id
            LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
            ' || group_assoc_join || ' publisher_groups_assoc pga ON pga.publisher_id = usr.id
            LEFT JOIN publisher_groups pg ON pga.group_id = pg.id AND pg.status = ''active'''
            || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_groups_assoc_get_count(arg_publisher_id bigint, arg_group_id bigint, arg_publisher_status text, arg_user_id bigint, arg_pubs_in_group boolean, arg_pubs_no_group boolean, arg_pubs_in_other_group boolean) OWNER TO w4;

--
-- Name: publisher_groups_assoc_get_details(bigint, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_assoc_get_details(arg_group_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause TEXT := '';
        order_clause TEXT;
    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pga.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_group_id::TEXT, 'pga.group_id = ' || arg_group_id, where_clause);
        order_clause := order_clause_build(arg_orderby, 'pg.name');
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    pga.publisher_id,
                                    pga.group_id,
                                    pg.name,
                                    pg.description,
                                    pg.last_modified
                                FROM publisher_groups_assoc pga
                                LEFT JOIN publisher_groups pg ON pga.group_id = pg.id '
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_groups_assoc_get_details(arg_group_id bigint, arg_publisher_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_groups_assoc_get_list(bigint, bigint, text, bigint, boolean, boolean, boolean, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_assoc_get_list(arg_publisher_id bigint DEFAULT NULL::bigint, arg_group_id bigint DEFAULT NULL::bigint, arg_publisher_status text DEFAULT NULL::text, arg_user_id bigint DEFAULT NULL::bigint, arg_pubs_in_group boolean DEFAULT NULL::boolean, arg_pubs_no_group boolean DEFAULT NULL::boolean, arg_pubs_in_other_group boolean DEFAULT NULL::boolean, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        group_assoc_join text := 'LEFT JOIN';
    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pga.publisher_id = ' || arg_publisher_id, where_clause);
        IF (arg_pubs_in_other_group) THEN
            where_clause := where_clause_build(arg_group_id::TEXT, 'pga.group_id != ' || arg_group_id, where_clause);
        ELSE
            where_clause := where_clause_build(arg_group_id::TEXT, 'pga.group_id = ' || arg_group_id, where_clause);
        END IF;
        where_clause := where_clause_build(arg_publisher_status::TEXT, 'usr.active = $$' || arg_publisher_status || '$$', where_clause);
        where_clause := where_clause_build(arg_user_id::TEXT, 'usr.manager_id = ' || arg_user_id, where_clause);
        where_clause := where_clause_build('publisher', 'usr.access = $$publisher$$'  , where_clause);
        where_clause := where_clause_build('data', 'pga.group_id IS NOT NULL', where_clause);

        order_clause := order_clause_build(arg_orderby, 'publisher_name');

        IF (arg_pubs_in_group) THEN
            group_assoc_join := 'INNER JOIN';
        ELSE
            IF (arg_pubs_no_group) THEN
                where_clause := where_clause || ' AND pga.publisher_id IS NULL ';
            END IF;
        END IF;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                               SELECT
                                    usr.id AS publisher_id,
                                    CONCAT(con.first_name, CHR(1), con.last_name) AS publisher_name,
                                    CONCAT (mcon.first_name, CHR(1), mcon.last_name) AS manager_name,
                                    pg.id,
                                    pg.name AS group_name
                                FROM users usr
                                LEFT JOIN contacts con ON con.id = usr.primary_contact_id
                                LEFT JOIN users mgr ON mgr.id = usr.manager_id
                                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                                ' || group_assoc_join || ' publisher_groups_assoc pga ON pga.publisher_id = usr.id
                                LEFT JOIN publisher_groups pg ON pga.group_id = pg.id AND pg.status = ''active'''
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_groups_assoc_get_list(arg_publisher_id bigint, arg_group_id bigint, arg_publisher_status text, arg_user_id bigint, arg_pubs_in_group boolean, arg_pubs_no_group boolean, arg_pubs_in_other_group boolean, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_groups_assoc_update(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_assoc_update(arg_publisher_id bigint, arg_group_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM publisher_groups WHERE id = arg_group_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified group (%) in the publisher groups.', arg_group_id;
        END IF;
        DELETE FROM publisher_groups_assoc where publisher_id = arg_publisher_id;
        INSERT INTO publisher_groups_assoc (publisher_id, group_id) VALUES (arg_publisher_id, arg_group_id);
        RETURN publisher_groups_assoc_get(arg_publisher_id, arg_group_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_groups_assoc_update(arg_publisher_id bigint, arg_group_id bigint) OWNER TO w4;

--
-- Name: publisher_groups_create(text, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_create(arg_group_name text, arg_user_id bigint, arg_description text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        new_id bigint;
    BEGIN
        INSERT INTO publisher_groups
            (name, description, last_modified, user_id)
            VALUES (arg_group_name, arg_description, CURRENT_TIMESTAMP, arg_user_id)
            RETURNING id
            INTO new_id;
        raise info 'new_id: %', new_id;
        RETURN w4api.publisher_groups_get_details(new_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_groups_create(arg_group_name text, arg_user_id bigint, arg_description text) OWNER TO w4;

--
-- Name: publisher_groups_delete(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_delete(arg_id bigint, arg_user_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$  BEGIN
        PERFORM id FROM publisher_groups WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified group (%) in the publisher groups.', arg_id;
        END IF;
	DELETE FROM publisher_groups WHERE id = arg_id;
	DELETE FROM publisher_groups_assoc WHERE group_id = arg_id;
        RETURN TRUE;
    END;$$;


ALTER FUNCTION w4api.publisher_groups_delete(arg_id bigint, arg_user_id bigint) OWNER TO w4;

--
-- Name: publisher_groups_get(bigint, text, text, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_get(arg_current_admin_id bigint DEFAULT NULL::bigint, arg_admin_search text DEFAULT NULL::text, arg_group_search text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_groups_get_count(arg_current_admin_id, arg_admin_search, arg_group_search), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || publisher_groups_get_list(arg_current_admin_id, arg_admin_search, arg_group_search, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_groups_get(arg_current_admin_id bigint, arg_admin_search text, arg_group_search text, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_groups_get_count(bigint, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_get_count(arg_current_admin_id bigint DEFAULT NULL::bigint, arg_admin_search text DEFAULT NULL::text, arg_group_search text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_current_admin_id::TEXT, 'mgr.id = ' || arg_current_admin_id, where_clause);
        where_clause := where_clause_build(arg_admin_search::TEXT, 'mgr.id = ' || arg_admin_search, where_clause);
        where_clause := where_clause_build(arg_group_search::TEXT, 'pg.name ILIKE $$%' || arg_group_search || '%$$', where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM publisher_groups pg
            LEFT JOIN users mgr ON mgr.id = pg.user_id
            LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id'
            || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_groups_get_count(arg_current_admin_id bigint, arg_admin_search text, arg_group_search text) OWNER TO w4;

--
-- Name: publisher_groups_get_details(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_get_details(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    pg.id AS group_id
                    , pg.name AS group_name
                    , pg.description
                    , pg.last_modified
                    , pg.user_id AS manager_id
                    , CONCAT (COALESCE(mcon.first_name, mup.first_name), ' ', COALESCE(mcon.last_name, mup.last_name)) AS manager_name
                INTO ret_val
                FROM publisher_groups pg
                LEFT JOIN users mgr
                    ON mgr.id = pg.user_id
                LEFT JOIN contacts mcon
                    ON mcon.id = mgr.primary_contact_id
                LEFT JOIN user_profiles mup
                    ON mup.user_id = mgr.id
                WHERE
                    pg.id = arg_id
            ) row;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'The group id [%] does not exist.', arg_id;
        END IF;
        RETURN ret_val;

    END;
$$;


ALTER FUNCTION w4api.publisher_groups_get_details(arg_id bigint) OWNER TO w4;

--
-- Name: publisher_groups_get_list(bigint, text, text, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_get_list(arg_current_admin_id bigint DEFAULT NULL::bigint, arg_admin_search text DEFAULT NULL::text, arg_group_search text DEFAULT NULL::text, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
        where_clause := where_clause_build(arg_current_admin_id::TEXT, 'mgr.id = ' || arg_current_admin_id, where_clause);
        where_clause := where_clause_build(arg_admin_search::TEXT, 'mgr.id = ' || arg_admin_search, where_clause);
        where_clause := where_clause_build(arg_group_search::TEXT, 'pg.name ILIKE $$%' || arg_group_search || '%$$', where_clause);

        order_clause := order_clause_build(arg_orderby, 'group_name');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    pg.id group_id,
                                    pg.name AS group_name,
                                    pg.last_modified,
                                    pg.description,
                                    mgr.id AS manager_id,
                                    CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS manager_name
                                FROM publisher_groups pg
                                LEFT JOIN users mgr ON mgr.id = pg.user_id
                                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                                LEFT JOIN user_profiles mup ON mup.user_id = mgr.id '
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_groups_get_list(arg_current_admin_id bigint, arg_admin_search text, arg_group_search text, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_groups_update(bigint, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_groups_update(arg_id bigint, arg_name text, arg_description text, arg_user_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM publisher_groups WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified group (%) in the publisher groups.', arg_id;
        END IF;

        UPDATE publisher_groups SET
            name            = COALESCE (arg_name, name),
            description     = COALESCE (arg_description, description),
            last_modified   = CURRENT_TIMESTAMP,
            user_id         = COALESCE (arg_user_id, user_id)
        WHERE id = arg_id;

        RETURN publisher_groups_get_details(arg_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_groups_update(arg_id bigint, arg_name text, arg_description text, arg_user_id bigint) OWNER TO w4;

--
-- Name: publisher_id_update(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_id_update(arg_publisher_id_current bigint, arg_publisher_id_requested bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_ftp_username text;
        var_ftp_folder text;

    BEGIN
        PERFORM id FROM users WHERE id = arg_publisher_id_current AND access='publisher';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the specified publisher (%).', arg_publisher_id_current;
        END IF;

        PERFORM id FROM users WHERE id = arg_publisher_id_requested;
        IF (FOUND) THEN
            RAISE EXCEPTION 'User id already exists (%).', arg_publisher_id_requested;
        END IF;

        UPDATE users SET            
            id = arg_publisher_id_requested
        WHERE id = arg_publisher_id_current;

        UPDATE user_profiles SET
            user_id = arg_publisher_id_requested
        WHERE user_id = arg_publisher_id_current;

        UPDATE publisher_contact SET
            publisher_id = arg_publisher_id_requested
        WHERE publisher_id = arg_publisher_id_current;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_id_update(arg_publisher_id_current bigint, arg_publisher_id_requested bigint) OWNER TO w4;

--
-- Name: publisher_invoice_create(bigint, timestamp with time zone, timestamp with time zone, bigint, bigint, text, public.status_invoice); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_create(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_admin_id bigint, arg_currency_id bigint, arg_memo text DEFAULT NULL::text, arg_status public.status_invoice DEFAULT 'unpaid'::public.status_invoice) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        where_clause text := '';
        new_invoice_id bigint;
        arg_min_doy integer := make_doy(arg_min_date);
        arg_max_doy integer := make_doy(arg_max_date);
        overlapping_invoice RECORD;
        overlapping_date_ranges doy_range[];
        overlapping_date_range doy_range;
        line_item RECORD;
        pay_total numeric := 0;
        con_total bigint := 0;
        var_paid_date timestamp with time zone;
test text;

    BEGIN
        --Check for existing upaid invoices in date range.
        FOR overlapping_invoice IN 
            SELECT
                id, status, min_doy, max_doy
            FROM acct_invoices_publisher
            WHERE
                publisher_id = arg_publisher_id AND
                currency_id = arg_currency_id AND
                ((min_doy BETWEEN arg_min_doy AND arg_max_doy) OR
                (max_doy BETWEEN arg_min_doy AND arg_max_doy))
        LOOP
            --Remove unpaid overlapping invoices.
            IF (overlapping_invoice.status = 'unpaid') THEN
                DELETE FROM acct_invoices_publisher WHERE id = overlapping_invoice.id;
                DELETE FROM acct_invoices_publisher_line_items WHERE invoice_id = overlapping_invoice.id;
                DELETE FROM acct_invoices_publisher_adjustments WHERE invoice_id = overlapping_invoice.id;
            ELSE
                --Add paid existing ranges to be not included in new overlapping invoice.
                overlapping_date_ranges = array_append(overlapping_date_ranges, (overlapping_invoice.min_doy, overlapping_invoice.max_doy)::doy_range);
            END IF;
        END LOOP;

        IF (array_length(overlapping_date_ranges, 1) > 0) THEN        
            FOREACH overlapping_date_range IN ARRAY overlapping_date_ranges LOOP
                where_clause := where_clause_build(overlapping_date_range.min_doy::text, 'NOT (doy BETWEEN ' || overlapping_date_range.min_doy || ' AND ' || overlapping_date_range.max_doy || ')', where_clause);
            END LOOP;
        END IF;

        IF (arg_status = 'paid') THEN
            var_paid_date = CURRENT_TIMESTAMP;
        END IF;

        --Create the invoice.
        INSERT INTO acct_invoices_publisher
            (publisher_id, min_doy, max_doy, status, created_date, admin_id, memo, currency_id, paid_date)
            VALUES (arg_publisher_id, arg_min_doy, arg_max_doy, arg_status, CURRENT_TIMESTAMP, arg_admin_id, arg_memo, arg_currency_id, var_paid_date)        
            RETURNING id
            INTO new_invoice_id;

        --Add line items.
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'publisher_id = ' || arg_publisher_id, where_clause);        
        where_clause := where_clause_build(arg_min_date::TEXT, 'doy BETWEEN ' || arg_min_doy || ' AND ' || arg_max_doy, where_clause);
        where_clause := where_clause_build('always'::TEXT, 'pay_out_amount > $$0$$', where_clause);
        where_clause := where_clause_build('always'::TEXT, 'total_conversions > 0', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);        
test := '
SELECT
                    campaign_id,
                    SUM(total_conversions) AS conversions,
                    pay_out_amount AS pay_out_amount
                FROM reports_daily rd
                LEFT JOIN campaigns c ON c.id = rd.campaign_id'
                || where_clause ||
                ' GROUP BY campaign_id, pay_out_amount';
raise info 'test: %', test;
        FOR line_item IN
            EXECUTE
                'SELECT
                    campaign_id,
                    SUM(total_conversions) AS conversions,
                    pay_out_amount AS pay_out_amount
                FROM reports_daily rd
                LEFT JOIN campaigns c ON c.id = rd.campaign_id'
                || where_clause ||
                ' GROUP BY campaign_id, pay_out_amount;'
        LOOP
            INSERT INTO acct_invoices_publisher_line_items
                (invoice_id, campaign_id, payout, conversions)
                VALUES (new_invoice_id, line_item.campaign_id, line_item.pay_out_amount, line_item.conversions);
            pay_total := pay_total + (line_item.pay_out_amount * line_item.conversions)::numeric;
            con_total := con_total + line_item.conversions;
        END LOOP;
        
        UPDATE acct_invoices_publisher SET conversion_total = con_total, payout_total = pay_total WHERE id = new_invoice_id;

        RETURN new_invoice_id;
    END;
$_$;


ALTER FUNCTION w4api.publisher_invoice_create(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_admin_id bigint, arg_currency_id bigint, arg_memo text, arg_status public.status_invoice) OWNER TO w4;

--
-- Name: publisher_invoice_create_paid(json, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_create_paid(arg_payouts json, arg_admin_id bigint, arg_currency_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        pub_id bigint;
        min_date timestamp with time zone;
        max_date timestamp with time zone;
        invoice_id bigint;

    BEGIN
        FOR pub_id, min_date, max_date IN SELECT * FROM json_populate_recordset(NULL::publisher_payout,arg_payouts->'payouts') LOOP
            invoice_id := publisher_invoice_create(pub_id, min_date, max_date, arg_admin_id, arg_currency_id, null, 'paid');          
        END LOOP;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_invoice_create_paid(arg_payouts json, arg_admin_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_invoice_delete(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_delete(arg_invoice_id bigint, arg_admin_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE

    BEGIN
        PERFORM id FROM acct_invoices_publisher WHERE id = arg_invoice_id AND status = 'unpaid';
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified invoice (%) that is unpaid.', arg_invoice_id;
            RETURN FALSE;
        ELSE
            DELETE FROM acct_invoices_publisher WHERE id = arg_invoice_id;
            DELETE FROM acct_invoices_publisher_line_items where invoice_id = arg_invoice_id;             
        END IF;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_invoice_delete(arg_invoice_id bigint, arg_admin_id bigint) OWNER TO w4;

--
-- Name: publisher_invoice_details_create(bigint, bigint, bigint, timestamp with time zone, money, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_details_create(arg_invoice_id bigint, arg_campaign_id bigint, arg_admin_id bigint, arg_change_date timestamp with time zone, arg_payout money, arg_conversions bigint, arg_memo text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        doy integer := make_doy(arg_change_date);
        adjustment_id bigint;
    BEGIN
        --Look for existing paid invoice that adjustment date is within and throw exception.
        PERFORM * FROM acct_invoices_publisher WHERE id = arg_invoice_id AND status = 'unpaid';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No unpaid invoice exists with id: %', arg_invoice_id;
        END IF;
        
        INSERT INTO "Accounting".acct_invoices_publisher_adjustments
            (invoice_id, campaign_id, payout, conversions, admin_id, change_date, doy, memo)
            VALUES (arg_invoice_id, arg_campaign_id, arg_payout, arg_conversions, arg_admin_id, CURRENT_TIMESTAMP, doy, arg_memo)
            RETURNING id
            INTO adjustment_id;

        --Peform adjustment on existing unpaid invoice that adjustment date is within.
        UPDATE acct_invoices_publisher SET payout_total = payout_total + (arg_payout * arg_conversions) WHERE id = arg_invoice_id;

        RETURN publisher_invoice_details_get(arg_invoice_id, adjustment_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_invoice_details_create(arg_invoice_id bigint, arg_campaign_id bigint, arg_admin_id bigint, arg_change_date timestamp with time zone, arg_payout money, arg_conversions bigint, arg_memo text) OWNER TO w4;

--
-- Name: publisher_invoice_details_get(bigint, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_details_get(arg_invoice_id bigint DEFAULT NULL::bigint, arg_adjustment_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        summary json;       
        count_total bigint;

    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    i.publisher_id,
                    COALESCE (up.company_name, CONCAT (con.first_name, CHR(1), con.last_name)) AS publisher_name,
                    i.status,
                    i.payout_total::numeric,
                    CASE
                        WHEN i.payout_total::numeric > 2500.00 THEN i.payout_total::numeric * 0.01
                        ELSE 0::numeric
                    END AS reward,                 
                    i.created_date,
                    i.paid_date,
                    i.memo
                FROM acct_invoices_publisher i
                LEFT JOIN users u
                    ON u.id = i.publisher_id
                LEFT JOIN user_profiles up
                    ON up.user_id = u.id
                LEFT JOIN contacts con
                    ON con.id = u.primary_contact_id
                WHERE
                    i.id = arg_invoice_id
            ) row
        INTO summary;

        IF arg_count THEN
            SELECT INTO count_total COALESCE (publisher_line_items_get_count(arg_invoice_id), 0);
        ELSE
            count_total := -1;
        END IF;
      
        ret_val := 
        (
                '{' || 
                        '"summary": ' || summary ||
                        ', "results": ' || publisher_line_items_get_list(arg_invoice_id, arg_adjustment_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_invoice_details_get(arg_invoice_id bigint, arg_adjustment_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_invoice_details_update(bigint, timestamp with time zone, timestamp with time zone, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_details_update(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_admin_id bigint, arg_memo text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        invoice_id bigint := NULL;
        arg_min_doy integer := make_doy(arg_min_date);
        arg_max_doy integer := make_doy(arg_max_date);
    BEGIN
        SELECT id FROM acct_invoices_publisher WHERE publisher_id = arg_publisher_id AND min_doy = arg_min_doy AND max_doy = arg_max_doy AND status = 'unpaid' INTO invoice_id;
raise info 'test: %', invoice_id; 
        IF (invoice_id IS NULL) THEN
            invoice_id := publisher_invoice_create(arg_publisher_id, arg_min_date, arg_max_date, arg_admin_id, arg_memo);
        ELSE
            UPDATE acct_invoices_publisher SET memo = arg_memo WHERE id = invoice_id;
        END IF;
        RETURN '{"memo": "' || arg_memo || '"}';
    END;
$$;


ALTER FUNCTION w4api.publisher_invoice_details_update(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_admin_id bigint, arg_memo text) OWNER TO w4;

--
-- Name: publisher_invoice_get(bigint, timestamp with time zone, timestamp with time zone, public.status_invoice, bigint, bigint, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_get(arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status public.status_invoice DEFAULT NULL::public.status_invoice, arg_invoice_id bigint DEFAULT NULL::bigint, arg_manager_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;

	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_invoice_get_count(arg_publisher_id, arg_min_date, arg_max_date, arg_status, arg_invoice_id, arg_manager_id, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_invoice_get_list(arg_publisher_id, arg_min_date, arg_max_date, arg_status, arg_invoice_id, arg_manager_id, arg_currency_id, arg_orderby, arg_limit, arg_offset)::json ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_invoice_get(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status public.status_invoice, arg_invoice_id bigint, arg_manager_id bigint, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_invoice_get_count(bigint, timestamp with time zone, timestamp with time zone, public.status_invoice, bigint, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_get_count(arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status public.status_invoice DEFAULT NULL::public.status_invoice, arg_invoice_id bigint DEFAULT NULL::bigint, arg_manager_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'i.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'i.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_invoice_id::TEXT, 'i.id = ' || arg_invoice_id, where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'i.admin_id = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build (arg_min_date::TEXT, 'i.created_date::date >= $$' || arg_min_date::date || '$$', where_clause);
        where_clause := where_clause_build (arg_max_date::TEXT, 'i.created_date::date < $$' || arg_max_date::date || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'i.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0)
            FROM acct_invoices_publisher i
            LEFT JOIN users u ON u.id = i.publisher_id
            LEFT JOIN contacts con ON con.id = u.primary_contact_id
            LEFT JOIN user_profiles up ON up.user_id = u.id
            LEFT JOIN users m ON m.id = i.admin_id
            LEFT JOIN contacts mcon ON mcon.id = m.primary_contact_id '
            || where_clause || ';'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_invoice_get_count(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status public.status_invoice, arg_invoice_id bigint, arg_manager_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_invoice_get_details(bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_get_details(arg_invoice_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        summary json;       
        count_total bigint;
test json;

    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    i.publisher_id,
                    COALESCE (up.company_name, CONCAT (con.first_name, CHR(1), con.last_name)) AS publisher_name,       
                    i.created_date,
                    i.memo
                FROM acct_invoices_publisher i
                LEFT JOIN users u
                    ON u.id = i.publisher_id
                LEFT JOIN user_profiles up
                    ON up.user_id = u.id
                LEFT JOIN contacts con
                    ON con.id = u.primary_contact_id               
                WHERE
                    i.id = arg_invoice_id
            ) row
        INTO summary;

        IF arg_count THEN
            SELECT INTO count_total COALESCE (publisher_line_items_get_count(arg_invoice_id), 0);
        ELSE
            count_total := -1;
        END IF;
test := publisher_line_items_get_list(arg_invoice_id, arg_orderby, arg_limit, arg_offset);
RAISE INFO 'test: %, %, %', summary, count_total, test;        
        ret_val := 
        (
                '{' || 
                        '"summary": ' || summary ||
                        ', "line_items": ' || publisher_line_items_get_list(arg_invoice_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "line_item_count": ' || count_total
                || '}'
        )::json;

        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_invoice_get_details(arg_invoice_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_invoice_get_list(bigint, timestamp with time zone, timestamp with time zone, public.status_invoice, bigint, bigint, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_get_list(arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status public.status_invoice DEFAULT NULL::public.status_invoice, arg_invoice_id bigint DEFAULT NULL::bigint, arg_manager_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'i.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'i.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_invoice_id::TEXT, 'i.id = ' || arg_invoice_id, where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'i.admin_id = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build (arg_min_date::TEXT, 'i.created_date::date >= $$' || arg_min_date::date || '$$', where_clause);
        where_clause := where_clause_build (arg_max_date::TEXT, 'i.created_date::date < $$' || arg_max_date::date || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'i.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'publisher_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    i.id AS invoice_id,
                                    i.created_date AS date_created,
                                    i.paid_date AS paid_date,
                                    i.min_doy,
                                    i.max_doy,
                                    i.status,
                                    i.memo,
                                    i.publisher_id,
                                    up.company_name AS publisher_name,
                                    i.admin_id AS manager_id,
                                    CONCAT(mcon.first_name, CHR(1), mcon.last_name) AS manager_name,
                                    i.payout_total::numeric AS amount
                                FROM acct_invoices_publisher i
                                LEFT JOIN users u ON u.id = i.publisher_id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users m ON m.id = i.admin_id
                                LEFT JOIN contacts mcon ON mcon.id = m.primary_contact_id '
                                || where_clause
                                || order_clause ||
                                ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') ||
                                ' OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_invoice_get_list(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status public.status_invoice, arg_invoice_id bigint, arg_manager_id bigint, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_invoice_update(bigint, bigint, text, public.status_invoice); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_invoice_update(arg_invoice_id bigint, arg_admin_id bigint, arg_memo text DEFAULT NULL::text, arg_status public.status_invoice DEFAULT 'unpaid'::public.status_invoice) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_paid_date timestamp with time zone;

    BEGIN
        PERFORM id FROM acct_invoices_publisher WHERE id = arg_invoice_id AND status = 'unpaid';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'No unpaid invoice exists with id: %', arg_invoice_id;
        ELSE
            IF (arg_status = 'paid') THEN
                var_paid_date = CURRENT_TIMESTAMP;
            END IF;


            UPDATE acct_invoices_publisher SET status = arg_status, memo = arg_memo, paid_date = var_paid_date WHERE id = arg_invoice_id;
        END IF;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_invoice_update(arg_invoice_id bigint, arg_admin_id bigint, arg_memo text, arg_status public.status_invoice) OWNER TO w4;

--
-- Name: publisher_line_items_get_count(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_line_items_get_count(arg_invoice_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        adjustment_where_clause text := '';
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_invoice_id::TEXT, 'li.invoice_id = ' || arg_invoice_id, where_clause);
        adjustment_where_clause := where_clause_build(arg_invoice_id::TEXT, 'a.invoice_id = ' || arg_invoice_id, adjustment_where_clause);

        EXECUTE
            'SELECT COALESCE (COUNT(1), 0) FROM (
                SELECT
                    li.id
                FROM acct_invoices_publisher_line_items li
                LEFT JOIN campaigns c ON c.id = li.campaign_id
                LEFT JOIN campaign_conversion_aliases cca ON cca.id = c.payin_model_id '   
                || where_clause || '
                UNION SELECT
                    a.id
                FROM acct_invoices_publisher_adjustments a
                LEFT JOIN campaigns c ON c.id = a.campaign_id
                LEFT JOIN campaign_conversion_aliases cca ON cca.id = c.payin_model_id '
                || adjustment_where_clause || '
            ) AS the_count;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_line_items_get_count(arg_invoice_id bigint) OWNER TO w4;

--
-- Name: publisher_line_items_get_list(bigint, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_line_items_get_list(arg_invoice_id bigint DEFAULT NULL::bigint, arg_adjustment_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        adjustment_where_clause text := '';
        order_clause text;

    BEGIN
        IF (arg_adjustment_id IS NULL) THEN
            adjustment_where_clause := where_clause_build(arg_invoice_id::TEXT, 'a.invoice_id = ' || arg_invoice_id, adjustment_where_clause);
            where_clause := where_clause_build(arg_invoice_id::TEXT, 'li.invoice_id = ' || arg_invoice_id, where_clause);
        ELSE
            adjustment_where_clause := where_clause_build(arg_invoice_id::TEXT, 'a.id = ' || arg_adjustment_id, adjustment_where_clause);
            where_clause := where_clause_build(arg_invoice_id::TEXT, 'li.invoice_id IS NULL', where_clause);
        END IF;

        order_clause := order_clause_build(arg_orderby, 'campaign_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    c.id AS campaign_id,
                                    c.name AS campaign_name,
                                    c.payin_model_id,
                                    cca.alias AS payin_model_name,
                                    li.conversions,
                                    li.payout::numeric,
                                    li.memo,
                                    (li.conversions * li.payout)::numeric AS amount
                                FROM acct_invoices_publisher_line_items li
                                LEFT JOIN campaigns c ON c.id = li.campaign_id
                                LEFT JOIN campaign_conversion_aliases cca ON cca.id = c.payin_model_id '   
                                || where_clause || '
                                 UNION SELECT
                                    c.id AS campaign_id,
                                    c.name AS campaign_name,
                                    c.payin_model_id,
                                    cca.alias AS payin_model_name,
                                    a.conversions,
                                    a.payout::numeric,
                                    a.memo,
                                    (a.conversions * a.payout)::numeric AS amount
                                FROM acct_invoices_publisher_adjustments a
                                LEFT JOIN campaigns c ON c.id = a.campaign_id
                                LEFT JOIN campaign_conversion_aliases cca ON cca.id = c.payin_model_id '
                                || adjustment_where_clause ||
                                order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '                             
                            ) row
                    ) results;'
        INTO ret_val;

        IF (ret_val IS NULL) THEN
            ret_val := '{}'::json;
        END IF;

        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_line_items_get_list(arg_invoice_id bigint, arg_adjustment_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_override_get(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_override_get(arg_campaign_id bigint, arg_publisher_id bigint, arg_effective_date timestamp with time zone, arg_expiration_date timestamp with time zone, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_ret_val json;

    BEGIN
        SELECT row_to_json (row) FROM (
            SELECT
                override_payin,
                override_payout
            FROM publisher_overrides
            WHERE
                (campaign_id = arg_campaign_id) AND
                (publisher_id = arg_publisher_id) AND
                (effective_date IS NULL OR effective_date <= arg_effective_date) AND
                (expiration_date IS NULL OR expiration_date > arg_expiration_date) AND
                (
                    ((COALESCE(sub_id_1, '') = '') OR (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, ''))) AND
                    ((COALESCE(sub_id_2, '') = '') OR (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, ''))) AND
                    ((COALESCE(sub_id_3, '') = '') OR (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, ''))) AND
                    ((COALESCE(sub_id_4, '') = '') OR (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')))
                )
        ) row
        INTO var_ret_val;

        RETURN COALESCE(var_ret_val, '{}');
    END
$$;


ALTER FUNCTION w4api.publisher_override_get(arg_campaign_id bigint, arg_publisher_id bigint, arg_effective_date timestamp with time zone, arg_expiration_date timestamp with time zone, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) OWNER TO w4;

--
-- Name: publisher_override_landing_page_get(bigint, bigint, timestamp with time zone, timestamp with time zone, text, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_override_landing_page_get(arg_campaign_id bigint, arg_publisher_id bigint, arg_effective_date timestamp with time zone, arg_expiration_date timestamp with time zone, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_override_advertiser_landing_page text;
        var_ret_val json;

    BEGIN

        SELECT
            override_advertiser_landing_page
        FROM publisher_overrides
        WHERE
            campaign_id = arg_campaign_id AND
            (publisher_id = arg_publisher_id) AND
            (effective_date IS NULL OR effective_date <= arg_effective_date) AND
            (expiration_date IS NULL OR expiration_date > arg_expiration_date) AND
            (
                ((COALESCE(sub_id_1, '') = '') OR (COALESCE(sub_id_1, '') = COALESCE(arg_sub_id_1, ''))) AND
                ((COALESCE(sub_id_2, '') = '') OR (COALESCE(sub_id_2, '') = COALESCE(arg_sub_id_2, ''))) AND
                ((COALESCE(sub_id_3, '') = '') OR (COALESCE(sub_id_3, '') = COALESCE(arg_sub_id_3, ''))) AND
                ((COALESCE(sub_id_4, '') = '') OR (COALESCE(sub_id_4, '') = COALESCE(arg_sub_id_4, '')))
            )
        INTO var_override_advertiser_landing_page;

        IF (FOUND) THEN
            var_ret_val := (
                '{' ||
                    '"override_advertiser_landing_page": "' || var_override_advertiser_landing_page
                || '"}'
            )::json;
        ELSE
            var_ret_val := '{}'::json;
        END IF;

        RETURN var_ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_override_landing_page_get(arg_campaign_id bigint, arg_publisher_id bigint, arg_effective_date timestamp with time zone, arg_expiration_date timestamp with time zone, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text) OWNER TO w4;

--
-- Name: publisher_overrides_create(double precision, double precision, timestamp with time zone, timestamp with time zone, text, bigint, bigint, text, text, text, text, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_overrides_create(arg_payout double precision, arg_payin double precision, arg_effective_date timestamp with time zone, arg_expiration_date timestamp with time zone, arg_advertiser_landing_page text, arg_campaign_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_publisher_tier_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM * FROM publisher_overrides WHERE
            campaign_id = arg_campaign_id AND
            publisher_id = arg_publisher_id AND
            sub_id_1 = arg_sub_id_1 AND
            sub_id_2 = arg_sub_id_2 AND
            sub_id_3 = arg_sub_id_3 AND
            sub_id_4 = arg_sub_id_4;
        IF (FOUND) THEN
            RAISE EXCEPTION 'The campaign / publisher / sub_id combo already exists.';
        END IF;

        INSERT INTO publisher_overrides
            (override_payout, override_payin, effective_date, expiration_date, override_advertiser_landing_page, campaign_id, publisher_id, sub_id_1, sub_id_2, sub_id_3,
                sub_id_4, publisher_tier_id)
            VALUES (arg_payout, arg_payin, arg_effective_date, arg_expiration_date, arg_advertiser_landing_page, arg_campaign_id, arg_publisher_id, arg_sub_id_1, arg_sub_id_2,
                arg_sub_id_3, arg_sub_id_4, arg_publisher_tier_id);

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_overrides_create(arg_payout double precision, arg_payin double precision, arg_effective_date timestamp with time zone, arg_expiration_date timestamp with time zone, arg_advertiser_landing_page text, arg_campaign_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_publisher_tier_id integer) OWNER TO w4;

--
-- Name: publisher_overrides_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_overrides_delete(arg_override_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM publisher_overrides WHERE id = arg_override_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher override (%).', arg_override_id;
        END IF;

        DELETE FROM publisher_overrides WHERE id = arg_override_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_overrides_delete(arg_override_id bigint) OWNER TO w4;

--
-- Name: publisher_overrides_get(bigint, bigint, bigint, text, text, text, text, bigint, integer, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_overrides_get(arg_override_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_publisher_tier_id integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
            ret_val json;
            count_total bigint = -1;

    BEGIN

            IF arg_count THEN
                SELECT w4api.publisher_overrides_get_list(
                                arg_override_id:=arg_override_id,
                                arg_publisher_id:=arg_publisher_id,
                                arg_campaign_id:=arg_campaign_id,
                                arg_sub_id_1:=arg_sub_id_1,
                                arg_sub_id_2:=arg_sub_id_2,
                                arg_sub_id_3:=arg_sub_id_3,
                                arg_sub_id_4:=arg_sub_id_4,                                            
                                arg_currency_id:=arg_currency_id,
                                arg_publisher_tier_id:=arg_publisher_tier_id, 
                                arg_count:=TRUE
                                ) INTO count_total;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || w4api.publisher_overrides_get_list(
                                        arg_override_id:=arg_override_id,
                                        arg_publisher_id:=arg_publisher_id,
                                        arg_campaign_id:=arg_campaign_id,
                                        arg_sub_id_1:=arg_sub_id_1,
                                        arg_sub_id_2:=arg_sub_id_2,
                                        arg_sub_id_3:=arg_sub_id_3,
                                        arg_sub_id_4:=arg_sub_id_4,    
                                        arg_currency_id:=arg_currency_id,
                                        arg_publisher_tier_id:=arg_publisher_tier_id,
                                        arg_orderby:=arg_orderby, 
                                        arg_limit:=arg_limit, 
                                        arg_offset:=arg_offset
                                    ) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_overrides_get(arg_override_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint, arg_publisher_tier_id integer, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_overrides_get_count(bigint, bigint, bigint, text, text, text, text, bigint, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_overrides_get_count(arg_override_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_publisher_tier_id integer DEFAULT NULL::integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
    BEGIN
        RETURN ( w4api.publisher_overrides_get_list(
                            arg_override_id:=arg_override_id,
                            arg_publisher_id:=arg_publisher_id,
                            arg_campaign_id:=arg_campaign_id,
                            arg_sub_id_1:=arg_sub_id_1,
                            arg_sub_id_2:=arg_sub_id_2,
                            arg_sub_id_3:=arg_sub_id_3,
                            arg_sub_id_4:=arg_sub_id_4,
                            arg_publisher_tier_id:=arg_publisher_tier_id,    
                            arg_currency_id:=arg_currency_id, 
                            arg_count:=TRUE
                        )
        );
    END
$$;


ALTER FUNCTION w4api.publisher_overrides_get_count(arg_override_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint, arg_publisher_tier_id integer) OWNER TO w4;

--
-- Name: publisher_overrides_get_list(bigint, bigint, bigint, text, text, text, text, bigint, integer, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_overrides_get_list(arg_override_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_sub_id_1 text DEFAULT NULL::text, arg_sub_id_2 text DEFAULT NULL::text, arg_sub_id_3 text DEFAULT NULL::text, arg_sub_id_4 text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_publisher_tier_id integer DEFAULT NULL::integer, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        from_clause text;

    BEGIN
        where_clause := w4_automatic_functions.where_clause_build(arg_override_id::TEXT, 'po.id = ' || arg_override_id, where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_campaign_id::TEXT, 'c.id = ' || arg_campaign_id, where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_publisher_id::TEXT,'u.id = ' || arg_publisher_id, where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_sub_id_1::TEXT, 'po.sub_id_1 = ''' ||arg_sub_id_1||'''', where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_sub_id_2::TEXT, 'po.sub_id_2 = ''' ||arg_sub_id_2||'''', where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_sub_id_3::TEXT, 'po.sub_id_3 = ''' ||arg_sub_id_3||'''', where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_sub_id_4::TEXT, 'po.sub_id_4 = ''' ||arg_sub_id_4||'''', where_clause);
        where_clause := w4_automatic_functions.where_clause_build(arg_publisher_tier_id::TEXT, 'po.publisher_tier_id = '||arg_publisher_tier_id, where_clause);
        order_clause := w4_automatic_functions.order_clause_build(arg_orderby, 'publisher_name ASC');
        from_clause := ' FROM publisher_overrides po
                                LEFT JOIN users u ON po.publisher_id = u.id
                                LEFT JOIN user_profiles up ON u.id = up.user_id
                                LEFT JOIN campaigns c ON po.campaign_id = c.id ';
    IF arg_count THEN
         EXECUTE
            'SELECT
            COALESCE (COUNT(1), 0)'
                || from_clause
                || where_clause
                ||';'
            INTO ret_val;
        RETURN ret_val;

    END IF;
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT po.id, 
                                    po.publisher_id, 
                                    COALESCE(up.company_name, concat(up.first_name, $$ $$, up.last_name)::character varying) AS publisher_name, 
                                    po.campaign_id, 
                                    c.name AS campaign_name, 
                                    po.override_payout AS payout, 
                                    c.default_payout, 
                                    po.override_payin AS payin, 
                                    c.default_payin, 
                                    to_json(ARRAY[COALESCE(po.sub_id_1, $$$$::text), COALESCE(po.sub_id_2, $$$$::text), COALESCE(po.sub_id_3, $$$$::text), COALESCE(po.sub_id_4, $$$$::text)])::text AS subids_json, 
                                    po.override_advertiser_landing_page AS landing_page, 
                                    to_char(po.effective_date, $$mm/dd/YYYY$$::text) AS start_date, 
                                    to_char(po.expiration_date, $$mm/dd/YYYY$$::text) AS end_date'
                    || from_clause
                    || where_clause
                    || order_clause 
                    || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') 
                    || ' OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN COALESCE(ret_val,'{}');
    END
$_$;


ALTER FUNCTION w4api.publisher_overrides_get_list(arg_override_id bigint, arg_publisher_id bigint, arg_campaign_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_currency_id bigint, arg_publisher_tier_id integer, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_overrides_update(bigint, double precision, double precision, timestamp with time zone, timestamp with time zone, text, bigint, bigint, text, text, text, text, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_overrides_update(arg_override_id bigint, arg_payout double precision, arg_payin double precision, arg_effective_date timestamp with time zone, arg_expiration_date timestamp with time zone, arg_advertiser_landing_page text, arg_campaign_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_publisher_tier_id integer) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM publisher_overrides WHERE id = arg_override_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified publisher override (%).', arg_override_id;
        END IF;

        UPDATE publisher_overrides SET
            override_payout            = COALESCE (arg_payout, override_payout),
            override_payin     = COALESCE (arg_payin, override_payin),
            effective_date     = COALESCE (arg_effective_date, effective_date),
            expiration_date     = arg_expiration_date,
            override_advertiser_landing_page     = COALESCE (arg_advertiser_landing_page, override_advertiser_landing_page),
            campaign_id     = COALESCE (arg_campaign_id, campaign_id),
            publisher_id     = COALESCE (arg_publisher_id, publisher_id),
            sub_id_1     = COALESCE (arg_sub_id_1, sub_id_1),
            sub_id_2     = COALESCE (arg_sub_id_2, sub_id_2),
            sub_id_3     = COALESCE (arg_sub_id_3, sub_id_3),
            sub_id_4     = COALESCE (arg_sub_id_4, sub_id_4),
            publisher_tier_id     = COALESCE (arg_publisher_tier_id, publisher_tier_id)
        WHERE id = arg_override_id;

        RETURN publisher_overrides_get_list(arg_override_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_overrides_update(arg_override_id bigint, arg_payout double precision, arg_payin double precision, arg_effective_date timestamp with time zone, arg_expiration_date timestamp with time zone, arg_advertiser_landing_page text, arg_campaign_id bigint, arg_publisher_id bigint, arg_sub_id_1 text, arg_sub_id_2 text, arg_sub_id_3 text, arg_sub_id_4 text, arg_publisher_tier_id integer) OWNER TO w4;

--
-- Name: publisher_payout_get(bigint, text, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_payout_get(arg_publisher_id bigint DEFAULT NULL::bigint, arg_payment_frequency text DEFAULT NULL::text, arg_payment_method bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;

	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_payout_get_count(arg_publisher_id, arg_payment_frequency, arg_payment_method, arg_min_date, arg_max_date, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_payout_get_list(arg_publisher_id, arg_payment_frequency, arg_payment_method, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset)::json ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_payout_get(arg_publisher_id bigint, arg_payment_frequency text, arg_payment_method bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_payout_get_count(bigint, text, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_payout_get_count(arg_publisher_id bigint DEFAULT NULL::bigint, arg_payment_frequency text DEFAULT NULL::text, arg_payment_method bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        where_clause_sub text := '';
        arg_min_doy integer := make_doy(arg_min_date);
        arg_max_doy integer := make_doy(arg_max_date);
        join_clause_im text := '';

    BEGIN
        where_clause := where_clause_build('invoice_null', 'ia.id IS NULL', where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'u.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_payment_frequency::TEXT, 'up.payment_schedule = $$' || arg_payment_frequency || '$$', where_clause);
        where_clause := where_clause_build(arg_payment_method::TEXT, 'up.payment_by = ' || arg_payment_method, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rca.doy BETWEEN ' || arg_min_doy || ' AND ' || arg_max_doy, where_clause);
        where_clause_sub := where_clause_build('publisher_id', 'rcas.publisher_id = u.id', where_clause_sub);
        where_clause_sub := where_clause_build(arg_min_date::TEXT, 'rcas.doy BETWEEN ' || arg_min_doy || ' AND ' || arg_max_doy, where_clause_sub);
        where_clause_sub := where_clause_build('invoice_null', 'ias.id IS NULL', where_clause_sub);
        where_clause := where_clause_build('zero', '(SELECT SUM(rcas.total_pay_out)::numeric amount_sub FROM reports_daily rcas LEFT JOIN acct_invoices_publisher ias ON ias.publisher_id = u.id AND rcas.doy BETWEEN ias.min_doy AND ias.max_doy AND ias.status = $$paid$$ ' || where_clause_sub || ') > 0', where_clause);        
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        IF (arg_min_date IS NOT NULL) THEN
            join_clause_im := 'AND im.min_doy = ' || arg_min_doy || ' AND im.max_doy = ' || arg_max_doy;
        END IF;

        EXECUTE
            'SELECT COALESCE (COUNT(1), 0) FROM (
                SELECT
                    u.id AS publisher_id,
                    MAX(up.company_name)  AS publisher_name,
                    MAX(up.payment_schedule) AS payment_frequency,
                    MAX(pm.description) AS payment_method,
                    SUM(rca.total_pay_out)::numeric AS amount,
                    (SELECT SUM(total_pay_out)::numeric FROM reports_daily rcb
                        LEFT JOIN acct_invoices_publisher ib ON ib.publisher_id = u.id AND ib.status = $$paid$$ AND rcb.doy BETWEEN ib.min_doy AND ib.max_doy
                        WHERE rcb.publisher_id = u.id AND ib IS NULL) as balance,
                    MAX(im.id) AS invoice_id,
                    MAX(im.memo) AS memo
                FROM users u
                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                LEFT JOIN user_profiles up ON up.user_id = u.id
                LEFT JOIN payment_methods pm ON pm.id = up.payment_by
                LEFT JOIN reports_daily rca ON rca.publisher_id = u.id
                LEFT JOIN campaigns cmp ON rca.campaign_id = cmp.id
                LEFT JOIN acct_invoices_publisher ia ON ia.publisher_id = u.id AND ia.status = $$paid$$ AND rca.doy BETWEEN ia.min_doy AND ia.max_doy
                LEFT JOIN acct_invoices_publisher im ON im.publisher_id = u.id AND im.status = $$unpaid$$ ' || join_clause_im
                || where_clause ||
                ' GROUP BY u.id
            ) AS the_count'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_payout_get_count(arg_publisher_id bigint, arg_payment_frequency text, arg_payment_method bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_payout_get_list(bigint, text, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_payout_get_list(arg_publisher_id bigint DEFAULT NULL::bigint, arg_payment_frequency text DEFAULT NULL::text, arg_payment_method bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        where_clause_sub text := '';
        order_clause text;
        arg_min_doy integer := make_doy(arg_min_date);
        arg_max_doy integer := make_doy(arg_max_date);
        join_clause_im text := '';
test text;

    BEGIN
        where_clause := where_clause_build('invoice_null', 'ia.id IS NULL', where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'u.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_payment_frequency::TEXT, 'up.payment_schedule = $$' || arg_payment_frequency || '$$', where_clause);
        where_clause := where_clause_build(arg_payment_method::TEXT, 'up.payment_by = ' || arg_payment_method, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'rca.doy BETWEEN ' || arg_min_doy || ' AND ' || arg_max_doy, where_clause);
        where_clause_sub := where_clause_build('publisher_id', 'rcas.publisher_id = u.id', where_clause_sub);
        where_clause_sub := where_clause_build(arg_min_date::TEXT, 'rcas.doy BETWEEN ' || arg_min_doy || ' AND ' || arg_max_doy, where_clause_sub);
        where_clause_sub := where_clause_build('invoice_null', 'ias.id IS NULL', where_clause_sub);
        where_clause := where_clause_build('zero', '(SELECT SUM(rcas.total_pay_out)::numeric amount_sub FROM reports_daily rcas LEFT JOIN acct_invoices_publisher ias ON ias.publisher_id = u.id AND rcas.doy BETWEEN ias.min_doy AND ias.max_doy AND ias.status = $$paid$$ ' || where_clause_sub || ') > 0', where_clause);        
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);
        
        order_clause := order_clause_build(arg_orderby, 'publisher_name');

        IF (arg_min_date IS NOT NULL) THEN
            join_clause_im := 'AND im.min_doy = ' || arg_min_doy || ' AND im.max_doy = ' || arg_max_doy;
        END IF;
        join_clause_im := where_clause_build(arg_currency_id::TEXT, 'im.currency_id = ' || arg_currency_id, join_clause_im);
test := '
SELECT
                                    u.id AS publisher_id,
                                    MAX(up.company_name)  AS publisher_name,
                                    MAX(up.payment_schedule) AS payment_frequency,
                                    MAX(pm.description) AS payment_method,
                                    SUM(rca.total_pay_out)::numeric AS amount,
                                    (SELECT SUM(total_pay_out)::numeric FROM reports_daily rcb
                                        LEFT JOIN acct_invoices_publisher ib ON ib.publisher_id = u.id AND ib.status = $$paid$$ AND rcb.doy BETWEEN ib.min_doy AND ib.max_doy
                                        LEFT JOIN campaigns c ON c.id = rcb.campaign_id
                                        WHERE rcb.publisher_id = u.id AND ib IS NULL AND c.currency_id = ' || arg_currency_id || ') as balance,
                                    im.id AS invoice_id,
                                    im.memo AS memo
                                FROM users u
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN payment_methods pm ON pm.id = up.payment_by
                                LEFT JOIN reports_daily rca ON rca.publisher_id = u.id
                                LEFT JOIN campaigns cmp ON rca.campaign_id = cmp.id
                                LEFT JOIN acct_invoices_publisher ia ON ia.publisher_id = u.id AND ia.status = $$paid$$ AND rca.doy BETWEEN ia.min_doy AND ia.max_doy
                                LEFT JOIN acct_invoices_publisher im ON im.publisher_id = u.id AND im.status = $$unpaid$$ ' || join_clause_im
                                || where_clause ||
                                ' GROUP BY u.id, im.id, im.memo '
                                || order_clause;
raise info 'test: %', test;
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    u.id AS publisher_id,
                                    MAX(up.company_name)  AS publisher_name,
                                    MAX(up.payment_schedule) AS payment_frequency,
                                    MAX(pm.description) AS payment_method,
                                    SUM(rca.total_pay_out)::numeric AS amount,
                                    (SELECT SUM(total_pay_out)::numeric FROM reports_daily rcb
                                        LEFT JOIN acct_invoices_publisher ib ON ib.publisher_id = u.id AND ib.status = $$paid$$ AND rcb.doy BETWEEN ib.min_doy AND ib.max_doy
                                        LEFT JOIN campaigns c ON c.id = rcb.campaign_id
                                        WHERE rcb.publisher_id = u.id AND ib IS NULL AND c.currency_id = ' || arg_currency_id || ') as balance,
                                    im.id AS invoice_id,
                                    im.memo AS memo
                                FROM users u
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN payment_methods pm ON pm.id = up.payment_by
                                LEFT JOIN reports_daily rca ON rca.publisher_id = u.id
                                LEFT JOIN campaigns cmp ON rca.campaign_id = cmp.id
                                LEFT JOIN acct_invoices_publisher ia ON ia.publisher_id = u.id AND ia.status = $$paid$$ AND rca.doy BETWEEN ia.min_doy AND ia.max_doy
                                LEFT JOIN acct_invoices_publisher im ON im.publisher_id = u.id AND im.status = $$unpaid$$ ' || join_clause_im
                                || where_clause ||
                                ' GROUP BY u.id, im.id, im.memo '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_payout_get_list(arg_publisher_id bigint, arg_payment_frequency text, arg_payment_method bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_profile_contact_get_details(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_contact_get_details(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    usr.id
                    , con.email_address
                    , con.first_name
                    , con.last_name
                    , con.primary_phone
                    , con.secondary_phone
                    , con.fax
                    , con.messenger_name
                    , con.messenger_type AS messenger_type
                    , usp.image_id
                INTO ret_val
                FROM users usr 
		LEFT JOIN user_profiles usp 
                    ON usr.id = usp.user_id 
                LEFT JOIN contacts con
                    ON con.id = usr.primary_contact_id
                WHERE
                    usr.id = arg_id
                    AND usr.access = 'publisher'
            ) row;

        IF NOT FOUND THEN
            PERFORM * FROM users WHERE users.id = arg_id AND users.access = 'publisher';
            IF NOT FOUND THEN
                    RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
            END IF;
        END IF;
        RETURN ret_val;

    END;
$$;


ALTER FUNCTION w4api.publisher_profile_contact_get_details(arg_id bigint) OWNER TO w4;

--
-- Name: publisher_profile_contact_update(bigint, bigint, text, text, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_contact_update(arg_id bigint, arg_image_id bigint DEFAULT NULL::bigint, arg_email text DEFAULT NULL::text, arg_primary_phone text DEFAULT NULL::text, arg_secondary_phone text DEFAULT NULL::text, arg_first_name text DEFAULT NULL::text, arg_last_name text DEFAULT NULL::text, arg_fax text DEFAULT NULL::text, arg_messenger_name text DEFAULT NULL::text, arg_messenger_type bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        contact_id bigint;
    BEGIN
        SELECT primary_contact_id INTO contact_id FROM users WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
        END IF;

        UPDATE user_profiles SET
            image_id = COALESCE (arg_image_id::text, image_id)
        WHERE user_id = arg_id;

        UPDATE contacts SET
            email_address = COALESCE (arg_email, email_address),
            first_name = COALESCE (arg_first_name, first_name),
            last_name = COALESCE (arg_last_name, last_name),
            primary_phone = COALESCE (arg_primary_phone, primary_phone),
            secondary_phone = COALESCE (arg_secondary_phone, secondary_phone),
            fax = COALESCE (arg_fax, fax),
            messenger_name = COALESCE (arg_messenger_name, messenger_name),
            messenger_type = COALESCE (arg_messenger_type, messenger_type)
        WHERE id = contact_id;

        RETURN publisher_profile_contact_get_details (arg_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_profile_contact_update(arg_id bigint, arg_image_id bigint, arg_email text, arg_primary_phone text, arg_secondary_phone text, arg_first_name text, arg_last_name text, arg_fax text, arg_messenger_name text, arg_messenger_type bigint) OWNER TO w4;

--
-- Name: publisher_profile_contact_update_request(bigint, bigint, text, text, text, text, text, text, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_contact_update_request(arg_id bigint, arg_image_id bigint DEFAULT NULL::bigint, arg_email text DEFAULT NULL::text, arg_primary_phone text DEFAULT NULL::text, arg_secondary_phone text DEFAULT NULL::text, arg_first_name text DEFAULT NULL::text, arg_last_name text DEFAULT NULL::text, arg_fax text DEFAULT NULL::text, arg_messenger_name text DEFAULT NULL::text, arg_messenger_type bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_manager_id bigint;
        var_recipients json;
        var_message_success boolean;

    BEGIN
        SELECT manager_id INTO var_manager_id FROM users WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
        END IF;

        INSERT INTO publisher_account_changes
            (publisher_id, changed_at, status, contact_type, image_id, email, primary_phone, secondary_phone, first_name, last_name, fax, messenger_name, messenger_type)
            VALUES (arg_id, CURRENT_TIMESTAMP, 'pending', 'primary'::contact, arg_image_id, arg_email, arg_primary_phone, arg_secondary_phone, arg_first_name, arg_last_name, arg_fax,
                    arg_messenger_name, arg_messenger_type);

        var_recipients := '{"recipients" : [' || var_manager_id || ']}';
        var_message_success := messages_create (arg_id, var_recipients, 5, 'Publisher has made a change to their account and it needs to be verified.', null, 1, 2);


        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_profile_contact_update_request(arg_id bigint, arg_image_id bigint, arg_email text, arg_primary_phone text, arg_secondary_phone text, arg_first_name text, arg_last_name text, arg_fax text, arg_messenger_name text, arg_messenger_type bigint) OWNER TO w4;

--
-- Name: publisher_profile_login_get_details(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_login_get_details(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    usr.id
                    , usr.email
                    , usr.login_name
                    , usp.website_url
                    , con.address_1
                    , con.address_2
                    , con.country_id
                    , gtc.country AS country_name
                    , con.region_id
                    , gtr.ascii_name AS region_name
                    , con.city_id
                    , gtct.place_name_ascii AS city_name
                    , con.postal_code
                INTO ret_val
                FROM users usr
                LEFT JOIN contacts con
                    ON con.id = usr.account_contact_id
		LEFT JOIN user_profiles usp
                    ON usr.id = usp.user_id
                LEFT JOIN geo_typeahead_countries gtc
                    ON con.country_id = gtc.id
                LEFT JOIN geo_typeahead_region gtr
                    ON con.region_id = gtr.id
                LEFT JOIN geo_typeahead_cities gtct
                    ON con.city_id = gtct.id
                WHERE
                    usr.id = arg_id
                    AND usr.access = 'publisher'
            ) row;
        IF NOT FOUND THEN
            PERFORM * FROM users WHERE users.id = arg_id AND users.access = 'publisher';
            IF NOT FOUND THEN
                    RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
            END IF;
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.publisher_profile_login_get_details(arg_id bigint) OWNER TO w4;

--
-- Name: publisher_profile_login_update(bigint, text, text, text, text, text, text, bigint, bigint, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_login_update(arg_id bigint, arg_email text DEFAULT NULL::text, arg_password text DEFAULT NULL::text, arg_login_name text DEFAULT NULL::text, arg_website_url text DEFAULT NULL::text, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_id bigint DEFAULT NULL::bigint, arg_city_id bigint DEFAULT NULL::bigint, arg_postal_code text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        contact_id bigint;
    BEGIN
        SELECT account_contact_id INTO contact_id FROM users WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
        END IF;
        IF arg_login_name = '' THEN
            RAISE EXCEPTION 'Invalid login name';
	END IF;
	PERFORM login_name FROM users WHERE login_name ILIKE arg_login_name AND id <> arg_id;
	IF FOUND THEN
            RAISE EXCEPTION 'The login name [%] is in use by another user', arg_login_name;
	END IF;
        UPDATE users SET
            login_name = COALESCE (arg_login_name, login_name),
            email = COALESCE (arg_email, email),
            password = COALESCE (arg_password, password)
        WHERE id = arg_id;
        UPDATE contacts SET
            address_1 = COALESCE (arg_address_1, address_1),
            address_2 = COALESCE (arg_address_2, address_2),
            country_id = COALESCE (arg_country_id, country_id),
            region_id = COALESCE (arg_region_id, region_id),
            city_id = COALESCE (arg_city_id, city_id),
            postal_code = COALESCE (arg_postal_code, postal_code)
        WHERE id = contact_id;
        UPDATE user_profiles SET
            website_url = COALESCE (arg_website_url, website_url)
        WHERE id = arg_id;
        RETURN publisher_profile_login_get_details(arg_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_profile_login_update(arg_id bigint, arg_email text, arg_password text, arg_login_name text, arg_website_url text, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_postal_code text) OWNER TO w4;

--
-- Name: publisher_profile_login_update_request(bigint, text, text, text, text, text, text, bigint, text, text, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_login_update_request(arg_id bigint, arg_email text DEFAULT NULL::text, arg_password text DEFAULT NULL::text, arg_login_name text DEFAULT NULL::text, arg_website_url text DEFAULT NULL::text, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_postal_code text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_manager_id bigint;
        var_recipients json;
        var_message_success boolean;
	var_region_id bigint;
        var_city_id bigint;
 
    BEGIN
        SELECT manager_id INTO var_manager_id FROM users WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
        END IF;

        IF arg_login_name = '' THEN
            RAISE EXCEPTION 'Invalid login name';
	END IF;

	PERFORM login_name FROM users WHERE login_name ILIKE arg_login_name AND id <> arg_id;
	IF FOUND THEN
            RAISE EXCEPTION 'The login name [%] is in use by another user', arg_login_name;
	END IF;

        SELECT region_id, city_id FROM geo_get(arg_country_id, arg_region_name, arg_city_name) INTO var_region_id, var_city_id;

        INSERT INTO publisher_account_changes
            (publisher_id, changed_at, status, contact_type, email, password, login_name, website_url, address_1, address_2, country_id, region_id, city_id, postal_code)
            VALUES (arg_id, CURRENT_TIMESTAMP, 'pending', 'account'::contact, arg_email, arg_password, arg_login_name, arg_website_url, arg_address_1, arg_address_2, arg_country_id,
                    var_region_id, var_city_id, arg_postal_code);

        var_recipients := '{"recipients" : [' || var_manager_id || ']}';
        var_message_success := messages_create (arg_id, var_recipients, 5, 'Publisher has made a change to their account and it needs to be verified.', null, 1, 2);

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_profile_login_update_request(arg_id bigint, arg_email text, arg_password text, arg_login_name text, arg_website_url text, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_name text, arg_city_name text, arg_postal_code text) OWNER TO w4;

--
-- Name: publisher_profile_payment_get_details(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_payment_get_details(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    usr.id
                    , con.address_1
                    , con.address_2
                    , con.country_id
                    , gtc.country AS country_name
                    , con.region_id
                    , gtr.ascii_name AS region_name
                    , con.city_id
                    , gtct.place_name_ascii AS city_name
                    , con.postal_code
                    , up.tax_id
                    , pm.id AS payment_id
                    , pm.description AS payment_name
                    , up.payment_to
                    , up.company_name
                INTO ret_val
                FROM users usr
                LEFT JOIN contacts con
                    ON con.id = usr.billing_contact_id
                LEFT JOIN user_profiles up
                    ON usr.id = up.user_id
                LEFT JOIN geo_typeahead_countries gtc
                    ON con.country_id = gtc.id
                LEFT JOIN geo_typeahead_region gtr
                    ON con.region_id = gtr.id
                LEFT JOIN geo_typeahead_cities gtct
                    ON con.city_id = gtct.id
                LEFT JOIN payment_methods pm
                    ON up.payment_by = pm.id
                WHERE
                    usr.id = arg_id
                    AND usr.access = 'publisher'
            ) row;
        IF NOT FOUND THEN
            PERFORM * FROM users WHERE users.id = arg_id AND users.access = 'publisher';
            IF NOT FOUND THEN
                    RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
            END IF;
        END IF;
        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.publisher_profile_payment_get_details(arg_id bigint) OWNER TO w4;

--
-- Name: publisher_profile_payment_update(bigint, text, text, bigint, bigint, bigint, text, text, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_payment_update(arg_id bigint, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_id bigint DEFAULT NULL::bigint, arg_city_id bigint DEFAULT NULL::bigint, arg_postal_code text DEFAULT NULL::text, arg_tax_id text DEFAULT NULL::text, arg_payment_method_id bigint DEFAULT NULL::bigint, arg_payment_to text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        contact_id bigint;
    BEGIN
        SELECT billing_contact_id INTO contact_id FROM users WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
        END IF;
raise info 'address: %', arg_address_1;
        UPDATE contacts SET
            address_1 = COALESCE (arg_address_1, address_1),
            address_2 = COALESCE (arg_address_2, address_2),
            country_id = COALESCE (arg_country_id, country_id),
            region_id = COALESCE (arg_region_id, region_id),
            city_id = COALESCE (arg_city_id, city_id),
            postal_code = COALESCE (arg_postal_code, postal_code)
        WHERE id = contact_id;

        UPDATE user_profiles SET
            tax_id = COALESCE (arg_tax_id, tax_id),
            payment_by = COALESCE (arg_payment_method_id, payment_by),
            payment_to = COALESCE (arg_payment_to, payment_to)
        WHERE user_id = arg_id;

        RETURN publisher_profile_payment_get_details(arg_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_profile_payment_update(arg_id bigint, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_id bigint, arg_city_id bigint, arg_postal_code text, arg_tax_id text, arg_payment_method_id bigint, arg_payment_to text) OWNER TO w4;

--
-- Name: publisher_profile_payment_update_request(bigint, text, text, bigint, text, text, text, text, bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_profile_payment_update_request(arg_id bigint, arg_address_1 text DEFAULT NULL::text, arg_address_2 text DEFAULT NULL::text, arg_country_id bigint DEFAULT NULL::bigint, arg_region_name text DEFAULT NULL::text, arg_city_name text DEFAULT NULL::text, arg_postal_code text DEFAULT NULL::text, arg_tax_id text DEFAULT NULL::text, arg_payment_method_id bigint DEFAULT NULL::bigint, arg_payment_to text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_manager_id bigint;
        var_recipients json;
        var_message_success boolean;
	var_region_id bigint;
        var_city_id bigint;

    BEGIN
        SELECT manager_id INTO var_manager_id FROM users WHERE id = arg_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'The user id [%] does not exist for any publisher.', arg_id;
        END IF;

        SELECT region_id, city_id FROM geo_get(arg_country_id, arg_region_name, arg_city_name) INTO var_region_id, var_city_id;

        INSERT INTO publisher_account_changes
            (publisher_id, changed_at, status, contact_type, address_1, address_2, country_id, region_id, city_id, postal_code, tax_id, payment_method_id, payment_to)
            VALUES (arg_id, CURRENT_TIMESTAMP, 'pending', 'billing'::contact, arg_address_1, arg_address_2, arg_country_id, var_region_id, var_city_id,
                arg_postal_code, arg_tax_id, arg_payment_method_id, arg_payment_to);

        var_recipients := '{"recipients" : [' || var_manager_id || ']}';
        var_message_success := messages_create (arg_id, var_recipients, 5, 'Publisher has made a change to their account and it needs to be verified.', null, 1, 2);

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_profile_payment_update_request(arg_id bigint, arg_address_1 text, arg_address_2 text, arg_country_id bigint, arg_region_name text, arg_city_name text, arg_postal_code text, arg_tax_id text, arg_payment_method_id bigint, arg_payment_to text) OWNER TO w4;

--
-- Name: publisher_recommendations_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_delete(arg_recommended_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        delete_count bigint;
    BEGIN
        DELETE FROM publisher_campaign_recommendations WHERE id = arg_recommended_id;
        IF FOUND THEN
            RETURN true;
        ELSE
            RETURN false;
        END IF;
    END;
$$;


ALTER FUNCTION w4api.publisher_recommendations_delete(arg_recommended_id bigint) OWNER TO w4;

--
-- Name: publisher_recommendations_get(bigint, bigint, bigint, bigint, text, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_get(arg_publisher_id bigint, arg_category_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_channel_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_recommendations_get_count(arg_publisher_id, arg_category_id, arg_campaign_id, arg_channel_id, arg_recommended_by, arg_min_date, arg_max_date, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_recommendations_get_list(arg_publisher_id, arg_category_id, arg_campaign_id, arg_channel_id, arg_recommended_by, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_recommendations_get(arg_publisher_id bigint, arg_category_id bigint, arg_campaign_id bigint, arg_channel_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_recommendations_get_count(bigint, bigint, bigint, bigint, text, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_get_count(arg_publisher_id bigint, arg_category_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_channel_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'pcr.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pcr.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, '(CONCAT (acon.first_name, CHR(1), acon.last_name) ILIKE $$%' || arg_recommended_by || '%$$ OR pcr.user_id::text ILIKE $$%' || arg_recommended_by || '%$$)' , where_clause);
        where_clause := where_clause_build(arg_category_id::TEXT, 'cca.category_id = ' || arg_category_id, where_clause);
        where_clause := where_clause_build(arg_channel_id::TEXT, 'cch.channel_id = ' || arg_channel_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT COALESCE (COUNT(1), 0) FROM (
                SELECT c.id
                FROM publisher_campaign_recommendations pcr
                LEFT JOIN campaigns c ON pcr.campaign_id = c.id
                LEFT JOIN campaign_categories cca ON pcr.campaign_id = cca.campaign_id
                LEFT JOIN campaign_channels cch ON pcr.campaign_id = cch.campaign_id
                LEFT JOIN channels ch ON cch.channel_id = ch.id
                LEFT JOIN users adm ON adm.id = pcr.user_id
                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id '                                
                || where_clause ||
                ' GROUP BY c.id
            ) AS the_count;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_recommendations_get_count(arg_publisher_id bigint, arg_category_id bigint, arg_campaign_id bigint, arg_channel_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_recommendations_get_list(bigint, bigint, bigint, bigint, text, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_get_list(arg_publisher_id bigint, arg_category_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_channel_id bigint DEFAULT NULL::bigint, arg_recommended_by text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'pcr.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pcr.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_recommended_by::TEXT, '(CONCAT (acon.first_name, CHR(1), acon.last_name) ILIKE $$%' || arg_recommended_by || '%$$ OR pcr.user_id::text ILIKE $$%' || arg_recommended_by || '%$$)' , where_clause);
        where_clause := where_clause_build(arg_category_id::TEXT, 'cca.category_id = ' || arg_category_id, where_clause);
        where_clause := where_clause_build(arg_channel_id::TEXT, 'cch.channel_id = ' || arg_channel_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'recommended_date DESC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    MAX(pcr.id) AS recommended_id,
                                    c.id AS campaign_id,
                                    MAX(c.name) AS campaign_name,
                                    campaign_channels_get_list(c.id) channel_names,
                                    campaign_categories_get_list(c.id) category_names,
                                    MAX(pcr.created_at) AS recommended_date,
                                    MAX(pcr.user_id) AS recommended_by_id,
                                    CONCAT (COALESCE(MAX(acon.first_name), MAX(aup.first_name)), '' '', COALESCE(MAX(acon.last_name), MAX(aup.last_name))) AS recommended_by_name,
                                    MAX(c.currency_id) AS currency_id
                                FROM publisher_campaign_recommendations pcr
                                LEFT JOIN campaigns c ON pcr.campaign_id = c.id
                                LEFT JOIN campaign_categories cca ON pcr.campaign_id = cca.campaign_id
                                LEFT JOIN campaign_channels cch ON pcr.campaign_id = cch.campaign_id
                                LEFT JOIN channels ch ON cch.channel_id = ch.id
                                LEFT JOIN users adm ON adm.id = pcr.user_id
                                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id
                                LEFT JOIN user_profiles aup ON aup.user_id = pcr.user_id '                               
                                || where_clause ||
                                ' GROUP BY c.id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_recommendations_get_list(arg_publisher_id bigint, arg_category_id bigint, arg_campaign_id bigint, arg_channel_id bigint, arg_recommended_by text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_recommendations_potential_get(text, bigint, bigint, bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_potential_get(arg_status text DEFAULT NULL::text, arg_category_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_channel_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_recommendations_potential_get_count(arg_status, arg_category_id, arg_campaign_id, arg_channel_id, arg_publisher_id, arg_min_date, arg_max_date, arg_currency_id), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_recommendations_potential_get_list(arg_status, arg_category_id, arg_campaign_id, arg_channel_id, arg_publisher_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_recommendations_potential_get(arg_status text, arg_category_id bigint, arg_campaign_id bigint, arg_channel_id bigint, arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_recommendations_potential_get_count(text, bigint, bigint, bigint, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_potential_get_count(arg_status text DEFAULT NULL::text, arg_category_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_channel_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        available_clause text;
        join_clause text := '';

    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'c.id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_category_id::TEXT, 'cca.category_id = ' || arg_category_id, where_clause);
        where_clause := where_clause_build(arg_channel_id::TEXT, 'cch.channel_id = ' || arg_channel_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);

        IF arg_publisher_id IS NULL THEN
            available_clause := 'MAX(pcr.id) IS NOT NULL';
        ELSE
            available_clause := 'MAX(pcr.publisher_id) = ' || arg_publisher_id;
            IF arg_status != 'available' OR arg_status IS NULL THEN
                join_clause := ' AND pcr.publisher_id = ' || arg_publisher_id;
            END IF;
        END IF;

        IF arg_status = 'available' THEN
            IF arg_publisher_id IS NOT NULL THEN
                join_clause := ' AND pcr.publisher_id != ' || arg_publisher_id;
            END IF;
        ELSEIF arg_status = 'recommended' THEN
            IF arg_publisher_id IS NULL THEN
                where_clause := where_clause_build('available', 'pcr.id IS NOT NULL', where_clause);
            ELSE
                where_clause := where_clause_build('available', 'pcr.publisher_id = ' || arg_publisher_id, where_clause);
            END IF;
        END IF;

        EXECUTE
            'SELECT COUNT(*) FROM (
                SELECT
                    COALESCE (COUNT(1), 0)
                FROM campaigns c
                LEFT JOIN publisher_campaign_recommendations pcr ON pcr.campaign_id = c.id ' || join_clause || '
                LEFT JOIN users adm ON adm.id = pcr.user_id
                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id '                                
                || where_clause ||
                ' GROUP BY c.id
            ) AS counting;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_recommendations_potential_get_count(arg_status text, arg_category_id bigint, arg_campaign_id bigint, arg_channel_id bigint, arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_recommendations_potential_get_list(text, bigint, bigint, bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_potential_get_list(arg_status text DEFAULT NULL::text, arg_category_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_channel_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        available_clause text;
        join_clause text := '';

    BEGIN
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'c.id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_category_id::TEXT, 'cca.category_id = ' || arg_category_id, where_clause);
        where_clause := where_clause_build(arg_channel_id::TEXT, 'cch.channel_id = ' || arg_channel_id, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'pcr.created_at >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'pcr.created_at < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_id DESC');

        IF arg_publisher_id IS NULL THEN
            available_clause := 'MAX(pcr.id) IS NOT NULL';
        ELSE
            available_clause := 'MAX(pcr.publisher_id) = ' || arg_publisher_id;
            IF arg_status != 'available' OR arg_status IS NULL THEN
                join_clause := ' AND pcr.publisher_id = ' || arg_publisher_id;
            END IF;
        END IF;

        IF arg_status = 'available' THEN
            IF arg_publisher_id IS NOT NULL THEN
                join_clause := ' AND pcr.publisher_id != ' || arg_publisher_id;
            END IF;
        ELSEIF arg_status = 'recommended' THEN
            IF arg_publisher_id IS NULL THEN
                where_clause := where_clause_build('available', 'pcr.id IS NOT NULL', where_clause);
            ELSE
                where_clause := where_clause_build('available', 'pcr.publisher_id = ' || arg_publisher_id, where_clause);
            END IF;
        END IF;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    MAX(pcr.id) AS recommended_id,
                                    c.id campaign_id,
                                    MAX(c.name) AS campaign_name,
                                    (CASE
                                        WHEN ' || available_clause || '
                                        THEN $$recommended$$ ELSE $$available$$
                                    END) AS status,
                                    campaign_channels_get_list(c.id) channel_names,
                                    campaign_categories_get_list(c.id) category_names,
                                    MAX(pcr.created_at) AS recommended_date,
                                    MAX(pcr.user_id) AS recommended_by_id,
                                    CONCAT (COALESCE(MAX(acon.first_name), MAX(aup.first_name)), '' '', COALESCE(MAX(acon.last_name), MAX(aup.last_name))) AS recommended_by_name 
                                FROM campaigns c
                                LEFT JOIN publisher_campaign_recommendations pcr ON pcr.campaign_id = c.id ' || join_clause || '
                                LEFT JOIN users adm ON adm.id = pcr.user_id
                                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id
                                LEFT JOIN user_profiles aup ON aup.user_id = pcr.user_id '                                
                                || where_clause ||
                                ' GROUP BY c.id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_recommendations_potential_get_list(arg_status text, arg_category_id bigint, arg_campaign_id bigint, arg_channel_id bigint, arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_recommendations_potential_update(json, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_potential_update(arg_changes json, arg_admin_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        pub_id bigint;
        cam_id bigint;
        recommended boolean;
        ret_val json;
        pcr_id bigint;
        pcr_ids bigint[];
        delete_ids bigint[];
        ret_str text;

    BEGIN
        FOR pub_id, cam_id, recommended IN SELECT * FROM json_populate_recordset(NULL::campaign_recommendation,arg_changes->'changes') LOOP
            IF recommended::boolean THEN
                INSERT INTO publisher_campaign_recommendations
                    (publisher_id, campaign_id, user_id, created_at, updated_at)
                    VALUES (pub_id, cam_id, arg_admin_id, NOW(), NOW())
                    RETURNING id
                    INTO pcr_id;
                pcr_ids = array_append(pcr_ids, pcr_id);
            ELSE
                SELECT id FROM publisher_campaign_recommendations WHERE publisher_id = pub_id AND campaign_id = cam_id INTO pcr_id;
                delete_ids = array_append(delete_ids, pcr_id);
            END IF;               
        END LOOP;
        
        ret_str := '{';
        IF array_length(delete_ids, 1) > 0 THEN
            ret_str := ret_str || '"available": ';
            ret_str := ret_str ||  publisher_recommendations_update_get_list(delete_ids, true);
            FOREACH pcr_id IN ARRAY delete_ids LOOP
                DELETE FROM publisher_campaign_recommendations WHERE id = pcr_id;
            END LOOP;
        END IF;

        IF array_length(pcr_ids, 1) > 0 THEN
            IF array_length(delete_ids, 1) > 0 THEN
                ret_str := ret_str || ', ';
            END IF;
            ret_str := ret_str || '"recommended": ';
            ret_str := ret_str || publisher_recommendations_update_get_list(pcr_ids, false);
        END IF;
        ret_val := (ret_str || '}')::json;

        RETURN ret_val;
    END;
$$;


ALTER FUNCTION w4api.publisher_recommendations_potential_update(arg_changes json, arg_admin_id bigint) OWNER TO w4;

--
-- Name: publisher_recommendations_update_get_list(bigint[], boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_recommendations_update_get_list(arg_pcr_ids bigint[], arg_delete boolean) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
	ret_val json;
        pcr_id bigint;
        where_clause text := '';

    BEGIN
        FOREACH pcr_id IN ARRAY arg_pcr_ids LOOP
            IF where_clause != '' THEN
                where_clause := where_clause || ' OR ';
            ELSE
                where_clause := ' WHERE ';
            END IF;
            where_clause := where_clause || 'pcr.id = ' || pcr_id;            
        END LOOP;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    MAX(pcr.id) AS recommended_id,
                                    pcr.publisher_id,                                    
                                    c.id campaign_id,
                                    MAX(c.name) AS campaign_name,
                                    (CASE
                                        WHEN ' || arg_delete || '
                                        THEN $$available$$ ELSE $$recommended$$
                                    END) AS status,
                                    campaign_channels_get_list(c.id) channel_names,
                                    campaign_categories_get_list(c.id) category_names,
                                    MAX(pcr.created_at) AS recommended_date,
                                    MAX(pcr.user_id) AS recommended_by_id,
                                    CONCAT (COALESCE(MAX(acon.first_name), MAX(aup.first_name)), '' '', COALESCE(MAX(acon.last_name), MAX(aup.last_name))) AS recommended_by_name                                    
                                FROM campaigns c
                                LEFT JOIN publisher_campaign_recommendations pcr ON pcr.campaign_id = c.id
                                LEFT JOIN campaign_categories cca ON c.id = cca.campaign_id
                                LEFT JOIN campaign_channels cch ON c.id = cch.campaign_id
                                LEFT JOIN channels ch ON cch.channel_id = ch.id
                                LEFT JOIN users adm ON adm.id = pcr.user_id
                                LEFT JOIN contacts acon ON acon.id = adm.primary_contact_id
                                LEFT JOIN user_profiles aup ON aup.user_id = adm.id '
                                || where_clause || '
                                GROUP BY c.id,pcr.publisher_id
                                
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_recommendations_update_get_list(arg_pcr_ids bigint[], arg_delete boolean) OWNER TO w4;

--
-- Name: publisher_requests_create(character varying, character varying, character varying, character varying, character varying, character varying, character varying, bigint, character varying, character varying, character varying, character varying, character varying, bigint, character varying, text, character varying, text, character varying, character varying, character, text, text, text, character varying, character varying, character varying, character varying, bigint, character varying, text, text, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_requests_create(arg_first_name character varying, arg_last_name character varying, arg_company_name character varying, arg_email character varying, arg_account_address_1 character varying, arg_account_city_name character varying, arg_account_region_name character varying, arg_account_country_id bigint, arg_account_postal_code character varying, arg_primary_phone character varying, arg_billing_address_1 character varying, arg_billing_city_name character varying, arg_billing_region_name character varying, arg_billing_country_id bigint, arg_billing_postal_code character varying, arg_tax_class text, arg_tax_id character varying, arg_payment_to text, arg_website_url character varying, arg_login_name character varying, arg_password character, arg_challenge_question text, arg_challenge_answer text, arg_security_code text, arg_title character varying DEFAULT NULL::character varying, arg_account_address_2 character varying DEFAULT NULL::character varying, arg_fax character varying DEFAULT NULL::character varying, arg_messenger_name character varying DEFAULT NULL::character varying, arg_messenger_type bigint DEFAULT NULL::bigint, arg_billing_address_2 character varying DEFAULT NULL::character varying, arg_site_category text DEFAULT NULL::text, arg_how_you_market text DEFAULT NULL::text, arg_comments text DEFAULT NULL::text, arg_parent_publisher_id bigint DEFAULT NULL::bigint, arg_referrer_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
    arg_billing_city_id bigint;
    arg_billing_region_id bigint;
    arg_account_city_id bigint;
    arg_account_region_id bigint;
    var_geo_fix  RECORD;
    BEGIN

	--gets the region and city ids for account
	SELECT city_id, region_id INTO arg_account_city_id, arg_account_region_id FROM w4api.geo_get(arg_account_country_id, initcap(lower(trim(arg_account_region_name))), initcap(lower(trim(arg_account_city_name))));

       --gets the region and city ids for account
	SELECT city_id, region_id INTO arg_billing_city_id, arg_billing_region_id FROM w4api.geo_get(arg_billing_country_id, initcap(lower(trim(arg_billing_region_name))), initcap(lower(trim(arg_billing_city_name))));

	INSERT INTO publisher_signup
            (first_name, last_name, title, account_address_1, account_address_2, account_city_name, account_city_id, account_region_id, account_country_id, account_postal_code,
                primary_phone, fax, email, messenger_name, messenger_type, company_name, billing_address_1, billing_address_2, billing_city_name, billing_city_id, billing_region_id,
                billing_country_id, billing_postal_code, tax_class, tax_id, payment_to, website_url, site_category, how_you_market, comments, login_name, password,
                challenge_question, challenge_answer, security_code, status, publisher_id, created, modified, parent_publisher_id, referrer_id)
            VALUES (arg_first_name, arg_last_name, arg_title, arg_account_address_1, arg_account_address_2, arg_account_city_name, arg_account_city_id, arg_account_region_id,
                arg_account_country_id, arg_account_postal_code, arg_primary_phone, arg_fax, arg_email, arg_messenger_name, arg_messenger_type, arg_company_name,
                arg_billing_address_1, arg_billing_address_2, arg_billing_city_name, arg_billing_city_id, arg_billing_region_id, arg_billing_country_id, arg_billing_postal_code,
                arg_tax_class, arg_tax_id, arg_payment_to, arg_website_url, arg_site_category, arg_how_you_market, arg_comments, arg_login_name, arg_password,
                arg_challenge_question, arg_challenge_answer, arg_security_code, 'unconfirmed', null, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, arg_parent_publisher_id, arg_referrer_id);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_requests_create(arg_first_name character varying, arg_last_name character varying, arg_company_name character varying, arg_email character varying, arg_account_address_1 character varying, arg_account_city_name character varying, arg_account_region_name character varying, arg_account_country_id bigint, arg_account_postal_code character varying, arg_primary_phone character varying, arg_billing_address_1 character varying, arg_billing_city_name character varying, arg_billing_region_name character varying, arg_billing_country_id bigint, arg_billing_postal_code character varying, arg_tax_class text, arg_tax_id character varying, arg_payment_to text, arg_website_url character varying, arg_login_name character varying, arg_password character, arg_challenge_question text, arg_challenge_answer text, arg_security_code text, arg_title character varying, arg_account_address_2 character varying, arg_fax character varying, arg_messenger_name character varying, arg_messenger_type bigint, arg_billing_address_2 character varying, arg_site_category text, arg_how_you_market text, arg_comments text, arg_parent_publisher_id bigint, arg_referrer_id bigint) OWNER TO w4;

--
-- Name: publisher_requests_create(character varying, character varying, character varying, character varying, character varying, character varying, bigint, bigint, bigint, character varying, character varying, character varying, character varying, bigint, bigint, bigint, character varying, text, character varying, text, character varying, character varying, character, text, text, text, character varying, character varying, character varying, character varying, bigint, character varying, text, text, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_requests_create(arg_first_name character varying, arg_last_name character varying, arg_company_name character varying, arg_email character varying, arg_account_address_1 character varying, arg_account_city_name character varying, arg_account_city_id bigint, arg_account_region_id bigint, arg_account_country_id bigint, arg_account_postal_code character varying, arg_primary_phone character varying, arg_billing_address_1 character varying, arg_billing_city_name character varying, arg_billing_city_id bigint, arg_billing_region_id bigint, arg_billing_country_id bigint, arg_billing_postal_code character varying, arg_tax_class text, arg_tax_id character varying, arg_payment_to text, arg_website_url character varying, arg_login_name character varying, arg_password character, arg_challenge_question text, arg_challenge_answer text, arg_security_code text, arg_title character varying DEFAULT NULL::character varying, arg_account_address_2 character varying DEFAULT NULL::character varying, arg_fax character varying DEFAULT NULL::character varying, arg_messenger_name character varying DEFAULT NULL::character varying, arg_messenger_type bigint DEFAULT NULL::bigint, arg_billing_address_2 character varying DEFAULT NULL::character varying, arg_site_category text DEFAULT NULL::text, arg_how_you_market text DEFAULT NULL::text, arg_comments text DEFAULT NULL::text, arg_parent_publisher_id bigint DEFAULT NULL::bigint, arg_referrer_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        INSERT INTO publisher_signup
            (first_name, last_name, title, account_address_1, account_address_2, account_city_name, account_city_id, account_region_id, account_country_id, account_postal_code,
                primary_phone, fax, email, messenger_name, messenger_type, company_name, billing_address_1, billing_address_2, billing_city_name, billing_city_id, billing_region_id,
                billing_country_id, billing_postal_code, tax_class, tax_id, payment_to, website_url, site_category, how_you_market, comments, login_name, password,
                challenge_question, challenge_answer, security_code, status, publisher_id, parent_publisher_id, referrer_id, created, modified)
            VALUES (arg_first_name, arg_last_name, arg_title, arg_account_address_1, arg_account_address_2, arg_account_city_name, arg_account_city_id, arg_account_region_id,
                arg_account_country_id, arg_account_postal_code, arg_primary_phone, arg_fax, arg_email, arg_messenger_name, arg_messenger_type, arg_company_name,
                arg_billing_address_1, arg_billing_address_2, arg_billing_city_name, arg_billing_city_id, arg_billing_region_id, arg_billing_country_id, arg_billing_postal_code,
                arg_tax_class, arg_tax_id, arg_payment_to, arg_website_url, arg_site_category, arg_how_you_market, arg_comments, arg_login_name, arg_password,
                arg_challenge_question, arg_challenge_answer, arg_security_code, 'unconfirmed', null, arg_parent_publisher_id, arg_referrer_id, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.publisher_requests_create(arg_first_name character varying, arg_last_name character varying, arg_company_name character varying, arg_email character varying, arg_account_address_1 character varying, arg_account_city_name character varying, arg_account_city_id bigint, arg_account_region_id bigint, arg_account_country_id bigint, arg_account_postal_code character varying, arg_primary_phone character varying, arg_billing_address_1 character varying, arg_billing_city_name character varying, arg_billing_city_id bigint, arg_billing_region_id bigint, arg_billing_country_id bigint, arg_billing_postal_code character varying, arg_tax_class text, arg_tax_id character varying, arg_payment_to text, arg_website_url character varying, arg_login_name character varying, arg_password character, arg_challenge_question text, arg_challenge_answer text, arg_security_code text, arg_title character varying, arg_account_address_2 character varying, arg_fax character varying, arg_messenger_name character varying, arg_messenger_type bigint, arg_billing_address_2 character varying, arg_site_category text, arg_how_you_market text, arg_comments text, arg_parent_publisher_id bigint, arg_referrer_id bigint) OWNER TO w4;

--
-- Name: publisher_requests_get(public.status_publisher, text, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_requests_get(arg_status public.status_publisher DEFAULT NULL::public.status_publisher, arg_search_publisher text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN

            IF arg_count THEN
                SELECT INTO count_total COALESCE (publisher_requests_get_count(arg_status, arg_search_publisher, arg_min_date, arg_max_date), 0);
            ELSE
                count_total := -1;
            END IF;

            ret_val := 
            (
                    '{' || 
                            '"results": ' || publisher_requests_get_list(arg_search_publisher, arg_status, arg_min_date, arg_max_date, null, null, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;

            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.publisher_requests_get(arg_status public.status_publisher, arg_search_publisher text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: publisher_requests_get_count(public.status_publisher, text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_requests_get_count(arg_status public.status_publisher DEFAULT NULL::public.status_publisher, arg_search_publisher text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';
        where_clause_user text := '';

    BEGIN
        where_clause := where_clause_build(arg_status::TEXT, 'status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'publisher_id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'modified >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'modified < $$' || arg_max_date || '$$', where_clause);

        where_clause_user := where_clause_build(arg_status::TEXT, 'u.active = $$' || arg_status || '$$', where_clause_user);
        where_clause_user := where_clause_build(arg_search_publisher::TEXT, 'u.id = ' || arg_search_publisher, where_clause_user);
        where_clause_user := where_clause_build(arg_min_date::TEXT, 'u.modified >= $$' || arg_min_date || '$$', where_clause_user);
        where_clause_user := where_clause_build(arg_max_date::TEXT, 'u.modified < $$' || arg_max_date || '$$', where_clause_user);
        where_clause_user := where_clause_build('publisher', 'u.access = $$publisher$$'  , where_clause_user);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0) FROM (
                    SELECT
                        id signup_id,
                        COALESCE (company_name, CONCAT (first_name, CHR(1), last_name)) AS publisher_name,
                        created AS created_date,
                        status::text,
                        publisher_id
                    FROM publisher_signup '                                
                    || where_clause || '
                    UNION SELECT
                        NULL AS signup_id,
                        COALESCE (up.company_name, CONCAT (cp.first_name, CHR(1), cp.last_name)) AS publisher_name,
                        u.created AS created_date,
                        u.active AS status,
                        u.id AS publisher_id
                    FROM users u
                    LEFT JOIN contacts cp ON cp.id = u.primary_contact_id
                    LEFT JOIN user_profiles up ON up.user_id = u.id
                    LEFT JOIN users mgr ON mgr.id = u.manager_id
                    LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                    LEFT JOIN user_profiles mup ON mup.user_id = mgr.id '                                
                    || where_clause_user || '
                ) AS the_count;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_requests_get_count(arg_status public.status_publisher, arg_search_publisher text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: publisher_requests_get_list(text, public.status_publisher, timestamp with time zone, timestamp with time zone, bigint, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_requests_get_list(arg_search_publisher text DEFAULT NULL::text, arg_status public.status_publisher DEFAULT NULL::public.status_publisher, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_signup_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        where_clause_user text := '';
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_status::TEXT, 'status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'publisher_id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'modified >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'modified < $$' || arg_max_date || '$$', where_clause);

        where_clause_user := where_clause_build(arg_status::TEXT, 'u.active = $$' || arg_status || '$$', where_clause_user);
        where_clause_user := where_clause_build(arg_search_publisher::TEXT, 'u.id = ' || arg_search_publisher, where_clause_user);
        where_clause_user := where_clause_build(arg_min_date::TEXT, 'u.modified >= $$' || arg_min_date || '$$', where_clause_user);
        where_clause_user := where_clause_build(arg_max_date::TEXT, 'u.modified < $$' || arg_max_date || '$$', where_clause_user);
        where_clause_user := where_clause_build('publisher', 'u.access = $$publisher$$'  , where_clause_user);

        order_clause := order_clause_build(arg_orderby, 'publisher_name');

       EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    id signup_id,
                                    COALESCE (company_name, CONCAT (first_name, CHR(1), last_name)) AS publisher_name,
                                    created AS created_date,
                                    status::text,
                                    publisher_id,
                                    modified AS modified_date,
                                    NULL AS manager_id,
                                    NULL AS manager_name
                                FROM publisher_signup '                                
                                || where_clause || '
                                UNION SELECT
                                    NULL AS signup_id,
                                    COALESCE (up.company_name, CONCAT (cp.first_name, CHR(1), cp.last_name)) AS publisher_name,
                                    u.created AS created_date,
                                    u.active AS status,
                                    u.id AS publisher_id,
                                    u.modified AS modified_date,
                                    u.manager_id,
                                    CONCAT (COALESCE(mcon.first_name, mup.first_name), '' '', COALESCE(mcon.last_name, mup.last_name)) AS manager_name
                                FROM users u
                                LEFT JOIN contacts cp ON cp.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users mgr ON mgr.id = u.manager_id
                                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                                LEFT JOIN user_profiles mup ON mup.user_id = mgr.id '                                
                                || where_clause_user
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_requests_get_list(arg_search_publisher text, arg_status public.status_publisher, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_signup_id bigint, arg_publisher_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_requests_update(public.status_publisher, bigint, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_requests_update(arg_status public.status_publisher, arg_signup_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_manager_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ps record;
        pub_id bigint;
        var_account_country_name text;
        var_account_region_name text;
        var_billing_country_name text;
        var_billing_region_name text;
        primary_contact_id bigint;
        account_contact_id bigint;
        billing_contact_id bigint;
        next_id bigint;
        vuuid text;
    BEGIN
        IF (arg_signup_id IS NOT NULL) THEN
            SELECT
                first_name,
                last_name,
                account_address_1,
                account_address_2,
                account_city_name,
                account_city_id,
                account_region_id,
                account_country_id,
                account_postal_code,
                primary_phone,
                fax,
                email,
                messenger_name,
                messenger_type,
                company_name,
                billing_address_1,
                billing_address_2,
                billing_city_name,
                billing_city_id,
                billing_region_id,
                billing_country_id,
                billing_postal_code,
                tax_class,
                tax_id,
                payment_to,
                website_url,
                login_name,    
                password,
                parent_publisher_id,
                referrer_id
            FROM publisher_signup
            WHERE id = arg_signup_id
            INTO ps;

            IF NOT FOUND THEN
                RAISE EXCEPTION 'Unable to find the specified publisher id (%) in the publisher signup table.', arg_signup_id;
            END IF;

            IF arg_status = 'active' THEN
		next_id := nextval( 'users_id_seq' );
		vuuid := uuid();

		PERFORM login_name FROM users WHERE login_name ILIKE ps.login_name;
		IF FOUND THEN
		    ps.login_name := CONCAT(ps.login_name,  next_id::text); --if login is taken then we approve it by appending the id to the username
		END IF;
 
		--gets region name for account
		SELECT ascii_name FROM geo_typeahead_region WHERE id = ps.account_region_id INTO var_account_region_name;
		
		--gets region name for billing
		SELECT ascii_name FROM geo_typeahead_region WHERE id = ps.billing_region_id INTO var_billing_region_name;

		--gets country name for account
		SELECT country FROM geo_typeahead_countries WHERE id = ps.account_city_id INTO var_account_country_name;
		
		--gets country name for billing
		SELECT country FROM geo_typeahead_countries WHERE id = ps.billing_city_id INTO var_billing_country_name;

		
		billing_contact_id := create_contact( ps.company_name, '', ps.billing_address_1, ps.billing_address_2, ps.billing_country_id, ps.billing_region_id, ps.billing_city_id, ps.billing_city_name, ps.billing_postal_code, '', null, '', '', '', '' );
		account_contact_id := create_contact( ps.company_name, '', ps.account_address_1, ps.account_address_2, ps.account_country_id, ps.account_region_id, ps.account_city_id, ps.account_city_name, ps.account_postal_code, '', null, '', '', '', '' );

		INSERT INTO users
		    (id, login_name, email, password, uuid, active, access, primary_contact_id, billing_contact_id, account_contact_id, manager_id, parent_id, modified, referrer_id)
		    VALUES (next_id,ps.login_name,ps.email,ps.password, vuuid, 'active', 'publisher', NULL::bigint, billing_contact_id, account_contact_id, arg_manager_id, ps.parent_publisher_id, CURRENT_TIMESTAMP, ps.referrer_id);
		    
		INSERT INTO user_profiles
		    (user_uuid, user_id, company_name, tax_id, website_url, first_name, last_name, address_1, address_2, city, state, region, zip, country, payment_address_1, payment_address_2,
			payment_city, payment_region, payment_postal_code, payment_country, created, modified, phone, cell, messenger_id, messenger_type, fax, contact_email)
		    VALUES (vuuid, next_id, ps.company_name, ps.tax_id, ps.website_url, ps.first_name, ps.last_name, ps.account_address_1, ps.account_address_2, ps.account_city_name, var_account_region_name, var_account_region_name,
			ps.account_postal_code, var_account_country_name, ps.billing_address_1, ps.billing_address_2, ps.billing_city_name, var_billing_region_name, ps.billing_postal_code, var_billing_country_name, now(), now(), ps.primary_phone,
			'', ps.messenger_name, ps.messenger_type, ps.fax, ps.email);

		primary_contact_id := id FROM create_publisher_contact(next_id, ps.first_name, ps.last_name, '', '', ps.account_country_id, ps.account_region_id, ps.account_city_id, '', '', ps.messenger_name, ps.messenger_type, ps.primary_phone, '', ps.fax, ps.email, true, false );
		pub_id := next_id;
            END IF;
            UPDATE publisher_signup SET status = arg_status, modified = CURRENT_TIMESTAMP, publisher_id = pub_id WHERE id = arg_signup_id;
        END IF;

        IF (arg_publisher_id IS NOT NULL) THEN
            UPDATE users SET active = arg_status, modified = CURRENT_TIMESTAMP, manager_id = arg_manager_id WHERE id = arg_publisher_id;
        END IF;

        RETURN publisher_requests_update_get(COALESCE(pub_id,arg_publisher_id), arg_signup_id);
    END;
$$;


ALTER FUNCTION w4api.publisher_requests_update(arg_status public.status_publisher, arg_signup_id bigint, arg_publisher_id bigint, arg_manager_id bigint) OWNER TO w4;

--
-- Name: publisher_requests_update_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_requests_update_get(arg_pub_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;

    BEGIN

       SELECT
            array_to_json (array_agg(row_to_json (results)))
                FROM (
                    SELECT row_to_json (row)
                        FROM (
                            SELECT
                                NULL AS signup_id,
                                COALESCE (up.company_name, CONCAT (cp.first_name, CHR(1), cp.last_name)) AS publisher_name,
                                u.created AS created_date,
                                u.active AS status,
                                u.id AS publisher_id
                            FROM users u
                            LEFT JOIN contacts cp ON cp.id = u.primary_contact_id
                            LEFT JOIN user_profiles up ON up.user_id = u.id
                            WHERE u.id = arg_pub_id
                        ) row
                ) results
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.publisher_requests_update_get(arg_pub_id bigint) OWNER TO w4;

--
-- Name: publisher_requests_update_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_requests_update_get(arg_pub_id bigint DEFAULT NULL::bigint, arg_signup_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;

    BEGIN        
        IF (arg_pub_id IS NOT NULL) THEN 
            SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    NULL AS signup_id,
                                    COALESCE (up.company_name, CONCAT (cp.first_name, CHR(1), cp.last_name)) AS publisher_name,
                                    u.created AS created_date,
                                    u.active AS status,
                                    u.id AS publisher_id,
                                    u.modified AS modified_date,
                                    u.manager_id AS manager_id,
                                    CONCAT (COALESCE(mcon.first_name, mup.first_name), ' ', COALESCE(mcon.last_name, mup.last_name)) AS manager_name                                    
                                FROM users u
                                LEFT JOIN contacts cp ON cp.id = u.primary_contact_id
                                LEFT JOIN user_profiles up ON up.user_id = u.id
                                LEFT JOIN users mgr ON mgr.id = u.manager_id
                                LEFT JOIN contacts mcon ON mcon.id = mgr.primary_contact_id
                                LEFT JOIN user_profiles mup ON mup.user_id = mgr.id
                                WHERE u.id = arg_pub_id
                        ) row
                ) results
            INTO ret_val;
            RETURN ret_val; 
        ELSE
            SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    id signup_id,
                                    COALESCE (company_name, CONCAT (first_name, CHR(1), last_name)) AS publisher_name,
                                    created AS created_date,
                                    status::text,
                                    publisher_id,
                                    modified AS modified_date
                                FROM publisher_signup
                                WHERE id = arg_signup_id
                        ) row
                ) results
            INTO ret_val;
            RETURN ret_val;       
        END IF;
    END
$$;


ALTER FUNCTION w4api.publisher_requests_update_get(arg_pub_id bigint, arg_signup_id bigint) OWNER TO w4;

--
-- Name: publisher_traffic_get(bigint, text, timestamp with time zone, timestamp with time zone, text, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, bigint, bigint, text, bigint, bigint, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_traffic_get(arg_publisher_id bigint DEFAULT NULL::bigint, arg_search_publisher text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_total_in_min numeric DEFAULT NULL::numeric, arg_total_in_max numeric DEFAULT NULL::numeric, arg_total_out_min numeric DEFAULT NULL::numeric, arg_total_out_max numeric DEFAULT NULL::numeric, arg_average_in_min numeric DEFAULT NULL::numeric, arg_average_in_max numeric DEFAULT NULL::numeric, arg_average_out_min numeric DEFAULT NULL::numeric, arg_average_out_max numeric DEFAULT NULL::numeric, arg_manager_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean, arg_summary boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
        summary json;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (publisher_traffic_get_count(arg_publisher_id, arg_search_publisher, arg_min_date, arg_max_date, arg_status, arg_conversion_percent_min,
                arg_conversion_percent_max, arg_profit_percent_min, arg_profit_percent_max, arg_total_in_min, arg_total_in_max, arg_total_out_min, arg_total_out_max,
                arg_average_in_min, arg_average_in_max, arg_average_out_min, arg_average_out_max, arg_manager_id, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        IF arg_summary THEN
            summary := publisher_traffic_get_summary(arg_publisher_id, arg_search_publisher, arg_min_date, arg_max_date, arg_status, arg_conversion_percent_min,
                arg_conversion_percent_max, arg_profit_percent_min, arg_profit_percent_max, arg_total_in_min, arg_total_in_max, arg_total_out_min, arg_total_out_max,
                arg_average_in_min, arg_average_in_max, arg_average_out_min, arg_average_out_max, arg_manager_id, arg_currency_id);
        ELSE
            summary := '{}';
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || publisher_traffic_get_list(arg_publisher_id, arg_search_publisher, arg_min_date, arg_max_date, arg_status, arg_conversion_percent_min,
                arg_conversion_percent_max, arg_profit_percent_min, arg_profit_percent_max, arg_total_in_min, arg_total_in_max, arg_total_out_min, arg_total_out_max,
                arg_average_in_min, arg_average_in_max, arg_average_out_min, arg_average_out_max, arg_manager_id, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "summary": ' || summary ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.publisher_traffic_get(arg_publisher_id bigint, arg_search_publisher text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_total_in_min numeric, arg_total_in_max numeric, arg_total_out_min numeric, arg_total_out_max numeric, arg_average_in_min numeric, arg_average_in_max numeric, arg_average_out_min numeric, arg_average_out_max numeric, arg_manager_id bigint, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_summary boolean) OWNER TO w4;

--
-- Name: publisher_traffic_get_count(bigint, text, timestamp with time zone, timestamp with time zone, text, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_traffic_get_count(arg_publisher_id bigint DEFAULT NULL::bigint, arg_search_publisher text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_total_in_min numeric DEFAULT NULL::numeric, arg_total_in_max numeric DEFAULT NULL::numeric, arg_total_out_min numeric DEFAULT NULL::numeric, arg_total_out_max numeric DEFAULT NULL::numeric, arg_average_in_min numeric DEFAULT NULL::numeric, arg_average_in_max numeric DEFAULT NULL::numeric, arg_average_out_min numeric DEFAULT NULL::numeric, arg_average_out_max numeric DEFAULT NULL::numeric, arg_manager_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        having_clause text := '';
        join_clause_rcrd text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pusr.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build('publisher', 'pusr.access = $$publisher$$', where_clause);
        where_clause := where_clause_build('moreThanZero', '(rcrd.total_clicks > 0 OR rcrd.total_conversions > 0)', where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'pusr.id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'pusr.active = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'pusr.manager_id = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        having_clause := having_clause_build(arg_conversion_percent_min::TEXT, 'COALESCE( sum(rcrd.total_conversions) / NULLIF( sum( rcrd.unique_clicks), 0 ) * 100, 0 ) BETWEEN ' || arg_conversion_percent_min || ' AND ' || arg_conversion_percent_max, having_clause);
        having_clause := having_clause_build(arg_profit_percent_min::TEXT, 'COALESCE( 100 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ) * 100, 0 ) BETWEEN ' || arg_profit_percent_min || ' AND ' || arg_profit_percent_max, having_clause);
        having_clause := having_clause_build(arg_total_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in), 0) BETWEEN ' || arg_total_in_min || ' AND ' || arg_total_in_max, having_clause);
        having_clause := having_clause_build(arg_total_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out), 0) BETWEEN ' || arg_total_out_min || ' AND ' || arg_total_out_max, having_clause);
        having_clause := having_clause_build(arg_average_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_in_min || ' AND ' || arg_average_in_max, having_clause);
        having_clause := having_clause_build(arg_average_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out ) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_out_min || ' AND ' || arg_average_out_max, having_clause);

        IF (arg_min_date IS NOT NULL) THEN
            join_clause_rcrd := ' AND rcrd.doy >= ' || min_doy || ' AND rcrd.doy < ' || max_doy;
        END IF;

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    pusr.id AS publisher_id,
                    max(pusr.active) AS status,
                    COALESCE(max(pup.company_name::text), concat(max(pup.first_name::text), $$ $$, max(pup.last_name::text))) AS publisher_name, 
                    max(pusr.manager_id) AS manager, 
                    max(vpg.groups) AS publisher_groups,
                    sum(rcrd.total_conversions) AS conversions, 
                    sum(rcrd.total_clicks) AS total_clicks, 
                    sum(rcrd.unique_clicks) AS unique_clicks, 
                    sum(rcrd.total_pay_in) AS total_in, 
                    sum(rcrd.total_pay_out) AS total_out, 
                    sum(rcrd.profit) AS total_profit,
                    (sum(rcrd.total_conversions) / NULLIF(sum(rcrd.unique_clicks), 0)) * 100 AS conversion_pct,
                    COALESCE( 100 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ) * 100, 0 ) AS profit_percent,
                    COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) AS average_in,
                    COALESCE( sum(rcrd.total_pay_out ) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) AS average_out,
                    COALESCE( sum(rcrd.total_pay_out) / NULLIF( sum(rcrd.unique_clicks), 0 ), 0 ) AS epc
                FROM users pusr
                LEFT JOIN user_profiles pup ON (pusr.id = pup.user_id)
                LEFT JOIN reports_daily rcrd ON pusr.id = rcrd.publisher_id  ' || join_clause_rcrd || '
                LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id
                LEFT JOIN vw_publisher_groups vpg ON pusr.id = vpg.publisher_id '
                || where_clause || '
                GROUP BY pusr.id '
                || having_clause || '
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.publisher_traffic_get_count(arg_publisher_id bigint, arg_search_publisher text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_total_in_min numeric, arg_total_in_max numeric, arg_total_out_min numeric, arg_total_out_max numeric, arg_average_in_min numeric, arg_average_in_max numeric, arg_average_out_min numeric, arg_average_out_max numeric, arg_manager_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: publisher_traffic_get_list(bigint, text, timestamp with time zone, timestamp with time zone, text, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, bigint, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_traffic_get_list(arg_publisher_id bigint DEFAULT NULL::bigint, arg_search_publisher text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_total_in_min numeric DEFAULT NULL::numeric, arg_total_in_max numeric DEFAULT NULL::numeric, arg_total_out_min numeric DEFAULT NULL::numeric, arg_total_out_max numeric DEFAULT NULL::numeric, arg_average_in_min numeric DEFAULT NULL::numeric, arg_average_in_max numeric DEFAULT NULL::numeric, arg_average_out_min numeric DEFAULT NULL::numeric, arg_average_out_max numeric DEFAULT NULL::numeric, arg_manager_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        having_clause text := '';
        join_clause_rcrd text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pusr.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build('publisher', 'pusr.access = $$publisher$$', where_clause);
        where_clause := where_clause_build('moreThanZero', '(rcrd.total_clicks > 0 OR rcrd.total_conversions > 0)', where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'pusr.id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'pusr.active = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'pusr.manager_id = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        having_clause := having_clause_build(arg_conversion_percent_min::TEXT, 'COALESCE( sum(rcrd.total_conversions) / NULLIF( sum( rcrd.unique_clicks), 0 ) * 100, 0 ) BETWEEN ' || arg_conversion_percent_min || ' AND ' || arg_conversion_percent_max, having_clause);
        having_clause := having_clause_build(arg_profit_percent_min::TEXT, 'COALESCE( 100 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ) * 100, 0 ) BETWEEN ' || arg_profit_percent_min || ' AND ' || arg_profit_percent_max, having_clause);
        having_clause := having_clause_build(arg_total_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in), 0) BETWEEN ' || arg_total_in_min || ' AND ' || arg_total_in_max, having_clause);
        having_clause := having_clause_build(arg_total_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out), 0) BETWEEN ' || arg_total_out_min || ' AND ' || arg_total_out_max, having_clause);
        having_clause := having_clause_build(arg_average_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_in_min || ' AND ' || arg_average_in_max, having_clause);
        having_clause := having_clause_build(arg_average_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out ) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_out_min || ' AND ' || arg_average_out_max, having_clause);

        order_clause := order_clause_build(arg_orderby, 'publisher_name ASC');

        IF (arg_min_date IS NOT NULL) THEN
            join_clause_rcrd := ' AND rcrd.doy >= ' || min_doy || ' AND rcrd.doy < ' || max_doy;
        END IF;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    pusr.id AS publisher_id,
                                    max(pusr.active) AS status,
                                    COALESCE(max(pup.company_name::text), concat(max(pup.first_name::text), $$ $$, max(pup.last_name::text))) AS publisher_name, 
                                    max(pusr.manager_id) AS manager, 
                                    max(vpg.groups) AS publisher_groups,
                                    sum(rcrd.total_conversions) AS conversions, 
                                    sum(rcrd.total_clicks) AS total_clicks, 
                                    sum(rcrd.unique_clicks) AS unique_clicks, 
                                    sum(rcrd.total_pay_in) AS total_in, 
                                    sum(rcrd.total_pay_out) AS total_out, 
                                    sum(rcrd.profit) AS total_profit,
                                    ROUND(COALESCE( sum(rcrd.total_conversions) / NULLIF(sum(rcrd.unique_clicks), 0), 0)::numeric, 4) AS conversion_pct,
                                    ROUND(COALESCE( 1 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ), 0 )::numeric, 4) AS profit_percent,
                                    COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) AS average_in,
                                    COALESCE( sum(rcrd.total_pay_out ) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) AS average_out,
                                    COALESCE( sum(rcrd.total_pay_out) / NULLIF( sum(rcrd.unique_clicks), 0 ), 0 ) AS epc
                                FROM users pusr
                                LEFT JOIN user_profiles pup ON (pusr.id = pup.user_id)
                                LEFT JOIN reports_daily rcrd ON pusr.id = rcrd.publisher_id  ' || join_clause_rcrd || '
                                LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id
                                LEFT JOIN vw_publisher_groups vpg ON pusr.id = vpg.publisher_id '
                                || where_clause || '
                                GROUP BY pusr.id '
                                || having_clause ||
                                order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;

        RETURN COALESCE(ret_val, '{}');
    END
$_$;


ALTER FUNCTION w4api.publisher_traffic_get_list(arg_publisher_id bigint, arg_search_publisher text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_total_in_min numeric, arg_total_in_max numeric, arg_total_out_min numeric, arg_total_out_max numeric, arg_average_in_min numeric, arg_average_in_max numeric, arg_average_out_min numeric, arg_average_out_max numeric, arg_manager_id bigint, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: publisher_traffic_get_summary(bigint, text, timestamp with time zone, timestamp with time zone, text, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION publisher_traffic_get_summary(arg_publisher_id bigint DEFAULT NULL::bigint, arg_search_publisher text DEFAULT NULL::text, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_status text DEFAULT NULL::text, arg_conversion_percent_min numeric DEFAULT NULL::numeric, arg_conversion_percent_max numeric DEFAULT NULL::numeric, arg_profit_percent_min numeric DEFAULT NULL::numeric, arg_profit_percent_max numeric DEFAULT NULL::numeric, arg_total_in_min numeric DEFAULT NULL::numeric, arg_total_in_max numeric DEFAULT NULL::numeric, arg_total_out_min numeric DEFAULT NULL::numeric, arg_total_out_max numeric DEFAULT NULL::numeric, arg_average_in_min numeric DEFAULT NULL::numeric, arg_average_in_max numeric DEFAULT NULL::numeric, arg_average_out_min numeric DEFAULT NULL::numeric, arg_average_out_max numeric DEFAULT NULL::numeric, arg_manager_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        having_clause text := '';
        join_clause_rcrd text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'pusr.id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build('publisher', 'pusr.access = $$publisher$$', where_clause);
        where_clause := where_clause_build(arg_search_publisher::TEXT, 'pusr.id = ' || arg_search_publisher, where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'pusr.active = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_manager_id::TEXT, 'pusr.manager_id = ' || arg_manager_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        having_clause := having_clause_build(arg_conversion_percent_min::TEXT, 'COALESCE( sum(rcrd.total_conversions) / NULLIF( sum( rcrd.unique_clicks), 0 ) * 100, 0 ) BETWEEN ' || arg_conversion_percent_min || ' AND ' || arg_conversion_percent_max, having_clause);
        having_clause := having_clause_build(arg_profit_percent_min::TEXT, 'COALESCE( 100 - sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0 ) * 100, 0 ) BETWEEN ' || arg_profit_percent_min || ' AND ' || arg_profit_percent_max, having_clause);
        having_clause := having_clause_build(arg_total_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in), 0) BETWEEN ' || arg_total_in_min || ' AND ' || arg_total_in_max, having_clause);
        having_clause := having_clause_build(arg_total_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out), 0) BETWEEN ' || arg_total_out_min || ' AND ' || arg_total_out_max, having_clause);
        having_clause := having_clause_build(arg_average_in_min::TEXT, 'COALESCE( sum(rcrd.total_pay_in) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_in_min || ' AND ' || arg_average_in_max, having_clause);
        having_clause := having_clause_build(arg_average_out_min::TEXT, 'COALESCE( sum(rcrd.total_pay_out ) / NULLIF( sum(rcrd.total_conversions), 0 ), 0 ) BETWEEN ' || arg_average_out_min || ' AND ' || arg_average_out_max, having_clause);

        IF (arg_min_date IS NOT NULL) THEN
            join_clause_rcrd := ' AND rcrd.doy >= ' || min_doy || ' AND rcrd.doy < ' || max_doy;
        END IF;

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    COALESCE( sum(rcrd.total_conversions), 0) AS conversions, 
                                    COALESCE( sum(rcrd.unique_clicks), 0) AS clicks,
                                    COALESCE( sum(rcrd.total_clicks), 0) AS total_clicks,
                                    ROUND(COALESCE( sum(rcrd.total_conversions) / NULLIF(sum(rcrd.unique_clicks), 0), 0)::numeric, 4) AS rate,
                                    COALESCE( sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.unique_clicks), 0), 0) AS epc,
                                    COALESCE( sum(rcrd.total_pay_out), 0) AS revenue,
                                    ROUND(COALESCE( 1- sum(rcrd.total_pay_out) / NULLIF(sum(rcrd.total_pay_in), 0), 0)::numeric, 4) AS margin,
                                    COALESCE( sum(rcrd.total_pay_in - rcrd.total_pay_out), 0) AS profit
                                FROM users pusr
                                LEFT JOIN user_profiles pup ON (pusr.id = pup.user_id)
                                LEFT JOIN reports_daily rcrd ON pusr.id = rcrd.publisher_id ' || join_clause_rcrd || '
                                LEFT JOIN campaigns cmp ON rcrd.campaign_id = cmp.id
                                LEFT JOIN vw_publisher_groups vpg ON pusr.id = vpg.publisher_id '
                                || where_clause
                                || having_clause || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.publisher_traffic_get_summary(arg_publisher_id bigint, arg_search_publisher text, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_status text, arg_conversion_percent_min numeric, arg_conversion_percent_max numeric, arg_profit_percent_min numeric, arg_profit_percent_max numeric, arg_total_in_min numeric, arg_total_in_max numeric, arg_total_out_min numeric, arg_total_out_max numeric, arg_average_in_min numeric, arg_average_in_max numeric, arg_average_out_min numeric, arg_average_out_max numeric, arg_manager_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_available_check(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_available_check(arg_campaign_id bigint, arg_publisher_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
            DECLARE
            var_valid_pub text := false;
            var_valid_campaign text := false;
            BEGIN

            ---- check if publisher/campaign/advertiser are active
            PERFORM * from users WHERE id = arg_publisher_id AND (active = 'active' OR active = 'suspended') ;
            IF( NOT FOUND)THEN 
                RETURN FALSE; --- publisher NOT active
            END IF;
            PERFORM * FROM campaigns cmp 
                LEFT JOIN advertisers adv ON cmp.advertiser_id = adv.id 
                LEFT JOIN campaign_assigned_publishers cap ON cap.campaign_id = cmp.id    AND cap.publisher_id=arg_publisher_id         
                WHERE adv.status = 'active' 
                AND (cmp.status = 'active' OR cmp.status = 'paused')                
                AND (
                    (cmp.access_type<>2 AND (cap.status='approved' OR cap.status='pending' OR cap.status IS NULL)) --- campaign is not private and publisher has not been banned or denied
                        OR 
                    (cmp.access_type=2 AND cap.status='approved') --- campaign is private and publisher was approved
                     )
                AND (cmp.expiry_date IS NULL OR cmp.expiry_date > now() )  ---  campaign not expired
                AND cmp.id = arg_campaign_id;
            IF( NOT FOUND)THEN 
                RETURN FALSE; --- campaign NOT active OR advertiser running the campaign is NOT active
            END IF;


            ----  check if publisher is banned by campaign advertiser completely (globally or on all sub ids)    
            PERFORM abp.id,abp.campaign_id  FROM advertiser_banned_publishers abp 
                LEFT JOIN campaigns cmp ON cmp.advertiser_id = abp.advertiser_id 
                    WHERE abp.publisher_id = arg_publisher_id 
                         AND cmp.advertiser_id =  abp.advertiser_id 
                         AND abp.status = 'active'  --- ban is in effect
                         AND cmp.id = arg_campaign_id 
                         AND abp.campaign_id IS NULL
                         AND (((abp.sub_id_1 <>'') AND (abp.sub_id_2 <>'') AND (abp.sub_id_3 <>'') AND (abp.sub_id_4 <>''))  --- banned on all subids
                            OR((abp.sub_id_1 ='') AND (abp.sub_id_2 ='') AND (abp.sub_id_3 ='') AND (abp.sub_id_4 ='')));  --- banned on global
            IF(FOUND)THEN 
                RETURN FALSE; --- publisher/advertiser combo is invalid
            END IF;
            
            ---- check if publisher is banned for this campaign specifically (globally or on all sub ids)
            PERFORM abp.id,abp.campaign_id  FROM advertiser_banned_publishers abp 
                    WHERE abp.publisher_id = arg_publisher_id 
                        AND abp.campaign_id = arg_campaign_id  
                        AND abp.status = 'active'  --- ban is in effect
                        AND (((abp.sub_id_1 <>'') AND (abp.sub_id_2 <>'') AND (abp.sub_id_3 <>'') AND (abp.sub_id_4 <>''))  --- banned on all subids
                            OR((abp.sub_id_1 ='') AND (abp.sub_id_2 ='') AND (abp.sub_id_3 ='') AND (abp.sub_id_4 ='')));  --- banned on global
            IF(FOUND)THEN 
                RETURN FALSE; --- publisher/campaign combo is invalid
            END IF; 
                  
            RETURN TRUE; --- publisher/campaign combo is valid
            END
        $$;


ALTER FUNCTION w4api.pubs_campaign_available_check(arg_campaign_id bigint, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_available_get(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_available_get(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false, arg_new_only boolean DEFAULT NULL::boolean, arg_recommendations_only boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
        DECLARE
        retval json;
        BEGIN
        retval := (
               '{"results": ' || (SELECT COALESCE(
                        (w4api.pubs_campaign_available_get_list(                                    
                                        arg_publisher_id:=arg_publisher_id, 
                                        arg_channel_ids_json:= arg_channel_ids_json, 
                                        arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                        arg_category_ids_json:= arg_category_ids_json, 
                                        arg_geos_ids_json:=arg_geos_ids_json, 
                                        arg_traffic_search:=arg_traffic_search,
                                        arg_currency_id:=arg_currency_id, 
                                        arg_payout_min:=arg_payout_min, 
                                        arg_payout_max:=arg_payout_max,
                                        arg_min_date:=arg_min_date, 
                                        arg_max_date:=arg_max_date,
                                        arg_orderby:=arg_orderby, 
                                        arg_limit:=arg_limit, 
                                        arg_offset:=arg_offset,
                                        arg_new_only:=arg_new_only,
                                        arg_recommendations_only := arg_recommendations_only
                                        )
                        ),'[]' 
                        )
                  )::text
                || ', "count": ' || (SELECT COALESCE(
                            (w4api.pubs_campaign_available_get_list(
                                        arg_publisher_id:=arg_publisher_id, 
                                        arg_channel_ids_json:= arg_channel_ids_json, 
                                        arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                        arg_category_ids_json:= arg_category_ids_json, 
                                        arg_geos_ids_json:=arg_geos_ids_json, 
                                        arg_traffic_search:=arg_traffic_search,
                                        arg_currency_id:=arg_currency_id,
                                        arg_payout_min:=arg_payout_min, 
                                        arg_payout_max:=arg_payout_min,
                                        arg_min_date:=arg_min_date, 
                                        arg_max_date:=arg_max_date,
                                        arg_count:= TRUE,
                                        arg_new_only:=arg_new_only,
                                        arg_recommendations_only := arg_recommendations_only
                                           )), '0')
                            )::text
                || '}'
            )::json;

        RETURN retval;
        END
    $$;


ALTER FUNCTION w4api.pubs_campaign_available_get(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_new_only boolean, arg_recommendations_only boolean) OWNER TO w4;

--
-- Name: pubs_campaign_available_get_count(bigint, json, json, json, json, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_available_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];

    BEGIN
        channel_ids  := json_array_convert( arg_channel_ids_json  )::bigint[];
        category_ids := json_array_convert( arg_category_ids_json )::bigint[];
        pays_on_ids  := json_array_convert( arg_pays_on_ids_json  )::bigint[];
        geos_ids     := json_array_convert( arg_geos_ids_json  )::text[];

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    cmp."name" AS campaign_name,
                    cmp.id AS campaign_id,
                    COALESCE( p.override_payout, cmp.default_payout )	AS payout,
                    pays_on_friendly_name( cmp.payout_model_id ) AS pays_on,
                    geos_json( cmp.id )::text AS geos_json,
                    categories_json( cmp.id ) AS categories,
                    channels_json( cmp.id ) AS channels,
                    categories_ids_json( cmp.id ) AS categories_ids,
                    channels_ids_json( cmp.id ) AS channel_ids,
                    return_geo_ids_json( cmp.id ) AS country_ids,
                    to_char( cmp.expiry_date, ''Month DD, YYYY'' ) AS expires,
                    cmp.description AS campaign_description,
                    CASE cmp.access_type
                        WHEN 1 THEN ''public''
                        WHEN 2 THEN ''approved''
                        WHEN 3 THEN COALESCE(p.status::text,''request'')
                    END	AS approval_status,
                    CASE WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE ELSE FALSE END AS is_new
                FROM campaigns cmp
                LEFT JOIN
                (
                    SELECT po.*,cap.status, cap.publisher_id AS pub_id, COALESCE(po.campaign_id,cap.campaign_id) AS cid
                    FROM publisher_overrides po
                    FULL JOIN campaign_assigned_publishers cap
                        ON po.publisher_id=cap.publisher_id
                        AND po.campaign_id=cap.campaign_id
                    WHERE (po.effective_date  < NOW() OR po.effective_date IS NULL) AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL) AND (cap.publisher_id=$1 OR po.publisher_id=$1)
                ) p ON p.cid=cmp.id
                WHERE
                    (((cmp.access_type<>2 AND p.status<>''denied'') OR (cmp.access_type<>2 AND p.status IS NULL)) OR (cmp.access_type=2 AND p.status=''approved'')) AND
                    cmp.status = ''active'' AND 
                        ( cmp.expiry_date IS NULL OR cmp.expiry_date > now() ) AND
                        ( $2 = ''{}'' OR check_channels( cmp.id,   $2 ) > 0 ) AND
                        ( $3 = ''{}'' OR check_categories( cmp.id, $3 ) > 0 ) AND
                        ( $4 = ''{}'' OR check_geos( cmp.id,       $4 ) > 0 ) AND
                        ( $5 = ''{}'' OR check_pays_on( cmp.id,    $5 ) > 0 ) AND
                        ( $6 IS NULL  OR cmp.currency_id = $6 ) AND
                        ( $7 IS NULL  OR matches(cmp.name, $7) )
            ) AS the_count '
        INTO retval
        USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_currency_id, arg_traffic_search;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.pubs_campaign_available_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_available_get_count(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_available_get_count(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
            BEGIN
            RETURN w4api.pubs_campaign_available_get_list(                                    
                                    arg_publisher_id:=arg_publisher_id, 
                                    arg_channel_ids_json:= arg_channel_ids_json, 
                                    arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                    arg_category_ids_json:= arg_category_ids_json, 
                                    arg_geos_ids_json:=arg_geos_ids_json, 
                                    arg_traffic_search:=arg_traffic_search,
                                    arg_currency_id:=arg_currency_id,
                                    arg_payout_min:=arg_payout_min, 
                                    arg_payout_max:=arg_payout_min,
                                    arg_min_date:=arg_min_date, 
                                    arg_max_date:=arg_max_date,
                                    arg_count:= TRUE
                                       );        
            END
        $$;


ALTER FUNCTION w4api.pubs_campaign_available_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: pubs_campaign_available_get_list(bigint, json, json, json, json, text, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_available_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        order_clause text;
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];

    BEGIN

        order_clause := order_clause_build(arg_orderby, 'campaign_id DESC');
        channel_ids  := json_array_convert( arg_channel_ids_json  )::bigint[];
        category_ids := json_array_convert( arg_category_ids_json )::bigint[];
        pays_on_ids  := json_array_convert( arg_pays_on_ids_json  )::bigint[];
        geos_ids     := json_array_convert( arg_geos_ids_json  )::text[];

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    cmp."name" AS campaign_name,
                                    cmp.id AS campaign_id,
                                    COALESCE( p.override_payout, cmp.default_payout )	AS payout,
                                    pays_on_friendly_name( cmp.payout_model_id ) AS pays_on,
                                    geos_json( cmp.id )::text AS geos_json,
                                    COALESCE(cca.category_names_json::text, ''[]'' )::json AS categories,
                                    COALESCE(cch.channel_names_json::text, ''[]'' )::json  AS channels,
                                    categories_ids_json( cmp.id ) AS categories_ids,
                                    channels_ids_json( cmp.id )::json AS channel_ids,
                                    return_geo_ids_json( cmp.id )::json AS country_ids,
                                    to_char( cmp.expiry_date, ''Month DD, YYYY'' ) AS expires,
                                    cmp.description AS campaign_description,
                                    cmp.payout_type AS payout_type,
                                    cmp.payin_type AS payin_type,
                                    CASE cmp.access_type
                                        WHEN 1 THEN ''public''
                                        WHEN 2 THEN ''approved''
                                        WHEN 3 THEN COALESCE(p.status::text,''request'')
                                    END	AS approval_status,
                                    CASE WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE ELSE FALSE END AS is_new
                                FROM campaigns cmp
                                LEFT JOIN
                                (
                                    SELECT po.*,cap.status, cap.publisher_id AS pub_id, COALESCE(po.campaign_id,cap.campaign_id) AS cid
                                    FROM publisher_overrides po
                                    FULL JOIN campaign_assigned_publishers cap
                                        ON po.publisher_id=cap.publisher_id
                                        AND po.campaign_id=cap.campaign_id
                                    WHERE (po.effective_date  < NOW() OR po.effective_date IS NULL)
                                        AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL)
                                        AND (cap.publisher_id=$1 OR po.publisher_id=$1)
                                ) p ON p.cid=cmp.id
				LEFT JOIN vw_campaign_categories_json cca ON cca.campaign_id = cmp.id
				LEFT JOIN vw_campaign_channels_json   cch ON cch.campaign_id = cmp.id
                                WHERE
                                    (((cmp.access_type<>2 AND p.status<>''denied'') OR (cmp.access_type<>2 AND p.status IS NULL)) OR (cmp.access_type=2 AND p.status=''approved'')) AND
                                    cmp.status = ''active'' AND 
                                        ( cmp.expiry_date IS NULL OR cmp.expiry_date > now() ) AND
                                        ( $2 = ''{}'' OR check_channels( cmp.id,   $2 ) > 0 ) AND
                                        ( $3 = ''{}'' OR check_categories( cmp.id, $3 ) > 0 ) AND
                                        ( $4 = ''{}'' OR check_geos( cmp.id,       $4 ) > 0 ) AND
                                        ( $5 = ''{}'' OR check_pays_on( cmp.id,    $5 ) > 0 ) AND
                                        ( $6 IS NULL  OR cmp.currency_id = $6 ) AND
                                        ( $7 IS NULL  OR matches(cmp.name, $7) ) '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val
        USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_currency_id, arg_traffic_search;

        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.pubs_campaign_available_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_campaign_available_get_list(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean, boolean, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_available_get_list(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false, arg_new_only boolean DEFAULT NULL::boolean, arg_recommendations_only boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $_$
            DECLARE
            ret_val json;       
            var_channel_ids        bigint[];
            var_category_ids    bigint[];
            var_pays_on_ids        bigint[];
            var_geos_ids        text[];
            order_clause         text;
            execute_statement     text :='';
            BEGIN
                        

    SELECT (string_to_array(w4_automatic_functions.clean_json_array(arg_json_arr:=arg_channel_ids_json, arg_return_int:=TRUE),','))::bigint[] INTO var_channel_ids;    
    SELECT (string_to_array(w4_automatic_functions.clean_json_array(arg_json_arr:=arg_category_ids_json, arg_return_int:=TRUE),','))::bigint[] INTO var_category_ids;
    SELECT (string_to_array(w4_automatic_functions.clean_json_array(arg_json_arr:=arg_pays_on_ids_json, arg_return_int:=TRUE),','))::bigint[] INTO var_pays_on_ids;
    SELECT (string_to_array(w4_automatic_functions.clean_json_array(arg_json_arr:=arg_geos_ids_json, arg_return_text:=TRUE),','))::text[] INTO var_geos_ids;
    execute_statement := ' 
                        FROM campaigns cmp
                            LEFT JOIN publisher_campaign_recommendations pcr ON pcr.campaign_id = cmp.id AND (pcr.publisher_id=$1)
                            LEFT JOIN campaign_assigned_publishers cap ON cap.campaign_id = cmp.id AND (cap.publisher_id=$1)
                        WHERE (SELECT w4api.pubs_campaign_available_check(arg_campaign_id:=cmp.id, arg_publisher_id:=$1)) AND
                        ( $2 IS NULL OR check_channels( cmp.id,   $2 ) > 0 ) AND
                        ( $3 IS NULL OR check_categories( cmp.id, $3 ) > 0 ) AND
                        ( $4 IS NULL OR check_geos( cmp.id,       $4 ) > 0 ) AND
                        ( $5 IS NULL OR check_pays_on( cmp.id,    $5 ) > 0 ) AND
			( ($6 IS NULL)  OR ((LOWER(cmp.name) LIKE ''%''||LOWER($6)||''%'' )OR(cmp.id::text LIKE ''%''||$6||''%'' )) ) AND
                        ( $7 IS NULL  OR cmp.currency_id = $7 ) AND
                        ( $8 IS NULL  OR ( cmp.default_payout >= $8) ) AND
                        ( $9 IS NULL  OR ( cmp.default_payout <= $9) ) AND
                        ( $10 IS NULL OR ( cmp.new_until::timestamptz > (NOW())::timestamptz ) ) AND
                        ( $11 IS NULL OR ( pcr.created_at NOTNULL) ) AND
                        ( $12 IS NULL OR ( pcr.created_at >= $12) ) AND
                        ( $13 IS NULL OR ( pcr.created_at <= $13) )
                        ';                            
                                    
            IF(arg_count) THEN
                execute_statement :=  'SELECT COUNT(cmp.id)'||execute_statement||';';    
            ELSE
                order_clause := order_clause_build(arg_orderby, 'cmp.id DESC') || ' LIMIT ' || COALESCE(arg_limit::text, 'ALL') || ' OFFSET ' || arg_offset;
                execute_statement := 'SELECT array_to_json (array_agg(row_to_json (results)))
                            FROM ( 
                                SELECT row_to_json (row)
                                FROM (
                                    SELECT
                                        cmp.name                            AS campaign_name,
                                        cmp.id                            AS campaign_id,
                                        cmp.default_payout                         AS payout,
                                        pays_on_friendly_name( cmp.payout_model_id )        AS pays_on,
                                        geos_json( cmp.id )::text                    AS geos_json,
                                        categories_json( cmp.id )                    AS categories,
                                        channels_json( cmp.id )                    AS channels,
                                        categories_ids_json( cmp.id )                AS categories_ids,
                                        channels_ids_json( cmp.id )                    AS channel_ids,
                                        return_geo_ids_json( cmp.id )                AS country_ids,
                                        to_char( cmp.expiry_date, ''Month DD, YYYY'' )        AS expires,
                                        cmp.description                        AS campaign_description,
                                        cmp.payout_type                         AS payout_type,
                                        cmp.payin_type                         AS payin_type,                                    
                                        CASE cmp.access_type
                                            WHEN 1 THEN ''public''
                                            WHEN 2 THEN ''approved''
                                            WHEN 3 THEN
                                                CASE WHEN cap.status IS NULL THEN ''request''
                                                ELSE cap.status::text
                                                END
                                        END                                AS approval_status,
                                        CASE
                                            WHEN ( cmp.new_until::timestamptz > (NOW())::timestamptz ) THEN TRUE
                                            ELSE FALSE
                                        END                                AS is_new,
                                        (pcr.created_at NOTNULL)                    AS is_recommended'
                                    || execute_statement
                                    || order_clause 
                                    ||') row
                                         ) results;';            

            END IF;
            
            EXECUTE execute_statement INTO ret_val USING arg_publisher_id,            --$1
                                    var_channel_ids,         --$2
                                    var_category_ids,         --$3
                                    var_geos_ids,             --$4
                                    var_pays_on_ids,         --$5
                                    arg_traffic_search,         --$6
                                    arg_currency_id,         --$7
                                    arg_payout_min,         --$8
                                    arg_payout_max,          --$9
                                    arg_new_only,             --$10
                                    arg_recommendations_only,     --$11
                                    arg_min_date,            --$12
                                    arg_max_date;            --$13
            RETURN ret_val;
            END
        $_$;


ALTER FUNCTION w4api.pubs_campaign_available_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean, arg_new_only boolean, arg_recommendations_only boolean) OWNER TO w4;

--
-- Name: pubs_campaign_available_get_update(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_available_get_update(arg_publisher_id bigint, arg_campaign_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;

    BEGIN
        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    cmp."name" AS campaign_name,
                                    cmp.id AS campaign_id,
                                    COALESCE( po.override_payout, cmp.default_payout )	AS payout,
                                    pays_on_friendly_name( cmp.payout_model_id ) AS pays_on,
                                    geos_json( cmp.id )::text AS geos_json,
                                    categories_json( cmp.id ) AS categories,
                                    channels_json( cmp.id ) AS channels,
                                    categories_ids_json( cmp.id ) AS categories_ids,
                                    channels_ids_json( cmp.id ) AS channel_ids,
                                    return_geo_ids_json( cmp.id ) AS country_ids,
                                    to_char( cmp.expiry_date, ''Month DD, YYYY'' ) AS expires,
                                    cmp.description AS campaign_description,
                                    cmp.payout_type AS payout_type,
                                    cmp.payin_type AS payin_type,
                                    CASE cmp.access_type
                                        WHEN 1 THEN ''public''
                                        WHEN 2 THEN ''approved''
                                        WHEN 3 THEN COALESCE(cap.status::text,''request'')
                                    END	AS approval_status,
                                    CASE WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE ELSE FALSE END AS is_new
                                FROM campaigns cmp
                                LEFT JOIN campaign_assigned_publishers cap ON cap.campaign_id = cmp.id AND cap.publisher_id = $1
                                LEFT JOIN publisher_overrides po ON po.campaign_id = $2 AND po.publisher_id = $1
                                WHERE
                                    cmp.id = $2
                            ) row
                    ) results;'
        INTO ret_val
        USING arg_publisher_id, arg_campaign_id;

        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.pubs_campaign_available_get_update(arg_publisher_id bigint, arg_campaign_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_available_update(bigint, bigint, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_available_update(arg_id bigint, arg_publisher_id bigint, arg_memo text DEFAULT NULL::text, arg_channel_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_message_return boolean;
        var_campaign_name text;
        var_manager_id bigint;
        var_publisher_name text;
        var_receiver json;
        var_content text;
        var_subject text;
        var_channel_name text := '';

    BEGIN
        SELECT name FROM campaigns WHERE id = arg_id INTO var_campaign_name;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find specific campaign (%).', arg_id;
        END IF;

        SELECT
            u.manager_id,
            up.company_name
        FROM users u
        LEFT JOIN user_profiles up ON (u.id = up.user_id)
        WHERE
            u.id = arg_publisher_id AND
            u.access = 'publisher' AND
            u.active = 'active'
        INTO
            var_manager_id,
            var_publisher_name;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find specific publisher (%).', arg_publisher_id;
        END IF;
        var_receiver := '{"recipients": [' || var_manager_id || ']}';

        IF (arg_channel_id IS NOT NULL) THEN
            PERFORM * FROM channels WHERE id = arg_channel_id;
            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Unable to find specified channel (%).', arg_channel_id;
            END IF;
        END IF;

        PERFORM * FROM campaign_assigned_publishers WHERE campaign_id = arg_id AND publisher_id = arg_publisher_id;
        IF FOUND THEN
            RAISE EXCEPTION 'campaign (%) and publisher (%) pair already exists in campaign approvals.', arg_id, arg_publisher_id;
        END IF;

        INSERT INTO campaign_assigned_publishers
            (campaign_id, publisher_id, status, allocations, created_at, updated_at, memo)
            VALUES (arg_id, arg_publisher_id, 'pending', '', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, arg_memo);

        var_content := '<p>A campaign request was made.</p><br><p>Publisher:
            <a target=''_blank'' href=''http://app.w4dev.net/publishers/view/id/108188''>' || var_publisher_name || '</a></p>
            <p>Campaign: <a target=''_blank'' href=''http://app.w4dev.net/campaigns/view/id/8851''>' || var_campaign_name || '</a></p>
            <p>Channel: ' || var_channel_name || '</p>
            <p>Memo: ' || arg_memo || '</p>';

        var_message_return := messages_create(arg_publisher_id, var_receiver, 4, var_content, 'Publisher Campaign Requested', 1, 4);

        RETURN pubs_campaign_available_get_update(arg_publisher_id, arg_id);
    END;
$$;


ALTER FUNCTION w4api.pubs_campaign_available_update(arg_id bigint, arg_publisher_id bigint, arg_memo text, arg_channel_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_new_get(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_new_get(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
        DECLARE
        retval json;
        BEGIN
        retval := (
               '{"results": ' || (SELECT COALESCE(
                        (w4api.pubs_campaign_available_get_list(                                    
                                        arg_publisher_id:=arg_publisher_id, 
                                        arg_channel_ids_json:= arg_channel_ids_json, 
                                        arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                        arg_category_ids_json:= arg_category_ids_json, 
                                        arg_geos_ids_json:=arg_geos_ids_json, 
                                        arg_traffic_search:=arg_traffic_search,
                                        arg_currency_id:=arg_currency_id, 
                                        arg_payout_min:=arg_payout_min, 
                                        arg_payout_max:=arg_payout_max,
                                        arg_min_date:=arg_min_date, 
                                        arg_max_date:=arg_max_date,
                                        arg_orderby:=arg_orderby, 
                                        arg_limit:=arg_limit, 
                                        arg_offset:=arg_offset,
                                        arg_new_only := TRUE
                                        )
                        ),'[]' 
                        )
                  )::text
                || ', "count": ' || (SELECT COALESCE(
                            (w4api.pubs_campaign_available_get_list(
                                        arg_publisher_id:=arg_publisher_id, 
                                        arg_channel_ids_json:= arg_channel_ids_json, 
                                        arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                        arg_category_ids_json:= arg_category_ids_json, 
                                        arg_geos_ids_json:=arg_geos_ids_json, 
                                        arg_traffic_search:=arg_traffic_search,
                                        arg_currency_id:=arg_currency_id,
                                        arg_payout_min:=arg_payout_min, 
                                        arg_payout_max:=arg_payout_min,
                                        arg_min_date:=arg_min_date, 
                                        arg_max_date:=arg_max_date,
                                        arg_count:= TRUE,
                                        arg_new_only := TRUE
                                           )), '0')
                            )::text
                || '}'
            )::json;

        RETURN retval;
        END
    $$;


ALTER FUNCTION w4api.pubs_campaign_new_get(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_campaign_new_get_count(bigint, json, json, json, json, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_new_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];

    BEGIN
        channel_ids  := json_array_convert( arg_channel_ids_json  )::bigint[];
        category_ids := json_array_convert( arg_category_ids_json )::bigint[];
        pays_on_ids  := json_array_convert( arg_pays_on_ids_json  )::bigint[];
        geos_ids     := json_array_convert( arg_geos_ids_json  )::text[];

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    cmp."name"						AS campaign_name,
                    cmp.id							AS campaign_id,
                    COALESCE( po.override_payout, cmp.default_payout )	AS payout,
                    pays_on_friendly_name( cmp.payout_model_id )		AS pays_on,
                    geos_json( cmp.id )::text				AS geos_json,
                    categories_json( cmp.id )				AS categories,
                    channels_json( cmp.id )					AS channels,
                    categories_ids_json( cmp.id )				AS categories_ids,
                    channels_ids_json( cmp.id )				AS channel_ids,
                    return_geo_ids_json( cmp.id )				AS country_ids,
                    to_char( cmp.expiry_date, ''Month DD, YYYY'' )		AS expires,
                    cmp.description						AS campaign_description,
                    CASE cmp.access_type
                        WHEN 1 THEN ''public''
                        WHEN 2 THEN ''approved''
                        WHEN 3 THEN
                            CASE WHEN cap.status IS NULL THEN ''request''
                            ELSE cap.status::text
                            END
                    END							AS approval_status,
                    CASE
                        WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE
                        ELSE FALSE
                    END							AS is_new
                FROM
                    campaigns cmp
                LEFT JOIN publisher_overrides po ON
                    po.publisher_id = $1
                    AND po.campaign_id = cmp.id
                    AND ( po.effective_date  < NOW() OR po.effective_date  IS NULL )
                    AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL )
                LEFT JOIN campaign_assigned_publishers cap ON
                    cap.campaign_id   = cmp.id
                    AND cap.publisher_id = $1
                WHERE
                    cmp.new_until::timestamptz > NOW() + ''1 day''::interval AND
                    (
                        cmp.access_type = 1 OR
                       ( cmp.access_type <> 1 AND cap.status = ''approved'' )
                    ) AND
                    ( $2 = ''{}'' OR check_channels( cmp.id,   $2 ) > 0 ) AND
                    ( $3 = ''{}'' OR check_categories( cmp.id, $3 ) > 0 ) AND
                    ( $4 = ''{}'' OR check_geos( cmp.id,       $4 ) > 0 ) AND
                    ( $5 = ''{}'' OR check_pays_on( cmp.id,    $5 ) > 0 ) AND
                    ( $6 IS NULL  OR cmp.currency_id = $6 )
            ) AS the_count '
        INTO retval
        USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_currency_id;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.pubs_campaign_new_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_new_get_count(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_new_get_count(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
            BEGIN
            RETURN w4api.pubs_campaign_available_get_list(                                    
                                    arg_publisher_id:=arg_publisher_id, 
                                    arg_channel_ids_json:= arg_channel_ids_json, 
                                    arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                    arg_category_ids_json:= arg_category_ids_json, 
                                    arg_geos_ids_json:=arg_geos_ids_json, 
                                    arg_traffic_search:=arg_traffic_search,
                                    arg_currency_id:=arg_currency_id,
                                    arg_payout_min:=arg_payout_min, 
                                    arg_payout_max:=arg_payout_min,
                                    arg_min_date:=arg_min_date, 
                                    arg_max_date:=arg_max_date,
                                    arg_count:= TRUE,
                                    arg_new_only:=TRUE
                                       );        
            END
        $$;


ALTER FUNCTION w4api.pubs_campaign_new_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: pubs_campaign_new_get_list(bigint, json, json, json, json, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_new_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        order_clause text;
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];

    BEGIN

        order_clause := order_clause_build(arg_orderby, 'campaign_id DESC');
        channel_ids  := json_array_convert( arg_channel_ids_json  )::bigint[];
        category_ids := json_array_convert( arg_category_ids_json )::bigint[];
        pays_on_ids  := json_array_convert( arg_pays_on_ids_json  )::bigint[];
        geos_ids     := json_array_convert( arg_geos_ids_json  )::text[];

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    cmp."name"						AS campaign_name,
                                    cmp.id							AS campaign_id,
                                    COALESCE( po.override_payout, cmp.default_payout )	AS payout,
                                    pays_on_friendly_name( cmp.payout_model_id )		AS pays_on,
                                    geos_json( cmp.id )::text				AS geos_json,
                                    categories_json( cmp.id )				AS categories,
                                    channels_json( cmp.id )					AS channels,
                                    categories_ids_json( cmp.id )				AS categories_ids,
                                    channels_ids_json( cmp.id )				AS channel_ids,
                                    return_geo_ids_json( cmp.id )				AS country_ids,
                                    to_char( cmp.expiry_date, ''Month DD, YYYY'' )		AS expires,
                                    cmp.description						AS campaign_description,
                                    cmp.payout_type AS payout_type,
                                    cmp.payin_type AS payin_type,
                                    CASE cmp.access_type
                                        WHEN 1 THEN ''public''
                                        WHEN 2 THEN ''approved''
                                        WHEN 3 THEN
                                            CASE WHEN cap.status IS NULL THEN ''request''
                                            ELSE cap.status::text
                                            END
                                    END							AS approval_status,
                                    CASE
                                        WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE
                                        ELSE FALSE
                                    END							AS is_new
                                FROM
                                    campaigns cmp
                                LEFT JOIN publisher_overrides po ON
                                    po.publisher_id = $1
                                    AND po.campaign_id = cmp.id
                                    AND ( po.effective_date  < NOW() OR po.effective_date  IS NULL )
                                    AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL )
                                LEFT JOIN campaign_assigned_publishers cap ON
                                    cap.campaign_id   = cmp.id
                                    AND cap.publisher_id = $1
                                WHERE
                                    cmp.new_until::timestamptz > NOW() + ''1 day''::interval AND
                                    (
					 cmp.access_type = 1 OR
                                        ( cmp.access_type <> 1 AND cap.status = ''approved'' )
                                    ) AND
                                    ( $2 = ''{}'' OR check_channels( cmp.id,   $2 ) > 0 ) AND
                                    ( $3 = ''{}'' OR check_categories( cmp.id, $3 ) > 0 ) AND
                                    ( $4 = ''{}'' OR check_geos( cmp.id,       $4 ) > 0 ) AND
                                    ( $5 = ''{}'' OR check_pays_on( cmp.id,    $5 ) > 0 ) AND
                                    ( $6 IS NULL  OR cmp.currency_id = $6 )'
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val
        USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_currency_id;

        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.pubs_campaign_new_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_campaign_new_get_list(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_new_get_list(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
        BEGIN
        RETURN w4api.pubs_campaign_available_get_list(                                    
                            arg_publisher_id:=arg_publisher_id, 
                            arg_channel_ids_json:= arg_channel_ids_json, 
                            arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                            arg_category_ids_json:= arg_category_ids_json, 
                            arg_geos_ids_json:=arg_geos_ids_json, 
                            arg_traffic_search:=arg_traffic_search,
                            arg_currency_id:=arg_currency_id, 
                            arg_payout_min:=arg_payout_min, 
                            arg_payout_max:=arg_payout_max,
                            arg_min_date:=arg_min_date, 
                            arg_max_date:=arg_max_date,
                            arg_orderby:=arg_orderby, 
                            arg_limit:=arg_limit, 
                            arg_offset:=arg_offset,
                            arg_new_only := TRUE
                            );
        END
    $$;


ALTER FUNCTION w4api.pubs_campaign_new_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_campaign_recommendations_get(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_recommendations_get(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
        DECLARE
        retval json;
        BEGIN
        retval := (
               '{"results": ' || (SELECT COALESCE(
                        (w4api.pubs_campaign_available_get_list(                                    
                                        arg_publisher_id:=arg_publisher_id, 
                                        arg_channel_ids_json:= arg_channel_ids_json, 
                                        arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                        arg_category_ids_json:= arg_category_ids_json, 
                                        arg_geos_ids_json:=arg_geos_ids_json, 
                                        arg_traffic_search:=arg_traffic_search,
                                        arg_currency_id:=arg_currency_id, 
                                        arg_payout_min:=arg_payout_min, 
                                        arg_payout_max:=arg_payout_max,
                                        arg_min_date:=arg_min_date, 
                                        arg_max_date:=arg_max_date,
                                        arg_orderby:=arg_orderby, 
                                        arg_limit:=arg_limit, 
                                        arg_offset:=arg_offset,
                                        arg_recommendations_only := TRUE
                                        )
                        ),'[]' 
                        )
                  )::text
                || ', "count": ' || (SELECT COALESCE(
                            (w4api.pubs_campaign_available_get_list(
                                        arg_publisher_id:=arg_publisher_id, 
                                        arg_channel_ids_json:= arg_channel_ids_json, 
                                        arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                        arg_category_ids_json:= arg_category_ids_json, 
                                        arg_geos_ids_json:=arg_geos_ids_json, 
                                        arg_traffic_search:=arg_traffic_search,
                                        arg_currency_id:=arg_currency_id,
                                        arg_payout_min:=arg_payout_min, 
                                        arg_payout_max:=arg_payout_min,
                                        arg_min_date:=arg_min_date, 
                                        arg_max_date:=arg_max_date,
                                        arg_count:= TRUE,
                                        arg_recommendations_only := TRUE
                                           )), '0')
                            )::text
                || '}'
            )::json;

        RETURN retval;
        END
    $$;


ALTER FUNCTION w4api.pubs_campaign_recommendations_get(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_campaign_recommendations_get_count(bigint, json, json, json, json, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_recommendations_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];

    BEGIN
        channel_ids := json_array_convert(arg_channel_ids_json)::bigint[];
        category_ids := json_array_convert(arg_category_ids_json)::bigint[];
        pays_on_ids := json_array_convert(arg_pays_on_ids_json)::bigint[];
        geos_ids := json_array_convert(arg_geos_ids_json)::text[];

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    cmp."name"						AS campaign_name,
                    cmp.id							AS campaign_id,
                    COALESCE( po.override_payout, cmp.default_payout )	AS payout,
                    pays_on_friendly_name( cmp.payout_model_id )		AS pays_on,
                    geos_json( cmp.id )::text				AS geos_json,
                    categories_json( cmp.id )				AS categories,
                    channels_json( cmp.id )					AS channels,
                    categories_ids_json( cmp.id )				AS categories_ids,
                    channels_ids_json( cmp.id )				AS channel_ids,
                    return_geo_ids_json( cmp.id )				AS country_ids,
                    to_char( cmp.expiry_date, ''Month DD, YYYY'' )		AS expires,
                    cmp.description						AS campaign_description,
                    CASE cmp.access_type
                            WHEN 1 THEN ''public''
                            WHEN 2 THEN ''approved''
                            WHEN 3 THEN
                                    CASE WHEN cap.status IS NULL THEN ''request''
                                    ELSE cap.status::text
                                    END
                    END							AS approval_status,
                    CASE
                            WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE
                            ELSE FALSE
                    END							AS is_new
                FROM publisher_campaign_recommendations pcr
                RIGHT JOIN campaigns cmp ON pcr.campaign_id = cmp.id
                LEFT JOIN publisher_overrides po
                    ON po.publisher_id = $1
                    AND po.campaign_id = cmp.id
                    AND ( po.effective_date  < NOW() OR po.effective_date  IS NULL )
                    AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL )
                LEFT JOIN campaign_assigned_publishers cap
                    ON cap.campaign_id   = cmp.id
                    AND cap.publisher_id = $1
                WHERE
                    pcr.publisher_id = $1 AND
                    (
                            cap.status IS NULL OR
                            ( cmp.access_type <> 2 OR ( cmp.access_type = 2 AND cap.status = ''approved'' ) ) AND
                            cap.status <> ''blocked'' AND
                            cap.status <> ''denied''
                    ) AND
                    ( $2 = ''{}'' OR check_channels( cmp.id,   $2 ) > 0 ) AND
                    ( $3 = ''{}'' OR check_categories( cmp.id, $3 ) > 0 ) AND
                    ( $4 = ''{}'' OR check_geos( cmp.id,       $4 ) > 0 ) AND
                    ( $5 = ''{}'' OR check_pays_on( cmp.id,    $5 ) > 0 ) AND
                    ( $6 IS NULL  OR cmp.currency_id = $6 )
            ) AS the_count '
        INTO retval
        USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_currency_id;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.pubs_campaign_recommendations_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_recommendations_get_count(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_recommendations_get_count(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
            BEGIN
            RETURN w4api.pubs_campaign_available_get_list(                                    
                                    arg_publisher_id:=arg_publisher_id, 
                                    arg_channel_ids_json:= arg_channel_ids_json, 
                                    arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                                    arg_category_ids_json:= arg_category_ids_json, 
                                    arg_geos_ids_json:=arg_geos_ids_json, 
                                    arg_traffic_search:=arg_traffic_search,
                                    arg_currency_id:=arg_currency_id,
                                    arg_payout_min:=arg_payout_min, 
                                    arg_payout_max:=arg_payout_min,
                                    arg_min_date:=arg_min_date, 
                                    arg_max_date:=arg_max_date,
                                    arg_count:= TRUE,
                                    arg_recommendations_only:=TRUE
                                       );        
            END
        $$;


ALTER FUNCTION w4api.pubs_campaign_recommendations_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone) OWNER TO w4;

--
-- Name: pubs_campaign_recommendations_get_list(bigint, json, json, json, json, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_recommendations_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        order_clause text;
        channel_ids	bigint[];
        category_ids	bigint[];
        pays_on_ids	bigint[];
        geos_ids	text[];

    BEGIN

        order_clause := order_clause_build(arg_orderby, 'campaign_id DESC');
        channel_ids  := json_array_convert( arg_channel_ids_json  )::bigint[];
        category_ids := json_array_convert( arg_category_ids_json )::bigint[];
        pays_on_ids  := json_array_convert( arg_pays_on_ids_json  )::bigint[];
        geos_ids     := json_array_convert( arg_geos_ids_json  )::text[];

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    cmp."name"						AS campaign_name,
                                    cmp.id							AS campaign_id,
                                    COALESCE( po.override_payout, cmp.default_payout )	AS payout,
                                    pays_on_friendly_name( cmp.payout_model_id )		AS pays_on,
                                    geos_json( cmp.id )::text				AS geos_json,
                                    categories_json( cmp.id )				AS categories,
                                    channels_json( cmp.id )					AS channels,
                                    categories_ids_json( cmp.id )				AS categories_ids,
                                    channels_ids_json( cmp.id )				AS channel_ids,
                                    return_geo_ids_json( cmp.id )				AS country_ids,
                                    to_char( cmp.expiry_date, ''Month DD, YYYY'' )		AS expires,
                                    cmp.description						AS campaign_description,
                                    cmp.payout_type AS payout_type,
                                    cmp.payin_type AS payin_type,                                    
                                    CASE cmp.access_type
                                            WHEN 1 THEN ''public''
                                            WHEN 2 THEN ''approved''
                                            WHEN 3 THEN
                                                    CASE WHEN cap.status IS NULL THEN ''request''
                                                    ELSE cap.status::text
                                                    END
                                    END							AS approval_status,
                                    CASE
                                            WHEN ( cmp.new_until::timestamptz > ( NOW() + INTERVAL ''1 day'' )::timestamptz ) THEN TRUE
                                            ELSE FALSE
                                    END							AS is_new
                                FROM publisher_campaign_recommendations pcr
                                RIGHT JOIN campaigns cmp ON pcr.campaign_id = cmp.id
                                LEFT JOIN publisher_overrides po
                                    ON po.publisher_id = $1
                                    AND po.campaign_id = cmp.id
                                    AND ( po.effective_date  < NOW() OR po.effective_date  IS NULL )
                                    AND ( po.expiration_date > NOW() OR po.expiration_date IS NULL )
                                LEFT JOIN campaign_assigned_publishers cap
                                    ON cap.campaign_id   = cmp.id
                                    AND cap.publisher_id = $1
                                WHERE
                                    pcr.publisher_id = $1 AND
                                    (
                                            cap.status IS NULL OR
                                            ( cmp.access_type <> 2 OR ( cmp.access_type = 2 AND cap.status = ''approved'' ) ) AND
                                            cap.status <> ''blocked'' AND
                                            cap.status <> ''denied''
                                    ) AND
                                    ( $2 = ''{}'' OR check_channels( cmp.id,   $2 ) > 0 ) AND
                                    ( $3 = ''{}'' OR check_categories( cmp.id, $3 ) > 0 ) AND
                                    ( $4 = ''{}'' OR check_geos( cmp.id,       $4 ) > 0 ) AND
                                    ( $5 = ''{}'' OR check_pays_on( cmp.id,    $5 ) > 0 ) AND
                                    ( $6 IS NULL  OR cmp.currency_id = $6 )'
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val
        USING arg_publisher_id, channel_ids, category_ids, geos_ids, pays_on_ids, arg_currency_id;

        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.pubs_campaign_recommendations_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_campaign_recommendations_get_list(bigint, json, json, json, json, text, bigint, numeric, numeric, timestamp with time zone, timestamp with time zone, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_recommendations_get_list(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint, arg_payout_min numeric DEFAULT NULL::numeric, arg_payout_max numeric DEFAULT NULL::numeric, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql
    AS $$
        BEGIN
        RETURN w4api.pubs_campaign_available_get_list(                                    
                            arg_publisher_id:=arg_publisher_id, 
                            arg_channel_ids_json:= arg_channel_ids_json, 
                            arg_pays_on_ids_json:= arg_pays_on_ids_json, 
                            arg_category_ids_json:= arg_category_ids_json, 
                            arg_geos_ids_json:=arg_geos_ids_json, 
                            arg_traffic_search:=arg_traffic_search,
                            arg_currency_id:=arg_currency_id, 
                            arg_payout_min:=arg_payout_min, 
                            arg_payout_max:=arg_payout_max,
                            arg_min_date:=arg_min_date, 
                            arg_max_date:=arg_max_date,
                            arg_orderby:=arg_orderby, 
                            arg_limit:=arg_limit, 
                            arg_offset:=arg_offset,
                            arg_recommendations_only := TRUE
                            );
        END
    $$;


ALTER FUNCTION w4api.pubs_campaign_recommendations_get_list(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint, arg_payout_min numeric, arg_payout_max numeric, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_campaign_tabs_get_count(bigint, json, json, json, json, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_tabs_get_count(arg_publisher_id bigint, arg_channel_ids_json json DEFAULT NULL::json, arg_pays_on_ids_json json DEFAULT NULL::json, arg_category_ids_json json DEFAULT NULL::json, arg_geos_ids_json json DEFAULT NULL::json, arg_traffic_search text DEFAULT NULL::text, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        retval := 
        (
                '{' || 
                        '"available": ' || w4api.pubs_campaign_available_get_list(arg_publisher_id:=arg_publisher_id, 
                            arg_channel_ids_json:=arg_channel_ids_json, 
                            arg_pays_on_ids_json:=arg_pays_on_ids_json, 
                            arg_category_ids_json:=arg_category_ids_json, 
                            arg_geos_ids_json:=arg_geos_ids_json,
                            arg_currency_id:=arg_currency_id,
                            arg_count:=TRUE) ||
                        ', "new": ' || w4api.pubs_campaign_available_get_list(arg_publisher_id:=arg_publisher_id, 
                            arg_channel_ids_json:=arg_channel_ids_json, 
                            arg_pays_on_ids_json:=arg_pays_on_ids_json, 
                            arg_category_ids_json:=arg_category_ids_json, 
                            arg_geos_ids_json:=arg_geos_ids_json,
                            arg_currency_id:=arg_currency_id,
                            arg_new_only:=TRUE,
                            arg_count:=TRUE) ||
                        ', "recommended": ' || w4api.pubs_campaign_available_get_list(
                            arg_publisher_id:=arg_publisher_id, 
                            arg_channel_ids_json:=arg_channel_ids_json, 
                            arg_pays_on_ids_json:=arg_pays_on_ids_json, 
                            arg_category_ids_json:=arg_category_ids_json, 
                            arg_geos_ids_json:=arg_geos_ids_json,
                            arg_currency_id:=arg_currency_id,
                            arg_recommendations_only:=TRUE,
                            arg_count:=TRUE
                             )
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_campaign_tabs_get_count(arg_publisher_id bigint, arg_channel_ids_json json, arg_pays_on_ids_json json, arg_category_ids_json json, arg_geos_ids_json json, arg_traffic_search text, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_top_get(bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_top_get(arg_publisher_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_campaign_top_get_count(arg_publisher_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_campaign_top_get_list(arg_publisher_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_campaign_top_get(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_campaign_top_get_count(bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_top_get_count(arg_publisher_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
                COALESCE (COUNT(1), 0) FROM (
                    SELECT 
                        MAX(cmp."name")::VARCHAR AS campaign_name
                        , rd.campaign_id::BIGINT AS campaign_id
                        , SUM(rd.unique_clicks)::BIGINT AS total_clicks
                        , SUM(rd.total_conversions)::BIGINT AS total_conversions
                        , SUM(rd.total_pay_out)::NUMERIC AS total_earned_revenue
                        , COALESCE(MAX(po.override_payout)::NUMERIC, MAX(cmp.default_payout)::NUMERIC)::NUMERIC AS payout
                        , categories_json(cmp.id)::TEXT AS categories
                        , channels_json(cmp.id)::TEXT AS channels
                        , to_char(MAX(cmp.expiry_date)::TIMESTAMPTZ,''Month DD, YYYY'')::TEXT AS expiration_date
                        , MAX(cmp.description)::TEXT AS description
                        , MAX(cmp.restrictions)::TEXT AS restrictions
                        , pays_on_friendly_name(MAX(cmp.payout_model_id))::TEXT AS pays_on
                        , CASE WHEN (cmp.new_until::TIMESTAMPTZ > (now() + INTERVAL ''1 day'')::TIMESTAMPTZ) THEN TRUE::BOOLEAN ELSE FALSE::BOOLEAN END AS is_new
                    FROM reports_daily rd 
                    LEFT JOIN campaigns cmp 
                        ON rd.campaign_id=cmp.id 
                    LEFT JOIN publisher_overrides po 
                        ON po.publisher_id= ' || arg_publisher_id || '
                        AND po.campaign_id=cmp.id 
                        AND (po.effective_date < now() OR po.effective_date IS NULL)
                        AND (po.expiration_date > now() OR po.expiration_date IS NULL) '
                    || where_clause || '
                    GROUP BY rd.publisher_id,rd.campaign_id,cmp.id
                ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_campaign_top_get_count(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_campaign_top_get_list(bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_campaign_top_get_list(arg_publisher_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN

        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT 
                                    MAX(cmp."name")::VARCHAR AS campaign_name
                                    , rd.campaign_id::BIGINT AS campaign_id
                                    , SUM(rd.unique_clicks)::BIGINT AS total_clicks
                                    , SUM(rd.total_conversions)::BIGINT AS total_conversions
                                    , SUM(rd.total_pay_out)::NUMERIC AS total_earned_revenue
                                    , COALESCE(MAX(po.override_payout)::NUMERIC, MAX(cmp.default_payout)::NUMERIC)::NUMERIC AS payout
                                    , categories_json(cmp.id) AS categories
                                    , channels_json(cmp.id) AS channels
                                    , to_char(MAX(cmp.expiry_date)::TIMESTAMPTZ,''Month DD, YYYY'')::TEXT AS expires
                                    , MAX(cmp.description)::TEXT AS campaign_description
                                    , MAX(cmp.restrictions)::TEXT AS restrictions
                                    , MAX(cmp.payout_type) AS payout_type
                                    , MAX(cmp.payin_type) AS payin_type
                                    , pays_on_friendly_name(MAX(cmp.payout_model_id))::TEXT AS pays_on
                                    , CASE WHEN (cmp.new_until::TIMESTAMPTZ > (now() + INTERVAL ''1 day'')::TIMESTAMPTZ) THEN TRUE::BOOLEAN ELSE FALSE::BOOLEAN END AS is_new
                                FROM reports_daily rd 
                                LEFT JOIN campaigns cmp 
                                    ON rd.campaign_id=cmp.id 
                                LEFT JOIN publisher_overrides po 
                                    ON po.publisher_id= ' || arg_publisher_id || '
                                    AND po.campaign_id=cmp.id 
                                    AND (po.effective_date < now() OR po.effective_date IS NULL)
                                    AND (po.expiration_date > now() OR po.expiration_date IS NULL) '
                                || where_clause || '
                                GROUP BY rd.publisher_id,rd.campaign_id,cmp.id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;

        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_campaign_top_get_list(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_details_sidebar_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_details_sidebar_get(arg_publisher_id bigint, arg_currency_id bigint DEFAULT (1)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
   DECLARE 
        ret_val json; 
        var_doy_current text; 
        var_doy_yesterday text;
        var_doy_last7days text; 
        var_moy_current text; 
        var_y_current text; 
    BEGIN 
        var_doy_current := w4_application_functions.make_doy(now()); 
        var_doy_yesterday := w4_application_functions.make_doy(now()-interval '1 day'); 
        var_doy_last7days := w4_application_functions.make_doy(now() - interval '7 days'); 
        var_moy_current := substring(var_doy_current,1,6); 
        var_y_current := substring(var_doy_current,1,4); 

        EXECUTE 
            'WITH 
                rcd AS(        ------------------------------------------------- non-aggregate reporting.reports_daily data: last 7 days
                        SELECT 
                            rr.total_pay_out, 
                            rr.doy
                        FROM reporting.reports_daily rr
                            LEFT JOIN campaigns cmp ON cmp.id = rr.campaign_id
                        WHERE rr.publisher_id = $1 AND  cmp.currency_id = $2
                            AND rr.doy > '||var_doy_last7days||'                            
                        ),
                rcm AS(        ------------------------------------------------- aggregate reporting.reports_monthly: current month
                        SELECT 
                            sum(rr.total_pay_out) AS total_pay_out,
                            CASE WHEN sum(rr.total_pay_out) > 2500.00 THEN sum(rr.total_pay_out)*0.01 ELSE NULL END AS rewards_balance
                        FROM reporting.reports_monthly rr
                            LEFT JOIN campaigns cmp ON cmp.id = rr.campaign_id
                        WHERE rr.publisher_id = $1 AND  cmp.currency_id = $2
                            AND rr.moy = '||var_moy_current||'                            
                        ),
                rcy AS(     ---------------------------------------------------- non-aggregate reporting.reports_yearly data: all time
                        SELECT
                            rr.total_pay_out,
                            rr.y
                        FROM reporting.reports_yearly rr
                            LEFT JOIN campaigns cmp ON cmp.id = rr.campaign_id
                        WHERE rr.publisher_id = $1 AND cmp.currency_id = $2
                    ),
                pub_inv AS(    ------------------------------------------------- aggregate invoice data: newsest publisher invoice to be paid                            
                        SELECT 
                            publisher_id,
                            max(payout_total) AS payout_total,
                            max(paid_date) AS paid_date        
                        FROM "Accounting".acct_invoices_publisher 
                        WHERE publisher_id = $1  AND currency_id = $2 
                            AND status =''paid'' 
                        GROUP BY publisher_id, paid_date 
                        ORDER BY paid_date DESC
                        )
                    SELECT row_to_json (row) FROM (
                        SELECT
                            pub_usr.manager_id                                                                                          AS affiliate_manager_id, 
                            COALESCE(amgr_ct.first_name ||'' ''|| amgr_ct.last_name, amgr_up.first_name ||'' ''|| amgr_up.last_name)    AS affiliate_manager_name, 
                            COALESCE(amgr_ct.email_address,amgr_up.contact_email,amgr_usr.email)                                        AS affiliate_manager_email,                                    
                            amgr_im.description                                                                                         AS affiliate_manager_messenger_type,
                            COALESCE(amgr_ct.messenger_name,amgr_up.messenger_id)                                                       AS affiliate_manager_messenger_id,
                            amgr_up.image_id                                                                                            AS affiliate_manager_image_id,
                            (SELECT row_to_json(data) FROM (
                                VALUES( COALESCE(amgr_ct.primary_phone,amgr_up.phone,''''),
                                    COALESCE(amgr_ct.fax,amgr_up.fax,''''),
                                    COALESCE(amgr_ct.secondary_phone,amgr_up.cell,'''')))
                                DATA(phone_number,fax_number,cell_number))                                                              AS affiliate_manager_phone,                         
                            (SELECT COALESCE(sum(rcd.total_pay_out),0.00) FROM rcd WHERE rcd.doy='||var_doy_current||')                 AS publisher_earnings_today,
                            (SELECT COALESCE(sum(rcd.total_pay_out),0.00) FROM rcd WHERE rcd.doy='||var_doy_yesterday||')               AS publisher_earnings_yesterday,
                            (SELECT COALESCE(sum(rcd.total_pay_out),0.00) FROM rcd)                                                     AS publisher_earnings_last_7_days,
                            (SELECT COALESCE(total_pay_out,0.00) FROM rcm)                                                              AS publisher_earnings_mtd,
                            (SELECT COALESCE(sum(rcy.total_pay_out),0.00) FROM rcy WHERE rcy.y='||var_y_current||')                     AS publisher_earnings_ytd,
                            (SELECT COALESCE(sum(rcy.total_pay_out),0.00) FROM rcy)                                                     AS publisher_earnings_all_time,
                            (SELECT COALESCE(rcm.rewards_balance,0.00)FROM rcm)                                                         AS mtd_rewards_balance,
                            COALESCE(pub_inv.payout_total,0.00::money)                                                                  AS payout,
                            pub_inv.paid_date                                                                                           AS paid_date
                        FROM users pub_usr
                           LEFT JOIN users amgr_usr ON pub_usr.manager_id = amgr_usr.id
                           LEFT JOIN contacts amgr_ct ON amgr_usr.primary_contact_id = amgr_ct.id
                           LEFT JOIN user_profiles amgr_up ON amgr_usr.id = amgr_up.user_id
                           LEFT JOIN im_types amgr_im ON amgr_ct.messenger_type = amgr_im.id
                           LEFT JOIN pub_inv ON pub_inv.publisher_id = pub_usr.id 
                        WHERE pub_usr.id = $1 AND pub_usr.access = ''publisher''
                      ) row;' 
        INTO ret_val USING arg_publisher_id, arg_currency_id; RETURN ret_val;

 END $_$;


ALTER FUNCTION w4api.pubs_details_sidebar_get(arg_publisher_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_epc_get(bigint, timestamp with time zone, timestamp with time zone, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_epc_get(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_campaign_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;
        var_start_doy bigint := make_doy(arg_start_date);
        var_end_doy bigint := make_doy(arg_end_date);
        
    BEGIN
        SELECT row_to_json (row) FROM (
            SELECT (COALESCE(SUM(total_payout),0)/NULLIF(COALESCE(SUM(unique_clicks),0),0))::money AS epc FROM (
                SELECT
                    COALESCE(SUM(rd.total_pay_out),0) as total_payout,
                    COALESCE(SUM(rd.unique_clicks),0) AS unique_clicks
                FROM reports_daily rd
                LEFT JOIN campaigns cmp ON rd.campaign_id = cmp.id
                WHERE
                    (rd.doy >= var_start_doy) AND
                    (rd.doy < var_end_doy) AND
                    (rd.publisher_id = arg_publisher_id) AND
                    (arg_campaign_id IS NULL OR rd.campaign_id = arg_campaign_id) AND
                    (arg_currency_id IS NULL OR arg_currency_id = cmp.currency_id)
                GROUP BY rd.publisher_id,rd.campaign_id
            ) AS the_totals
        ) row
        INTO var_results;

        RETURN COALESCE(var_results, '{}');		
    END
$$;


ALTER FUNCTION w4api.pubs_epc_get(arg_publisher_id bigint, arg_start_date timestamp with time zone, arg_end_date timestamp with time zone, arg_campaign_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_browsers_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_browsers_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_browsers_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_browsers_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_browsers_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_browsers_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_browsers_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                     b.browser_name AS browser,
                     SUM(rd.total_clicks) AS total_clicks,
                     SUM(rd.unique_clicks) AS unique_clicks,
                     SUM(rd.total_conversions) AS total_conversions,
                     SUM(rd.payout) AS payout,
                     rd.campaign_id
                 FROM vw_pub_campaign_report_details_browser rd
                 LEFT JOIN user_agent_browser_lookup b ON (b.id = rd.browser::bigint)
                 LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                 || where_clause || '
                 GROUP BY rd.campaign_id,b.browser_name
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_browsers_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_browsers_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_browsers_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'browser ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    b.browser_name AS browser,
                                    SUM(rd.total_clicks) AS total_clicks,
                                    SUM(rd.unique_clicks) AS unique_clicks,
                                    SUM(rd.total_conversions) AS total_conversions,
                                    SUM(rd.payout) AS payout,
                                    rd.campaign_id
                                FROM vw_pub_campaign_report_details_browser rd
                                LEFT JOIN user_agent_browser_lookup b ON (b.id = rd.browser::bigint)
                                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                                || where_clause || '
                                GROUP BY rd.campaign_id,b.browser_name '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_browsers_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_reports_click_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_click_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_click_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_click_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_click_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_click_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_click_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    SUM(rd.total_clicks) AS total_clicks,
                    SUM(rd.unique_clicks) AS unique_clicks,
                    SUM(rd.foreign_clicks) AS foreign_clicks,
                    SUM(rd.banned_clicks) AS banned_clicks,
                    rd.campaign_id
                FROM vw_pub_campaign_report_details_clicks_overview rd
                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                || where_clause || '
                GROUP BY rd.campaign_id
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_click_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_click_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_click_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_id ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    SUM(rd.total_clicks) AS total_clicks,
                                    SUM(rd.unique_clicks) AS unique_clicks,
                                    SUM(rd.foreign_clicks) AS foreign_clicks,
                                    SUM(rd.banned_clicks) AS banned_clicks,
                                    rd.campaign_id
                                FROM vw_pub_campaign_report_details_clicks_overview rd
                                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                                || where_clause || '
                                GROUP BY rd.campaign_id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_click_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_reports_creatives_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_creatives_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_creative_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_creatives_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_creative_id, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_creatives_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_creative_id, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_creatives_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_creative_id bigint, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_creatives_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_creatives_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_creative_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'v.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'v.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'v.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'v.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_creative_id::TEXT, 'v.creative_id = ' || arg_creative_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    v.creative_id,
                    v.creative_name,
                    v.creative_description,
                    v.creative_image_id,
                    SUM(v.total_clicks) AS total_clicks,
                    SUM(v.unique_clicks) AS unique_clicks,
                    SUM(v.total_conversions) AS total_conversions,
                    SUM(v.payout) AS payout,
                    v.campaign_id, 
                    c.name AS campaign_name,
                    (SUM(v.total_conversions) / NULLIF(SUM(v.total_clicks),0)) AS conversion_pct
                FROM vw_pub_campaign_report_details_creatives v
                INNER JOIN campaigns c ON v.campaign_id = c.id '
                || where_clause || '
                GROUP BY v.campaign_id, c.name, v.creative_id, v.creative_name, v.creative_description, v.creative_image_id
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_creatives_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_creative_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_creatives_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_creatives_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_creative_id bigint DEFAULT NULL::bigint, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'v.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'v.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'v.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'v.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_creative_id::TEXT, 'v.creative_id = ' || arg_creative_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'c.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'creative_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    v.creative_id,
                                    v.creative_name,
                                    v.creative_description,
                                    v.creative_image_id,
                                    SUM(v.total_clicks) AS total_clicks,
                                    SUM(v.unique_clicks) AS unique_clicks,
                                    SUM(v.total_conversions) AS total_conversions,
                                    SUM(v.payout) AS payout,
                                    v.campaign_id, 
                                    c.name AS campaign_name,
                                    (SUM(v.total_conversions) / NULLIF(SUM(v.total_clicks),0)) AS conversion_pct
                                FROM vw_pub_campaign_report_details_creatives v
                                INNER JOIN campaigns c ON v.campaign_id = c.id '
                                || where_clause || '
                                GROUP BY v.campaign_id, c.name, v.creative_id, v.creative_name, v.creative_description, v.creative_image_id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_creatives_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_creative_id bigint, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_reports_daily_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_daily_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_daily_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_daily_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_daily_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_daily_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_daily_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    SUM(rd.total_clicks) AS total_clicks, 
                    SUM(rd.unique_clicks) AS unique_clicks,
                    SUM(rd.total_conversions) AS total_conversions,
                    SUM(rd.payout) AS payout,
                    COALESCE(SUM(rd.total_conversions)/NULLIF(COALESCE(SUM(rd.unique_clicks),0),0),0) AS conversion_rate,
                    COALESCE(SUM(rd.payout)/NULLIF(COALESCE(SUM(rd.unique_clicks),0),0),0) AS epc,
                    COALESCE(SUM(rd.payout)/NULLIF(COALESCE(SUM(rd.total_conversions),0),0),0) AS average_payout,
                    rd.campaign_id
                FROM vw_pub_campaign_report_details_daily rd
                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                || where_clause || '
                GROUP BY rd.campaign_id 
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_daily_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_daily_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_daily_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_id ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    SUM(rd.total_clicks) AS total_clicks, 
                                    SUM(rd.unique_clicks) AS unique_clicks,
                                    SUM(rd.total_conversions) AS total_conversions,
                                    SUM(rd.payout) AS payout,
                                    COALESCE(SUM(rd.total_conversions)/NULLIF(COALESCE(SUM(rd.unique_clicks),0),0),0) AS conversion_rate,
                                    COALESCE(SUM(rd.payout)/NULLIF(COALESCE(SUM(rd.unique_clicks),0),0),0) AS epc,
                                    COALESCE(SUM(rd.payout)/NULLIF(COALESCE(SUM(rd.total_conversions),0),0),0) AS average_payout,
                                    rd.campaign_id,
                                    rd.doy
                                FROM vw_pub_campaign_report_details_daily rd
                                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                                || where_clause || '
                                GROUP BY rd.campaign_id, rd.doy '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_daily_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_reports_geo_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_geo_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_geo_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_geo_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_geo_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_geo_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_geo_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    rd.geo_location,
                    SUM(rd.total_clicks) AS total_clicks,
                    SUM(rd.unique_clicks) AS unique_clicks,
                    SUM(rd.total_conversions) AS total_conversions,
                    SUM(rd.payout) AS payout,
                    rd.campaign_id
                FROM vw_pub_campaign_report_details_geos rd
                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                || where_clause || '
                GROUP BY rd.campaign_id, rd.geo_location
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_geo_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_geo_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_geo_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'geo_location ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    rd.geo_location,
                                    SUM(rd.total_clicks) AS total_clicks,
                                    SUM(rd.unique_clicks) AS unique_clicks,
                                    SUM(rd.total_conversions) AS total_conversions,
                                    SUM(rd.payout) AS payout,
                                    rd.campaign_id
                                FROM vw_pub_campaign_report_details_geos rd
                                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                                || where_clause || '
                                GROUP BY rd.campaign_id, rd.geo_location '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_geo_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_reports_platforms_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_platforms_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_platforms_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_platforms_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_platforms_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_platforms_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_platforms_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    p.platform_name AS platform,
                    SUM(rd.total_clicks) AS total_clicks,
                    SUM(rd.unique_clicks) AS unique_clicks,
                    SUM(rd.total_conversions) AS total_conversions,
                    SUM(rd.payout) AS payout,
                    rd.campaign_id
                FROM vw_pub_campaign_report_details_platform rd
                LEFT JOIN user_agent_platform_lookup p ON (p.id = rd.platform::bigint)
                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                || where_clause || '
                GROUP BY rd.campaign_id, p.platform_name 
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_platforms_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_platforms_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_platforms_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'platform ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    p.platform_name AS platform,
                                    SUM(rd.total_clicks) AS total_clicks,
                                    SUM(rd.unique_clicks) AS unique_clicks,
                                    SUM(rd.total_conversions) AS total_conversions,
                                    SUM(rd.payout) AS payout,
                                    rd.campaign_id
                                FROM vw_pub_campaign_report_details_platform rd
                                LEFT JOIN user_agent_platform_lookup p ON (p.id = rd.platform::bigint)
                                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                                || where_clause || '
                                GROUP BY rd.campaign_id, p.platform_name '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_platforms_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_reports_referrer_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_referrer_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_referrer_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_referrer_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_referrer_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_referrer_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_referrer_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    rd.referrer,
                    SUM(rd.total_clicks) AS total_clicks,
                    SUM(rd.unique_clicks) AS unique_clicks,
                    SUM(rd.total_conversions) AS total_conversions,
                    SUM(rd.payout) AS payout,
                    rd.campaign_id
                FROM vw_pub_campaign_report_details_referrer rd
                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                || where_clause || '
                GROUP BY rd.campaign_id, rd.referrer
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_referrer_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_referrer_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_referrer_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'referrer ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    rd.referrer,
                                    SUM(rd.total_clicks) AS total_clicks,
                                    SUM(rd.unique_clicks) AS unique_clicks,
                                    SUM(rd.total_conversions) AS total_conversions,
                                    SUM(rd.payout) AS payout,
                                    rd.campaign_id
                                FROM vw_pub_campaign_report_details_referrer rd
                                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                                || where_clause || '
                                GROUP BY rd.campaign_id, rd.referrer '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_referrer_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_reports_subid_get(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_subid_get(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_subid_get_count(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_subid_get_list(arg_publisher_id, arg_campaign_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_subid_get(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_subid_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_subid_get_count(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0) FROM (
                SELECT
                    rd.sub_id_1,
                    rd.sub_id_2,
                    rd.sub_id_3,
                    rd.sub_id_4,
                    SUM(rd.total_clicks) AS total_clicks,
                    SUM(rd.unique_clicks) AS unique_clicks,
                    SUM(rd.total_conversions) AS total_conversions,
                    SUM(rd.payout) AS payout,
                    rd.campaign_id
                FROM vw_pub_campaign_report_details_subid rd
                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                || where_clause || '
                GROUP BY campaign_id,sub_id_1,sub_id_2,sub_id_3,sub_id_4            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_subid_get_count(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_subid_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_subid_get_list(arg_publisher_id bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy < ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'rd.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_id ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    rd.sub_id_1,
                                    rd.sub_id_2,
                                    rd.sub_id_3,
                                    rd.sub_id_4,
                                    SUM(rd.total_clicks) AS total_clicks,
                                    SUM(rd.unique_clicks) AS unique_clicks,
                                    SUM(rd.total_conversions) AS total_conversions,
                                    SUM(rd.payout) AS payout,
                                    rd.campaign_id
                                FROM vw_pub_campaign_report_details_subid rd
                                LEFT JOIN campaigns cmp ON (rd.campaign_id = cmp.id) '
                                || where_clause || '
                                GROUP BY campaign_id,sub_id_1,sub_id_2,sub_id_3,sub_id_4 '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_subid_get_list(arg_publisher_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_reports_transactions_get(bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_transactions_get(arg_publisher_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;

    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (pubs_reports_transactions_get_count(arg_publisher_id, arg_min_date, arg_max_date, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || pubs_reports_transactions_get_list(arg_publisher_id, arg_min_date, arg_max_date, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_transactions_get(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: pubs_reports_transactions_get_count(bigint, timestamp with time zone, timestamp with time zone, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_transactions_get_count(arg_publisher_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy <= ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT 
		COALESCE (COUNT(1), 0) FROM (
			SELECT
			cmp.id AS campaign_id 
			FROM campaigns cmp
			LEFT JOIN reports_daily rd ON cmp.id = rd.campaign_id'
			|| where_clause || '
			GROUP BY cmp.id
            ) AS the_count'
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_transactions_get_count(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_reports_transactions_get_list(bigint, timestamp with time zone, timestamp with time zone, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_reports_transactions_get_list(arg_publisher_id bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        min_doy integer := make_doy(arg_min_date);
        max_doy integer := make_doy(arg_max_date);
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_min_date::TEXT, 'rd.doy >= ' || min_doy, where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'rd.doy <= ' || max_doy, where_clause);
        where_clause := where_clause_build(arg_publisher_id::TEXT, 'rd.publisher_id = ' || arg_publisher_id, where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'campaign_name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    cmp.id AS campaign_id, 
                                    cmp.name AS campaign_name, 
                                    COALESCE(sum(rd.total_clicks), 0::numeric) AS total_clicks, 
                                    COALESCE(sum(rd.unique_clicks), 0::numeric) AS unique_clicks, 
                                    COALESCE(sum(rd.total_conversions), 0::numeric) AS conversions, 
                                    ROUND(COALESCE(sum(rd.total_conversions)/NULLIF(sum(rd.unique_clicks),0), 0)::numeric, 4) AS conversion_rate,
                                    COALESCE(sum(rd.total_pay_out)/NULLIF(sum(rd.unique_clicks),0),0) epc,
                                    COALESCE(sum(rd.total_pay_out), 0::numeric) AS earnings, 
                                    max(cmp.expiry_date) AS expires, 
                                    max(cmp.payout_type) AS payout_type,
                                    max(cmp.payin_type) AS payin_type,
                                    avg(
					COALESCE(
						(SELECT po.override_payout FROM publisher_overrides po 
							LEFT JOIN campaigns cmp ON cmp.id = po.campaign_id 
							WHERE po.publisher_id = rd.publisher_id 
							AND po.campaign_id = cmp.id
							AND po.effective_date <= now() 
							AND po.expiration_date >= now()
							GROUP BY po.override_payout)::double precision,
						cmp.default_payout::double precision 
						)
				     ) AS payout,
                                    pays_on_friendly_name(max(cmp.payout_model_id)) AS pays_on, 
                                    geos_json(cmp.id) AS geos_json, 
                                    categories_json(cmp.id) AS categories, 
                                    channels_json(cmp.id) AS channels, 
                                    max(cmp.description) AS campaign_description, 
                                    CASE
                                        WHEN cmp.new_until::timestamp with time zone > (now() + ''1 day''::interval) THEN true
                                        ELSE false
                                    END AS is_new
                                FROM campaigns cmp
                                LEFT JOIN reports_daily rd ON cmp.id = rd.campaign_id'
                                || where_clause || '
                                GROUP BY cmp.id, rd.publisher_id '
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.pubs_reports_transactions_get_list(arg_publisher_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: pubs_rewards_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_rewards_get(arg_publisher_id bigint, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_moy bigint := make_moy(CURRENT_TIMESTAMP);
        var_results json;
    BEGIN        
	SELECT
	    CASE
		WHEN sum(total_pay_out)::numeric > 2500.00 THEN sum(total_pay_out)::numeric * 0.01
		ELSE 0::numeric
	    END AS reward_mtd
	FROM reporting.reports_monthly rm LEFT JOIN campaigns cmp ON rm.campaign_id = cmp.id AND (cmp.currency_id = arg_currency_id OR arg_currency_id IS NULL )
	WHERE rm.publisher_id = arg_publisher_id AND moy = var_moy
        INTO var_results;
        RETURN var_results;
    END
$$;


ALTER FUNCTION w4api.pubs_rewards_get(arg_publisher_id bigint, arg_currency_id bigint) OWNER TO w4;

--
-- Name: pubs_suppression_internal_request_create(bigint, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_suppression_internal_request_create(arg_suppression_id bigint, arg_publisher_id bigint, arg_campaign_id bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
    DECLARE
var_ret_val json;
        var_file_path text;
        var_advertiser_id bigint;
        var_campaign_access int;

    BEGIN
        PERFORM * FROM users WHERE id = arg_publisher_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the publisher id %.', arg_publisher_id;
        END IF;
        
        SELECT
            suf.file_path,
            suf.advertiser_id,
            c.access_type
        FROM campaign_suppression_lists csl
        LEFT JOIN suppression_upload_files suf
            ON csl.suppression_lists_id = suf.id
        LEFT JOIN campaigns c
            ON suf.campaign_id = c.id
        WHERE
            csl.suppression_lists_id = arg_suppression_id AND
            csl.campaign_id = arg_campaign_id
        INTO var_file_path, var_advertiser_id, var_campaign_access;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the campaign id (%) suppression id (%) combination.', arg_suppression_id, arg_campaign_id;
        END IF;

        IF (var_campaign_access > 1) THEN
            PERFORM
                c.id
            FROM campaigns c
            LEFT JOIN campaign_assigned_publishers cap ON c.id = cap.campaign_id
            WHERE
                cap.publisher_id = arg_publisher_id AND
                cap.campaign_id = arg_campaign_id;
            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Publisher does not have access to this campaign.';
            END IF;
        END IF;

        INSERT INTO publisher_suppression_internal_requests
            (list_id, publisher_id, campaign_id, advertiser_id, created_date)
            VALUES (arg_suppression_id, arg_publisher_id, arg_campaign_id, var_advertiser_id, CURRENT_TIMESTAMP);
        
        RETURN var_file_path;
    END;
$$;


ALTER FUNCTION w4api.pubs_suppression_internal_request_create(arg_suppression_id bigint, arg_publisher_id bigint, arg_campaign_id bigint) OWNER TO w4;

--
-- Name: pubs_suppression_optizmo_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_suppression_optizmo_get(arg_campaign_id bigint, arg_publisher_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
	var_ret_val json;
        var_campaign_name text;
        var_advertiser_id bigint;
        var_advertiser_name text;
        var_publisher_name text;
        var_campaign_access int;

    BEGIN
        SELECT
            CONCAT(c.first_name, ' ', c.last_name) AS publisher_name
        FROM users u
        LEFT JOIN contacts c ON u.primary_contact_id = c.id
        WHERE u.id = arg_publisher_id
        INTO var_publisher_name;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the publisher id %.', arg_publisher_id;
        END IF;

        SELECT
            c.advertiser_id,
            c.name,
            a.name,
            c.access_type
        FROM campaigns c
        LEFT JOIN advertisers a ON c.advertiser_id = a.id 
        WHERE c.id = arg_campaign_id
        INTO var_advertiser_id, var_campaign_name, var_advertiser_name, var_campaign_access;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the campaign id %.', arg_campaign_id;
        END IF;

        IF (var_campaign_access > 1) THEN
            PERFORM
                c.id
            FROM campaigns c
            LEFT JOIN campaign_assigned_publishers cap ON c.id = cap.campaign_id
            WHERE
                cap.publisher_id = arg_campaign_id AND
                cap.campaign_id = arg_publisher_id;
            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Publisher does not have access to this campaign.';
            END IF;
        END IF;

        INSERT INTO publisher_suppression_optizmo_requests
            (publisher_id, campaign_id, advertiser_id, created_date)
            VALUES (arg_publisher_id, arg_campaign_id, var_advertiser_id, CURRENT_TIMESTAMP);
        
        var_ret_val := '{"campaign_name": "' || var_campaign_name || '", "advertiser_id": ' || var_advertiser_id || ', "advertiser_name": "' || var_advertiser_name || '", "publisher_name": "' || var_publisher_name || '"}';
        RETURN var_ret_val;
    END;
$$;


ALTER FUNCTION w4api.pubs_suppression_optizmo_get(arg_campaign_id bigint, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: pubs_terms_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_terms_get(arg_publisher_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE 
	ret_val boolean;
    BEGIN	
	RETURN (SELECT CASE WHEN(is_require_renewed_terms > 0) THEN true ELSE false END FROM user_profiles WHERE user_id = arg_publisher_id);
    END;
$$;


ALTER FUNCTION w4api.pubs_terms_get(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: pubs_terms_update(bigint, integer); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION pubs_terms_update(arg_publisher_id bigint, arg_is_require_renewed_terms integer DEFAULT 0) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	BEGIN
		PERFORM id FROM users WHERE access = 'publisher' AND id = arg_publisher_id;
	IF (NOT FOUND) THEN	
		RAISE WARNING 'Invalid Publisher.';
			RETURN false;
	ELSIF(arg_is_require_renewed_terms<0)THEN arg_is_require_renewed_terms=0;
	ELSIF(arg_is_require_renewed_terms>0) THEN arg_is_require_renewed_terms=1;
	END IF;		
	UPDATE user_profiles SET is_require_renewed_terms = arg_is_require_renewed_terms::smallint WHERE user_id = arg_publisher_id RETURNING is_require_renewed_terms INTO arg_is_require_renewed_terms;
	RETURN COALESCE(arg_is_require_renewed_terms::boolean,false);	  
    END;
$$;


ALTER FUNCTION w4api.pubs_terms_update(arg_publisher_id bigint, arg_is_require_renewed_terms integer) OWNER TO w4;

--
-- Name: screenshot_create(text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION screenshot_create(arg_url text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_file_id bigint;
    BEGIN
        INSERT INTO files
            (status, last_modified, user_id)
            VALUES ('pending', CURRENT_TIMESTAMP, 0)
            RETURNING id
            INTO var_file_id;

        INSERT INTO screenshot_queue
            (file_id, url, status)
            VALUES (var_file_id, arg_url, 'pending');
        RETURN var_file_id;
    END;
$$;


ALTER FUNCTION w4api.screenshot_create(arg_url text) OWNER TO w4;

--
-- Name: screenshot_get(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION screenshot_get(arg_file_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;

    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    status
                FROM screenshot_queue
                WHERE file_id = arg_file_id
            ) row
        INTO var_results;

        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4api.screenshot_get(arg_file_id bigint) OWNER TO w4;

--
-- Name: screenshot_queue_get(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION screenshot_queue_get() RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;
        var_queue json;
        var_batch_id bigint;

    BEGIN
        PERFORM * FROM screenshot_queue WHERE batch_id IS NULL;
        IF (FOUND) THEN
            var_batch_id := nextval( 'screenshot_batches_id_seq' );
            UPDATE screenshot_queue SET batch_id = var_batch_id, status = 'processing' WHERE batch_id IS NULL;
            IF (FOUND) THEN
                INSERT INTO screenshot_batches
                    (id, start_time, status)
                    VALUES (var_batch_id, CURRENT_TIMESTAMP, 'processing');

                SELECT
                    array_to_json (array_agg(row_to_json (results)))
                        FROM (
                            SELECT row_to_json (row)
                                FROM (
                                    SELECT
                                        id,
                                        file_id,
                                        url
                                    FROM screenshot_queue
                                    WHERE batch_id = var_batch_id
                            ) row
                    ) results
                INTO var_queue;
                var_results := '{"batch_id": ' || var_batch_id || ', "queue": ' || var_queue || '}';
            END IF;
        END IF;

        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4api.screenshot_queue_get() OWNER TO w4;

--
-- Name: screenshot_queue_update(bigint, public.status_batch); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION screenshot_queue_update(arg_batch_id bigint, arg_status public.status_batch) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        UPDATE screenshot_batches SET status = arg_status, stop_time = CURRENT_TIMESTAMP WHERE id = arg_batch_id;
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.screenshot_queue_update(arg_batch_id bigint, arg_status public.status_batch) OWNER TO w4;

--
-- Name: screenshot_update(bigint, bigint, public.status_batch, text, text, text, text, numeric, numeric); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION screenshot_update(arg_queue_id bigint, arg_file_id bigint, arg_batch_status public.status_batch, arg_file_name text DEFAULT NULL::text, arg_folder text DEFAULT NULL::text, arg_mime_type text DEFAULT NULL::text, arg_extension text DEFAULT NULL::text, arg_width numeric DEFAULT NULL::numeric, arg_height numeric DEFAULT NULL::numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        UPDATE screenshot_queue SET status= arg_batch_status WHERE id = arg_queue_id;
        IF (arg_batch_status = 'complete') THEN
            UPDATE files SET
                file_name = arg_file_name,
                mime_type = arg_mime_type,
                folder = arg_folder,
                width = arg_width,
                height = arg_height,
                status = 'active',
                last_modified = CURRENT_TIMESTAMP,
                user_id = 0,
                extension = arg_extension
            WHERE id = arg_file_id;
        END IF;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.screenshot_update(arg_queue_id bigint, arg_file_id bigint, arg_batch_status public.status_batch, arg_file_name text, arg_folder text, arg_mime_type text, arg_extension text, arg_width numeric, arg_height numeric) OWNER TO w4;

--
-- Name: set_global(text, anyelement); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION set_global(arg_name text, arg_value anyelement) RETURNS void
    LANGUAGE plpgsql
    AS $$

		BEGIN

			PERFORM set_config( 'w4.' || arg_name,  arg_value::text, false );
		END;
	$$;


ALTER FUNCTION w4api.set_global(arg_name text, arg_value anyelement) OWNER TO w4;

--
-- Name: suppression_internal_get(bigint, bigint, timestamp with time zone, timestamp with time zone, text, public.status_entity, public.suppression_scope, public.suppression_format, bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_internal_get(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_list_name text DEFAULT NULL::text, arg_status public.status_entity DEFAULT NULL::public.status_entity, arg_scope public.suppression_scope DEFAULT NULL::public.suppression_scope, arg_format public.suppression_format DEFAULT NULL::public.suppression_format, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (suppression_internal_get_count(arg_advertiser_id, arg_campaign_id, arg_min_date, arg_max_date, arg_list_name, arg_status, arg_scope, arg_format, arg_currency_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || suppression_internal_get_list(arg_advertiser_id, arg_campaign_id, arg_min_date, arg_max_date, arg_list_name, arg_status, arg_scope, arg_format, arg_currency_id, arg_orderby, arg_limit, arg_offset) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.suppression_internal_get(arg_advertiser_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_list_name text, arg_status public.status_entity, arg_scope public.suppression_scope, arg_format public.suppression_format, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: suppression_internal_get_count(bigint, bigint, timestamp with time zone, timestamp with time zone, text, public.status_entity, public.suppression_scope, public.suppression_format, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_internal_get_count(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_list_name text DEFAULT NULL::text, arg_status public.status_entity DEFAULT NULL::public.status_entity, arg_scope public.suppression_scope DEFAULT NULL::public.suppression_scope, arg_format public.suppression_format DEFAULT NULL::public.suppression_format, arg_currency_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'suf.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'suf.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_list_name::TEXT, 'suf.list_name ILIKE $$' || arg_list_name || '$$', where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'suf.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_scope::TEXT, 'suf.scope = $$' || arg_scope || '$$', where_clause);
        where_clause := where_clause_build(arg_format::TEXT, 'suf.format = $$' || arg_format || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'suf.modified_date >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'suf.modified_date < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        EXECUTE
            'SELECT COALESCE (COUNT(1), 0) FROM (
                SELECT
                    suf.advertiser_id,
                    ad.name AS advertiser_name,
                    suf.campaign_id,
                    cmp.name AS campaign_name,
                    suf.list_scope,
                    suf.list_format,
                    suf.list_name,
                    suf.initial_count,
                    suf.cleaned_count,
                    suf.pre_existing_count,
                    suf.matching_count,
                    suf.final_count,
                    suf.status,
                    suf.error_message,
                    suf.modified_by,
                    suf.modified_date
                FROM suppression_upload_files suf
                LEFT JOIN advertisers ad ON (ad.id = suf.advertiser_id)
                LEFT JOIN campaigns cmp ON (cmp.id = suf.campaign_id)
                LEFT JOIN users u ON suf.modified_by = u.id
                LEFT JOIN user_profiles up ON u.id = up.user_id
                LEFT JOIN contacts con ON con.id = u.primary_contact_id '
                || where_clause || '
            ) AS the_count '
        INTO retval;
        RETURN  retval;
    END
$_$;


ALTER FUNCTION w4api.suppression_internal_get_count(arg_advertiser_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_list_name text, arg_status public.status_entity, arg_scope public.suppression_scope, arg_format public.suppression_format, arg_currency_id bigint) OWNER TO w4;

--
-- Name: suppression_internal_get_file(bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_internal_get_file(arg_campaign_id bigint, arg_destination_folder text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        var_advertiser_id bigint;
        var_suppression_id bigint;
        var_file_path text;

    BEGIN
        SELECT advertiser_id FROM campaigns WHERE id = arg_campaign_id INTO var_advertiser_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unknown campaign id (%).', arg_campaign_id;
        END IF;
        
        SELECT row_to_json (row)
            FROM (
               SELECT
                    id,
                    file_path,
                    var_advertiser_id AS advertiser_id,
                    true AS pre_existing
                FROM suppression_upload_files
                WHERE
                    campaign_id = arg_campaign_id AND
                    status = 'active' AND
                    list_scope = 'email' AND
                    list_format = 'plain'
            ) row
        INTO retval;

        --if not current internal suppression file then create one
        IF (retval IS NULL) THEN
            var_file_path := arg_destination_folder || '/' || var_advertiser_id || '/email_plain_' || arg_campaign_id || '.txt';
            INSERT INTO suppression_upload_files
                (advertiser_id, campaign_id, upload_path, file_path, list_scope, list_format, status, modified_date)
                VALUES (var_advertiser_id, arg_campaign_id, 'unsub_prior_to_upload', var_file_path, 'email', 'plain', 'pending', CURRENT_TIMESTAMP)
                RETURNING id
                INTO var_suppression_id;
            retval := '{"id": ' || var_suppression_id || ', "file_path": "' || var_file_path || '", "advertiser_id": ' || var_advertiser_id || ', "pre_existing": false}';
        END IF;


        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.suppression_internal_get_file(arg_campaign_id bigint, arg_destination_folder text) OWNER TO w4;

--
-- Name: suppression_internal_get_list(bigint, bigint, timestamp with time zone, timestamp with time zone, text, public.status_entity, public.suppression_scope, public.suppression_format, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_internal_get_list(arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_min_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_max_date timestamp with time zone DEFAULT NULL::timestamp with time zone, arg_list_name text DEFAULT NULL::text, arg_status public.status_entity DEFAULT NULL::public.status_entity, arg_scope public.suppression_scope DEFAULT NULL::public.suppression_scope, arg_format public.suppression_format DEFAULT NULL::public.suppression_format, arg_currency_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        retval json;
        where_clause TEXT := '';
        order_clause TEXT;

    BEGIN
        where_clause := where_clause_build(arg_advertiser_id::TEXT, 'suf.advertiser_id = ' || arg_advertiser_id, where_clause);
        where_clause := where_clause_build(arg_campaign_id::TEXT, 'suf.campaign_id = ' || arg_campaign_id, where_clause);
        where_clause := where_clause_build(arg_list_name::TEXT, 'suf.list_name ILIKE $$' || arg_list_name || '$$', where_clause);
        where_clause := where_clause_build(arg_status::TEXT, 'suf.status = $$' || arg_status || '$$', where_clause);
        where_clause := where_clause_build(arg_scope::TEXT, 'suf.scope = $$' || arg_scope || '$$', where_clause);
        where_clause := where_clause_build(arg_format::TEXT, 'suf.format = $$' || arg_format || '$$', where_clause);
        where_clause := where_clause_build(arg_min_date::TEXT, 'suf.modified_date >= $$' || arg_min_date || '$$', where_clause);
        where_clause := where_clause_build(arg_max_date::TEXT, 'suf.modified_date < $$' || arg_max_date || '$$', where_clause);
        where_clause := where_clause_build(arg_currency_id::TEXT, 'cmp.currency_id = ' || arg_currency_id, where_clause);

        order_clause := order_clause_build(arg_orderby, 'advertiser_name');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                               SELECT
                                    suf.id AS list_id,
                                    suf.advertiser_id,
                                    ad.name AS advertiser_name,
                                    suf.campaign_id,
                                    cmp.name AS campaign_name,
                                    suf.list_scope,
                                    suf.list_format,
                                    suf.list_name,
                                    suf.initial_count,
                                    suf.cleaned_count,
                                    suf.pre_existing_count,
                                    suf.matching_count,
                                    suf.final_count,
                                    suf.status,
                                    suf.error_message,
                                    suf.modified_by,
                                    CONCAT (COALESCE(con.first_name, up.first_name), '' '', COALESCE(con.last_name, up.last_name)) AS modified_by_name, 
                                    suf.modified_date
                                FROM suppression_upload_files suf
                                LEFT JOIN advertisers ad ON (ad.id = suf.advertiser_id)
                                LEFT JOIN campaigns cmp ON (cmp.id = suf.campaign_id)
                                LEFT JOIN users u ON suf.modified_by = u.id
                                LEFT JOIN user_profiles up ON u.id = up.user_id
                                LEFT JOIN contacts con ON con.id = u.primary_contact_id '
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' ||arg_offset || '
                            ) row
                    ) results;'
        INTO retval;
        RETURN retval;
    END
$_$;


ALTER FUNCTION w4api.suppression_internal_get_list(arg_advertiser_id bigint, arg_campaign_id bigint, arg_min_date timestamp with time zone, arg_max_date timestamp with time zone, arg_list_name text, arg_status public.status_entity, arg_scope public.suppression_scope, arg_format public.suppression_format, arg_currency_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: suppression_internal_path_get(bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_internal_path_get(arg_suppression_id bigint, arg_admin_id bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_file_path text;

    BEGIN
        PERFORM * FROM users WHERE id = arg_admin_id AND access != 'publisher' AND active = 'active';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the admin id %.', arg_admin_id;
        END IF;
        
        SELECT
            suf.file_path
        FROM suppression_upload_files suf
        WHERE suf.id = arg_suppression_id
        INTO var_file_path;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unable to find the internal suppression file %.', arg_suppression_id;
        END IF;
        
        RETURN var_file_path;
    END;
$$;


ALTER FUNCTION w4api.suppression_internal_path_get(arg_suppression_id bigint, arg_admin_id bigint) OWNER TO w4;

--
-- Name: suppression_unsubscribe_create(bigint, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_unsubscribe_create(arg_campaign_id bigint, arg_email text, arg_publisher_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM * FROM campaigns WHERE id = arg_campaign_id;
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Unknown campaign id (%).', arg_campaign_id;
        END IF;

        IF (arg_publisher_id IS NOT NULL) THEN
            PERFORM * FROM users WHERE id = arg_publisher_id AND access = 'publisher';
            IF (NOT FOUND) THEN
                RAISE EXCEPTION 'Unknown publisher id (%).', arg_publisher_id;
            END IF;
        END IF;

        INSERT INTO suppression_unsubscribe_queue
            (campaign_id, publisher_id, email, created_date)
            VALUES (arg_campaign_id, arg_publisher_id, arg_email, CURRENT_TIMESTAMP);
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.suppression_unsubscribe_create(arg_campaign_id bigint, arg_email text, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: suppression_unsubscribe_file_create(bigint, bigint, bigint, bigint, bigint, bigint, public.status_entity, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_unsubscribe_file_create(arg_suppression_id bigint, arg_initial_count bigint DEFAULT NULL::bigint, arg_pre_existing_count bigint DEFAULT NULL::bigint, arg_matching_count bigint DEFAULT NULL::bigint, arg_final_count bigint DEFAULT NULL::bigint, arg_batch_id bigint DEFAULT NULL::bigint, arg_status public.status_entity DEFAULT 'pending'::public.status_entity, arg_error_message text DEFAULT NULL::text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN
        PERFORM * FROM suppression_upload_files WHERE id = arg_suppression_id AND status = 'active';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Suppression id (%) does not exist or is not active.', arg_suppression_id;
        END IF;
        
        INSERT INTO suppression_unsubscribe_files
            (suppression_id, initial_count, pre_existing_count, matching_count, final_count, status, error_message, modified_date)
            VALUES (arg_suppression_id, arg_initial_count, arg_pre_existing_count, arg_matching_count, arg_final_count, arg_status, arg_error_message, CURRENT_TIMESTAMP)
            RETURNING id
            INTO var_id;

        RETURN var_id;
    END
$$;


ALTER FUNCTION w4api.suppression_unsubscribe_file_create(arg_suppression_id bigint, arg_initial_count bigint, arg_pre_existing_count bigint, arg_matching_count bigint, arg_final_count bigint, arg_batch_id bigint, arg_status public.status_entity, arg_error_message text) OWNER TO w4;

--
-- Name: suppression_unsubscribe_get(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_unsubscribe_get() RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;
        var_queue json;
        var_batch_id bigint;

    BEGIN
        PERFORM * FROM suppression_unsubscribe_queue WHERE batch_id IS NULL;
        IF (FOUND) THEN
            var_batch_id := nextval('suppression_unsubscribe_batches_id_seq');
            UPDATE suppression_unsubscribe_queue SET batch_id = var_batch_id WHERE batch_id IS NULL;
            IF (FOUND) THEN
                INSERT INTO suppression_unsubscribe_batches
                    (id, start_time, status)
                    VALUES (var_batch_id, CURRENT_TIMESTAMP, 'processing');

                SELECT
                    array_to_json (array_agg(row_to_json (results)))
                        FROM (
                            SELECT row_to_json (row)
                                FROM (
                                    SELECT DISTINCT
                                        campaign_id,
                                        email
                                    FROM suppression_unsubscribe_queue
                                    WHERE batch_id = var_batch_id
                                    ORDER BY campaign_id, email
                            ) row
                    ) results
                INTO var_queue;
                var_results := '{"batch_id": ' || var_batch_id || ', "queue": ' || var_queue || '}';
            END IF;
        END IF;

        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4api.suppression_unsubscribe_get() OWNER TO w4;

--
-- Name: suppression_unsubscribe_update(bigint, public.status_batch, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_unsubscribe_update(arg_batch_id bigint, arg_status public.status_batch, arg_message text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        UPDATE suppression_unsubscribe_batches SET
            status = arg_status,
            message = arg_message,           
            stop_time = CURRENT_TIMESTAMP
        WHERE id = arg_batch_id;
        RETURN TRUE;
    END
$$;


ALTER FUNCTION w4api.suppression_unsubscribe_update(arg_batch_id bigint, arg_status public.status_batch, arg_message text) OWNER TO w4;

--
-- Name: suppression_upload_batch_update(bigint, public.status_batch, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_upload_batch_update(arg_batch_id bigint, arg_status public.status_batch, arg_message text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_stop_time timestamp with time zone := null;
    BEGIN
        IF ((arg_status = 'complete') OR (arg_status = 'failed')) THEN
            var_stop_time := CURRENT_TIMESTAMP;
        END IF;

        UPDATE suppression_upload_batches SET
            status      = arg_status,
            stop_time   = var_stop_time,
            message     = arg_message
        WHERE id = arg_batch_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.suppression_upload_batch_update(arg_batch_id bigint, arg_status public.status_batch, arg_message text) OWNER TO w4;

--
-- Name: suppression_upload_create(text, public.suppression_scope, public.suppression_format, bigint, bigint, public.status_entity, text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_upload_create(arg_upload_file_path text, arg_list_scope public.suppression_scope, arg_list_format public.suppression_format, arg_advertiser_id bigint DEFAULT NULL::bigint, arg_campaign_id bigint DEFAULT NULL::bigint, arg_status public.status_entity DEFAULT 'pending'::public.status_entity, arg_error_message text DEFAULT NULL::text, arg_manager_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_id bigint;
    BEGIN
        IF ((arg_advertiser_id IS NULL) AND (arg_campaign_id IS NULL)) THEN
            RAISE EXCEPTION 'Must have a campaign or advertiser id to proceed.'; 
        END IF;

        IF (arg_advertiser_id IS NULL) THEN
            SELECT advertiser_id FROM campaigns WHERE id = arg_campaign_id INTO arg_advertiser_id;
        END IF;

        PERFORM * FROM advertisers WHERE id = arg_advertiser_id AND status = 'active';
        IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Advertiser id (%) is not active or does not exist.', arg_advertiser_id;
        END IF;
        
        INSERT INTO suppression_upload_files
            (advertiser_id, campaign_id, upload_path, list_scope, list_format, status, error_message, modified_date, modified_by)
            VALUES (arg_advertiser_id, arg_campaign_id, arg_upload_file_path, arg_list_scope, arg_list_format, arg_status, arg_error_message, CURRENT_TIMESTAMP, arg_manager_id)
            RETURNING id
            INTO var_id;

        RETURN var_id;
    END
$$;


ALTER FUNCTION w4api.suppression_upload_create(arg_upload_file_path text, arg_list_scope public.suppression_scope, arg_list_format public.suppression_format, arg_advertiser_id bigint, arg_campaign_id bigint, arg_status public.status_entity, arg_error_message text, arg_manager_id bigint) OWNER TO w4;

--
-- Name: suppression_upload_get_pending(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_upload_get_pending() RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;
        var_files json;
        var_batch_id bigint;

    BEGIN
        PERFORM * FROM suppression_upload_files WHERE batch_id IS NULL;
        IF (FOUND) THEN
            INSERT INTO suppression_upload_batches
                (start_time, status)
                VALUES (CURRENT_TIMESTAMP, 'processing')
                RETURNING id
                INTO var_batch_id;
            UPDATE suppression_upload_files SET batch_id = var_batch_id WHERE batch_id IS NULL;
            SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row) FROM (
                            SELECT
                                id,
                                advertiser_id,
                                campaign_id,
                                upload_path AS path,
                                list_scope,
                                list_format,
                                modified_by
                            FROM suppression_upload_files
                            WHERE batch_id = var_batch_id
                        ) row
                    ) results
            INTO var_files;
            var_results := '{"batch_id": ' || var_batch_id || ', "files": ' || var_files || '}';
        END IF;
     
        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4api.suppression_upload_get_pending() OWNER TO w4;

--
-- Name: suppression_upload_get_status(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_upload_get_status(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_results json;
    BEGIN
        SELECT
            array_to_json (array_agg(row_to_json (results)))
                FROM (
                    SELECT row_to_json (row) FROM (
                        SELECT
                            status,
                            file_path
                        FROM suppression_upload_files
                        WHERE id = arg_id
                    ) row
                ) results
        INTO var_results;
     
        RETURN COALESCE(var_results, '{}');
    END
$$;


ALTER FUNCTION w4api.suppression_upload_get_status(arg_id bigint) OWNER TO w4;

--
-- Name: suppression_upload_update(bigint, text, text, bigint, bigint, bigint, bigint, bigint, public.status_batch, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION suppression_upload_update(arg_id bigint, arg_destination_path text DEFAULT NULL::text, arg_file_name text DEFAULT NULL::text, arg_initial_count bigint DEFAULT NULL::bigint, arg_cleaned_count bigint DEFAULT NULL::bigint, arg_pre_existing_count bigint DEFAULT NULL::bigint, arg_matching_count bigint DEFAULT NULL::bigint, arg_final_count bigint DEFAULT NULL::bigint, arg_status public.status_batch DEFAULT NULL::public.status_batch, arg_error_message text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
        var_status status_entity;

    BEGIN
        PERFORM id FROM suppression_upload_files WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified suppression file upload record (%).', arg_id;
        END IF;

        IF (arg_status = 'complete') THEN
            UPDATE suppression_upload_files SET status = 'inactive' WHERE status = 'active' AND file_path = arg_destination_path;
            var_status = 'active';
        ELSE
            var_status = 'inactive';
        END IF;

        UPDATE suppression_upload_files SET            
            file_path           = COALESCE (arg_destination_path, file_path),
            list_name           = COALESCE (arg_file_name, list_name),
            initial_count       = COALESCE (arg_initial_count, initial_count),
            cleaned_count       = COALESCE (arg_cleaned_count, cleaned_count),
            pre_existing_count  = COALESCE (arg_pre_existing_count, pre_existing_count),
            matching_count      = COALESCE (arg_matching_count, matching_count),
            final_count         = COALESCE (arg_final_count, final_count),
            status              = COALESCE (var_status, status),
            error_message       = COALESCE (arg_error_message, error_message),
            modified_date       = CURRENT_TIMESTAMP
        WHERE id = arg_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.suppression_upload_update(arg_id bigint, arg_destination_path text, arg_file_name text, arg_initial_count bigint, arg_cleaned_count bigint, arg_pre_existing_count bigint, arg_matching_count bigint, arg_final_count bigint, arg_status public.status_batch, arg_error_message text) OWNER TO w4;

--
-- Name: tracking_domains_create(text, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION tracking_domains_create(arg_name text, arg_publisher_id bigint DEFAULT NULL::bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        INSERT INTO tracking_domains
            (publisher_id, name)
            VALUES (arg_publisher_id, arg_name);

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.tracking_domains_create(arg_name text, arg_publisher_id bigint) OWNER TO w4;

--
-- Name: tracking_domains_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION tracking_domains_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM tracking_domains WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified tracking domain (%).', arg_id;
        END IF;

        DELETE FROM tracking_domains WHERE id = arg_id;

        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.tracking_domains_delete(arg_id bigint) OWNER TO w4;

--
-- Name: tracking_domains_get(bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION tracking_domains_get(arg_publisher_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        count_total bigint;
        entity_where TEXT;
    BEGIN
        IF arg_count THEN
            SELECT INTO count_total COALESCE (tracking_domains_get_count(arg_publisher_id), 0);
        ELSE
            count_total := -1;
        END IF;

        retval := 
        (
                '{' || 
                        '"results": ' || tracking_domains_get_list(null, arg_publisher_id) ||
                        ', "count": ' || count_total
                || '}'
        )::json;

        RETURN retval;
    END
$$;


ALTER FUNCTION w4api.tracking_domains_get(arg_publisher_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: tracking_domains_get_count(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION tracking_domains_get_count(arg_publisher_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
    DECLARE
        retval json;
        where_clause TEXT := '';
    BEGIN
        IF (arg_publisher_id IS NOT NULL) THEN
            where_clause := ' WHERE publisher_id = ' || arg_publisher_id;
        ELSE
            where_clause := ' WHERE publisher_id IS NULL';
        END IF;

        EXECUTE
            'SELECT 
            COALESCE (COUNT(1), 0)
            FROM tracking_domains '
            || where_clause ||
            ' LIMIT 1; '
        INTO retval;
        RETURN  retval;
    END
$$;


ALTER FUNCTION w4api.tracking_domains_get_count(arg_publisher_id bigint) OWNER TO w4;

--
-- Name: tracking_domains_get_list(bigint, bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION tracking_domains_get_list(arg_id bigint DEFAULT NULL::bigint, arg_publisher_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;

    BEGIN
        IF (arg_id IS NULL) THEN
            IF (arg_publisher_id IS NOT NULL) THEN
                where_clause := ' WHERE td.publisher_id = ' || arg_publisher_id;
            ELSE
                where_clause := ' WHERE td.publisher_id IS NULL';
            END IF;
        ELSE
            where_clause := ' WHERE td.id = ' || arg_id;
        END IF;

        order_clause := order_clause_build(arg_orderby, 'name ASC');

        EXECUTE
            'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (
                        SELECT row_to_json (row)
                            FROM (
                                SELECT
                                    td.id,
                                    td.publisher_id,
                                    COALESCE(up.company_name, pg_catalog.concat(up.first_name, CHR(1), up.last_name)::character varying) AS publisher_name, 
                                    td.name
                                FROM tracking_domains td
                                LEFT JOIN users u ON td.publisher_id = u.id
                                LEFT JOIN user_profiles up ON (u.id = up.user_id) '
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END
$$;


ALTER FUNCTION w4api.tracking_domains_get_list(arg_id bigint, arg_publisher_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

--
-- Name: tracking_domains_update(bigint, text); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION tracking_domains_update(arg_id bigint, arg_name text) RETURNS json
    LANGUAGE plpgsql
    AS $$
    BEGIN
        PERFORM id FROM tracking_domains WHERE id = arg_id;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Unable to find the specified tracking domain (%).', arg_id;
        END IF;

        UPDATE tracking_domains SET            
            name     = COALESCE (arg_name, name)
        WHERE id = arg_id;

        RETURN tracking_domains_get_list(arg_id);
    END;
$$;


ALTER FUNCTION w4api.tracking_domains_update(arg_id bigint, arg_name text) OWNER TO w4;

--
-- Name: try_cast(anyelement); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION try_cast(arg_value anyelement) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
	BEGIN

		RETURN arg_value::bigint;

	EXCEPTION WHEN others THEN

		RETURN NULL::bigint;

	END;
$$;


ALTER FUNCTION w4api.try_cast(arg_value anyelement) OWNER TO w4;

--
-- Name: udpate_user_from_tmp(); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION udpate_user_from_tmp() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    var_ret_val boolean;
    tmp RECORD;
    usr RECORD;
    newuser RECORD;
    taken RECORD;
    BEGIN
	    SELECT INTO usr * FROM users WHERE access = 'publisher';
	    FOR tmp IN SELECT * FROM users_tmp
	    LOOP
		taken := NULL;
		SELECT INTO taken * FROM users WHERE id = tmp.id;
		IF taken.id NOTNULL THEN
		    UPDATE 
		    users SET 
			email = tmp.email, 
			parent_id = tmp.parent_id, 
			manager_id = tmp.manager_id, 
			active = tmp.active, 
			access = tmp.access, 
			ip_address = tmp.ip_address, 
			modified = tmp.modified, 
			login_name = tmp.login_name,
			referrer_id = tmp.referrer_id
		    WHERE id = tmp.id;
		ELSE
		    INSERT INTO users
		     (uuid, id, email, password, parent_id,manager_id,active,access,ip_address,last_login,created, modified, login_name, referrer_id)
		     VALUES (tmp.uuid, tmp.id, tmp.email, tmp.password, tmp.parent_id, tmp.manager_id, tmp.active, tmp.access, tmp.ip_address, tmp.last_login, tmp.created, tmp.modified, tmp.login_name, tmp.referrer_id);
		END IF;
		--SELECT INTO newuser * FROM users WHERE access = 'publisher' AND id = tmp.id;
		--IF  newuser.id = tmp.id THEN
		   --DELETE FROM users_tmp WHERE id = tmp.id;
		--END IF;
	    END LOOP;
	    RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.udpate_user_from_tmp() OWNER TO w4;

--
-- Name: user_profile_get_details(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION user_profile_get_details(arg_id bigint) RETURNS json
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ret_val json;
    BEGIN
        SELECT row_to_json (row)
            FROM (
                SELECT
                    usr.id
                    , usr.email
                    , COALESCE(con.first_name, usp.first_name) AS first_name
                    , COALESCE(con.last_name, usp.last_name) AS last_name
                    , usr.login_name
                    , usr.manager_id AS manager_id
                    , CONCAT (COALESCE(mcon.first_name, mup.first_name), ' ', COALESCE(mcon.last_name, mup.last_name)) AS manager_name
                    , COALESCE(con.primary_phone, usp.phone) AS primary_phone
                    , COALESCE(con.messenger_name, usp.messenger_id) AS messenger_name
                    , COALESCE(con.messenger_type, usp.messenger_type) AS messenger_type
                    , usp.image_id
                    , usr.access
                FROM users usr 
		LEFT JOIN user_profiles usp 
                    ON usr.id = usp.user_id 
                LEFT JOIN contacts con
                    ON con.id = usr.primary_contact_id
                LEFT JOIN users mgr
                    ON mgr.id = usr.manager_id
                LEFT JOIN contacts mcon
                    ON mcon.id = mgr.primary_contact_id
		LEFT JOIN user_profiles mup 
                    ON mup.user_id = mgr.id 
                WHERE
                    usr.id = arg_id
                    AND usr.access != 'publisher'
                    AND usr.active = 'active'
            ) row
        INTO ret_val;

        IF NOT FOUND THEN
            PERFORM * FROM users WHERE users.id = arg_id AND users.access != 'publisher';
            IF NOT FOUND THEN
                    RAISE EXCEPTION 'The user id [%] does not exist for any user or administrator.', arg_id;
            END IF;
        END IF;
        RETURN ret_val;

    END;
$$;


ALTER FUNCTION w4api.user_profile_get_details(arg_id bigint) OWNER TO w4;

--
-- Name: user_profiles_delete(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION user_profiles_delete(arg_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE
    BEGIN
        UPDATE users SET active='banned' WHERE id=arg_id;
        RETURN TRUE;
    END;
$$;


ALTER FUNCTION w4api.user_profiles_delete(arg_id bigint) OWNER TO w4;

--
-- Name: user_profiles_get(bigint, text, bigint, bigint, boolean); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION user_profiles_get(arg_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint, arg_count boolean DEFAULT NULL::boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
            ret_val json;
            count_total bigint;
	BEGIN
            IF arg_count THEN
                SELECT INTO count_total COALESCE (user_profiles_get_count(arg_id), 0);
            ELSE
                count_total := -1;
            END IF;
            ret_val :=
            (
                    '{' ||
                            '"results": ' || user_profiles_get_list(arg_id, arg_orderby, arg_limit, arg_offset) ||
                            ', "count": ' || count_total
                    || '}'
            )::json;
            RETURN ret_val;
      END
$$;


ALTER FUNCTION w4api.user_profiles_get(arg_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint, arg_count boolean) OWNER TO w4;

--
-- Name: user_profiles_get_count(bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION user_profiles_get_count(arg_id bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val bigint;
        where_clause text := '';

    BEGIN
        where_clause := where_clause_build(arg_id::TEXT, 'usr.id = ' || arg_id, where_clause);
        where_clause := where_clause_build('admin', 'usr.access != $$publisher$$'  , where_clause);
        where_clause := where_clause_build('active', 'usr.active = $$active$$'  , where_clause);

        EXECUTE
            'SELECT
                COALESCE (COUNT(1), 0) FROM (
                    SELECT usr.id AS id
                        , usr.manager_id AS user_id
                        , CONCAT (con.first_name,'' '', con.last_name) AS full_name
                        , con.first_name AS first_name
                        , con.last_name AS last_name
                        , usr.login_name AS login_name
                        , CONCAT (mcon.first_name, '' '', mcon.last_name) AS user_name
                        , usr.email AS email_address
                        , con.primary_phone AS primary_phone
                        , con.messenger_name AS messenger_name
                        , con.messenger_type AS messenger_type
                        , up.image_id AS image_id
                        , usr.access
                    FROM users usr
                    LEFT JOIN user_profiles up
                        ON up.user_id = usr.id
                    LEFT JOIN contacts con
                        ON con.id = usr.primary_contact_id
                    LEFT JOIN users mgr
                        ON mgr.id = usr.manager_id
                    LEFT JOIN contacts mcon
                        ON mcon.id = mgr.primary_contact_id'
                    || where_clause || ') the_count;'
        INTO ret_val;
        RETURN ret_val;
    END
$_$;


ALTER FUNCTION w4api.user_profiles_get_count(arg_id bigint) OWNER TO w4;

--
-- Name: user_profiles_get_list(bigint, text, bigint, bigint); Type: FUNCTION; Schema: w4api; Owner: w4
--

CREATE FUNCTION user_profiles_get_list(arg_id bigint DEFAULT NULL::bigint, arg_orderby text DEFAULT NULL::text, arg_limit bigint DEFAULT NULL::bigint, arg_offset bigint DEFAULT (0)::bigint) RETURNS json
    LANGUAGE plpgsql
    AS $_$
    DECLARE
        ret_val json;
        where_clause text := '';
        order_clause text;

    BEGIN
        where_clause := where_clause_build(arg_id::TEXT, 'usr.id = ' || arg_id, where_clause);
        where_clause := where_clause_build('admin', 'usr.access != $$publisher$$'  , where_clause);
        where_clause := where_clause_build('active', 'usr.active = $$active$$'  , where_clause);
        order_clause := order_clause_build(arg_orderby, 'con.first_name');

        EXECUTE
	'SELECT
                array_to_json (array_agg(row_to_json (results)))
                    FROM (        
                        SELECT row_to_json (row)
                            FROM (
                                SELECT usr.id AS id
                                    , usr.manager_id AS user_id
                                    , CONCAT (con.first_name,'' '', con.last_name) AS full_name
                                    , con.first_name AS first_name
                                    , con.last_name AS last_name
                                    , usr.login_name AS login_name
                                    , CONCAT (mcon.first_name, '' '', mcon.last_name) AS user_name
                                    , usr.email AS email_address
                                    , con.primary_phone AS primary_phone
                                    , con.messenger_name AS messenger_name
                                    , con.messenger_type AS messenger_type
                                    , up.image_id AS image_id
                                    , usr.access
                                FROM users usr
                                LEFT JOIN user_profiles up
                                    ON up.user_id = usr.id
                                LEFT JOIN contacts con
                                    ON con.id = usr.primary_contact_id
                                LEFT JOIN users mgr
                                    ON mgr.id = usr.manager_id
                                LEFT JOIN contacts mcon
                                    ON mcon.id = mgr.primary_contact_id'
                                || where_clause
                                || order_clause || '
                                LIMIT ' || COALESCE(arg_limit::text, 'ALL') || '
                                OFFSET ' || arg_offset || '
                            ) row
                    ) results;'
        INTO ret_val;
        RETURN ret_val;
    END;
$_$;


ALTER FUNCTION w4api.user_profiles_get_list(arg_id bigint, arg_orderby text, arg_limit bigint, arg_offset bigint) OWNER TO w4;

SET search_path = topology, pg_catalog;

--
-- Name: topoelementarray_agg(topoelement); Type: AGGREGATE; Schema: topology; Owner: w4
--

CREATE AGGREGATE topoelementarray_agg(topoelement) (
    SFUNC = topoelementarray_append,
    STYPE = topoelementarray
);


ALTER AGGREGATE topology.topoelementarray_agg(topoelement) OWNER TO w4;

--
-- Name: AGGREGATE topoelementarray_agg(topoelement); Type: COMMENT; Schema: topology; Owner: w4
--

COMMENT ON AGGREGATE topoelementarray_agg(topoelement) IS 'args: tefield - Returns a topoelementarray for a set of element_id, type arrays (topoelements)';


SET search_path = "ACL", pg_catalog;

--
-- Name: acl_group_management; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE acl_group_management (
    id bigint NOT NULL,
    manager_group_id integer NOT NULL,
    managed_group_id integer NOT NULL,
    CONSTRAINT acl_group_management_managed_group_id_check CHECK ((managed_group_id >= 0)),
    CONSTRAINT acl_group_management_manager_group_id_check CHECK ((manager_group_id >= 0))
);


ALTER TABLE "ACL".acl_group_management OWNER TO w4;

--
-- Name: acl_group_management_id_seq; Type: SEQUENCE; Schema: ACL; Owner: w4
--

CREATE SEQUENCE acl_group_management_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "ACL".acl_group_management_id_seq OWNER TO w4;

--
-- Name: acl_group_management_id_seq; Type: SEQUENCE OWNED BY; Schema: ACL; Owner: w4
--

ALTER SEQUENCE acl_group_management_id_seq OWNED BY acl_group_management.id;


--
-- Name: acl_group_privileges; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE acl_group_privileges (
    group_id integer DEFAULT 0 NOT NULL,
    resource_id integer DEFAULT 0 NOT NULL,
    privilege_id smallint NOT NULL,
    CONSTRAINT acl_group_privileges_group_id_check CHECK ((group_id >= 0)),
    CONSTRAINT acl_group_privileges_privilege_id_check CHECK ((privilege_id >= 0)),
    CONSTRAINT acl_group_privileges_resource_id_check CHECK ((resource_id >= 0))
);


ALTER TABLE "ACL".acl_group_privileges OWNER TO w4;

--
-- Name: acl_groups; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE acl_groups (
    id bigint NOT NULL,
    static_id smallint,
    name character varying(128) NOT NULL,
    CONSTRAINT acl_groups_static_id_check CHECK ((static_id >= 0))
);


ALTER TABLE "ACL".acl_groups OWNER TO w4;

--
-- Name: acl_groups_id_seq; Type: SEQUENCE; Schema: ACL; Owner: w4
--

CREATE SEQUENCE acl_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "ACL".acl_groups_id_seq OWNER TO w4;

--
-- Name: acl_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: ACL; Owner: w4
--

ALTER SEQUENCE acl_groups_id_seq OWNED BY acl_groups.id;


--
-- Name: acl_resources; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE acl_resources (
    id bigint NOT NULL,
    parent_id integer,
    description character varying(128) NOT NULL,
    resource character varying(128) NOT NULL,
    CONSTRAINT acl_resources_parent_id_check CHECK ((parent_id >= 0))
);


ALTER TABLE "ACL".acl_resources OWNER TO w4;

--
-- Name: acl_resources_id_seq; Type: SEQUENCE; Schema: ACL; Owner: w4
--

CREATE SEQUENCE acl_resources_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "ACL".acl_resources_id_seq OWNER TO w4;

--
-- Name: acl_resources_id_seq; Type: SEQUENCE OWNED BY; Schema: ACL; Owner: w4
--

ALTER SEQUENCE acl_resources_id_seq OWNED BY acl_resources.id;


--
-- Name: acl_user_groups; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE acl_user_groups (
    user_id integer DEFAULT 0 NOT NULL,
    group_id integer DEFAULT 0 NOT NULL,
    CONSTRAINT acl_user_groups_group_id_check CHECK ((group_id >= 0)),
    CONSTRAINT acl_user_groups_user_id_check CHECK ((user_id >= 0))
);


ALTER TABLE "ACL".acl_user_groups OWNER TO w4;

--
-- Name: acl_user_privileges; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE acl_user_privileges (
    resource_id integer DEFAULT 0 NOT NULL,
    user_id integer DEFAULT 0 NOT NULL,
    privilege_id smallint NOT NULL,
    CONSTRAINT acl_user_privileges_privilege_id_check CHECK ((privilege_id >= 0)),
    CONSTRAINT acl_user_privileges_resource_id_check CHECK ((resource_id >= 0)),
    CONSTRAINT acl_user_privileges_user_id_check CHECK ((user_id >= 0))
);


ALTER TABLE "ACL".acl_user_privileges OWNER TO w4;

--
-- Name: controller_group_privileges; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE controller_group_privileges (
    id bigint NOT NULL,
    group_id integer DEFAULT 0 NOT NULL,
    resource_id integer DEFAULT 0 NOT NULL,
    CONSTRAINT group_privileges_group_id_check CHECK ((group_id >= 0)),
    CONSTRAINT group_privileges_resource_id_check CHECK ((resource_id >= 0))
);


ALTER TABLE "ACL".controller_group_privileges OWNER TO w4;

--
-- Name: controller_group_privileges_id_seq; Type: SEQUENCE; Schema: ACL; Owner: w4
--

CREATE SEQUENCE controller_group_privileges_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "ACL".controller_group_privileges_id_seq OWNER TO w4;

--
-- Name: controller_group_privileges_id_seq; Type: SEQUENCE OWNED BY; Schema: ACL; Owner: w4
--

ALTER SEQUENCE controller_group_privileges_id_seq OWNED BY controller_group_privileges.id;


--
-- Name: controller_resources; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE controller_resources (
    id bigint NOT NULL,
    name text NOT NULL,
    action text NOT NULL
);


ALTER TABLE "ACL".controller_resources OWNER TO w4;

--
-- Name: file_group_privileges; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE file_group_privileges (
    id bigint NOT NULL,
    group_id integer DEFAULT 0 NOT NULL,
    resource_id integer DEFAULT 0 NOT NULL,
    CONSTRAINT group_privileges_group_id_check CHECK ((group_id >= 0)),
    CONSTRAINT group_privileges_resource_id_check CHECK ((resource_id >= 0))
);


ALTER TABLE "ACL".file_group_privileges OWNER TO w4;

--
-- Name: file_group_privileges_id_seq; Type: SEQUENCE; Schema: ACL; Owner: w4
--

CREATE SEQUENCE file_group_privileges_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "ACL".file_group_privileges_id_seq OWNER TO w4;

--
-- Name: file_group_privileges_id_seq; Type: SEQUENCE OWNED BY; Schema: ACL; Owner: w4
--

ALTER SEQUENCE file_group_privileges_id_seq OWNED BY file_group_privileges.id;


--
-- Name: file_resources; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE file_resources (
    id bigint NOT NULL,
    name text NOT NULL,
    crud text NOT NULL
);


ALTER TABLE "ACL".file_resources OWNER TO w4;

--
-- Name: groups; Type: TABLE; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE TABLE groups (
    id integer NOT NULL,
    name character varying(128) NOT NULL
);


ALTER TABLE "ACL".groups OWNER TO w4;

--
-- Name: vw_acl_group_priv; Type: VIEW; Schema: ACL; Owner: w4
--

CREATE VIEW vw_acl_group_priv AS
 SELECT max(ag.id) AS id,
    max(ag.static_id) AS static_id,
    max((ag.name)::text) AS name,
    string_agg((agp.resource_id)::text, ','::text) AS resource,
    string_agg((agp.privilege_id)::text, ','::text) AS priv
   FROM (acl_groups ag
   LEFT JOIN acl_group_privileges agp ON ((ag.id = agp.group_id)))
  GROUP BY agp.group_id
  ORDER BY agp.group_id;


ALTER TABLE "ACL".vw_acl_group_priv OWNER TO w4;

SET search_path = "Accounting", pg_catalog;

--
-- Name: acct_conversion_ledger_id_seq; Type: SEQUENCE; Schema: Accounting; Owner: w4
--

CREATE SEQUENCE acct_conversion_ledger_id_seq
    START WITH 2094980
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Accounting".acct_conversion_ledger_id_seq OWNER TO w4;

--
-- Name: acct_conversion_ledger; Type: TABLE; Schema: Accounting; Owner: w4; Tablespace: 
--

CREATE TABLE acct_conversion_ledger (
    id bigint DEFAULT nextval('acct_conversion_ledger_id_seq'::regclass) NOT NULL,
    internal_ledger_id bigint,
    conversion_id bigint,
    transaction_type bigint DEFAULT (1000)::bigint,
    advertiser_id bigint,
    campaign_id bigint,
    publisher_id bigint,
    publisher_pid bigint,
    pay_in_amt numeric(20,4) DEFAULT NULL::numeric,
    pay_out_amt numeric(20,4) DEFAULT NULL::numeric,
    click_date_time timestamp with time zone,
    conversion_date_time timestamp with time zone,
    i_hoy integer,
    i_doy integer,
    i_woy integer,
    i_moy integer,
    i_qoy integer,
    i_y integer,
    a_hoy integer,
    a_doy integer,
    a_woy integer,
    a_moy integer,
    a_qoy integer,
    a_y integer,
    p_hoy integer,
    p_doy integer,
    p_woy integer,
    p_moy integer,
    p_qoy integer,
    p_y integer,
    profit numeric(20,4) DEFAULT NULL::numeric,
    margin numeric(5,2) DEFAULT NULL::numeric,
    status integer DEFAULT 1,
    advertiser_invoice_status integer,
    publisher_invoice_status integer,
    parent_payout money,
    parent_publisher_invoice_status integer
);


ALTER TABLE "Accounting".acct_conversion_ledger OWNER TO w4;

--
-- Name: acct_invoices_publisher; Type: TABLE; Schema: Accounting; Owner: w4; Tablespace: 
--

CREATE TABLE acct_invoices_publisher (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    min_doy bigint NOT NULL,
    max_doy bigint NOT NULL,
    conversion_total bigint DEFAULT (0)::bigint,
    payout_total money DEFAULT (0)::money,
    status public.status_invoice DEFAULT 'unpaid'::public.status_invoice NOT NULL,
    created_date timestamp with time zone DEFAULT now() NOT NULL,
    admin_id bigint NOT NULL,
    memo text,
    currency_id bigint DEFAULT 1 NOT NULL,
    paid_date timestamp with time zone
);


ALTER TABLE "Accounting".acct_invoices_publisher OWNER TO w4;

--
-- Name: acct_invoices_publisher_adjustments; Type: TABLE; Schema: Accounting; Owner: w4; Tablespace: 
--

CREATE TABLE acct_invoices_publisher_adjustments (
    id bigint NOT NULL,
    invoice_id bigint NOT NULL,
    line_item_id bigint,
    campaign_id bigint NOT NULL,
    conversions bigint NOT NULL,
    payout money NOT NULL,
    admin_id bigint NOT NULL,
    change_date timestamp with time zone DEFAULT now() NOT NULL,
    doy bigint,
    memo text
);


ALTER TABLE "Accounting".acct_invoices_publisher_adjustments OWNER TO w4;

--
-- Name: acct_invoices_publisher_adjustments_id_seq; Type: SEQUENCE; Schema: Accounting; Owner: w4
--

CREATE SEQUENCE acct_invoices_publisher_adjustments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Accounting".acct_invoices_publisher_adjustments_id_seq OWNER TO w4;

--
-- Name: acct_invoices_publisher_adjustments_id_seq; Type: SEQUENCE OWNED BY; Schema: Accounting; Owner: w4
--

ALTER SEQUENCE acct_invoices_publisher_adjustments_id_seq OWNED BY acct_invoices_publisher_adjustments.id;


--
-- Name: acct_invoices_publisher_id_seq; Type: SEQUENCE; Schema: Accounting; Owner: w4
--

CREATE SEQUENCE acct_invoices_publisher_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Accounting".acct_invoices_publisher_id_seq OWNER TO w4;

--
-- Name: acct_invoices_publisher_id_seq; Type: SEQUENCE OWNED BY; Schema: Accounting; Owner: w4
--

ALTER SEQUENCE acct_invoices_publisher_id_seq OWNED BY acct_invoices_publisher.id;


--
-- Name: acct_invoices_publisher_line_items; Type: TABLE; Schema: Accounting; Owner: w4; Tablespace: 
--

CREATE TABLE acct_invoices_publisher_line_items (
    id bigint NOT NULL,
    invoice_id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    payout money DEFAULT (0)::money NOT NULL,
    conversions integer DEFAULT 0 NOT NULL,
    memo text
);


ALTER TABLE "Accounting".acct_invoices_publisher_line_items OWNER TO w4;

--
-- Name: acct_invoices_publisher_line_items_id_seq; Type: SEQUENCE; Schema: Accounting; Owner: w4
--

CREATE SEQUENCE acct_invoices_publisher_line_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "Accounting".acct_invoices_publisher_line_items_id_seq OWNER TO w4;

--
-- Name: acct_invoices_publisher_line_items_id_seq; Type: SEQUENCE OWNED BY; Schema: Accounting; Owner: w4
--

ALTER SEQUENCE acct_invoices_publisher_line_items_id_seq OWNED BY acct_invoices_publisher_line_items.id;


SET search_path = ftp, pg_catalog;

--
-- Name: user; Type: TABLE; Schema: ftp; Owner: w4; Tablespace: 
--

CREATE TABLE "user" (
    id bigint NOT NULL,
    username character varying(30) NOT NULL,
    password text NOT NULL,
    advertiser_id bigint,
    folder text,
    gid integer NOT NULL,
    shell text,
    last_accessed timestamp with time zone
);


ALTER TABLE ftp."user" OWNER TO w4;

--
-- Name: user_id_seq; Type: SEQUENCE; Schema: ftp; Owner: w4
--

CREATE SEQUENCE user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ftp.user_id_seq OWNER TO w4;

--
-- Name: user_id_seq; Type: SEQUENCE OWNED BY; Schema: ftp; Owner: w4
--

ALTER SEQUENCE user_id_seq OWNED BY "user".id;


--
-- Name: user_salt; Type: TABLE; Schema: ftp; Owner: w4; Tablespace: 
--

CREATE TABLE user_salt (
    id bigint NOT NULL,
    username character varying(30) NOT NULL,
    salt text
);


ALTER TABLE ftp.user_salt OWNER TO w4;

--
-- Name: user_salt_id_seq; Type: SEQUENCE; Schema: ftp; Owner: w4
--

CREATE SEQUENCE user_salt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ftp.user_salt_id_seq OWNER TO w4;

--
-- Name: user_salt_id_seq; Type: SEQUENCE OWNED BY; Schema: ftp; Owner: w4
--

ALTER SEQUENCE user_salt_id_seq OWNED BY user_salt.id;


SET search_path = public, pg_catalog;

--
-- Name: action_areas; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE action_areas (
    id integer DEFAULT 0 NOT NULL,
    area_name character varying(50) DEFAULT NULL::character varying
);


ALTER TABLE public.action_areas OWNER TO w4;

--
-- Name: action_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE action_types (
    id integer DEFAULT 0 NOT NULL,
    type_name character varying(50) DEFAULT NULL::character varying
);


ALTER TABLE public.action_types OWNER TO w4;

--
-- Name: admin_alert_settings; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE admin_alert_settings (
    id bigint NOT NULL,
    user_id bigint DEFAULT (0)::bigint,
    entity_id bigint DEFAULT (0)::bigint,
    entity_type text DEFAULT ''::text,
    entity_name text DEFAULT ''::text,
    sub_entity_id bigint DEFAULT (0)::bigint,
    sub_entity_type text DEFAULT ''::text,
    sub_entity_name text DEFAULT ''::text,
    alert_when text DEFAULT ''::text,
    alert_unit text DEFAULT ''::text,
    alert_status boolean DEFAULT true,
    modified timestamp with time zone DEFAULT now()
);


ALTER TABLE public.admin_alert_settings OWNER TO w4;

--
-- Name: admin_alert_settings_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE admin_alert_settings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.admin_alert_settings_id_seq OWNER TO w4;

--
-- Name: admin_alert_settings_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE admin_alert_settings_id_seq OWNED BY admin_alert_settings.id;


--
-- Name: admin_pubs_terms; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE admin_pubs_terms (
    id bigint NOT NULL,
    modified_by bigint,
    date_modified timestamp with time zone DEFAULT now(),
    terms text
);


ALTER TABLE public.admin_pubs_terms OWNER TO w4;

--
-- Name: admin_pubs_terms_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE admin_pubs_terms_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.admin_pubs_terms_id_seq OWNER TO w4;

--
-- Name: admin_pubs_terms_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE admin_pubs_terms_id_seq OWNED BY admin_pubs_terms.id;


--
-- Name: advertiser_banned_publishers; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE advertiser_banned_publishers (
    id bigint NOT NULL,
    advertiser_id integer NOT NULL,
    publisher_id integer NOT NULL,
    campaign_id integer,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    lookup text,
    status status_entity DEFAULT 'active'::status_entity NOT NULL,
    CONSTRAINT advertiser_banned_publishers_advertiser_id_check CHECK ((advertiser_id >= 0)),
    CONSTRAINT advertiser_banned_publishers_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT advertiser_banned_publishers_publisher_id_check CHECK ((publisher_id >= 0))
);


ALTER TABLE public.advertiser_banned_publishers OWNER TO w4;

--
-- Name: TABLE advertiser_banned_publishers; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE advertiser_banned_publishers IS 'Table name needs to be changed to banned_publisher or the like because the ban can be campaign centric.';


--
-- Name: advertiser_banned_publishers_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE advertiser_banned_publishers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.advertiser_banned_publishers_id_seq OWNER TO w4;

--
-- Name: advertiser_banned_publishers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE advertiser_banned_publishers_id_seq OWNED BY advertiser_banned_publishers.id;


--
-- Name: advertiser_banned_sub_publishers; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE advertiser_banned_sub_publishers (
    id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    sub_publisher_id bigint NOT NULL,
    CONSTRAINT advertiser_banned_sub_publishers_advertiser_id_check CHECK ((advertiser_id >= 0)),
    CONSTRAINT advertiser_banned_sub_publishers_sub_publisher_id_check CHECK ((sub_publisher_id >= 0))
);


ALTER TABLE public.advertiser_banned_sub_publishers OWNER TO w4;

--
-- Name: advertiser_banned_sub_publishers_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE advertiser_banned_sub_publishers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.advertiser_banned_sub_publishers_id_seq OWNER TO w4;

--
-- Name: advertiser_banned_sub_publishers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE advertiser_banned_sub_publishers_id_seq OWNED BY advertiser_banned_sub_publishers.id;


--
-- Name: advertiser_contacts; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE advertiser_contacts (
    id bigint NOT NULL,
    advertiser_id bigint,
    contact_id bigint
);


ALTER TABLE public.advertiser_contacts OWNER TO w4;

--
-- Name: advertiser_contacts_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE advertiser_contacts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.advertiser_contacts_id_seq OWNER TO w4;

--
-- Name: advertiser_contacts_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE advertiser_contacts_id_seq OWNED BY advertiser_contacts.id;


--
-- Name: advertiser_payment_terms; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE advertiser_payment_terms (
    id bigint NOT NULL,
    name character varying(128) NOT NULL,
    description text NOT NULL,
    alert_when smallint NOT NULL,
    alert_when_type character varying NOT NULL,
    alert_from character varying NOT NULL,
    CONSTRAINT advertiser_payment_terms_alert_from_check CHECK (((alert_from)::text = ANY (ARRAY[('Invoice Date'::character varying)::text, ('Last Day of the Month'::character varying)::text, ('First Day of the Month'::character varying)::text, ('First Conversion'::character varying)::text]))),
    CONSTRAINT advertiser_payment_terms_alert_when_type_check CHECK (((alert_when_type)::text = ANY (ARRAY[('Days'::character varying)::text, ('Weeks'::character varying)::text, ('Months'::character varying)::text])))
);


ALTER TABLE public.advertiser_payment_terms OWNER TO w4;

--
-- Name: advertiser_payment_terms_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE advertiser_payment_terms_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.advertiser_payment_terms_id_seq OWNER TO w4;

--
-- Name: advertiser_payment_terms_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE advertiser_payment_terms_id_seq OWNED BY advertiser_payment_terms.id;


--
-- Name: advertiser_uploads; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE advertiser_uploads (
    id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    file_id character varying(128) NOT NULL,
    extension character varying(4) NOT NULL,
    file_name character varying(128) NOT NULL,
    datetime timestamp with time zone NOT NULL,
    CONSTRAINT advertiser_uploads_advertiser_id_check CHECK ((advertiser_id >= 0))
);


ALTER TABLE public.advertiser_uploads OWNER TO w4;

--
-- Name: advertiser_uploads_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE advertiser_uploads_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.advertiser_uploads_id_seq OWNER TO w4;

--
-- Name: advertiser_uploads_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE advertiser_uploads_id_seq OWNED BY advertiser_uploads.id;


--
-- Name: advertiser_versions; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE advertiser_versions (
    id bigint NOT NULL,
    version_id bigint NOT NULL,
    manager_id integer,
    name character varying(128),
    credit_limit double precision,
    credit_limit_per character varying,
    payment_terms_id integer,
    allow_to_go_over_credit_limit character varying NOT NULL,
    send_alert_if_credit_is_used character varying,
    credit_alert_type character varying,
    credit_alert_value numeric(18,2) DEFAULT NULL::numeric,
    next_payment_due_date character varying(36),
    status character varying,
    created timestamp with time zone,
    modified timestamp with time zone,
    contact_name character varying(128),
    phone character varying(128),
    mobile character varying(128) DEFAULT NULL::character varying,
    email character varying(128),
    address_1 text,
    address_2 text,
    city character varying(128),
    state character varying(128),
    zip character varying(128),
    country character varying(128),
    messenger_id character varying(255) DEFAULT NULL::character varying,
    fax character varying(255) DEFAULT NULL::character varying,
    website_url character varying(255) DEFAULT NULL::character varying,
    description text,
    send_alert_if_credit_percent_to character varying(1024) DEFAULT NULL::character varying,
    ftp_password character varying(128),
    note_login_url character varying(255) DEFAULT NULL::character varying,
    note_login_username character varying(255) DEFAULT NULL::character varying,
    note_login_password character varying(255) DEFAULT NULL::character varying,
    billing_company character varying(250) DEFAULT NULL::character varying,
    billing_first_name character varying(250) DEFAULT NULL::character varying,
    billing_last_name character varying(250) DEFAULT NULL::character varying,
    billing_address_1 character varying(250) DEFAULT NULL::character varying,
    billing_address_2 character varying(250) DEFAULT NULL::character varying,
    billing_city character varying(250) DEFAULT NULL::character varying,
    billing_region_id integer,
    billing_country_id integer,
    primary_contact_id bigint,
    billing_contact_id bigint
);


ALTER TABLE public.advertiser_versions OWNER TO w4;

--
-- Name: advertisers_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE advertisers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.advertisers_id_seq OWNER TO w4;

--
-- Name: advertisers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE advertisers_id_seq OWNED BY advertisers.id;


--
-- Name: assets; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE assets (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    owner_id integer NOT NULL,
    file_id character varying(24) NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    mime_type character varying(255) NOT NULL,
    file_name character varying(255) NOT NULL,
    file_size integer NOT NULL,
    is_campaign_preview smallint DEFAULT (0)::smallint NOT NULL,
    CONSTRAINT assets_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT assets_file_size_check CHECK ((file_size >= 0)),
    CONSTRAINT assets_is_campaign_preview_check CHECK ((is_campaign_preview >= 0)),
    CONSTRAINT assets_owner_id_check CHECK ((owner_id >= 0))
);


ALTER TABLE public.assets OWNER TO w4;

--
-- Name: assets_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE assets_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.assets_id_seq OWNER TO w4;

--
-- Name: assets_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE assets_id_seq OWNED BY assets.id;


--
-- Name: audit_log; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE audit_log (
    id bigint NOT NULL,
    entity_id bigint,
    entity_type_id integer,
    user_id bigint,
    user_ip text,
    created timestamp with time zone,
    message text,
    currency_id integer
);


ALTER TABLE public.audit_log OWNER TO w4;

--
-- Name: audit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE audit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.audit_log_id_seq OWNER TO w4;

--
-- Name: audit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE audit_log_id_seq OWNED BY audit_log.id;


--
-- Name: audit_log_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE audit_log_types (
    id integer NOT NULL,
    base_type integer,
    is_entity boolean,
    name text
);


ALTER TABLE public.audit_log_types OWNER TO w4;

--
-- Name: audit_log_types_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE audit_log_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.audit_log_types_id_seq OWNER TO w4;

--
-- Name: audit_log_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE audit_log_types_id_seq OWNED BY audit_log_types.id;


--
-- Name: banned_ips; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE banned_ips (
    ip inet NOT NULL,
    reason smallint NOT NULL,
    note text
);


ALTER TABLE public.banned_ips OWNER TO w4;

--
-- Name: cache_invalidation; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE cache_invalidation (
    id bigint NOT NULL,
    cache_object_name character varying(250) DEFAULT NULL::character varying,
    invalidation_rule character varying(250) DEFAULT NULL::character varying
);


ALTER TABLE public.cache_invalidation OWNER TO w4;

--
-- Name: cache_invalidation_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE cache_invalidation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cache_invalidation_id_seq OWNER TO w4;

--
-- Name: cache_invalidation_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE cache_invalidation_id_seq OWNED BY cache_invalidation.id;


--
-- Name: campaign_assigned_publishers; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_assigned_publishers (
    campaign_id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    status character varying DEFAULT 'pending'::character varying NOT NULL,
    allocations text,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    memo text,
    admin_id bigint,
    CONSTRAINT campaign_assigned_publishers_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT campaign_assigned_publishers_publisher_id_check CHECK ((publisher_id >= 0)),
    CONSTRAINT campaign_assigned_publishers_status_check CHECK (((status)::text = ANY (ARRAY[('approved'::character varying)::text, ('pending'::character varying)::text, ('denied'::character varying)::text, ('blocked'::character varying)::text])))
);


ALTER TABLE public.campaign_assigned_publishers OWNER TO w4;

--
-- Name: campaign_banned_sub_publishers; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_banned_sub_publishers (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    sub_publisher_id bigint NOT NULL,
    CONSTRAINT campaign_banned_sub_publishers_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT campaign_banned_sub_publishers_sub_publisher_id_check CHECK ((sub_publisher_id >= 0))
);


ALTER TABLE public.campaign_banned_sub_publishers OWNER TO w4;

--
-- Name: campaign_banned_sub_publishers_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_banned_sub_publishers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_banned_sub_publishers_id_seq OWNER TO w4;

--
-- Name: campaign_banned_sub_publishers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_banned_sub_publishers_id_seq OWNED BY campaign_banned_sub_publishers.id;


--
-- Name: campaign_caps; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_caps (
    id bigint NOT NULL,
    campaign_id bigint DEFAULT 0 NOT NULL,
    type smallint DEFAULT (1)::smallint NOT NULL,
    period smallint DEFAULT (1)::smallint NOT NULL,
    value integer DEFAULT 1 NOT NULL,
    unit_type character varying(20) DEFAULT 'currency'::character varying,
    units numeric(28,4) DEFAULT 0.0000
);


ALTER TABLE public.campaign_caps OWNER TO w4;

--
-- Name: campaign_caps_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_caps_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_caps_id_seq OWNER TO w4;

--
-- Name: campaign_caps_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_caps_id_seq OWNED BY campaign_caps.id;


--
-- Name: campaign_categories; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_categories (
    campaign_id bigint DEFAULT 0 NOT NULL,
    category_id integer DEFAULT 0 NOT NULL,
    CONSTRAINT campaign_categories_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT campaign_categories_category_id_check CHECK ((category_id >= 0))
);


ALTER TABLE public.campaign_categories OWNER TO w4;

--
-- Name: campaign_channels; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_channels (
    campaign_id bigint NOT NULL,
    channel_id integer NOT NULL,
    CONSTRAINT campaign_traffic_types_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT campaign_traffic_types_traffic_type_id_check CHECK ((channel_id >= 0))
);


ALTER TABLE public.campaign_channels OWNER TO w4;

--
-- Name: campaign_conversion_aliases; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_conversion_aliases (
    id bigint NOT NULL,
    alias character varying(255) NOT NULL,
    alias_type character varying NOT NULL,
    CONSTRAINT campaign_conversion_aliases_alias_type_check CHECK (((alias_type)::text = ANY (ARRAY[('CPA'::character varying)::text, ('CPC'::character varying)::text, ('CPL'::character varying)::text, ('CPM'::character varying)::text])))
);


ALTER TABLE public.campaign_conversion_aliases OWNER TO w4;

--
-- Name: campaign_conversion_aliases_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_conversion_aliases_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_conversion_aliases_id_seq OWNER TO w4;

--
-- Name: campaign_conversion_aliases_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_conversion_aliases_id_seq OWNED BY campaign_conversion_aliases.id;


--
-- Name: campaign_geotargeting; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_geotargeting (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    country character varying(2),
    region character varying(2),
    city character varying(255),
    city_id integer DEFAULT 0,
    CONSTRAINT campaign_geotargeting_campaign_id_check CHECK ((campaign_id >= 0))
);


ALTER TABLE public.campaign_geotargeting OWNER TO w4;

--
-- Name: campaign_geotargeting_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_geotargeting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_geotargeting_id_seq OWNER TO w4;

--
-- Name: campaign_geotargeting_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_geotargeting_id_seq OWNED BY campaign_geotargeting.id;


--
-- Name: campaign_geotargeting_postal_codes; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_geotargeting_postal_codes (
    campaign_id bigint NOT NULL,
    postal_code character varying(20) NOT NULL,
    CONSTRAINT campaign_geotargeting_postal_codes_campaign_id_check CHECK ((campaign_id >= 0))
);


ALTER TABLE public.campaign_geotargeting_postal_codes OWNER TO w4;

--
-- Name: campaign_group_items; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_group_items (
    id bigint NOT NULL,
    campaign_id bigint DEFAULT 0 NOT NULL,
    campaign_group_id bigint DEFAULT (0)::bigint NOT NULL
);


ALTER TABLE public.campaign_group_items OWNER TO w4;

--
-- Name: campaign_group_items_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_group_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_group_items_id_seq OWNER TO w4;

--
-- Name: campaign_group_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_group_items_id_seq OWNED BY campaign_group_items.id;


--
-- Name: campaign_groups; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_groups (
    id bigint NOT NULL,
    user_id bigint DEFAULT (0)::bigint NOT NULL,
    group_name character varying(128) NOT NULL,
    created timestamp with time zone NOT NULL,
    modified timestamp with time zone NOT NULL
);


ALTER TABLE public.campaign_groups OWNER TO w4;

--
-- Name: campaign_groups_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_groups_id_seq OWNER TO w4;

--
-- Name: campaign_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_groups_id_seq OWNED BY campaign_groups.id;


--
-- Name: campaign_payout_changes; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_payout_changes (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    payout numeric NOT NULL,
    created_at timestamp with time zone NOT NULL,
    status status_request DEFAULT 'pending'::status_request,
    admin_id bigint,
    CONSTRAINT campaign_payout_changes_campaign_id_check CHECK ((campaign_id >= 0))
);


ALTER TABLE public.campaign_payout_changes OWNER TO w4;

--
-- Name: campaign_payout_changes_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_payout_changes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_payout_changes_id_seq OWNER TO w4;

--
-- Name: campaign_payout_changes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_payout_changes_id_seq OWNED BY campaign_payout_changes.id;


--
-- Name: campaign_piggyback_pixels_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_piggyback_pixels_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_piggyback_pixels_id_seq OWNER TO w4;

--
-- Name: campaign_piggyback_pixels_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_piggyback_pixels_id_seq OWNED BY campaign_piggyback_pixels.id;


--
-- Name: campaign_pixels_legacy; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_pixels_legacy (
    id bigint NOT NULL,
    campaign_id bigint,
    tracking_type_id bigint,
    code text,
    modified_by_id bigint,
    last_modified timestamp with time zone
);


ALTER TABLE public.campaign_pixels_legacy OWNER TO w4;

--
-- Name: campaign_pixels_legacy_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_pixels_legacy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_pixels_legacy_id_seq OWNER TO w4;

--
-- Name: campaign_pixels_legacy_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_pixels_legacy_id_seq OWNED BY campaign_pixels_legacy.id;


--
-- Name: campaign_suppression_lists; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_suppression_lists (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    list_type suppression NOT NULL,
    suppression_lists_id bigint,
    external_id text,
    external_name text,
    modified_by bigint NOT NULL,
    modified_date timestamp with time zone NOT NULL,
    status status_entity NOT NULL
);


ALTER TABLE public.campaign_suppression_lists OWNER TO w4;

--
-- Name: campaign_suppression_lists_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_suppression_lists_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_suppression_lists_id_seq OWNER TO w4;

--
-- Name: campaign_suppression_lists_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_suppression_lists_id_seq OWNED BY campaign_suppression_lists.id;


--
-- Name: campaign_tracking_type_lookup_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaign_tracking_type_lookup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaign_tracking_type_lookup_id_seq OWNER TO w4;

--
-- Name: campaign_tracking_type_lookup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaign_tracking_type_lookup_id_seq OWNED BY campaign_tracking_type_lookup.id;


--
-- Name: campaign_versions; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE campaign_versions (
    id bigint NOT NULL,
    version_id bigint NOT NULL,
    advertiser_id bigint,
    user_id integer,
    name character varying(255),
    description text,
    restrictions text,
    default_redirect_url character varying(2083),
    screenshot_id character varying(24),
    landing_pages text,
    failure_redirect_type smallint,
    failure_redirect_url character varying(1024),
    failure_redirect_campaign_id bigint,
    unsubscription_url character varying(2083),
    unsubscription_screenshot_id character varying(24),
    default_payout numeric,
    payout_type smallint,
    payout_model_id integer,
    default_payin numeric,
    payin_type smallint,
    payin_model_id integer,
    start_date timestamp with time zone,
    is_expiration smallint,
    expiry_date timestamp with time zone,
    geotargeting_postal_code_directive character varying,
    outgeo_redirect_type smallint,
    outgeo_redirect_url character varying(1024),
    outgeo_redirect_campaign_id bigint,
    outgeo_redirect_screenshot_id character varying(24),
    cookie_duration_time smallint,
    cookie_duration_unit smallint,
    access_type smallint,
    status character varying,
    epc numeric,
    tracking_type character varying,
    tracking_secure character varying,
    new_until date,
    do_redirect_mobile smallint,
    mobile_redirect_url character varying(2048),
    mobile_screenshot_id character varying(24),
    version_start_date timestamp with time zone,
    currency_id bigint
);


ALTER TABLE public.campaign_versions OWNER TO w4;

--
-- Name: COLUMN campaign_versions.failure_redirect_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaign_versions.failure_redirect_type IS '1 - Url, 2 - Campaign';


--
-- Name: COLUMN campaign_versions.payout_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaign_versions.payout_type IS '1 - Flat Rate, 2 - Percentage';


--
-- Name: COLUMN campaign_versions.payin_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaign_versions.payin_type IS '1 - Flat Rate, 2 - Percentage';


--
-- Name: COLUMN campaign_versions.outgeo_redirect_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaign_versions.outgeo_redirect_type IS '1 - Url, 2 - Campaign';


--
-- Name: COLUMN campaign_versions.cookie_duration_unit; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaign_versions.cookie_duration_unit IS '1 - Seconds, 2 - Minutes, 3 - Hours, 4 - Days, 5 - Weeks, 6 - Months, 7 - Years';


--
-- Name: COLUMN campaign_versions.access_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN campaign_versions.access_type IS '1 - Public, 2 - Private, 3 - By Approval';


--
-- Name: campaigns_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE campaigns_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campaigns_id_seq OWNER TO w4;

--
-- Name: campaigns_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE campaigns_id_seq OWNED BY campaigns.id;


--
-- Name: categories_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE categories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.categories_id_seq OWNER TO w4;

--
-- Name: categories_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE categories_id_seq OWNED BY categories.id;


--
-- Name: channel_creative_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE channel_creative_types (
    channel_id integer NOT NULL,
    creative_type integer NOT NULL,
    CONSTRAINT traffic_type_creative_types_creative_type_check CHECK ((creative_type >= 0)),
    CONSTRAINT traffic_type_creative_types_traffic_type_id_check CHECK ((channel_id >= 0))
);


ALTER TABLE public.channel_creative_types OWNER TO w4;

--
-- Name: COLUMN channel_creative_types.creative_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN channel_creative_types.creative_type IS '1 - Banner, 2 - Text Link, 3 - Email';


--
-- Name: channels; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE channels (
    id bigint NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.channels OWNER TO w4;

--
-- Name: channels_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE channels_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.channels_id_seq OWNER TO w4;

--
-- Name: channels_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE channels_id_seq OWNED BY channels.id;


--
-- Name: cities; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE cities (
    id bigint NOT NULL,
    country character varying(2) NOT NULL,
    region character varying(2) NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.cities OWNER TO w4;

--
-- Name: cities_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE cities_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cities_id_seq OWNER TO w4;

--
-- Name: cities_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE cities_id_seq OWNED BY cities.id;


--
-- Name: click_geo; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE click_geo (
    id bigint NOT NULL,
    click_db_id bigint NOT NULL,
    loc_id bigint,
    continent character(2) DEFAULT NULL::bpchar,
    country_id integer,
    region_id integer,
    city_id bigint,
    postal_code character varying(6) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer
);


ALTER TABLE public.click_geo OWNER TO w4;

--
-- Name: TABLE click_geo; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE click_geo IS 'Data Types per http://www.maxmind.com/app/city';


--
-- Name: click_geo_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE click_geo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.click_geo_id_seq OWNER TO w4;

--
-- Name: click_geo_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE click_geo_id_seq OWNED BY click_geo.id;


--
-- Name: click_user_agent; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE click_user_agent (
    id bigint NOT NULL,
    click_db_id bigint NOT NULL,
    platform bigint,
    browser bigint,
    idx_user_agent_string character varying(128) DEFAULT NULL::character varying,
    full_user_agent text
);


ALTER TABLE public.click_user_agent OWNER TO w4;

--
-- Name: TABLE click_user_agent; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE click_user_agent IS 'Allows full user agent storage per requirements';


--
-- Name: click_user_agent_features; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE click_user_agent_features (
    click_user_agent_id bigint DEFAULT (0)::bigint NOT NULL,
    user_agent_feature_id bigint DEFAULT (0)::bigint NOT NULL
);


ALTER TABLE public.click_user_agent_features OWNER TO w4;

--
-- Name: TABLE click_user_agent_features; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE click_user_agent_features IS 'Stores any and all UserAgent features we want';


--
-- Name: click_user_agent_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE click_user_agent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.click_user_agent_id_seq OWNER TO w4;

--
-- Name: click_user_agent_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE click_user_agent_id_seq OWNED BY click_user_agent.id;


--
-- Name: clicks; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE clicks (
    id bigint NOT NULL,
    publisher_id bigint,
    sub_publisher_id bigint,
    creative_id integer,
    nb_dupes integer,
    campaign_id bigint,
    advertiser_id bigint,
    traffic_type smallint,
    r_hoy integer,
    r_doy integer,
    r_woy integer,
    r_moy integer,
    r_qoy integer,
    r_y integer,
    created_date timestamp with time zone,
    ip_address character(15) DEFAULT NULL::bpchar,
    click_id bigint,
    sub_id_1 character varying(64) DEFAULT NULL::character varying,
    sub_id_2 character varying(64) DEFAULT NULL::character varying,
    sub_id_3 character varying(64) DEFAULT NULL::character varying,
    sub_id_4 character varying(64) DEFAULT NULL::character varying,
    campaign_name character varying(255) DEFAULT NULL::character varying,
    base_uri character varying(250) DEFAULT NULL::character varying,
    refferal_url character varying(2048) DEFAULT NULL::character varying
);


ALTER TABLE public.clicks OWNER TO w4;

--
-- Name: clicks_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE clicks_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.clicks_id_seq OWNER TO w4;

--
-- Name: clicks_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE clicks_id_seq OWNED BY clicks.id;


--
-- Name: cmpl_alert_template; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE cmpl_alert_template (
    id bigint NOT NULL,
    after_days integer,
    alert_message text,
    alert_level smallint,
    delimeter character varying(128) DEFAULT NULL::character varying
);


ALTER TABLE public.cmpl_alert_template OWNER TO w4;

--
-- Name: cmpl_alert_template_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE cmpl_alert_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmpl_alert_template_id_seq OWNER TO w4;

--
-- Name: cmpl_alert_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE cmpl_alert_template_id_seq OWNED BY cmpl_alert_template.id;


--
-- Name: cmpl_downloaded; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE cmpl_downloaded (
    id bigint NOT NULL,
    campaign_id bigint,
    publisher_id bigint,
    downloaded_ts timestamp with time zone DEFAULT now() NOT NULL,
    sha1_hash character varying(40) DEFAULT NULL::character varying
);


ALTER TABLE public.cmpl_downloaded OWNER TO w4;

--
-- Name: cmpl_downloaded_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE cmpl_downloaded_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmpl_downloaded_id_seq OWNER TO w4;

--
-- Name: cmpl_downloaded_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE cmpl_downloaded_id_seq OWNED BY cmpl_downloaded.id;


--
-- Name: cmpl_email_template; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE cmpl_email_template (
    id bigint NOT NULL,
    after_days integer,
    email_message text,
    delimeter character varying(128) DEFAULT NULL::character varying
);


ALTER TABLE public.cmpl_email_template OWNER TO w4;

--
-- Name: cmpl_email_template_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE cmpl_email_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmpl_email_template_id_seq OWNER TO w4;

--
-- Name: cmpl_email_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE cmpl_email_template_id_seq OWNED BY cmpl_email_template.id;


--
-- Name: cmpl_exceptions; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE cmpl_exceptions (
    id bigint NOT NULL,
    publisher_id bigint,
    campaign_id bigint,
    created_ts timestamp with time zone DEFAULT now() NOT NULL,
    status character varying,
    memo text,
    last_hash character varying(40) DEFAULT NULL::character varying,
    except_hash character varying(40) DEFAULT NULL::character varying,
    CONSTRAINT cmpl_exceptions_status_check CHECK (((status)::text = ANY (ARRAY[('suspended'::character varying)::text, ('unsuspended'::character varying)::text])))
);


ALTER TABLE public.cmpl_exceptions OWNER TO w4;

--
-- Name: cmpl_exceptions_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE cmpl_exceptions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmpl_exceptions_id_seq OWNER TO w4;

--
-- Name: cmpl_exceptions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE cmpl_exceptions_id_seq OWNED BY cmpl_exceptions.id;


--
-- Name: cmpl_notifications; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE cmpl_notifications (
    id bigint NOT NULL,
    after_days integer,
    publisher_id bigint,
    campaign_id bigint,
    status character varying,
    create_ts timestamp with time zone DEFAULT now() NOT NULL,
    sent_ts timestamp with time zone DEFAULT '1970-01-01 00:00:00-08'::timestamp with time zone NOT NULL,
    CONSTRAINT cmpl_notifications_status_check CHECK (((status)::text = ANY (ARRAY[('new'::character varying)::text, ('sent'::character varying)::text])))
);


ALTER TABLE public.cmpl_notifications OWNER TO w4;

--
-- Name: cmpl_notifications_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE cmpl_notifications_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmpl_notifications_id_seq OWNER TO w4;

--
-- Name: cmpl_notifications_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE cmpl_notifications_id_seq OWNED BY cmpl_notifications.id;


--
-- Name: cmpl_suppression_file; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE cmpl_suppression_file (
    id bigint NOT NULL,
    campaign_id bigint,
    dom_sha1_hash character varying(40) DEFAULT NULL::character varying,
    raw_sha1_hash character varying(40) DEFAULT NULL::character varying,
    md5_sha1_hash character varying(40) DEFAULT NULL::character varying,
    modified_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.cmpl_suppression_file OWNER TO w4;

--
-- Name: cmpl_suppression_file_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE cmpl_suppression_file_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmpl_suppression_file_id_seq OWNER TO w4;

--
-- Name: cmpl_suppression_file_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE cmpl_suppression_file_id_seq OWNED BY cmpl_suppression_file.id;


--
-- Name: code_locations; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE code_locations (
    id bigint NOT NULL,
    details character varying(255) DEFAULT NULL::character varying
);


ALTER TABLE public.code_locations OWNER TO w4;

--
-- Name: code_locations_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE code_locations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_locations_id_seq OWNER TO w4;

--
-- Name: code_locations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE code_locations_id_seq OWNED BY code_locations.id;


--
-- Name: contact_id; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE contact_id (
    billing_contact_id bigint
);


ALTER TABLE public.contact_id OWNER TO w4;

--
-- Name: contact_type_lookup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE contact_type_lookup (
    id bigint NOT NULL,
    contact_type_name character varying(64) DEFAULT NULL::character varying
);


ALTER TABLE public.contact_type_lookup OWNER TO w4;

--
-- Name: contact_type_lookup_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE contact_type_lookup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.contact_type_lookup_id_seq OWNER TO w4;

--
-- Name: contact_type_lookup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE contact_type_lookup_id_seq OWNED BY contact_type_lookup.id;


--
-- Name: contacts_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE contacts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.contacts_id_seq OWNER TO w4;

--
-- Name: contacts_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE contacts_id_seq OWNED BY contacts.id;


--
-- Name: conversion_geo; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE conversion_geo (
    id bigint NOT NULL,
    conversion_db_id bigint NOT NULL,
    loc_id bigint,
    continent character(2) DEFAULT NULL::bpchar,
    country_id integer,
    region_id integer,
    city_id bigint,
    postal_code character varying(6) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer
);


ALTER TABLE public.conversion_geo OWNER TO w4;

--
-- Name: TABLE conversion_geo; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE conversion_geo IS 'Data Types per http://www.maxmind.com/app/city';


--
-- Name: conversion_geo_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE conversion_geo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.conversion_geo_id_seq OWNER TO w4;

--
-- Name: conversion_geo_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE conversion_geo_id_seq OWNED BY conversion_geo.id;


--
-- Name: conversion_user_agent_features; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE conversion_user_agent_features (
    conv_user_agent_id bigint DEFAULT (0)::bigint NOT NULL,
    user_agent_feature_id bigint DEFAULT (0)::bigint NOT NULL
);


ALTER TABLE public.conversion_user_agent_features OWNER TO w4;

--
-- Name: TABLE conversion_user_agent_features; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE conversion_user_agent_features IS 'Stores any and all UserAgent features we want';


--
-- Name: countries; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE countries (
    id bigint NOT NULL,
    country character varying(2) NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.countries OWNER TO w4;

--
-- Name: countries_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE countries_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.countries_id_seq OWNER TO w4;

--
-- Name: countries_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE countries_id_seq OWNED BY countries.id;


--
-- Name: creative_banners; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creative_banners (
    creative_id integer NOT NULL,
    image_id bigint NOT NULL,
    thumbnail_id character varying(24) DEFAULT NULL::character varying,
    upload_type smallint DEFAULT (1)::smallint NOT NULL,
    alt_text character varying(255) DEFAULT NULL::character varying,
    size integer NOT NULL,
    width smallint NOT NULL,
    height smallint NOT NULL,
    extension character varying(12) NOT NULL,
    content text,
    html text,
    redirect_screenshot_id character varying(24) DEFAULT NULL::character varying,
    id bigint NOT NULL,
    CONSTRAINT creative_banners_creative_id_check CHECK ((creative_id >= 0)),
    CONSTRAINT creative_banners_height_check CHECK ((height >= 0)),
    CONSTRAINT creative_banners_size_check CHECK ((size >= 0)),
    CONSTRAINT creative_banners_upload_type_check CHECK ((upload_type >= 0)),
    CONSTRAINT creative_banners_width_check CHECK ((width >= 0))
);


ALTER TABLE public.creative_banners OWNER TO w4;

--
-- Name: COLUMN creative_banners.upload_type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN creative_banners.upload_type IS '1 - Local, 2 - Remote';


--
-- Name: creative_banners_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE creative_banners_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.creative_banners_id_seq OWNER TO w4;

--
-- Name: creative_banners_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE creative_banners_id_seq OWNED BY creative_banners.id;


--
-- Name: creative_email_image_lookup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creative_email_image_lookup (
    asset_id integer,
    image_id character varying(24) DEFAULT NULL::character varying,
    CONSTRAINT creative_email_image_lookup_asset_id_check CHECK ((asset_id >= 0))
);


ALTER TABLE public.creative_email_image_lookup OWNER TO w4;

--
-- Name: creative_email_images; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creative_email_images (
    id bigint NOT NULL,
    image_id character varying(24) DEFAULT NULL::character varying,
    image_token character varying(32) DEFAULT NULL::character varying,
    image_width character varying(32) DEFAULT NULL::character varying,
    image_height character varying(32) DEFAULT NULL::character varying,
    image_status smallint
);


ALTER TABLE public.creative_email_images OWNER TO w4;

--
-- Name: creative_email_images_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE creative_email_images_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.creative_email_images_id_seq OWNER TO w4;

--
-- Name: creative_email_images_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE creative_email_images_id_seq OWNED BY creative_email_images.id;


--
-- Name: creative_email_links; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creative_email_links (
    id bigint NOT NULL,
    creative_id bigint NOT NULL,
    original_url text,
    redirect_type text,
    is_html boolean,
    CONSTRAINT creative_email_links_creative_id_check CHECK ((creative_id >= 0))
);


ALTER TABLE public.creative_email_links OWNER TO w4;

--
-- Name: creative_email_links_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE creative_email_links_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.creative_email_links_id_seq OWNER TO w4;

--
-- Name: creative_email_links_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE creative_email_links_id_seq OWNED BY creative_email_links.id;


--
-- Name: creative_emails; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creative_emails (
    creative_id integer NOT NULL,
    screenshot_id character varying(24) DEFAULT NULL::character varying,
    is_html smallint DEFAULT (1)::smallint NOT NULL,
    content text NOT NULL,
    email_from_address character varying(128) DEFAULT NULL::character varying,
    email_from_name character varying(128) DEFAULT NULL::character varying,
    email_subject character varying(250) DEFAULT NULL::character varying,
    id bigint NOT NULL,
    CONSTRAINT creative_emails_creative_id_check CHECK ((creative_id >= 0)),
    CONSTRAINT creative_emails_is_html_check CHECK ((is_html >= 0))
);


ALTER TABLE public.creative_emails OWNER TO w4;

--
-- Name: creative_emails_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE creative_emails_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.creative_emails_id_seq OWNER TO w4;

--
-- Name: creative_emails_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE creative_emails_id_seq OWNED BY creative_emails.id;


--
-- Name: creative_status_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creative_status_types (
    id smallint NOT NULL,
    description character varying(50) DEFAULT NULL::character varying
);


ALTER TABLE public.creative_status_types OWNER TO w4;

--
-- Name: creative_swfs; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creative_swfs (
    creative_id integer NOT NULL,
    image_id character varying(24) NOT NULL,
    screenshot_id character varying(24) DEFAULT NULL::character varying,
    id bigint NOT NULL,
    CONSTRAINT creative_swfs_creative_id_check CHECK ((creative_id >= 0))
);


ALTER TABLE public.creative_swfs OWNER TO w4;

--
-- Name: creative_swfs_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE creative_swfs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.creative_swfs_id_seq OWNER TO w4;

--
-- Name: creative_swfs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE creative_swfs_id_seq OWNED BY creative_swfs.id;


--
-- Name: creative_textlinks; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creative_textlinks (
    creative_id integer NOT NULL,
    text text NOT NULL,
    redirect_screenshot_id character varying(24) DEFAULT NULL::character varying,
    id bigint,
    CONSTRAINT creative_textlinks_creative_id_check CHECK ((creative_id >= 0))
);


ALTER TABLE public.creative_textlinks OWNER TO w4;

--
-- Name: creatives; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE creatives (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    type smallint NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    redirect_url character varying(2083) DEFAULT NULL::character varying,
    is_active smallint DEFAULT (1)::smallint NOT NULL,
    CONSTRAINT creatives_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT creatives_is_active_check CHECK ((is_active >= 0)),
    CONSTRAINT creatives_type_check CHECK ((type >= 0))
);


ALTER TABLE public.creatives OWNER TO w4;

--
-- Name: COLUMN creatives.type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN creatives.type IS '1 - Banner, 2 - Text Link, 3 - Email';


--
-- Name: creatives_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE creatives_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.creatives_id_seq OWNER TO w4;

--
-- Name: creatives_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE creatives_id_seq OWNED BY creatives.id;


--
-- Name: currency_lookup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE currency_lookup (
    id bigint NOT NULL,
    currency_name text NOT NULL,
    symbol text NOT NULL,
    country_code text,
    iso text NOT NULL
);


ALTER TABLE public.currency_lookup OWNER TO w4;

--
-- Name: dashboard_message_groups; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE dashboard_message_groups (
    message_id integer DEFAULT 0 NOT NULL,
    group_id integer DEFAULT 0 NOT NULL,
    CONSTRAINT dashboard_message_groups_group_id_check CHECK ((group_id >= 0)),
    CONSTRAINT dashboard_message_groups_message_id_check CHECK ((message_id >= 0))
);


ALTER TABLE public.dashboard_message_groups OWNER TO w4;

--
-- Name: dashboard_message_users; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE dashboard_message_users (
    message_id integer DEFAULT 0 NOT NULL,
    publisher_id bigint DEFAULT 0 NOT NULL,
    CONSTRAINT dashboard_message_users_message_id_check CHECK ((message_id >= 0)),
    CONSTRAINT dashboard_message_users_publisher_id_check CHECK ((publisher_id >= 0))
);


ALTER TABLE public.dashboard_message_users OWNER TO w4;

--
-- Name: dashboard_messages; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE dashboard_messages (
    id bigint NOT NULL,
    title character varying(255) NOT NULL,
    message text NOT NULL,
    type smallint DEFAULT (1)::smallint NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    created_at timestamp with time zone NOT NULL,
    CONSTRAINT dashboard_messages_type_check CHECK ((type >= 0))
);


ALTER TABLE public.dashboard_messages OWNER TO w4;

--
-- Name: COLUMN dashboard_messages.type; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON COLUMN dashboard_messages.type IS '1 - Announcement, 2 - Alert';


--
-- Name: dashboard_messages_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE dashboard_messages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dashboard_messages_id_seq OWNER TO w4;

--
-- Name: dashboard_messages_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE dashboard_messages_id_seq OWNED BY dashboard_messages.id;


--
-- Name: data_anomaly_log; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE data_anomaly_log (
    id bigint NOT NULL,
    calltype text,
    callname text,
    callarguments text,
    process text,
    indication text,
    errorconfidence text,
    created_timestamp timestamp with time zone
);


ALTER TABLE public.data_anomaly_log OWNER TO w4;

--
-- Name: data_anomaly_log_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE data_anomaly_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.data_anomaly_log_id_seq OWNER TO w4;

--
-- Name: data_anomaly_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE data_anomaly_log_id_seq OWNED BY data_anomaly_log.id;


--
-- Name: duration_type_lookup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE duration_type_lookup (
    id integer DEFAULT 0 NOT NULL,
    duration_name text NOT NULL,
    duration_adj text NOT NULL
);


ALTER TABLE public.duration_type_lookup OWNER TO w4;

--
-- Name: email_batches; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE email_batches (
    id bigint NOT NULL,
    start_time timestamp with time zone,
    stop_time timestamp with time zone,
    status status_batch,
    message text
);


ALTER TABLE public.email_batches OWNER TO w4;

--
-- Name: email_batches_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE email_batches_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.email_batches_id_seq OWNER TO w4;

--
-- Name: email_batches_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE email_batches_id_seq OWNED BY email_batches.id;


--
-- Name: email_from_lines; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE email_from_lines (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    content text NOT NULL,
    CONSTRAINT email_from_lines_campaign_id_check CHECK ((campaign_id >= 0))
);


ALTER TABLE public.email_from_lines OWNER TO w4;

--
-- Name: email_from_lines_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE email_from_lines_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.email_from_lines_id_seq OWNER TO w4;

--
-- Name: email_from_lines_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE email_from_lines_id_seq OWNED BY email_from_lines.id;


--
-- Name: email_queue; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE email_queue (
    id bigint NOT NULL,
    message_id bigint NOT NULL,
    subject text,
    content text,
    sender text,
    receiver text,
    status status_batch,
    batch_id bigint
);


ALTER TABLE public.email_queue OWNER TO w4;

--
-- Name: email_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE email_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.email_queue_id_seq OWNER TO w4;

--
-- Name: email_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE email_queue_id_seq OWNED BY email_queue.id;


--
-- Name: email_subject_lines; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE email_subject_lines (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    content text NOT NULL,
    CONSTRAINT email_subject_lines_campaign_id_check CHECK ((campaign_id >= 0))
);


ALTER TABLE public.email_subject_lines OWNER TO w4;

--
-- Name: email_subject_lines_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE email_subject_lines_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.email_subject_lines_id_seq OWNER TO w4;

--
-- Name: email_subject_lines_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE email_subject_lines_id_seq OWNED BY email_subject_lines.id;


--
-- Name: engine_audit_log; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_audit_log (
    id bigint NOT NULL,
    click_id bigint,
    conversion_id bigint,
    failed_step text,
    message text,
    created_date timestamp with time zone,
    campaign_id bigint,
    advertiser_id bigint,
    publisher_id bigint,
    audit_reason_ordinal bigint
);


ALTER TABLE public.engine_audit_log OWNER TO w4;

--
-- Name: engine_audit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_audit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_audit_log_id_seq OWNER TO w4;

--
-- Name: engine_audit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_audit_log_id_seq OWNED BY engine_audit_log.id;


--
-- Name: engine_click_tests; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_click_tests (
    id bigint NOT NULL,
    url text,
    result json
);


ALTER TABLE public.engine_click_tests OWNER TO w4;

--
-- Name: engine_click_tests_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_click_tests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_click_tests_id_seq OWNER TO w4;

--
-- Name: engine_click_tests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_click_tests_id_seq OWNED BY engine_click_tests.id;


--
-- Name: engine_clicks_calls; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_clicks_calls (
    id bigint NOT NULL,
    url_path text,
    url_args text,
    created_date timestamp with time zone
);


ALTER TABLE public.engine_clicks_calls OWNER TO w4;

--
-- Name: engine_clicks_calls_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_clicks_calls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_clicks_calls_id_seq OWNER TO w4;

--
-- Name: engine_clicks_calls_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_clicks_calls_id_seq OWNED BY engine_clicks_calls.id;


--
-- Name: engine_clicks_calls_success; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_clicks_calls_success (
    id bigint NOT NULL,
    click_call_id bigint,
    click_id bigint,
    click_ip text,
    cookie text,
    created_date timestamp with time zone
);


ALTER TABLE public.engine_clicks_calls_success OWNER TO w4;

--
-- Name: engine_clicks_calls_success_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_clicks_calls_success_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_clicks_calls_success_id_seq OWNER TO w4;

--
-- Name: engine_clicks_calls_success_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_clicks_calls_success_id_seq OWNED BY engine_clicks_calls_success.id;


--
-- Name: engine_clicks_dupes; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_clicks_dupes (
    id integer NOT NULL,
    click_id bigint NOT NULL,
    campaign_id integer,
    publisher_id bigint,
    parent_publisher_id bigint,
    redirect_url_id integer,
    consumer_id bigint,
    creative_id integer,
    ip_address inet,
    continent character(2) DEFAULT NULL::bpchar,
    country character varying(255) DEFAULT NULL::character varying,
    region character varying(2) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT (1)::smallint NOT NULL,
    channel bigint,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    created_date timestamp with time zone NOT NULL,
    base_uri character varying(250) DEFAULT NULL::character varying,
    referral_url text,
    rollup_id bigint,
    rollup_clicks bigint DEFAULT 0,
    hitpath_ref_id text
);


ALTER TABLE public.engine_clicks_dupes OWNER TO w4;

--
-- Name: engine_clicks_dupes_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_clicks_dupes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_clicks_dupes_id_seq OWNER TO w4;

--
-- Name: engine_clicks_dupes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_clicks_dupes_id_seq OWNED BY engine_clicks_dupes.id;


--
-- Name: engine_clicks_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_clicks_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_clicks_id_seq OWNER TO w4;

--
-- Name: engine_clicks_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_clicks_id_seq OWNED BY engine_clicks.id;


--
-- Name: engine_clicks_rollup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_clicks_rollup (
    id bigint NOT NULL,
    start_time timestamp with time zone,
    stop_time timestamp with time zone,
    status status_rollup,
    message text
);


ALTER TABLE public.engine_clicks_rollup OWNER TO w4;

--
-- Name: engine_clicks_rollup_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_clicks_rollup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_clicks_rollup_id_seq OWNER TO w4;

--
-- Name: engine_clicks_rollup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_clicks_rollup_id_seq OWNED BY engine_clicks_rollup.id;


--
-- Name: engine_clicks_rollup_queue; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_clicks_rollup_queue (
    id integer NOT NULL,
    click_id bigint NOT NULL,
    campaign_id bigint,
    advertiser_id bigint,
    publisher_id bigint,
    parent_publisher_id bigint,
    creative_id integer,
    country character varying(255) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    browser_id integer,
    platform_id integer,
    unique_click boolean DEFAULT false,
    nb_dupes integer DEFAULT 0 NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    created_date timestamp with time zone NOT NULL,
    base_uri character varying(250) DEFAULT NULL::character varying,
    rollup_id bigint
);


ALTER TABLE public.engine_clicks_rollup_queue OWNER TO w4;

--
-- Name: engine_clicks_rollup_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_clicks_rollup_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_clicks_rollup_queue_id_seq OWNER TO w4;

--
-- Name: engine_clicks_rollup_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_clicks_rollup_queue_id_seq OWNED BY engine_clicks_rollup_queue.id;


--
-- Name: engine_clicks_staging; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_clicks_staging (
    id bigint,
    campaign_id integer,
    publisher_id bigint,
    parent_publisher_id bigint,
    redirect_url_id integer,
    consumer_id bigint,
    creative_id integer,
    ip_address inet,
    continent character(2) DEFAULT NULL::bpchar,
    country character varying(255) DEFAULT NULL::character varying,
    region character varying(2) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT (1)::smallint NOT NULL,
    channel bigint,
    nb_dupes integer DEFAULT 0 NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    created_date timestamp with time zone,
    base_uri character varying(250) DEFAULT NULL::character varying,
    referral_url text
);


ALTER TABLE public.engine_clicks_staging OWNER TO w4;

--
-- Name: engine_clicks_tmp; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_clicks_tmp (
    id bigint NOT NULL,
    campaign_id integer,
    publisher_id bigint,
    parent_publisher_id bigint,
    redirect_url_id integer,
    consumer_id bigint,
    creative_id integer,
    ip_address inet,
    continent character(2) DEFAULT NULL::bpchar,
    country character varying(255) DEFAULT NULL::character varying,
    region character varying(2) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT (1)::smallint NOT NULL,
    channel bigint,
    nb_dupes integer DEFAULT 0 NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    created_date timestamp with time zone NOT NULL,
    base_uri character varying(250) DEFAULT NULL::character varying,
    referral_url text
);


ALTER TABLE public.engine_clicks_tmp OWNER TO w4;

--
-- Name: engine_clicks_tmp_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_clicks_tmp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_clicks_tmp_id_seq OWNER TO w4;

--
-- Name: engine_clicks_tmp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_clicks_tmp_id_seq OWNED BY engine_clicks_tmp.id;


--
-- Name: engine_consumers; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_consumers (
    id integer NOT NULL,
    email character varying(255) DEFAULT NULL::character varying,
    first_name character varying(255) DEFAULT NULL::character varying,
    last_name character varying(255) DEFAULT NULL::character varying,
    address character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    region character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    phone character varying(30) DEFAULT NULL::character varying,
    cell character varying(30) DEFAULT NULL::character varying,
    gender gender,
    dob date,
    ip_address inet,
    ip_lookup_loc_id bigint DEFAULT (0)::bigint NOT NULL,
    ip_lookup_continent character(2) DEFAULT NULL::bpchar,
    ip_lookup_country character varying(255) DEFAULT NULL::character varying,
    ip_lookup_region character varying(2) DEFAULT NULL::character varying,
    ip_lookup_region_name character varying(255) DEFAULT NULL::character varying,
    ip_lookup_city character varying(255) DEFAULT NULL::character varying,
    ip_lookup_postal_code character varying(6) DEFAULT NULL::character varying,
    ip_lookup_latitude double precision,
    ip_lookup_longitude double precision,
    ip_lookup_metro_code integer,
    ip_lookup_area_code integer,
    created_date timestamp with time zone
);


ALTER TABLE public.engine_consumers OWNER TO w4;

--
-- Name: engine_consumers_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_consumers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_consumers_id_seq OWNER TO w4;

--
-- Name: engine_consumers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_consumers_id_seq OWNED BY engine_consumers.id;


--
-- Name: engine_conversions_calls; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions_calls (
    id bigint NOT NULL,
    click_id bigint,
    url_path text,
    url_args text,
    cookie text,
    failure text,
    conversion_ip text,
    created_date timestamp with time zone,
    hitpath_ref_id text
);


ALTER TABLE public.engine_conversions_calls OWNER TO w4;

--
-- Name: engine_conversions_calls_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_calls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_calls_id_seq OWNER TO w4;

--
-- Name: engine_conversions_calls_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_calls_id_seq OWNED BY engine_conversions_calls.id;


--
-- Name: engine_conversions_calls_success; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions_calls_success (
    id bigint NOT NULL,
    conversion_call_id bigint,
    conversion_id bigint,
    failure text,
    created_date timestamp with time zone
);


ALTER TABLE public.engine_conversions_calls_success OWNER TO w4;

--
-- Name: engine_conversions_calls_success_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_calls_success_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_calls_success_id_seq OWNER TO w4;

--
-- Name: engine_conversions_calls_success_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_calls_success_id_seq OWNED BY engine_conversions_calls_success.id;


--
-- Name: engine_conversions_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_id_seq OWNER TO w4;

--
-- Name: engine_conversions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_id_seq OWNED BY engine_conversions.id;


--
-- Name: engine_conversions_manual; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions_manual (
    id bigint NOT NULL,
    conversion_id bigint,
    admin_id bigint,
    status smallint,
    payin money,
    payout money,
    manual_type conversion_manual
);


ALTER TABLE public.engine_conversions_manual OWNER TO w4;

--
-- Name: engine_conversions_manual_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_manual_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_manual_id_seq OWNER TO w4;

--
-- Name: engine_conversions_manual_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_manual_id_seq OWNED BY engine_conversions_manual.id;


--
-- Name: engine_conversions_rollup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions_rollup (
    id bigint NOT NULL,
    start_time timestamp with time zone,
    stop_time timestamp with time zone,
    status status_rollup,
    message text
);


ALTER TABLE public.engine_conversions_rollup OWNER TO w4;

--
-- Name: engine_conversions_rollup_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_rollup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_rollup_id_seq OWNER TO w4;

--
-- Name: engine_conversions_rollup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_rollup_id_seq OWNED BY engine_conversions_rollup.id;


--
-- Name: engine_conversions_rollup_queue; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions_rollup_queue (
    id integer NOT NULL,
    conversion_id bigint NOT NULL,
    campaign_id bigint,
    advertiser_id bigint,
    publisher_id bigint,
    parent_publisher_id bigint,
    creative_id integer,
    country character varying(255) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    browser_id integer,
    platform_id integer,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    created_date timestamp with time zone NOT NULL,
    base_uri character varying(250) DEFAULT NULL::character varying,
    payin money,
    payout money,
    rollup_id bigint
);


ALTER TABLE public.engine_conversions_rollup_queue OWNER TO w4;

--
-- Name: engine_conversions_rollup_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_rollup_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_rollup_queue_id_seq OWNER TO w4;

--
-- Name: engine_conversions_rollup_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_rollup_queue_id_seq OWNED BY engine_conversions_rollup_queue.id;


--
-- Name: engine_conversions_staging; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions_staging (
    id bigint NOT NULL,
    click_id bigint,
    payin money,
    payout money,
    parent_payout money,
    campaign_id bigint DEFAULT 0,
    publisher_id bigint DEFAULT 0,
    parent_publisher_id bigint DEFAULT 0,
    referral_url_id text,
    creative_id integer DEFAULT 0,
    ip_address inet,
    continent character(2) DEFAULT NULL::bpchar,
    country character varying(255) DEFAULT NULL::character varying,
    region character varying(2) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT 1,
    channel integer,
    modified_date timestamp with time zone,
    created_date timestamp with time zone
);


ALTER TABLE public.engine_conversions_staging OWNER TO w4;

--
-- Name: engine_conversions_staging_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_staging_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_staging_id_seq OWNER TO w4;

--
-- Name: engine_conversions_staging_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_staging_id_seq OWNED BY engine_conversions_staging.id;


--
-- Name: engine_conversions_tmp; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions_tmp (
    id bigint NOT NULL,
    click_id bigint,
    payin money,
    payout money,
    parent_payout money,
    campaign_id bigint DEFAULT 0,
    publisher_id bigint DEFAULT 0,
    parent_publisher_id bigint DEFAULT 0,
    referral_url text,
    creative_id integer DEFAULT 0,
    ip_address inet,
    continent character(2) DEFAULT NULL::bpchar,
    country character varying(255) DEFAULT NULL::character varying,
    region character varying(2) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT 1,
    channel bigint,
    modified_date timestamp with time zone,
    created_date timestamp with time zone NOT NULL,
    advertiser_refid text
);


ALTER TABLE public.engine_conversions_tmp OWNER TO w4;

--
-- Name: engine_conversions_tmp_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_tmp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_tmp_id_seq OWNER TO w4;

--
-- Name: engine_conversions_tmp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_tmp_id_seq OWNED BY engine_conversions_tmp.id;


--
-- Name: engine_conversions_waiting; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_conversions_waiting (
    id bigint NOT NULL,
    reason conversion_wait_reasons,
    click_id bigint,
    payin money,
    payout money,
    parent_payout money,
    campaign_id bigint DEFAULT 0,
    publisher_id bigint DEFAULT 0,
    parent_publisher_id bigint DEFAULT 0,
    referral_url text,
    creative_id integer DEFAULT 0,
    ip_address inet,
    continent character(2) DEFAULT NULL::bpchar,
    country character varying(255) DEFAULT NULL::character varying,
    region character varying(2) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT 1,
    channel bigint,
    modified_date timestamp with time zone,
    created_date timestamp with time zone NOT NULL
);


ALTER TABLE public.engine_conversions_waiting OWNER TO w4;

--
-- Name: engine_conversions_waiting_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_conversions_waiting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_conversions_waiting_id_seq OWNER TO w4;

--
-- Name: engine_conversions_waiting_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_conversions_waiting_id_seq OWNED BY engine_conversions_waiting.id;


--
-- Name: engine_error_log; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_error_log (
    id bigint NOT NULL,
    campaign_id bigint,
    pub_id integer,
    url character varying(255) DEFAULT NULL::character varying,
    short_error character varying(255) DEFAULT NULL::character varying,
    debug_trace text,
    first_occurrence timestamp with time zone,
    last_occurrence timestamp with time zone,
    number_of_occurrences integer DEFAULT 1 NOT NULL,
    status character varying,
    CONSTRAINT engine_error_log_status_check CHECK (((status)::text = ANY (ARRAY[('new'::character varying)::text, ('ticketed'::character varying)::text, ('unresolved'::character varying)::text, ('resolved'::character varying)::text])))
);


ALTER TABLE public.engine_error_log OWNER TO w4;

--
-- Name: engine_error_log_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_error_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_error_log_id_seq OWNER TO w4;

--
-- Name: engine_error_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_error_log_id_seq OWNED BY engine_error_log.id;


--
-- Name: engine_pixel_tests; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_pixel_tests (
    id bigint NOT NULL,
    url text,
    result json
);


ALTER TABLE public.engine_pixel_tests OWNER TO w4;

--
-- Name: engine_pixel_tests_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_pixel_tests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_pixel_tests_id_seq OWNER TO w4;

--
-- Name: engine_pixel_tests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_pixel_tests_id_seq OWNED BY engine_pixel_tests.id;


--
-- Name: engine_redirect_decisions; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_redirect_decisions (
    id bigint NOT NULL,
    click_id bigint,
    campaign_id bigint,
    publisher_id bigint,
    redirect text,
    pixel text,
    failed_reason text
);


ALTER TABLE public.engine_redirect_decisions OWNER TO w4;

--
-- Name: engine_redirect_decisions_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_redirect_decisions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_redirect_decisions_id_seq OWNER TO w4;

--
-- Name: engine_redirect_decisions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_redirect_decisions_id_seq OWNED BY engine_redirect_decisions.id;


--
-- Name: engine_tests; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE engine_tests (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    manager_id bigint NOT NULL,
    click_results json,
    conversion_results json,
    status status_entity,
    created_date timestamp with time zone
);


ALTER TABLE public.engine_tests OWNER TO w4;

--
-- Name: engine_tests_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE engine_tests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.engine_tests_id_seq OWNER TO w4;

--
-- Name: engine_tests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE engine_tests_id_seq OWNED BY engine_tests.id;


--
-- Name: entity_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE entity_types (
    id integer DEFAULT 0 NOT NULL,
    type_name character varying(50) DEFAULT NULL::character varying
);


ALTER TABLE public.entity_types OWNER TO w4;

--
-- Name: entries; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE entries (
    id character varying(255) NOT NULL,
    name character varying(255) NOT NULL,
    content text NOT NULL
);


ALTER TABLE public.entries OWNER TO w4;

--
-- Name: files; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE files (
    id bigint NOT NULL,
    file_name text,
    mime_type text,
    folder text,
    width integer,
    height integer,
    size integer,
    status status_entity,
    last_modified timestamp with time zone,
    user_id bigint,
    extension text,
    parent_file_id bigint
);


ALTER TABLE public.files OWNER TO w4;

--
-- Name: files_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE files_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.files_id_seq OWNER TO w4;

--
-- Name: files_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE files_id_seq OWNED BY files.id;


--
-- Name: gearman_jobs; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE gearman_jobs (
    id bigint NOT NULL,
    unique_id character(40) DEFAULT NULL::bpchar,
    job_handle character(20) DEFAULT NULL::bpchar,
    user_id bigint,
    function_called character varying(100) DEFAULT NULL::character varying,
    submitted_timestamp timestamp with time zone,
    start_timestamp timestamp with time zone,
    complete_timestamp timestamp with time zone,
    status character varying DEFAULT 'running'::character varying,
    percent_complete integer DEFAULT 0,
    error_number integer,
    error_message character varying(255) DEFAULT NULL::character varying,
    results bytea,
    CONSTRAINT gearman_jobs_status_check CHECK (((status)::text = ANY (ARRAY[('submitted'::character varying)::text, ('running'::character varying)::text, ('success'::character varying)::text, ('failure'::character varying)::text])))
);


ALTER TABLE public.gearman_jobs OWNER TO w4;

--
-- Name: gearman_jobs_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE gearman_jobs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.gearman_jobs_id_seq OWNER TO w4;

--
-- Name: gearman_jobs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE gearman_jobs_id_seq OWNED BY gearman_jobs.id;


--
-- Name: geo_target_cities; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE geo_target_cities (
    id bigint NOT NULL,
    maxmind_id bigint,
    place_name text,
    place_name_ascii text,
    alternate_names text,
    latitude numeric,
    longitude numeric,
    country_code character(2),
    admin1_code text,
    area_code integer,
    metro_code integer,
    postal_code text,
    modification_date date,
    search_string text
);


ALTER TABLE public.geo_target_cities OWNER TO w4;

--
-- Name: geo_target_cities_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE geo_target_cities_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.geo_target_cities_id_seq OWNER TO w4;

--
-- Name: geo_target_cities_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE geo_target_cities_id_seq OWNED BY geo_target_cities.id;


--
-- Name: geo_target_countries; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE geo_target_countries (
    id bigint NOT NULL,
    iso character varying,
    country character varying,
    continent character varying,
    country_search text
);


ALTER TABLE public.geo_target_countries OWNER TO w4;

--
-- Name: geo_target_countries_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE geo_target_countries_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.geo_target_countries_id_seq OWNER TO w4;

--
-- Name: geo_target_countries_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE geo_target_countries_id_seq OWNED BY geo_target_countries.id;


--
-- Name: geo_target_region; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE geo_target_region (
    id bigint NOT NULL,
    country character varying NOT NULL,
    admin1_code character varying NOT NULL,
    local_name character varying,
    ascii_name character varying,
    region_search text
);


ALTER TABLE public.geo_target_region OWNER TO w4;

--
-- Name: geo_target_region_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE geo_target_region_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.geo_target_region_id_seq OWNER TO w4;

--
-- Name: geo_target_region_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE geo_target_region_id_seq OWNED BY geo_target_region.id;


--
-- Name: geo_typeahead_cities; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE geo_typeahead_cities (
    id bigint NOT NULL,
    place_name text,
    place_name_ascii text,
    alternate_names text,
    latitude numeric,
    longitude numeric,
    feature_class character(1),
    feature_code text,
    country_code character(2),
    cc2 text,
    admin1_code text,
    admin2_code text,
    admin3_code text,
    admin4_code text,
    population bigint,
    elevation bigint,
    dem bigint,
    timezone text,
    modification_date date,
    search_string text
);


ALTER TABLE public.geo_typeahead_cities OWNER TO w4;

--
-- Name: geo_typeahead_countries; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE geo_typeahead_countries (
    id bigint NOT NULL,
    iso character varying,
    iso3 character varying,
    iso_numeric character varying,
    fips character varying,
    country character varying,
    capital character varying,
    area_sq_km character varying,
    population character varying,
    continent character varying,
    tld character varying,
    currencycode character varying,
    currencyname character varying,
    phone character varying,
    postal_code_format character varying,
    postal_code_regex character varying,
    languages character varying,
    geonameid character varying,
    neighbours character varying,
    equivalentfipscode character varying,
    set_order integer DEFAULT 150 NOT NULL,
    country_search text
);


ALTER TABLE public.geo_typeahead_countries OWNER TO w4;

--
-- Name: geo_typeahead_countries_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE geo_typeahead_countries_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.geo_typeahead_countries_id_seq OWNER TO w4;

--
-- Name: geo_typeahead_countries_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE geo_typeahead_countries_id_seq OWNED BY geo_typeahead_countries.id;


--
-- Name: geo_typeahead_region; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE geo_typeahead_region (
    country character varying NOT NULL,
    admin1_code character varying NOT NULL,
    local_name character varying,
    ascii_name character varying,
    id bigint NOT NULL,
    region_search text
);


ALTER TABLE public.geo_typeahead_region OWNER TO w4;

--
-- Name: geo_typeahead_region_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE geo_typeahead_region_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.geo_typeahead_region_id_seq OWNER TO w4;

--
-- Name: geo_typeahead_region_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE geo_typeahead_region_id_seq OWNED BY geo_typeahead_region.id;


--
-- Name: geocoding; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE geocoding (
    address character varying(255) DEFAULT ''::character varying NOT NULL,
    latitude character varying(255) NOT NULL,
    longitude character varying(255) NOT NULL
);


ALTER TABLE public.geocoding OWNER TO w4;

--
-- Name: global_settings; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE global_settings (
    id bigint NOT NULL,
    name text NOT NULL,
    value text,
    type text DEFAULT '0'::text
);


ALTER TABLE public.global_settings OWNER TO w4;

--
-- Name: global_settings_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE global_settings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.global_settings_id_seq OWNER TO w4;

--
-- Name: global_settings_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE global_settings_id_seq OWNED BY global_settings.id;


--
-- Name: hosted_creative_assets; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE hosted_creative_assets (
    id bigint NOT NULL,
    creative_id integer NOT NULL,
    sequence_id smallint NOT NULL,
    file_id character varying(24) NOT NULL,
    url character varying(2083) DEFAULT NULL::character varying,
    archive_name character varying(255) DEFAULT NULL::character varying,
    file_name character varying(255) DEFAULT NULL::character varying,
    file_hash character varying(255) DEFAULT NULL::character varying,
    CONSTRAINT hosted_creative_assets_creative_id_check CHECK ((creative_id >= 0)),
    CONSTRAINT hosted_creative_assets_sequence_id_check CHECK ((sequence_id >= 0))
);


ALTER TABLE public.hosted_creative_assets OWNER TO w4;

--
-- Name: hosted_creative_assets_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE hosted_creative_assets_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.hosted_creative_assets_id_seq OWNER TO w4;

--
-- Name: hosted_creative_assets_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE hosted_creative_assets_id_seq OWNED BY hosted_creative_assets.id;


--
-- Name: im_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE im_types (
    id bigint NOT NULL,
    name_short character varying(30) NOT NULL,
    description character varying(150) NOT NULL
);


ALTER TABLE public.im_types OWNER TO w4;

--
-- Name: im_types_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE im_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.im_types_id_seq OWNER TO w4;

--
-- Name: im_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE im_types_id_seq OWNED BY im_types.id;


--
-- Name: image_url_batches; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE image_url_batches (
    id bigint NOT NULL,
    start_time timestamp with time zone,
    stop_time timestamp with time zone,
    status status_batch,
    message text
);


ALTER TABLE public.image_url_batches OWNER TO w4;

--
-- Name: image_url_batches_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE image_url_batches_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.image_url_batches_id_seq OWNER TO w4;

--
-- Name: image_url_batches_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE image_url_batches_id_seq OWNED BY image_url_batches.id;


--
-- Name: image_url_queue; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE image_url_queue (
    id bigint NOT NULL,
    file_id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    url text NOT NULL,
    width numeric,
    height numeric,
    status status_batch,
    batch_id bigint
);


ALTER TABLE public.image_url_queue OWNER TO w4;

--
-- Name: image_url_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE image_url_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.image_url_queue_id_seq OWNER TO w4;

--
-- Name: image_url_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE image_url_queue_id_seq OWNED BY image_url_queue.id;


--
-- Name: interfaces; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE interfaces (
    id integer DEFAULT 0 NOT NULL,
    interface_name character varying(50) DEFAULT NULL::character varying
);


ALTER TABLE public.interfaces OWNER TO w4;

--
-- Name: message_delivery_setting_types_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE message_delivery_setting_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.message_delivery_setting_types_id_seq OWNER TO w4;

--
-- Name: message_delivery_setting_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE message_delivery_setting_types_id_seq OWNED BY message_delivery_setting_types.id;


--
-- Name: message_delivery_settings; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE message_delivery_settings (
    id bigint NOT NULL,
    delivery_setting_name character varying(32) DEFAULT NULL::character varying,
    delivery_setting_description character varying(250) DEFAULT NULL::character varying
);


ALTER TABLE public.message_delivery_settings OWNER TO w4;

--
-- Name: message_delivery_settings_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE message_delivery_settings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.message_delivery_settings_id_seq OWNER TO w4;

--
-- Name: message_delivery_settings_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE message_delivery_settings_id_seq OWNED BY message_delivery_settings.id;


--
-- Name: message_delivery_types_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE message_delivery_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.message_delivery_types_id_seq OWNER TO w4;

--
-- Name: message_delivery_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE message_delivery_types_id_seq OWNED BY message_delivery_types.id;


--
-- Name: message_status_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE message_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.message_status_id_seq OWNER TO w4;

--
-- Name: message_status_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE message_status_id_seq OWNED BY message_status.id;


--
-- Name: message_types_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE message_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.message_types_id_seq OWNER TO w4;

--
-- Name: message_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE message_types_id_seq OWNED BY message_types.id;


--
-- Name: messages_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE messages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.messages_id_seq OWNER TO w4;

--
-- Name: messages_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE messages_id_seq OWNED BY messages.id;


--
-- Name: normalization_io; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE normalization_io (
    function_name text,
    db_var text,
    ui_var text
);


ALTER TABLE public.normalization_io OWNER TO w4;

--
-- Name: overtracking_settings; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE overtracking_settings (
    min_val_overtracking numeric(40,4) DEFAULT NULL::numeric,
    base_amt_not_distributed numeric(5,4) DEFAULT NULL::numeric,
    max_fraud_click_count integer,
    distribution_method character varying(32) DEFAULT NULL::character varying
);


ALTER TABLE public.overtracking_settings OWNER TO w4;

--
-- Name: payment_methods; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE payment_methods (
    id integer NOT NULL,
    name_short character varying(30) NOT NULL,
    description character varying(150) NOT NULL,
    CONSTRAINT payment_methods_id_check CHECK ((id >= 0))
);


ALTER TABLE public.payment_methods OWNER TO w4;

--
-- Name: pgbench_accounts; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE pgbench_accounts (
    aid integer NOT NULL,
    bid integer,
    abalance integer,
    filler character(84)
)
WITH (fillfactor=100);


ALTER TABLE public.pgbench_accounts OWNER TO w4;

--
-- Name: pgbench_branches; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE pgbench_branches (
    bid integer NOT NULL,
    bbalance integer,
    filler character(88)
)
WITH (fillfactor=100);


ALTER TABLE public.pgbench_branches OWNER TO w4;

--
-- Name: pgbench_history; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE pgbench_history (
    tid integer,
    bid integer,
    aid integer,
    delta integer,
    mtime timestamp without time zone,
    filler character(22)
);


ALTER TABLE public.pgbench_history OWNER TO w4;

--
-- Name: pgbench_tellers; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE pgbench_tellers (
    tid integer NOT NULL,
    bid integer,
    tbalance integer,
    filler character(84)
)
WITH (fillfactor=100);


ALTER TABLE public.pgbench_tellers OWNER TO w4;

--
-- Name: publisher_account_changes; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_account_changes (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    changed_at timestamp with time zone DEFAULT now() NOT NULL,
    status status_request DEFAULT 'pending'::status_request,
    contact_type contact,
    image_id bigint,
    email text,
    primary_phone text,
    secondary_phone text,
    first_name text,
    last_name text,
    fax text,
    messenger_name text,
    messenger_type bigint,
    password text,
    login_name text,
    website_url text,
    address_1 text,
    address_2 text,
    country_id bigint,
    region_id bigint,
    city_id bigint,
    postal_code text,
    tax_id text,
    payment_method_id bigint,
    payment_to text
);


ALTER TABLE public.publisher_account_changes OWNER TO w4;

--
-- Name: publisher_account_changes_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_account_changes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_account_changes_id_seq OWNER TO w4;

--
-- Name: publisher_account_changes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_account_changes_id_seq OWNED BY publisher_account_changes.id;


--
-- Name: publisher_account_changes_import; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_account_changes_import (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    creator_initials character varying(16) NOT NULL,
    ip_address inet NOT NULL,
    description text NOT NULL,
    changed_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.publisher_account_changes_import OWNER TO w4;

--
-- Name: publisher_account_changes_import_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_account_changes_import_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_account_changes_import_id_seq OWNER TO w4;

--
-- Name: publisher_account_changes_import_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_account_changes_import_id_seq OWNED BY publisher_account_changes_import.id;


--
-- Name: publisher_application_scores; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_application_scores (
    publisher_id bigint NOT NULL,
    score numeric,
    risk_score numeric,
    distance smallint,
    ip character varying(255) NOT NULL,
    ip_fwd character varying(255) NOT NULL,
    ip_isp character varying(255) DEFAULT NULL::character varying,
    ip_org character varying(255) DEFAULT NULL::character varying,
    ip_latitude character varying(255) DEFAULT NULL::character varying,
    ip_longitude character varying(255) DEFAULT NULL::character varying,
    ip_city character varying(255) DEFAULT NULL::character varying,
    ip_region character varying(255) DEFAULT NULL::character varying,
    ip_country character varying(2) DEFAULT NULL::character varying,
    declared_city character varying(255) NOT NULL,
    declared_region character varying(255) NOT NULL,
    declared_postal character varying(255) NOT NULL,
    declared_country character varying(2) NOT NULL,
    is_ip_country_match smallint,
    is_city_postal_match smallint,
    proxy_score numeric,
    is_anonymous_proxy smallint,
    is_transparent_proxy smallint,
    email character varying(255) NOT NULL,
    is_free_email smallint,
    is_disposable_email smallint,
    is_high_risk_country smallint,
    is_common_password smallint,
    is_high_risk_password smallint,
    phone character varying(255) DEFAULT NULL::character varying,
    is_phone_in_location smallint,
    notes text,
    updated_at timestamp with time zone NOT NULL,
    CONSTRAINT publisher_application_scores_distance_check CHECK ((distance >= 0)),
    CONSTRAINT publisher_application_scores_is_anonymous_proxy_check CHECK ((is_anonymous_proxy >= 0)),
    CONSTRAINT publisher_application_scores_is_city_postal_match_check CHECK ((is_city_postal_match >= 0)),
    CONSTRAINT publisher_application_scores_is_common_password_check CHECK ((is_common_password >= 0)),
    CONSTRAINT publisher_application_scores_is_disposable_email_check CHECK ((is_disposable_email >= 0)),
    CONSTRAINT publisher_application_scores_is_free_email_check CHECK ((is_free_email >= 0)),
    CONSTRAINT publisher_application_scores_is_high_risk_country_check CHECK ((is_high_risk_country >= 0)),
    CONSTRAINT publisher_application_scores_is_high_risk_password_check CHECK ((is_high_risk_password >= 0)),
    CONSTRAINT publisher_application_scores_is_ip_country_match_check CHECK ((is_ip_country_match >= 0)),
    CONSTRAINT publisher_application_scores_is_phone_in_location_check CHECK ((is_phone_in_location >= 0)),
    CONSTRAINT publisher_application_scores_is_transparent_proxy_check CHECK ((is_transparent_proxy >= 0)),
    CONSTRAINT publisher_application_scores_proxy_score_check CHECK ((proxy_score >= (0)::numeric)),
    CONSTRAINT publisher_application_scores_publisher_id_check CHECK ((publisher_id >= 0)),
    CONSTRAINT publisher_application_scores_risk_score_check CHECK ((risk_score >= (0)::numeric)),
    CONSTRAINT publisher_application_scores_score_check CHECK ((score >= (0)::numeric))
);


ALTER TABLE public.publisher_application_scores OWNER TO w4;

--
-- Name: publisher_auth_tokens; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_auth_tokens (
    publisher_id bigint NOT NULL,
    token character varying(255) NOT NULL,
    CONSTRAINT publisher_auth_tokens_publisher_id_check CHECK ((publisher_id >= 0))
);


ALTER TABLE public.publisher_auth_tokens OWNER TO w4;

--
-- Name: publisher_blocked_subids_import; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_blocked_subids_import (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    campaign_id bigint,
    subid text,
    status text,
    creation_date timestamp with time zone NOT NULL,
    creator text
);


ALTER TABLE public.publisher_blocked_subids_import OWNER TO w4;

--
-- Name: publisher_blocked_subids_import_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_blocked_subids_import_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_blocked_subids_import_id_seq OWNER TO w4;

--
-- Name: publisher_blocked_subids_import_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_blocked_subids_import_id_seq OWNED BY publisher_blocked_subids_import.id;


--
-- Name: publisher_campaign_recommendations; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_campaign_recommendations (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    user_id integer NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    CONSTRAINT publisher_campaign_recommendations_campaign_id_check CHECK ((campaign_id >= 0)),
    CONSTRAINT publisher_campaign_recommendations_publisher_id_check CHECK ((publisher_id >= 0)),
    CONSTRAINT publisher_campaign_recommendations_user_id_check CHECK ((user_id >= 0))
);


ALTER TABLE public.publisher_campaign_recommendations OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_campaign_recommendations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_campaign_recommendations_id_seq OWNER TO w4;

--
-- Name: publisher_campaign_recommendations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_campaign_recommendations_id_seq OWNED BY publisher_campaign_recommendations.id;


--
-- Name: publisher_campaign_searches; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_campaign_searches (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    query character varying(255) NOT NULL,
    CONSTRAINT publisher_campaign_searches_publisher_id_check CHECK ((publisher_id >= 0))
);


ALTER TABLE public.publisher_campaign_searches OWNER TO w4;

--
-- Name: publisher_campaign_searches_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_campaign_searches_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_campaign_searches_id_seq OWNER TO w4;

--
-- Name: publisher_campaign_searches_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_campaign_searches_id_seq OWNED BY publisher_campaign_searches.id;


--
-- Name: publisher_change_requests; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_change_requests (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    company_name character varying(255) DEFAULT NULL::character varying,
    company_position character varying(255) DEFAULT NULL::character varying,
    payment_address_1 character varying(255) DEFAULT NULL::character varying,
    payment_address_2 character varying(255) DEFAULT NULL::character varying,
    payment_city character varying(255) DEFAULT NULL::character varying,
    payment_region character varying(255) DEFAULT NULL::character varying,
    payment_postal_code character varying(10) DEFAULT NULL::character varying,
    payment_country character(2) DEFAULT NULL::bpchar,
    payment_to character varying,
    payment_by smallint,
    payment_schedule character varying,
    payment_threshold numeric(18,4) DEFAULT NULL::numeric,
    tax_id character varying(32) DEFAULT NULL::character varying,
    payment_type character varying DEFAULT ''::character varying,
    payment_bank_routing_number character varying(30) DEFAULT NULL::character varying,
    payment_bank_account_number character varying(40) DEFAULT NULL::character varying,
    change_status character varying DEFAULT 'new'::character varying,
    created timestamp with time zone,
    approved_by bigint,
    CONSTRAINT publisher_change_requests_change_status_check CHECK (((change_status)::text = ANY (ARRAY[('new'::character varying)::text, ('approved'::character varying)::text, ('rejected'::character varying)::text]))),
    CONSTRAINT publisher_change_requests_payment_schedule_check CHECK (((payment_schedule)::text = ANY (ARRAY[('monthly'::character varying)::text, ('weekly'::character varying)::text, ('semi-monthly'::character varying)::text, ('bi-weekly'::character varying)::text, (''::character varying)::text]))),
    CONSTRAINT publisher_change_requests_payment_to_check CHECK (((payment_to)::text = ANY (ARRAY[('company'::character varying)::text, ('person'::character varying)::text]))),
    CONSTRAINT publisher_change_requests_payment_type_check CHECK (((payment_type)::text = ANY (ARRAY[('check'::character varying)::text, ('wire'::character varying)::text, ('ach'::character varying)::text, (''::character varying)::text])))
);


ALTER TABLE public.publisher_change_requests OWNER TO w4;

--
-- Name: publisher_change_requests_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_change_requests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_change_requests_id_seq OWNER TO w4;

--
-- Name: publisher_change_requests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_change_requests_id_seq OWNED BY publisher_change_requests.id;


--
-- Name: publisher_contact; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_contact (
    id bigint NOT NULL,
    publisher_id bigint,
    contact_id bigint
);


ALTER TABLE public.publisher_contact OWNER TO w4;

--
-- Name: publisher_contact_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_contact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_contact_id_seq OWNER TO w4;

--
-- Name: publisher_contact_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_contact_id_seq OWNED BY publisher_contact.id;


--
-- Name: publisher_groups; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_groups (
    id bigint NOT NULL,
    name character varying(128) NOT NULL,
    description text,
    last_modified timestamp with time zone,
    user_id bigint,
    status status_entity DEFAULT 'active'::status_entity
);


ALTER TABLE public.publisher_groups OWNER TO w4;

--
-- Name: publisher_groups_assoc; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_groups_assoc (
    publisher_id bigint NOT NULL,
    group_id integer NOT NULL,
    CONSTRAINT publisher_groups_assoc_group_id_check CHECK ((group_id >= 0)),
    CONSTRAINT publisher_groups_assoc_publisher_id_check CHECK ((publisher_id >= 0))
);


ALTER TABLE public.publisher_groups_assoc OWNER TO w4;

--
-- Name: publisher_groups_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_groups_id_seq OWNER TO w4;

--
-- Name: publisher_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_groups_id_seq OWNED BY publisher_groups.id;


--
-- Name: publisher_interface_settings; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_interface_settings (
    id bigint NOT NULL,
    publisher_id bigint,
    ui_location text,
    settings text
);


ALTER TABLE public.publisher_interface_settings OWNER TO w4;

--
-- Name: TABLE publisher_interface_settings; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE publisher_interface_settings IS 'This is used to store Publisher UI choices in a convenient JSON format';


--
-- Name: publisher_interface_settings_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_interface_settings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_interface_settings_id_seq OWNER TO w4;

--
-- Name: publisher_interface_settings_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_interface_settings_id_seq OWNED BY publisher_interface_settings.id;


--
-- Name: publisher_notes; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_notes (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    content character varying(255) NOT NULL,
    created_at timestamp with time zone NOT NULL,
    CONSTRAINT publisher_notes_publisher_id_check CHECK ((publisher_id >= 0))
);


ALTER TABLE public.publisher_notes OWNER TO w4;

--
-- Name: publisher_notes_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_notes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_notes_id_seq OWNER TO w4;

--
-- Name: publisher_notes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_notes_id_seq OWNED BY publisher_notes.id;


--
-- Name: publisher_overrides_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_overrides_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_overrides_id_seq OWNER TO w4;

--
-- Name: publisher_overrides_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_overrides_id_seq OWNED BY publisher_overrides.id;


--
-- Name: publisher_password_recovery_keys; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_password_recovery_keys (
    publisher_id bigint NOT NULL,
    recovery_key integer NOT NULL,
    CONSTRAINT publisher_password_recovery_keys_publisher_id_check CHECK ((publisher_id >= 0)),
    CONSTRAINT publisher_password_recovery_keys_recovery_key_check CHECK ((recovery_key >= 0))
);


ALTER TABLE public.publisher_password_recovery_keys OWNER TO w4;

--
-- Name: publisher_signup; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_signup (
    id bigint NOT NULL,
    first_name character varying(250),
    last_name character varying(250),
    title character varying(20) DEFAULT NULL::character varying,
    account_address_1 character varying(250),
    account_address_2 character varying(250) DEFAULT NULL::character varying,
    account_city_name character varying(250),
    account_city_id bigint,
    account_region_id bigint,
    account_country_id bigint,
    account_postal_code character varying(16),
    primary_phone character varying(32),
    fax character varying(32) DEFAULT NULL::character varying,
    email character varying(255),
    messenger_name character varying(250) DEFAULT NULL::character varying,
    messenger_type bigint,
    company_name character varying(255),
    billing_address_1 character varying(250),
    billing_address_2 character varying(250) DEFAULT NULL::character varying,
    billing_city_name character varying(250),
    billing_city_id bigint,
    billing_region_id bigint,
    billing_country_id bigint,
    billing_postal_code character varying(16),
    tax_class text,
    tax_id character varying(32),
    payment_to text,
    website_url character varying(255),
    site_category text,
    how_you_market text,
    comments text,
    login_name character varying NOT NULL,
    password character(40),
    challenge_question text,
    challenge_answer text,
    security_code text,
    status status_publisher,
    publisher_id bigint,
    created timestamp with time zone,
    modified timestamp with time zone,
    publisher_parent_id bigint,
    parent_publisher_id bigint,
    referrer_id bigint
);


ALTER TABLE public.publisher_signup OWNER TO w4;

--
-- Name: publisher_signup_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_signup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_signup_id_seq OWNER TO w4;

--
-- Name: publisher_signup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_signup_id_seq OWNED BY publisher_signup.id;


--
-- Name: publisher_support_contact; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_support_contact (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    user_id bigint NOT NULL,
    subject text NOT NULL,
    message text NOT NULL,
    sent_on timestamp with time zone NOT NULL,
    status character varying(12) NOT NULL,
    http_user_agent character(32) NOT NULL,
    http_referrer character varying(1024) NOT NULL,
    remote_ip inet NOT NULL,
    remote_host character varying(1024) NOT NULL,
    CONSTRAINT publisher_support_contact_publisher_id_check CHECK ((publisher_id >= 0)),
    CONSTRAINT publisher_support_contact_user_id_check CHECK ((user_id >= 0))
);


ALTER TABLE public.publisher_support_contact OWNER TO w4;

--
-- Name: publisher_support_contact_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_support_contact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_support_contact_id_seq OWNER TO w4;

--
-- Name: publisher_support_contact_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_support_contact_id_seq OWNED BY publisher_support_contact.id;


--
-- Name: publisher_suppression_internal_requests; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_suppression_internal_requests (
    id bigint NOT NULL,
    list_id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    created_date timestamp with time zone
);


ALTER TABLE public.publisher_suppression_internal_requests OWNER TO w4;

--
-- Name: publisher_suppression_internal_requests_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_suppression_internal_requests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_suppression_internal_requests_id_seq OWNER TO w4;

--
-- Name: publisher_suppression_internal_requests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_suppression_internal_requests_id_seq OWNED BY publisher_suppression_internal_requests.id;


--
-- Name: publisher_suppression_optizmo_requests; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_suppression_optizmo_requests (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    created_date timestamp with time zone
);


ALTER TABLE public.publisher_suppression_optizmo_requests OWNER TO w4;

--
-- Name: publisher_suppression_optizmo_requests_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_suppression_optizmo_requests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_suppression_optizmo_requests_id_seq OWNER TO w4;

--
-- Name: publisher_suppression_optizmo_requests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_suppression_optizmo_requests_id_seq OWNED BY publisher_suppression_optizmo_requests.id;


--
-- Name: publisher_tiers; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_tiers (
    id bigint NOT NULL,
    name character varying(128) NOT NULL
);


ALTER TABLE public.publisher_tiers OWNER TO w4;

--
-- Name: publisher_tiers_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_tiers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_tiers_id_seq OWNER TO w4;

--
-- Name: publisher_tiers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_tiers_id_seq OWNED BY publisher_tiers.id;


--
-- Name: publisher_uploads; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE publisher_uploads (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    file_id character varying(24) NOT NULL,
    file_name character varying(255) NOT NULL,
    extension character varying(4) DEFAULT NULL::character varying,
    comments text,
    uploaded_at timestamp with time zone NOT NULL,
    CONSTRAINT publisher_uploads_publisher_id_check CHECK ((publisher_id >= 0))
);


ALTER TABLE public.publisher_uploads OWNER TO w4;

--
-- Name: publisher_uploads_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE publisher_uploads_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.publisher_uploads_id_seq OWNER TO w4;

--
-- Name: publisher_uploads_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE publisher_uploads_id_seq OWNED BY publisher_uploads.id;


--
-- Name: raster_overviews; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW raster_overviews AS
 SELECT current_database() AS o_table_catalog,
    n.nspname AS o_table_schema,
    c.relname AS o_table_name,
    a.attname AS o_raster_column,
    current_database() AS r_table_catalog,
    (split_part(split_part(s.consrc, '''::name'::text, 1), ''''::text, 2))::name AS r_table_schema,
    (split_part(split_part(s.consrc, '''::name'::text, 2), ''''::text, 2))::name AS r_table_name,
    (split_part(split_part(s.consrc, '''::name'::text, 3), ''''::text, 2))::name AS r_raster_column,
    (btrim(split_part(s.consrc, ','::text, 2)))::integer AS overview_factor
   FROM pg_class c,
    pg_attribute a,
    pg_type t,
    pg_namespace n,
    pg_constraint s
  WHERE ((((((((((t.typname = 'raster'::name) AND (a.attisdropped = false)) AND (a.atttypid = t.oid)) AND (a.attrelid = c.oid)) AND (c.relnamespace = n.oid)) AND ((c.relkind = 'r'::"char") OR (c.relkind = 'v'::"char"))) AND (s.connamespace = n.oid)) AND (s.conrelid = c.oid)) AND (s.consrc ~~ '%_overview_constraint(%'::text)) AND (NOT pg_is_other_temp_schema(c.relnamespace)));


ALTER TABLE public.raster_overviews OWNER TO w4;

--
-- Name: regions; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE regions (
    id bigint NOT NULL,
    country character varying(2) NOT NULL,
    region character varying(2) NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.regions OWNER TO w4;

--
-- Name: regions_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE regions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.regions_id_seq OWNER TO w4;

--
-- Name: regions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE regions_id_seq OWNED BY regions.id;


--
-- Name: reports_clicks; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks (
    id integer NOT NULL,
    encrypted_id text,
    campaign_id bigint,
    advertiser_id bigint,
    publisher_id bigint,
    parent_publisher_id bigint,
    redirect_url_id integer,
    creative_id integer,
    ip_address inet,
    country character varying(255) DEFAULT NULL::character varying,
    region_name character varying(255) DEFAULT NULL::character varying,
    city character varying(255) DEFAULT NULL::character varying,
    postal_code character varying(10) DEFAULT NULL::character varying,
    latitude double precision,
    longitude double precision,
    metro_code integer,
    area_code integer,
    browser_id integer,
    platform_id integer,
    status smallint DEFAULT (1)::smallint NOT NULL,
    channel bigint,
    nb_dupes integer DEFAULT 0 NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    created_date timestamp with time zone NOT NULL,
    hoy integer,
    base_uri character varying(250) DEFAULT NULL::character varying,
    referral_url text
);


ALTER TABLE public.reports_clicks OWNER TO w4;

--
-- Name: reports_clicks_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE reports_clicks_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.reports_clicks_id_seq OWNER TO w4;

--
-- Name: reports_clicks_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE reports_clicks_id_seq OWNED BY reports_clicks.id;


--
-- Name: ret_val; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE ret_val (
    id bigint,
    address_1 character varying(250),
    address_2 character varying(250),
    country_id bigint,
    country_name character varying,
    region_id bigint,
    region_name character varying,
    city_id bigint,
    city_name text,
    postal_code character varying(16),
    tax_id character varying(32),
    payment_id integer,
    payment_name character varying(150),
    payment_to character varying,
    company_name character varying(255)
);


ALTER TABLE public.ret_val OWNER TO w4;

--
-- Name: rewards_program; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE rewards_program (
    id bigint NOT NULL,
    publisher_tier_id integer,
    target_balance double precision NOT NULL,
    reward_id integer,
    CONSTRAINT rewards_program_publisher_tier_id_check CHECK ((publisher_tier_id >= 0)),
    CONSTRAINT rewards_program_reward_id_check CHECK ((reward_id >= 0)),
    CONSTRAINT rewards_program_target_balance_check CHECK ((target_balance >= (0)::double precision))
);


ALTER TABLE public.rewards_program OWNER TO w4;

--
-- Name: rewards_program_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE rewards_program_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rewards_program_id_seq OWNER TO w4;

--
-- Name: rewards_program_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE rewards_program_id_seq OWNED BY rewards_program.id;


--
-- Name: rewards_types; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE rewards_types (
    id bigint NOT NULL,
    name character varying(128) NOT NULL,
    type character varying NOT NULL,
    value double precision NOT NULL,
    CONSTRAINT rewards_types_type_check CHECK (((type)::text = ANY (ARRAY[('fixed_cash_value'::character varying)::text, ('percent_of_current_balance'::character varying)::text, ('gift_card'::character varying)::text, ('other'::character varying)::text]))),
    CONSTRAINT rewards_types_value_check CHECK ((value >= (0)::double precision))
);


ALTER TABLE public.rewards_types OWNER TO w4;

--
-- Name: rewards_types_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE rewards_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rewards_types_id_seq OWNER TO w4;

--
-- Name: rewards_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE rewards_types_id_seq OWNED BY rewards_types.id;


--
-- Name: screenshot_batches; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE screenshot_batches (
    id bigint NOT NULL,
    start_time timestamp with time zone,
    stop_time timestamp with time zone,
    status status_batch,
    message text
);


ALTER TABLE public.screenshot_batches OWNER TO w4;

--
-- Name: screenshot_batches_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE screenshot_batches_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.screenshot_batches_id_seq OWNER TO w4;

--
-- Name: screenshot_batches_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE screenshot_batches_id_seq OWNED BY screenshot_batches.id;


--
-- Name: screenshot_queue; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE screenshot_queue (
    id bigint NOT NULL,
    file_id bigint NOT NULL,
    url text NOT NULL,
    width numeric,
    height numeric,
    status status_batch,
    batch_id bigint
);


ALTER TABLE public.screenshot_queue OWNER TO w4;

--
-- Name: screenshot_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE screenshot_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.screenshot_queue_id_seq OWNER TO w4;

--
-- Name: screenshot_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE screenshot_queue_id_seq OWNED BY screenshot_queue.id;


--
-- Name: spatial_ref_sys; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE spatial_ref_sys (
    srid integer NOT NULL,
    auth_name character varying(256),
    auth_srid integer,
    srtext character varying(2048),
    proj4text character varying(2048),
    CONSTRAINT spatial_ref_sys_srid_check CHECK (((srid > 0) AND (srid <= 998999)))
);


ALTER TABLE public.spatial_ref_sys OWNER TO w4;

--
-- Name: suppression_lists; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE suppression_lists (
    id bigint NOT NULL,
    list_name text NOT NULL,
    file_id bigint,
    modified_by bigint NOT NULL,
    modified_date timestamp with time zone NOT NULL,
    status status_entity NOT NULL
);


ALTER TABLE public.suppression_lists OWNER TO w4;

--
-- Name: suppression_lists_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE suppression_lists_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.suppression_lists_id_seq OWNER TO w4;

--
-- Name: suppression_lists_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE suppression_lists_id_seq OWNED BY suppression_lists.id;


--
-- Name: suppression_unsubscribe_batches; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE suppression_unsubscribe_batches (
    id bigint NOT NULL,
    start_time timestamp with time zone,
    stop_time timestamp with time zone,
    status status_batch,
    message text
);


ALTER TABLE public.suppression_unsubscribe_batches OWNER TO w4;

--
-- Name: suppression_unsubscribe_batches_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE suppression_unsubscribe_batches_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.suppression_unsubscribe_batches_id_seq OWNER TO w4;

--
-- Name: suppression_unsubscribe_batches_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE suppression_unsubscribe_batches_id_seq OWNED BY suppression_unsubscribe_batches.id;


--
-- Name: suppression_unsubscribe_files; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE suppression_unsubscribe_files (
    id bigint NOT NULL,
    suppression_id bigint,
    initial_count bigint,
    pre_existing_count bigint,
    matching_count bigint,
    final_count bigint,
    status status_entity NOT NULL,
    batch_id bigint,
    error_message text,
    modified_date timestamp with time zone
);


ALTER TABLE public.suppression_unsubscribe_files OWNER TO w4;

--
-- Name: suppression_unsubscribe_files_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE suppression_unsubscribe_files_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.suppression_unsubscribe_files_id_seq OWNER TO w4;

--
-- Name: suppression_unsubscribe_files_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE suppression_unsubscribe_files_id_seq OWNED BY suppression_unsubscribe_files.id;


--
-- Name: suppression_unsubscribe_queue; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE suppression_unsubscribe_queue (
    id bigint NOT NULL,
    campaign_id bigint NOT NULL,
    publisher_id bigint,
    email text NOT NULL,
    suppression_file_id bigint,
    created_date timestamp with time zone NOT NULL,
    batch_id bigint
);


ALTER TABLE public.suppression_unsubscribe_queue OWNER TO w4;

--
-- Name: suppression_unsubscribe_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE suppression_unsubscribe_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.suppression_unsubscribe_queue_id_seq OWNER TO w4;

--
-- Name: suppression_unsubscribe_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE suppression_unsubscribe_queue_id_seq OWNED BY suppression_unsubscribe_queue.id;


--
-- Name: suppression_upload_batches; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE suppression_upload_batches (
    id bigint NOT NULL,
    start_time timestamp with time zone,
    stop_time timestamp with time zone,
    status status_batch,
    message text
);


ALTER TABLE public.suppression_upload_batches OWNER TO w4;

--
-- Name: suppression_upload_batches_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE suppression_upload_batches_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.suppression_upload_batches_id_seq OWNER TO w4;

--
-- Name: suppression_upload_batches_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE suppression_upload_batches_id_seq OWNED BY suppression_upload_batches.id;


--
-- Name: suppression_upload_files; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE suppression_upload_files (
    id bigint NOT NULL,
    advertiser_id bigint,
    campaign_id bigint,
    upload_path text,
    file_path text,
    initial_count bigint,
    cleaned_count bigint,
    pre_existing_count bigint,
    matching_count bigint,
    final_count bigint,
    status status_entity NOT NULL,
    batch_id bigint,
    list_name text,
    list_scope suppression_scope,
    list_format suppression_format,
    error_message text,
    modified_by bigint,
    modified_date timestamp with time zone
);


ALTER TABLE public.suppression_upload_files OWNER TO w4;

--
-- Name: suppression_upload_files_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE suppression_upload_files_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.suppression_upload_files_id_seq OWNER TO w4;

--
-- Name: suppression_upload_files_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE suppression_upload_files_id_seq OWNED BY suppression_upload_files.id;


--
-- Name: tracking_domains; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE tracking_domains (
    id bigint NOT NULL,
    publisher_id bigint,
    name text NOT NULL
);


ALTER TABLE public.tracking_domains OWNER TO w4;

--
-- Name: tracking_domains_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE tracking_domains_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tracking_domains_id_seq OWNER TO w4;

--
-- Name: tracking_domains_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE tracking_domains_id_seq OWNED BY tracking_domains.id;


SET search_path = reporting, pg_catalog;

--
-- Name: reports_clicks_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_rollup_hourly OWNER TO w4;

--
-- Name: reports_conversions_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_conversions_rollup_hourly OWNER TO w4;

--
-- Name: reports_daily; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_daily AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.doy
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    clk_con_roll.pay_in_amount,
                    clk_con_roll.pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    (clk_con_roll.doy)::bigint AS doy
                   FROM (         SELECT reports_clicks_rollup_hourly.publisher_id,
                                    reports_clicks_rollup_hourly.publisher_pid,
                                    reports_clicks_rollup_hourly.campaign_id,
                                    reports_clicks_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    ("substring"((reports_clicks_rollup_hourly.hoy)::text, 1, 8))::integer AS doy
                                   FROM reports_clicks_rollup_hourly
                                  GROUP BY reports_clicks_rollup_hourly.advertiser_id, reports_clicks_rollup_hourly.publisher_id, reports_clicks_rollup_hourly.publisher_pid, reports_clicks_rollup_hourly.campaign_id, "substring"((reports_clicks_rollup_hourly.hoy)::text, 1, 8)
                        UNION
                                 SELECT reports_conversions_rollup_hourly.publisher_id,
                                    reports_conversions_rollup_hourly.publisher_pid,
                                    reports_conversions_rollup_hourly.campaign_id,
                                    reports_conversions_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    (sum(reports_conversions_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    (reports_conversions_rollup_hourly.payin_amount)::numeric AS pay_in_amount,
                                    (reports_conversions_rollup_hourly.payout_amount)::numeric AS pay_out_amount,
                                    sum((reports_conversions_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_rollup_hourly.profit)::numeric) AS profit,
                                    ("substring"((reports_conversions_rollup_hourly.hoy)::text, 1, 8))::integer AS doy
                                   FROM reports_conversions_rollup_hourly
                                  GROUP BY reports_conversions_rollup_hourly.advertiser_id, reports_conversions_rollup_hourly.publisher_id, reports_conversions_rollup_hourly.publisher_pid, reports_conversions_rollup_hourly.campaign_id, "substring"((reports_conversions_rollup_hourly.hoy)::text, 1, 8), reports_conversions_rollup_hourly.payin_amount, reports_conversions_rollup_hourly.payout_amount) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.doy, clk_con_roll.pay_in_amount, clk_con_roll.pay_out_amount
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    clk_and_con.pay_in_amount,
                    clk_and_con.pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.doy
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_doy(engine_clicks_rollup_queue.created_date) AS doy
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_doy(engine_clicks_rollup_queue.created_date)
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    (engine_conversions_rollup_queue.payin)::numeric AS pay_in_amount,
                                    (engine_conversions_rollup_queue.payout)::numeric AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_doy(engine_conversions_rollup_queue.created_date) AS doy
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_doy(engine_conversions_rollup_queue.created_date), engine_conversions_rollup_queue.payin, engine_conversions_rollup_queue.payout) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.doy, clk_and_con.pay_in_amount, clk_and_con.pay_out_amount) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.doy, ag_and_new.pay_in_amount, ag_and_new.pay_out_amount;


ALTER TABLE reporting.reports_daily OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: vw_clicks_doy; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_clicks_doy AS
 SELECT (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    ag_and_new.advertiser_id,
    ag_and_new.publisher_id,
    ag_and_new.campaign_id,
    ag_and_new.doy
   FROM (         SELECT (sum(clk.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk.total_clicks))::bigint AS total_clicks,
                    clk.advertiser_id,
                    clk.publisher_id,
                    clk.campaign_id,
                    (clk.doy)::integer AS doy
                   FROM reporting.reports_daily clk
                  GROUP BY clk.publisher_id, clk.advertiser_id, clk.campaign_id, clk.doy
        UNION
                 SELECT sum(
                        CASE
                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                            ELSE 0
                        END) AS unique_clicks,
                    (sum(engine_clicks_rollup_queue.nb_dupes) + 1) AS total_clicks,
                    engine_clicks_rollup_queue.advertiser_id,
                    engine_clicks_rollup_queue.publisher_id,
                    engine_clicks_rollup_queue.campaign_id,
                    make_doy(engine_clicks_rollup_queue.created_date) AS doy
                   FROM engine_clicks_rollup_queue
                  GROUP BY engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.campaign_id, make_doy(engine_clicks_rollup_queue.created_date)) ag_and_new
  GROUP BY ag_and_new.publisher_id, ag_and_new.advertiser_id, ag_and_new.campaign_id, ag_and_new.doy;


ALTER TABLE public.vw_clicks_doy OWNER TO w4;

--
-- Name: vw_trend_point_doy_u; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_trend_point_doy_u AS
        (         SELECT sum(vw_clicks_doy.total_clicks) AS total_clicks,
                    sum(vw_clicks_doy.unique_clicks) AS unique_clicks,
                    vw_clicks_doy.campaign_id,
                    NULL::bigint AS publisher_id,
                    vw_clicks_doy.doy
                   FROM vw_clicks_doy
                  GROUP BY vw_clicks_doy.campaign_id, vw_clicks_doy.doy
        UNION
                 SELECT sum(vw_clicks_doy.total_clicks) AS total_clicks,
                    sum(vw_clicks_doy.unique_clicks) AS unique_clicks,
                    vw_clicks_doy.campaign_id,
                    vw_clicks_doy.publisher_id,
                    vw_clicks_doy.doy
                   FROM vw_clicks_doy
                  GROUP BY vw_clicks_doy.campaign_id, vw_clicks_doy.publisher_id, vw_clicks_doy.doy)
UNION
         SELECT 0 AS total_clicks,
            0 AS unique_clicks,
            campaigns.id AS campaign_id,
            NULL::bigint AS publisher_id,
            0 AS doy
           FROM campaigns;


ALTER TABLE public.vw_trend_point_doy_u OWNER TO w4;

--
-- Name: vw_doy_trend_point; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_doy_trend_point AS
         SELECT vw_trend_point_doy_u.total_clicks,
            vw_trend_point_doy_u.unique_clicks,
            vw_trend_point_doy_u.campaign_id,
            vw_trend_point_doy_u.publisher_id,
            vw_trend_point_doy_u.doy
           FROM vw_trend_point_doy_u
UNION
         SELECT 0 AS total_clicks,
            0 AS unique_clicks,
            campaigns.id AS campaign_id,
            NULL::bigint AS publisher_id,
            0 AS doy
           FROM campaigns
          GROUP BY campaigns.id
  ORDER BY 3, 4;


ALTER TABLE public.vw_doy_trend_point OWNER TO w4;

--
-- Name: vw_7_day_trend; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_7_day_trend AS
        (        (        (        (        (         SELECT 6 AS days_ago,
                                                    vw_doy_trend_point.total_clicks,
                                                    vw_doy_trend_point.unique_clicks,
                                                    vw_doy_trend_point.campaign_id,
                                                    vw_doy_trend_point.publisher_id,
                                                    (to_char((((now() - '6 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint AS doy
                                                   FROM vw_doy_trend_point
                                                  WHERE ((vw_doy_trend_point.doy = (to_char((((now() - '00:00:00'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint) OR ((vw_doy_trend_point.doy = 0) AND (vw_doy_trend_point.publisher_id IS NULL)))
                                        UNION
                                                 SELECT 5 AS days_ago,
                                                    vw_doy_trend_point.total_clicks,
                                                    vw_doy_trend_point.unique_clicks,
                                                    vw_doy_trend_point.campaign_id,
                                                    vw_doy_trend_point.publisher_id,
                                                    (to_char((((now() - '5 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint AS doy
                                                   FROM vw_doy_trend_point
                                                  WHERE ((vw_doy_trend_point.doy = (to_char((((now() - '1 day'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint) OR ((vw_doy_trend_point.doy = 0) AND (vw_doy_trend_point.publisher_id IS NULL))))
                                UNION
                                         SELECT 4 AS days_ago,
                                            vw_doy_trend_point.total_clicks,
                                            vw_doy_trend_point.unique_clicks,
                                            vw_doy_trend_point.campaign_id,
                                            vw_doy_trend_point.publisher_id,
                                            (to_char((((now() - '4 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint AS doy
                                           FROM vw_doy_trend_point
                                          WHERE ((vw_doy_trend_point.doy = (to_char((((now() - '2 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint) OR ((vw_doy_trend_point.doy = 0) AND (vw_doy_trend_point.publisher_id IS NULL))))
                        UNION
                                 SELECT 3 AS days_ago,
                                    vw_doy_trend_point.total_clicks,
                                    vw_doy_trend_point.unique_clicks,
                                    vw_doy_trend_point.campaign_id,
                                    vw_doy_trend_point.publisher_id,
                                    (to_char((((now() - '3 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint AS doy
                                   FROM vw_doy_trend_point
                                  WHERE ((vw_doy_trend_point.doy = (to_char((((now() - '3 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint) OR ((vw_doy_trend_point.doy = 0) AND (vw_doy_trend_point.publisher_id IS NULL))))
                UNION
                         SELECT 2 AS days_ago,
                            vw_doy_trend_point.total_clicks,
                            vw_doy_trend_point.unique_clicks,
                            vw_doy_trend_point.campaign_id,
                            vw_doy_trend_point.publisher_id,
                            (to_char((((now() - '2 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint AS doy
                           FROM vw_doy_trend_point
                          WHERE ((vw_doy_trend_point.doy = (to_char((((now() - '4 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint) OR ((vw_doy_trend_point.doy = 0) AND (vw_doy_trend_point.publisher_id IS NULL))))
        UNION
                 SELECT 1 AS days_ago,
                    vw_doy_trend_point.total_clicks,
                    vw_doy_trend_point.unique_clicks,
                    vw_doy_trend_point.campaign_id,
                    vw_doy_trend_point.publisher_id,
                    (to_char((((now() - '1 day'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint AS doy
                   FROM vw_doy_trend_point
                  WHERE ((vw_doy_trend_point.doy = (to_char((((now() - '5 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint) OR ((vw_doy_trend_point.doy = 0) AND (vw_doy_trend_point.publisher_id IS NULL))))
UNION
         SELECT 0 AS days_ago,
            vw_doy_trend_point.total_clicks,
            vw_doy_trend_point.unique_clicks,
            vw_doy_trend_point.campaign_id,
            vw_doy_trend_point.publisher_id,
            (to_char((((now() - '00:00:00'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint AS doy
           FROM vw_doy_trend_point
          WHERE ((vw_doy_trend_point.doy = (to_char((((now() - '6 days'::interval))::date)::timestamp with time zone, 'YYYYmmdd'::text))::bigint) OR ((vw_doy_trend_point.doy = 0) AND (vw_doy_trend_point.publisher_id IS NULL)));


ALTER TABLE public.vw_7_day_trend OWNER TO w4;

--
-- Name: tvw_7_day_trend_line; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW tvw_7_day_trend_line AS
 SELECT v7t.campaign_id,
    v7t.publisher_id,
    string_agg((COALESCE(v7t.total_clicks, (0)::numeric))::text, ','::text) AS total_clk_trend,
    string_agg((COALESCE(v7t.unique_clicks, (0)::numeric))::text, ','::text) AS unique_clk_trend
   FROM vw_7_day_trend v7t
  GROUP BY v7t.campaign_id, v7t.publisher_id;


ALTER TABLE public.tvw_7_day_trend_line OWNER TO w4;

--
-- Name: user_access_logs; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_access_logs (
    id bigint NOT NULL,
    user_id bigint,
    ip_address character(15) DEFAULT NULL::bpchar,
    modified timestamp with time zone DEFAULT now() NOT NULL,
    optional_attributes text
);


ALTER TABLE public.user_access_logs OWNER TO w4;

--
-- Name: user_access_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE user_access_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_access_logs_id_seq OWNER TO w4;

--
-- Name: user_access_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE user_access_logs_id_seq OWNED BY user_access_logs.id;


--
-- Name: user_agent_browser_lookup_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE user_agent_browser_lookup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_agent_browser_lookup_id_seq OWNER TO w4;

--
-- Name: user_agent_browser_lookup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE user_agent_browser_lookup_id_seq OWNED BY user_agent_browser_lookup.id;


--
-- Name: user_agent_feature; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_agent_feature (
    id bigint NOT NULL,
    feature_name character varying(64) DEFAULT NULL::character varying,
    feature_version character varying(32) DEFAULT NULL::character varying,
    feature_description character varying(255) DEFAULT NULL::character varying,
    feature_special character varying(32) DEFAULT NULL::character varying
);


ALTER TABLE public.user_agent_feature OWNER TO w4;

--
-- Name: TABLE user_agent_feature; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON TABLE user_agent_feature IS 'Allows for storing detected user agent features';


--
-- Name: user_agent_feature_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE user_agent_feature_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_agent_feature_id_seq OWNER TO w4;

--
-- Name: user_agent_feature_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE user_agent_feature_id_seq OWNED BY user_agent_feature.id;


--
-- Name: user_agent_platform_lookup_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE user_agent_platform_lookup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_agent_platform_lookup_id_seq OWNER TO w4;

--
-- Name: user_agent_platform_lookup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE user_agent_platform_lookup_id_seq OWNED BY user_agent_platform_lookup.id;


--
-- Name: user_impersonation; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_impersonation (
    id bigint NOT NULL,
    user_id bigint,
    impersonated_user_id bigint,
    token_id character varying(23),
    created timestamp with time zone,
    CONSTRAINT user_impersonation_impersonated_user_id_check CHECK ((impersonated_user_id >= 0)),
    CONSTRAINT user_impersonation_user_id_check CHECK ((user_id >= 0))
);


ALTER TABLE public.user_impersonation OWNER TO w4;

--
-- Name: user_impersonation_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE user_impersonation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_impersonation_id_seq OWNER TO w4;

--
-- Name: user_impersonation_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE user_impersonation_id_seq OWNED BY user_impersonation.id;


--
-- Name: user_profile_pics; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_profile_pics (
    user_id integer DEFAULT 0 NOT NULL,
    image_id character varying(24) DEFAULT NULL::character varying,
    thumbnail_id character varying(24) DEFAULT NULL::character varying,
    upload_type smallint,
    alt_text character varying(255) DEFAULT NULL::character varying,
    size smallint,
    width smallint,
    height smallint,
    mime_type character varying(16) DEFAULT NULL::character varying,
    modified timestamp with time zone
);


ALTER TABLE public.user_profile_pics OWNER TO w4;

--
-- Name: user_profile_versions; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_profile_versions (
    id bigint NOT NULL,
    version_id bigint NOT NULL,
    user_uuid character(36),
    first_name character varying(255),
    last_name character varying(255),
    address_1 character varying(255),
    address_2 character varying(255),
    city character varying(255),
    state character(250),
    zip character varying(10),
    country character(250),
    created timestamp with time zone,
    modified timestamp with time zone,
    image_id character varying(255),
    phone character varying(30),
    cell character varying(30),
    messenger_id character varying(255),
    messenger_type character varying(64),
    skype character varying(255),
    preferred_language character varying(32),
    contact_email character varying(255),
    tier_id integer,
    currency character varying(16),
    region character varying(32),
    fax character varying(32),
    company_name character varying(255),
    company_position character varying(255),
    payment_address_1 character varying(255),
    payment_address_2 character varying(255),
    payment_city character varying(255),
    payment_region character varying(255),
    payment_postal_code character varying(10),
    payment_country character(250),
    payment_to character varying,
    payment_by smallint,
    payment_schedule character varying,
    payment_threshold numeric(18,4),
    tax_id character varying(32),
    website_url character varying(255),
    website_category character varying(255),
    website_marketing character varying(255),
    is_network_account smallint,
    is_require_renewed_terms smallint,
    has_uploaded_w9_file smallint,
    approver_id bigint,
    approve_date timestamp with time zone,
    registration_comment text,
    register_ip_address inet,
    register_date timestamp with time zone,
    payment_bank_routing_number character varying(30),
    payment_bank_account_number character varying(40),
    version_start_date timestamp with time zone
);


ALTER TABLE public.user_profile_versions OWNER TO w4;

--
-- Name: user_profiles_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE user_profiles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_profiles_id_seq OWNER TO w4;

--
-- Name: user_profiles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE user_profiles_id_seq OWNED BY user_profiles.id;


--
-- Name: user_tokens; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE user_tokens (
    id bigint NOT NULL,
    user_id character(36) DEFAULT '0'::bpchar NOT NULL,
    token character(32) DEFAULT ''::bpchar NOT NULL,
    duration character varying(32) DEFAULT NULL::character varying,
    type character varying DEFAULT 'cookie'::character varying NOT NULL,
    expires timestamp with time zone NOT NULL,
    created timestamp with time zone NOT NULL,
    CONSTRAINT user_tokens_type_check CHECK (((type)::text = ANY (ARRAY[('cookie'::character varying)::text, ('registration'::character varying)::text, ('lost_password'::character varying)::text])))
);


ALTER TABLE public.user_tokens OWNER TO w4;

--
-- Name: user_tokens_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE user_tokens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_tokens_id_seq OWNER TO w4;

--
-- Name: user_tokens_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE user_tokens_id_seq OWNED BY user_tokens.id;


--
-- Name: users_id_seq; Type: SEQUENCE; Schema: public; Owner: w4
--

CREATE SEQUENCE users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.users_id_seq OWNER TO w4;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: w4
--

ALTER SEQUENCE users_id_seq OWNED BY users.id;


--
-- Name: vw_adv_cpg_balances; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_adv_cpg_balances AS
         SELECT sum(acct_conversion_ledger.pay_in_amt) AS total_credit_used,
            acct_conversion_ledger.campaign_id,
            acct_conversion_ledger.advertiser_id,
            'New'::text AS type
           FROM "Accounting".acct_conversion_ledger
          WHERE ((acct_conversion_ledger.status < 11) AND (acct_conversion_ledger.transaction_type = 70))
          GROUP BY acct_conversion_ledger.campaign_id, acct_conversion_ledger.advertiser_id
UNION
         SELECT sum(acct_conversion_ledger.pay_in_amt) AS total_credit_used,
            acct_conversion_ledger.campaign_id,
            acct_conversion_ledger.advertiser_id,
            'Invoiced'::text AS type
           FROM "Accounting".acct_conversion_ledger
          WHERE (((acct_conversion_ledger.status >= 30) AND (acct_conversion_ledger.status <= 39)) AND (acct_conversion_ledger.transaction_type = 70))
          GROUP BY acct_conversion_ledger.campaign_id, acct_conversion_ledger.advertiser_id
  ORDER BY 2;


ALTER TABLE public.vw_adv_cpg_balances OWNER TO w4;

--
-- Name: vw_advertiser_banned_publishers; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_advertiser_banned_publishers AS
 SELECT abp.id,
    abp.advertiser_id,
    ad.name AS advertiser_name,
    abp.publisher_id,
    COALESCE(up.company_name, (concat(up.first_name, ' ', up.last_name))::character varying) AS publisher_name,
    abp.campaign_id,
    c.name AS campaign_name,
    abp.sub_id_1,
    abp.sub_id_2,
    abp.sub_id_3,
    abp.sub_id_4
   FROM ((((advertiser_banned_publishers abp
   LEFT JOIN advertisers ad ON ((abp.advertiser_id = ad.id)))
   LEFT JOIN users u ON ((abp.publisher_id = u.id)))
   LEFT JOIN user_profiles up ON ((u.uuid = up.user_uuid)))
   LEFT JOIN campaigns c ON ((abp.campaign_id = c.id)));


ALTER TABLE public.vw_advertiser_banned_publishers OWNER TO w4;

--
-- Name: vw_advertiser_campaigns; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_advertiser_campaigns AS
 SELECT campaigns.advertiser_id,
    campaigns.id AS campaign_id,
    campaigns.name AS campaign_name
   FROM campaigns
  ORDER BY campaigns.name;


ALTER TABLE public.vw_advertiser_campaigns OWNER TO w4;

--
-- Name: vw_advertiser_detail_campaign_tab; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_advertiser_detail_campaign_tab AS
 SELECT "XxX".campaign_id,
    cmp.name AS campaign_name,
    "XxX".advertiser_id,
    "XxX".total_clicks,
    "XxX".total_conversions,
    "XxX".total_pay_in,
    "XxX".total_pay_out,
    "XxX".profit AS total_profit,
    "XxX".pay_in_amount,
    "XxX".pay_out_amount,
    cmp.status,
    "XxX".doy,
    COALESCE(v7dtl.unique_clk_trend, ('0+0+0+0+0+0+0'::character varying)::text) AS trending
   FROM ((reporting.reports_daily "XxX"
   LEFT JOIN tvw_7_day_trend_line v7dtl ON (("XxX".campaign_id = v7dtl.campaign_id)))
   LEFT JOIN campaigns cmp ON (("XxX".campaign_id = cmp.id)))
  WHERE (v7dtl.publisher_id IS NULL);


ALTER TABLE public.vw_advertiser_detail_campaign_tab OWNER TO w4;

--
-- Name: vw_advertiser_detail_date_tab; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_advertiser_detail_date_tab AS
 SELECT rd.doy AS date,
    rd.advertiser_id,
    count(DISTINCT rd.campaign_id) AS campaigns,
    sum(rd.total_clicks) AS clicks,
    sum(rd.total_conversions) AS conversions,
    COALESCE(((sum(rd.total_conversions) / NULLIF(sum(rd.total_clicks), (0)::numeric)) * (100)::numeric), (0)::numeric) AS conversion_pct,
    (sum(rd.total_pay_in) / NULLIF(sum(rd.total_clicks), (0)::numeric)) AS epc,
    sum(rd.total_pay_in) AS total_in,
    sum(rd.total_pay_out) AS total_out,
    (sum(rd.total_pay_in) - sum(rd.total_pay_out)) AS total_profit,
    COALESCE((((sum(rd.total_pay_in) - sum(rd.total_pay_out)) * (100)::numeric) / NULLIF(sum(rd.total_pay_in), (0)::numeric)), (0)::numeric) AS profit_pct,
    COALESCE(rd.pay_in_amount, (0)::numeric) AS average_in,
    COALESCE(rd.pay_out_amount, (0)::numeric) AS average_out
   FROM reporting.reports_daily rd
  GROUP BY rd.doy, rd.advertiser_id, rd.pay_in_amount, rd.pay_out_amount;


ALTER TABLE public.vw_advertiser_detail_date_tab OWNER TO w4;

--
-- Name: vw_advertiser_edit; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_advertiser_edit AS
 SELECT ad.id,
    ad.name,
    ad.credit_limit,
    ad.allow_over_limit,
    ad.payment_terms_id,
    ad.url,
    ad.ftp_password,
    ad.description AS notes,
    ad.note_login_url AS tracking_url,
    ad.note_login_username AS tracking_username,
    ad.note_login_password AS tracking_password,
    COALESCE(cp.first_name, (split_part((ad.contact_name)::text, ' '::text, 1))::character varying) AS primary_first_name,
    COALESCE(cp.last_name, (btrim((ad.contact_name)::text, (split_part((ad.contact_name)::text, ' '::text, 1) || ' '::text)))::character varying) AS primary_last_name,
    COALESCE(cp.address_1, (ad.address_1)::character varying) AS primary_address_1,
    COALESCE(cp.address_2, (ad.address_2)::character varying) AS primary_address_2,
    COALESCE(cp.country_id, (0)::bigint) AS primary_country_id,
    COALESCE(pc.country, ad.country) AS primary_country_name,
    COALESCE(cp.region_id, (0)::bigint) AS primary_region_id,
    COALESCE(pr.ascii_name, ad.state) AS primary_region_name,
    COALESCE(cp.city_id, (0)::bigint) AS primary_city_id,
    COALESCE(pct.place_name_ascii, (cp.city_name)::text, (ad.city)::text) AS primary_city_name,
    COALESCE(cp.postal_code, ad.zip) AS primary_postal_code,
    COALESCE(cp.primary_phone, (ad.phone)::text) AS primary_primary_phone,
    COALESCE(cp.secondary_phone, ad.mobile) AS primary_secondary_phone,
    COALESCE(cp.fax, ad.fax) AS primary_fax,
    COALESCE(cp.email_address, ad.email) AS primary_email_address,
    COALESCE(cp.messenger_name, ad.messenger_id) AS primary_messenger_name,
    im.description AS primary_messenger_type,
    COALESCE(cb.first_name, (split_part((ad.contact_name)::text, ' '::text, 1))::character varying) AS billing_first_name,
    COALESCE(cb.last_name, (ltrim((ad.contact_name)::text, (split_part((ad.contact_name)::text, ' '::text, 1) || ' '::text)))::character varying) AS billing_last_name,
    COALESCE(cb.address_1, (ad.address_1)::character varying) AS billing_address_1,
    COALESCE(cb.address_2, (ad.address_2)::character varying) AS billing_address_2,
    COALESCE(cb.country_id, (ad.billing_country_id)::bigint, (0)::bigint) AS billing_country_id,
    COALESCE(bc.country, ad.country) AS billing_country_name,
    COALESCE(cb.region_id, (ad.billing_region_id)::bigint, (0)::bigint) AS billing_region_id,
    COALESCE(br.ascii_name, ad.state) AS billing_region_name,
    COALESCE(cb.city_id, (0)::bigint) AS billing_city_id,
    COALESCE(bct.place_name_ascii, (cb.city_name)::text, (ad.city)::text) AS billing_city_name,
    COALESCE(cb.postal_code, ad.zip) AS billing_postal_code,
    COALESCE(cb.primary_phone, (ad.phone)::text) AS billing_primary_phone,
    COALESCE(cb.secondary_phone, ad.mobile) AS billing_secondary_phone,
    COALESCE(cb.fax, ad.fax) AS billing_fax,
    COALESCE(cb.email_address, ad.email) AS billing_email_address,
    COALESCE(cb.messenger_name, ad.messenger_id) AS billing_messenger_name,
    imb.description AS billing_messenger_type,
    ad.billing_contact_id,
    ad.primary_contact_id,
    ad.account_contact_id
   FROM ((((((((((((advertisers ad
   LEFT JOIN contacts cp ON ((ad.primary_contact_id = cp.id)))
   LEFT JOIN im_types im ON ((cp.messenger_type = im.id)))
   LEFT JOIN geo_typeahead_countries pc ON ((cp.country_id = pc.id)))
   LEFT JOIN geo_typeahead_region pr ON ((cp.region_id = pr.id)))
   LEFT JOIN geo_typeahead_cities pct ON ((cp.city_id = pct.id)))
   LEFT JOIN contacts cb ON ((ad.billing_contact_id = cb.id)))
   LEFT JOIN im_types imb ON ((cb.messenger_type = imb.id)))
   LEFT JOIN geo_typeahead_countries bc ON ((cb.country_id = bc.id)))
   LEFT JOIN geo_typeahead_countries obc ON ((ad.billing_country_id = obc.id)))
   LEFT JOIN geo_typeahead_region br ON ((cb.region_id = br.id)))
   LEFT JOIN geo_typeahead_region obr ON ((ad.billing_region_id = obr.id)))
   LEFT JOIN geo_typeahead_cities bct ON ((cb.city_id = bct.id)));


ALTER TABLE public.vw_advertiser_edit OWNER TO w4;

--
-- Name: vw_advertiser_list_traffic_view; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_advertiser_list_traffic_view AS
 SELECT adv.name AS advertiser_name,
    adv.id AS advertiser_id,
    cmp.name AS campaign_name,
    cmp.id AS campaigns_id,
    sum(vpdts.total_clicks) AS clicks,
    sum(vpdts.total_conversions) AS conversions,
    sum(vpdts.total_pay_in) AS total_in,
    sum(vpdts.total_pay_out) AS total_out,
    sum(vpdts.profit) AS total_profit,
    avg(vpdts.pay_in_amount) AS average_in,
    avg(vpdts.pay_out_amount) AS average_out,
    vpdts.doy
   FROM ((advertisers adv
   LEFT JOIN reporting.reports_daily vpdts ON ((adv.id = vpdts.advertiser_id)))
   LEFT JOIN campaigns cmp ON ((vpdts.campaign_id = cmp.id)))
  GROUP BY adv.id, adv.name, cmp.name, cmp.id, vpdts.campaign_id, vpdts.doy;


ALTER TABLE public.vw_advertiser_list_traffic_view OWNER TO w4;

--
-- Name: vw_advertiser_main_listing; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_advertiser_main_listing AS
         SELECT adv.id AS advertiser_id,
            adv.name AS advertiser_name,
            adv.status,
            rcrd.doy,
            sum(rcrd.total_conversions) AS conversions,
            sum(rcrd.total_clicks) AS total_clicks,
            sum(rcrd.unique_clicks) AS unique_clicks,
            sum(rcrd.total_pay_in) AS total_in,
            sum(rcrd.total_pay_out) AS total_out,
            sum(rcrd.profit) AS total_profit
           FROM (advertisers adv
      LEFT JOIN reporting.reports_daily rcrd ON (((adv.id = rcrd.advertiser_id) AND (rcrd.doy < 0))))
     GROUP BY adv.id, adv.name, adv.status, rcrd.doy
UNION
         SELECT adv.id AS advertiser_id,
            adv.name AS advertiser_name,
            adv.status,
            rcrd.doy,
            sum(rcrd.total_conversions) AS conversions,
            sum(rcrd.total_clicks) AS total_clicks,
            sum(rcrd.unique_clicks) AS unique_clicks,
            sum(rcrd.total_pay_in) AS total_in,
            sum(rcrd.total_pay_out) AS total_out,
            sum(rcrd.profit) AS total_profit
           FROM (advertisers adv
      LEFT JOIN reporting.reports_daily rcrd ON ((adv.id = rcrd.advertiser_id)))
     GROUP BY adv.id, adv.name, adv.status, rcrd.doy;


ALTER TABLE public.vw_advertiser_main_listing OWNER TO w4;

--
-- Name: vw_advertiser_main_listing_cpa; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_advertiser_main_listing_cpa AS
         SELECT adv.id AS advertiser_id,
            adv.name AS advertiser_name,
            adv.status,
            rcrd.doy,
            sum(rcrd.total_conversions) AS conversions,
            sum(rcrd.total_clicks) AS total_clicks,
            sum(rcrd.unique_clicks) AS unique_clicks,
            sum(rcrd.total_pay_in) AS total_in,
            sum(rcrd.total_pay_out) AS total_out,
            sum(rcrd.profit) AS total_profit,
            rcrd.pay_in_amount AS pay_in,
            rcrd.pay_out_amount AS pay_out
           FROM (advertisers adv
      LEFT JOIN reporting.reports_daily rcrd ON (((adv.id = rcrd.advertiser_id) AND (rcrd.doy < 0))))
     GROUP BY adv.id, adv.name, adv.status, rcrd.doy, rcrd.pay_in_amount, rcrd.pay_out_amount
UNION
         SELECT adv.id AS advertiser_id,
            adv.name AS advertiser_name,
            adv.status,
            rcrd.doy,
            sum(rcrd.total_conversions) AS conversions,
            sum(rcrd.total_clicks) AS total_clicks,
            sum(rcrd.unique_clicks) AS unique_clicks,
            sum(rcrd.total_pay_in) AS total_in,
            sum(rcrd.total_pay_out) AS total_out,
            sum(rcrd.profit) AS total_profit,
            rcrd.pay_in_amount AS pay_in,
            rcrd.pay_out_amount AS pay_out
           FROM (advertisers adv
      LEFT JOIN reporting.reports_daily rcrd ON ((adv.id = rcrd.advertiser_id)))
     GROUP BY adv.id, adv.name, adv.status, rcrd.doy, rcrd.pay_in_amount, rcrd.pay_out_amount;


ALTER TABLE public.vw_advertiser_main_listing_cpa OWNER TO w4;

--
-- Name: vw_user_listing; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_user_listing AS
 SELECT usp.id AS profile_id,
    usr.id AS user_id,
    usr.uuid,
    concat(usp.first_name, ' ', usp.last_name) AS full_name,
    usr.access
   FROM (users usr
   LEFT JOIN user_profiles usp ON ((usr.id = usp.user_id)))
  WHERE (((usr.access)::text = 'admin'::text) OR ((usr.access)::text = 'accountant'::text))
  ORDER BY concat(usp.first_name, ' ', usp.last_name);


ALTER TABLE public.vw_user_listing OWNER TO w4;

--
-- Name: vw_all_users_search; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_all_users_search AS
 SELECT concat(' ', COALESCE(usp.company_name, (musp.full_name)::character varying, (concat(usp.first_name, ' ', usp.last_name))::character varying), ' ', usr.id, ' ') AS search_field,
    concat(initcap((usr.access)::text), ': ', COALESCE(usp.company_name, (concat(musp.full_name, usp.first_name, ' ', usp.last_name))::character varying)) AS entity_name,
    usr.id AS entity_id
   FROM ((users usr
   LEFT JOIN user_profiles usp ON ((usr.uuid = usp.user_uuid)))
   LEFT JOIN vw_user_listing musp ON ((usr.uuid = musp.uuid)))
  ORDER BY concat(' ', COALESCE(usp.company_name, (concat(usp.first_name, ' ', usp.last_name))::character varying), ' ', usr.id, ' ');


ALTER TABLE public.vw_all_users_search OWNER TO w4;

--
-- Name: vw_campaign_approvals; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_approvals AS
 SELECT cap.campaign_id,
    cmp.name AS campaign_name,
    cap.created_at AS date_of_request,
    cap.publisher_id,
    COALESCE(usp.company_name, (concat(usp.first_name, ' ', usp.last_name))::character varying) AS publisher_name,
    cap.status AS request_status,
    cap.memo AS request_note
   FROM (((campaign_assigned_publishers cap
   LEFT JOIN campaigns cmp ON ((cap.campaign_id = cmp.id)))
   LEFT JOIN users usr ON ((cap.publisher_id = usr.id)))
   LEFT JOIN user_profiles usp ON ((usr.uuid = usp.user_uuid)));


ALTER TABLE public.vw_campaign_approvals OWNER TO w4;

SET search_path = reporting, pg_catalog;

--
-- Name: reports_conversions_rollup_daily; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_rollup_daily (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    doy bigint NOT NULL
);


ALTER TABLE reporting.reports_conversions_rollup_daily OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: vw_campaign_cap_report; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_cap_report AS
 SELECT max((cmp.name)::text) AS campaign_name,
    cmp.id AS campaign_id,
    max((ad.name)::text) AS advertiser_name,
    max(ad.id) AS advertiser_id,
    (COALESCE(sum(rcrd.total_pay_in), (0)::money))::numeric AS cap_utilized,
    COALESCE(max(ad.credit_limit), (0)::double precision) AS cap_total,
    COALESCE(((((sum(rcrd.total_pay_in))::numeric)::double precision / NULLIF(max(ad.credit_limit), (0)::double precision)) * (100)::double precision), (0)::double precision) AS cap_percent_utilized,
    max(cmp.expiry_date) AS campaign_expires
   FROM ((campaigns cmp
   LEFT JOIN reporting.reports_conversions_rollup_daily rcrd ON ((rcrd.campaign_id = cmp.id)))
   LEFT JOIN advertisers ad ON ((cmp.advertiser_id = ad.id)))
  GROUP BY cmp.id;


ALTER TABLE public.vw_campaign_cap_report OWNER TO w4;

--
-- Name: vw_campaign_categories; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_categories AS
 SELECT cc.campaign_id,
    cc.category_id,
    c.name AS category_name
   FROM (campaign_categories cc
   LEFT JOIN categories c ON ((cc.category_id = c.id)))
  ORDER BY c.name;


ALTER TABLE public.vw_campaign_categories OWNER TO w4;

--
-- Name: vw_campaign_categories_json; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_categories_json AS
 SELECT vcc.campaign_id,
    (array_agg(vcc.category_id))::bigint[] AS category_ids,
    array_to_json((array_agg(vcc.category_id))::bigint[]) AS category_ids_json,
    (array_agg(vcc.category_name))::text[] AS category_names,
    array_to_json((array_agg(vcc.category_name))::text[]) AS category_names_json
   FROM vw_campaign_categories vcc
  GROUP BY vcc.campaign_id;


ALTER TABLE public.vw_campaign_categories_json OWNER TO w4;

--
-- Name: vw_campaign_category_hierarchy; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_category_hierarchy AS
 SELECT parent.id AS parent_id,
    parent.name AS parent_name,
    child.id AS child_id,
    child.name AS child_name
   FROM ((campaign_categories
   LEFT JOIN categories child ON ((campaign_categories.category_id = child.id)))
   LEFT JOIN categories parent ON ((child.parent_id = parent.id)))
  WHERE (child.parent_id = parent.id)
  GROUP BY parent.id, parent.name, child.id, child.name
  ORDER BY parent.id;


ALTER TABLE public.vw_campaign_category_hierarchy OWNER TO w4;

--
-- Name: vw_campaign_category_info; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_category_info AS
 SELECT vw_campaign_categories.campaign_id,
    vw_campaign_categories.category_id AS category_ids,
    vw_campaign_categories.category_name AS category_names
   FROM vw_campaign_categories
  ORDER BY vw_campaign_categories.campaign_id;


ALTER TABLE public.vw_campaign_category_info OWNER TO w4;

--
-- Name: vw_campaign_category_labels; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_category_labels AS
 SELECT campaign_categories.campaign_id,
    concat(COALESCE(string_agg((','::text || (((categories.id || ','::text))::character varying)::text), ''::text)), ',') AS category_ids,
    concat(COALESCE(string_agg((((','::text || (categories.name)::text) || ','::text) || chr(32)), ''::text), (',,'::text || chr(32)))) AS categories
   FROM (campaign_categories
   LEFT JOIN categories ON ((campaign_categories.category_id = categories.id)))
  GROUP BY campaign_categories.campaign_id;


ALTER TABLE public.vw_campaign_category_labels OWNER TO w4;

--
-- Name: vw_campaign_channel_info; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_channel_info AS
 SELECT campaign_channels.campaign_id,
    channel.id,
    channel.name
   FROM (campaign_channels campaign_channels
   LEFT JOIN channels channel ON ((channel.id = campaign_channels.channel_id)))
  ORDER BY campaign_channels.campaign_id;


ALTER TABLE public.vw_campaign_channel_info OWNER TO w4;

--
-- Name: vw_campaign_channel_labels; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_channel_labels AS
 SELECT ctt.campaign_id,
    (concat(',', COALESCE(string_agg(((tt.id)::character varying)::text, ','::text)), ','))::character(1) AS channel_ids,
    (((string_agg((tt.name)::text, ''::text) || ','::text) || chr(32)))::character(1) AS channels
   FROM (campaign_channels ctt
   LEFT JOIN channels tt ON ((ctt.channel_id = tt.id)))
  GROUP BY ctt.campaign_id;


ALTER TABLE public.vw_campaign_channel_labels OWNER TO w4;

--
-- Name: vw_campaign_channels; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_channels AS
 SELECT cc.campaign_id,
    cc.channel_id,
    c.name AS channel_name
   FROM (campaign_channels cc
   LEFT JOIN channels c ON ((cc.channel_id = c.id)))
  ORDER BY c.name;


ALTER TABLE public.vw_campaign_channels OWNER TO w4;

--
-- Name: vw_campaign_channels_json; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_channels_json AS
 SELECT vcc.campaign_id,
    (array_agg(vcc.channel_id))::bigint[] AS channel_ids,
    array_to_json((array_agg(vcc.channel_id))::bigint[]) AS channel_ids_json,
    (array_agg(vcc.channel_name))::text[] AS channel_names,
    array_to_json((array_agg(vcc.channel_name))::text[]) AS channel_names_json
   FROM vw_campaign_channels vcc
  GROUP BY vcc.campaign_id;


ALTER TABLE public.vw_campaign_channels_json OWNER TO w4;

--
-- Name: vw_campaign_detail_geo_report; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_detail_geo_report AS
 SELECT (eclks.campaign_id)::bigint AS campaign_id,
    cmp.status,
    eclks.country AS country_name,
    rgn.name AS region_name,
    eclks.city AS city_name,
    count(eclks.id) AS num_clicks,
    count(econvs.id) AS num_conversions,
    w4_application_functions.make_doy(eclks.created_date) AS r_doy
   FROM (((engine_clicks eclks
   LEFT JOIN engine_conversions econvs ON ((eclks.id = econvs.click_id)))
   LEFT JOIN campaigns cmp ON ((eclks.campaign_id = cmp.id)))
   LEFT JOIN regions rgn ON (((eclks.region)::text = (rgn.region)::text)))
  GROUP BY w4_application_functions.make_doy(eclks.created_date), eclks.campaign_id, cmp.status, eclks.country, eclks.city, rgn.name;


ALTER TABLE public.vw_campaign_detail_geo_report OWNER TO w4;

SET search_path = reporting, pg_catalog;

--
-- Name: reports_hourly; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_hourly AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.hoy
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    clk_con_roll.hoy
                   FROM (         SELECT reports_clicks_rollup_hourly.publisher_id,
                                    reports_clicks_rollup_hourly.publisher_pid,
                                    reports_clicks_rollup_hourly.campaign_id,
                                    reports_clicks_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    reports_clicks_rollup_hourly.hoy
                                   FROM reports_clicks_rollup_hourly
                                  GROUP BY reports_clicks_rollup_hourly.advertiser_id, reports_clicks_rollup_hourly.publisher_id, reports_clicks_rollup_hourly.publisher_pid, reports_clicks_rollup_hourly.campaign_id, reports_clicks_rollup_hourly.hoy
                        UNION
                                 SELECT reports_conversions_rollup_hourly.publisher_id,
                                    reports_conversions_rollup_hourly.publisher_pid,
                                    reports_conversions_rollup_hourly.campaign_id,
                                    reports_conversions_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    (sum(reports_conversions_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_rollup_hourly.profit)::numeric) AS profit,
                                    reports_conversions_rollup_hourly.hoy
                                   FROM reports_conversions_rollup_hourly
                                  GROUP BY reports_conversions_rollup_hourly.advertiser_id, reports_conversions_rollup_hourly.publisher_id, reports_conversions_rollup_hourly.publisher_pid, reports_conversions_rollup_hourly.campaign_id, reports_conversions_rollup_hourly.hoy) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.hoy
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.hoy
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_hoy(engine_clicks_rollup_queue.created_date) AS hoy
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_hoy(engine_clicks_rollup_queue.created_date)
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_hoy(engine_conversions_rollup_queue.created_date) AS hoy
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_hoy(engine_conversions_rollup_queue.created_date)) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.hoy) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.hoy;


ALTER TABLE reporting.reports_hourly OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: vw_campaign_detail_hourly; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_detail_hourly AS
 SELECT mccth.campaign_id,
    cmp.name AS campaign_name,
    mccth.publisher_id,
    COALESCE(concat(prof.first_name, ' ', prof.last_name), ''::text) AS publisher_name,
    usr.manager_id,
    COALESCE(concat(man.first_name, ' ', man.last_name), ''::text) AS manager_name,
    pga.publisher_id AS group_publisher_id,
    mccth.hoy AS hour_range,
    mccth.total_clicks,
    mccth.total_conversions
   FROM ((((((reporting.reports_hourly mccth
   LEFT JOIN campaigns cmp ON ((mccth.campaign_id = cmp.id)))
   LEFT JOIN users usr ON ((mccth.publisher_id = usr.id)))
   LEFT JOIN user_profiles prof ON ((usr.id = prof.user_id)))
   LEFT JOIN users usr_man ON ((usr.manager_id = usr_man.id)))
   LEFT JOIN user_profiles man ON ((usr_man.id = man.user_id)))
   LEFT JOIN publisher_groups_assoc pga ON ((mccth.publisher_id = pga.publisher_id)));


ALTER TABLE public.vw_campaign_detail_hourly OWNER TO w4;

SET search_path = reporting, pg_catalog;

--
-- Name: reports_clicks_geo_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_geo_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_geo_rollup_hourly OWNER TO w4;

--
-- Name: reports_conversions_geo_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_geo_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_conversions_geo_rollup_hourly OWNER TO w4;

--
-- Name: reports_geo_daily; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_geo_daily AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    ag_and_new.country,
    ag_and_new.region_name,
    ag_and_new.city_name,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.doy
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    clk_con_roll.country,
                    clk_con_roll.region_name,
                    clk_con_roll.city_name,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    (clk_con_roll.doy)::bigint AS doy
                   FROM (         SELECT reports_clicks_geo_rollup_hourly.publisher_id,
                                    reports_clicks_geo_rollup_hourly.publisher_pid,
                                    reports_clicks_geo_rollup_hourly.campaign_id,
                                    reports_clicks_geo_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_geo_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_geo_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    reports_clicks_geo_rollup_hourly.country,
                                    reports_clicks_geo_rollup_hourly.region_name,
                                    reports_clicks_geo_rollup_hourly.city_name,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    ("substring"((reports_clicks_geo_rollup_hourly.hoy)::text, 1, 8))::integer AS doy
                                   FROM reports_clicks_geo_rollup_hourly
                                  GROUP BY reports_clicks_geo_rollup_hourly.advertiser_id, reports_clicks_geo_rollup_hourly.publisher_id, reports_clicks_geo_rollup_hourly.publisher_pid, reports_clicks_geo_rollup_hourly.campaign_id, "substring"((reports_clicks_geo_rollup_hourly.hoy)::text, 1, 8), reports_clicks_geo_rollup_hourly.country, reports_clicks_geo_rollup_hourly.region_name, reports_clicks_geo_rollup_hourly.city_name
                        UNION
                                 SELECT reports_conversions_geo_rollup_hourly.publisher_id,
                                    reports_conversions_geo_rollup_hourly.publisher_pid,
                                    reports_conversions_geo_rollup_hourly.campaign_id,
                                    reports_conversions_geo_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    reports_conversions_geo_rollup_hourly.country,
                                    reports_conversions_geo_rollup_hourly.region_name,
                                    reports_conversions_geo_rollup_hourly.city_name,
                                    (sum(reports_conversions_geo_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_geo_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_geo_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_geo_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_geo_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_geo_rollup_hourly.profit)::numeric) AS profit,
                                    ("substring"((reports_conversions_geo_rollup_hourly.hoy)::text, 1, 8))::integer AS doy
                                   FROM reports_conversions_geo_rollup_hourly
                                  GROUP BY reports_conversions_geo_rollup_hourly.advertiser_id, reports_conversions_geo_rollup_hourly.publisher_id, reports_conversions_geo_rollup_hourly.publisher_pid, reports_conversions_geo_rollup_hourly.campaign_id, "substring"((reports_conversions_geo_rollup_hourly.hoy)::text, 1, 8), reports_conversions_geo_rollup_hourly.country, reports_conversions_geo_rollup_hourly.region_name, reports_conversions_geo_rollup_hourly.city_name) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.doy, clk_con_roll.country, clk_con_roll.region_name, clk_con_roll.city_name
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    clk_and_con.country,
                    clk_and_con.region_name,
                    clk_and_con.city_name,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.doy
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    engine_clicks_rollup_queue.country,
                                    engine_clicks_rollup_queue.region_name,
                                    engine_clicks_rollup_queue.city AS city_name,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_doy(engine_clicks_rollup_queue.created_date) AS doy
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_doy(engine_clicks_rollup_queue.created_date), engine_clicks_rollup_queue.country, engine_clicks_rollup_queue.region_name, engine_clicks_rollup_queue.city
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    engine_conversions_rollup_queue.country,
                                    engine_conversions_rollup_queue.region_name,
                                    engine_conversions_rollup_queue.city AS city_name,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_doy(engine_conversions_rollup_queue.created_date) AS doy
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_doy(engine_conversions_rollup_queue.created_date), engine_conversions_rollup_queue.country, engine_conversions_rollup_queue.region_name, engine_conversions_rollup_queue.city) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.doy, clk_and_con.country, clk_and_con.region_name, clk_and_con.city_name) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.doy, ag_and_new.country, ag_and_new.region_name, ag_and_new.city_name;


ALTER TABLE reporting.reports_geo_daily OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: vw_campaign_details_geo; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_details_geo AS
 SELECT cmp.status,
    clk.campaign_id,
    clk.country,
    clk.region_name AS state,
    clk.city_name,
    sum(clk.unique_clicks) AS clicks,
    sum(clk.total_conversions) AS conversions,
    clk.doy
   FROM (reporting.reports_geo_daily clk
   LEFT JOIN campaigns cmp ON ((clk.campaign_id = cmp.id)))
  GROUP BY clk.doy, clk.campaign_id, clk.city_name, clk.country, clk.region_name, cmp.status;


ALTER TABLE public.vw_campaign_details_geo OWNER TO w4;

--
-- Name: vw_campaign_details_summary; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_details_summary AS
 SELECT cmp.id AS campaign_id,
    cmp.name AS campaign_name,
    cmp.description AS campaign_description,
    cmp.advertiser_id,
    adv.name AS advertiser_name,
    adv.manager_id,
    COALESCE(concat(usp.first_name, ' ', usp.last_name), ''::text) AS manager_name,
    cmp.default_payin AS campaign_default_payin,
    cmp.default_payout AS campaign_default_payout,
    cmp.allow_postback_payin,
    abs((adv.credit_limit - (adv_bal.total_credit_used)::double precision)) AS advertisers_credit_balance,
    adv.credit_limit AS advertiser_credit_limit,
    adv.send_alert_if_credit_is_used AS advertiser_send_alert_if_credit_is_used,
    adv.credit_alert_value AS advertiser_credit_alert_value,
    ((adv.credit_alert_value - adv_bal.total_credit_used) / NULLIF(adv.credit_alert_value, (0)::numeric)) AS advertiser_credit_alert_under,
    ((adv_bal.total_credit_used - adv.credit_alert_value) / NULLIF(adv.credit_alert_value, (0)::numeric)) AS advertiser_credit_alert_over,
    cmp.failure_redirect_type AS campaign_failure_redirect_type,
    cmp.failure_redirect_url AS campaign_failure_redirect_url,
    cmp.failure_redirect_campaign_id AS campaign_failure_redirect_campaign_id,
    cmp_fail.name AS campaign_failure_redirect_campaign_name,
    cmp.start_date AS campaign_start_date,
    cmp.expiry_date AS campaign_expiry_date,
    cmp.status AS campaign_status,
    cmp.access_type AS campaign_access_type,
        CASE cmp.access_type
            WHEN 1 THEN 'Public'::text
            WHEN 2 THEN 'Private'::text
            WHEN 3 THEN 'By Approval'::text
            ELSE NULL::text
        END AS access_type_description,
        CASE cmp.failure_redirect_type
            WHEN 1 THEN 'URL'::text
            WHEN 2 THEN 'Campaign'::text
            ELSE NULL::text
        END AS failure_redirect_type_description,
    cmp.cookie_duration_time AS campaign_cookie_duration_time,
    cmp.cookie_duration_unit AS campaign_cookie_duration_unit,
        CASE cmp.cookie_duration_unit
            WHEN 1 THEN 'Seconds'::text
            WHEN 2 THEN 'Minutes'::text
            WHEN 3 THEN 'Hours'::text
            WHEN 4 THEN 'Days'::text
            WHEN 5 THEN 'Weeks'::text
            WHEN 6 THEN 'Months'::text
            WHEN 7 THEN 'Years'::text
            ELSE NULL::text
        END AS cookie_duration_unit_description,
    cmp.tracking_type_id AS campaign_tracking_type,
    concat('per ', picca.alias) AS campaign_pay_in_model_description,
    concat('per ', pocca.alias) AS campaign_pay_out_model_description,
    (cmp.tracking_secure)::boolean AS is_secure
   FROM (((((((campaigns cmp
   LEFT JOIN advertisers adv ON ((cmp.advertiser_id = adv.id)))
   LEFT JOIN users usr ON ((adv.manager_id = usr.id)))
   LEFT JOIN user_profiles usp ON ((usr.uuid = usp.user_uuid)))
   LEFT JOIN vw_adv_cpg_balances adv_bal ON (((cmp.id = adv_bal.campaign_id) AND (cmp.advertiser_id = adv_bal.advertiser_id))))
   LEFT JOIN campaigns cmp_fail ON ((cmp.failure_redirect_campaign_id = cmp_fail.id)))
   LEFT JOIN campaign_conversion_aliases picca ON ((cmp.payin_model_id = picca.id)))
   LEFT JOIN campaign_conversion_aliases pocca ON ((cmp.payout_model_id = pocca.id)))
  ORDER BY cmp.id;


ALTER TABLE public.vw_campaign_details_summary OWNER TO w4;

--
-- Name: vw_campaign_edit; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_edit AS
 SELECT cmp.id,
    cmp.advertiser_id,
    cmp.user_id,
    cmp.name,
    cmp.description,
    cmp.restrictions,
    cmp.default_redirect_url,
    cmp.screenshot_id,
    cmp.landing_pages,
    cmp.failure_redirect_type,
    cmp.failure_redirect_url,
    cmp.failure_redirect_campaign_id,
    cmp.unsubscription_url,
    cmp.unsubscription_screenshot_id,
    cmp.default_payout,
    cmp.payout_type,
    cmp.payout_model_id,
    cmp.default_payin,
    cmp.payin_type,
    cmp.payin_model_id,
    cmp.start_date,
    cmp.is_expiration,
    cmp.expiry_date,
    cmp.geotargeting_postal_code_directive,
    cmp.outgeo_redirect_type,
    cmp.outgeo_redirect_url,
    cmp.outgeo_redirect_campaign_id,
    cmp.outgeo_redirect_screenshot_id,
    cmp.cookie_duration_time,
    cmp.cookie_duration_unit,
    cmp.access_type,
    cmp.status,
    cmp.epc,
    cmp.tracking_type,
    cmp.tracking_secure,
    cmp.new_until,
    cmp.do_redirect_mobile,
    cmp.mobile_redirect_url,
    cmp.mobile_screenshot_id,
    ogr.name AS outgeo_redirect_campaign_name,
    ogr.screenshot_id AS outgeoredirect_screenshot_id,
    flr.name AS failure_redirect_campaign_name,
    flr.screenshot_id AS failureredirect_screenshot_id
   FROM ((campaigns cmp
   LEFT JOIN campaigns ogr ON ((cmp.outgeo_redirect_campaign_id = ogr.id)))
   LEFT JOIN campaigns flr ON ((cmp.failure_redirect_campaign_id = flr.id)));


ALTER TABLE public.vw_campaign_edit OWNER TO w4;

--
-- Name: vw_campaign_geo_engine; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_geo_engine AS
 SELECT geo.campaign_id,
    geo.country,
    geo.region,
    geo.city_id,
    cit.name AS city
   FROM (campaign_geotargeting geo
   LEFT JOIN cities cit ON ((cit.id = geo.city_id)));


ALTER TABLE public.vw_campaign_geo_engine OWNER TO w4;

--
-- Name: vw_campaign_geo_info; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_geo_info AS
 SELECT DISTINCT geo.campaign_id,
    COALESCE(country.name, ''::character varying) AS country,
    COALESCE(geo.country, ''::character varying) AS country_id,
    COALESCE(region.name, ''::character varying) AS region,
    COALESCE(geo.region, ''::character varying) AS region_id,
    (COALESCE(city.place_name, ''::text))::character varying AS city,
    COALESCE(geo.city_id, 0) AS city_id,
    geo.id AS geo_id
   FROM (((campaign_geotargeting geo
   LEFT JOIN countries country ON (((country.country)::text = (geo.country)::text)))
   LEFT JOIN regions region ON ((((region.country)::text = (geo.country)::text) AND ((region.region)::text = (geo.region)::text))))
   LEFT JOIN geo_typeahead_cities city ON ((city.id = geo.city_id)));


ALTER TABLE public.vw_campaign_geo_info OWNER TO w4;

--
-- Name: vw_campaign_group_campaign_ids; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_group_campaign_ids AS
 SELECT string_agg(((campaign_group_items.campaign_id)::character(1))::text, ','::text) AS campaign_ids,
    campaign_group_items.campaign_group_id
   FROM campaign_group_items
  GROUP BY campaign_group_items.campaign_group_id;


ALTER TABLE public.vw_campaign_group_campaign_ids OWNER TO w4;

--
-- Name: vw_campaign_group_group_ids; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_group_group_ids AS
 SELECT string_agg(((campaign_group_items.campaign_group_id)::character(1))::text, ','::text) AS campaign_group_ids,
    campaign_group_items.campaign_id
   FROM campaign_group_items
  GROUP BY campaign_group_items.campaign_id;


ALTER TABLE public.vw_campaign_group_group_ids OWNER TO w4;

--
-- Name: vw_campaign_groups; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_groups AS
 SELECT campaign_groups.id,
    campaign_groups.user_id,
    campaign_groups.group_name
   FROM campaign_groups;


ALTER TABLE public.vw_campaign_groups OWNER TO w4;

--
-- Name: vw_campaign_list_traffic; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_list_traffic AS
 SELECT cmp.id AS campaign_id,
    cmp.name AS campaign_name,
    adv.id AS advertiser_id,
    adv.name AS advertiser_name,
    vccl.channel_ids,
    vccl.channels AS channel_names,
    vcl.category_ids,
    vcl.categories AS category_names,
    cmp.expiry_date AS expires,
    rcrd.profit,
    rcrd.total_pay_in AS total_in,
    rcrd.total_pay_out AS total_out,
    rcrd.unique_clicks,
    rcrd.total_conversions AS conversions,
    rcrd.doy,
    adv.credit_limit AS cap_amount,
    COALESCE(
        CASE
            WHEN (cmp.new_until > now()) THEN 'Yes'::text
            ELSE 'No'::text
        END, 'No'::text) AS is_new,
    cmp.status AS campaign_status
   FROM ((((campaigns cmp
   LEFT JOIN advertisers adv ON ((cmp.advertiser_id = adv.id)))
   LEFT JOIN vw_campaign_channel_labels vccl ON ((cmp.id = vccl.campaign_id)))
   LEFT JOIN vw_campaign_category_labels vcl ON ((cmp.id = vcl.campaign_id)))
   LEFT JOIN reporting.reports_daily rcrd ON ((cmp.id = rcrd.campaign_id)))
  WHERE (((rcrd.doy <= 20130501) AND (rcrd.doy >= 20130501)) OR (rcrd.doy IS NULL))
  ORDER BY cmp.id DESC;


ALTER TABLE public.vw_campaign_list_traffic OWNER TO w4;

--
-- Name: vw_campaign_status; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_campaign_status AS
 SELECT DISTINCT campaigns.status
   FROM campaigns;


ALTER TABLE public.vw_campaign_status OWNER TO w4;

--
-- Name: vw_campaigns_traffic_list_view; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE vw_campaigns_traffic_list_view (
    campaign_id bigint,
    campaign_name text,
    campaign_status text,
    advertiser_name text,
    advertiser_id bigint,
    doy bigint,
    category_ids text,
    categories text,
    channel_ids text,
    channels text,
    total_clicks numeric,
    unique_clicks numeric,
    total_conversions numeric,
    total_in numeric,
    total_out numeric,
    campaign_cap numeric,
    currency_id numeric,
    is_new text,
    expires timestamp with time zone
);


ALTER TABLE public.vw_campaigns_traffic_list_view OWNER TO w4;

--
-- Name: vw_categories; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_categories AS
 SELECT cat.id,
    cat.name,
    cat.description,
    cat.parent_id,
    pcat.name AS parent_name
   FROM (categories cat
   LEFT JOIN categories pcat ON ((cat.parent_id = pcat.id)));


ALTER TABLE public.vw_categories OWNER TO w4;

--
-- Name: vw_channel_info; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_channel_info AS
 SELECT channel.id,
    channel.name AS val
   FROM channels channel
  ORDER BY channel.name;


ALTER TABLE public.vw_channel_info OWNER TO w4;

--
-- Name: vw_click_geo; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_click_geo AS
 SELECT cgo.click_db_id,
    cgo.loc_id,
    cgo.continent,
    cgo.country_id,
    cntr.country AS country_code,
    cntr.name AS country_name,
    cgo.region_id,
    rgn.region AS region_code,
    rgn.name AS region_name,
    cgo.city_id,
    cty.name AS city_name,
    cgo.postal_code,
    cgo.latitude,
    cgo.longitude,
    cgo.metro_code,
    cgo.area_code
   FROM (((click_geo cgo
   LEFT JOIN countries cntr ON ((cgo.country_id = cntr.id)))
   LEFT JOIN regions rgn ON ((cgo.region_id = rgn.id)))
   LEFT JOIN cities cty ON ((cgo.city_id = cty.id)));


ALTER TABLE public.vw_click_geo OWNER TO w4;

--
-- Name: vw_cmpl_suppression_list; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_cmpl_suppression_list AS
 SELECT cmp.id AS campaign_id,
    csf.modified_date,
    csf.md5_sha1_hash AS file_name
   FROM (cmpl_suppression_file csf
   LEFT JOIN campaigns cmp ON ((cmp.id = csf.campaign_id)));


ALTER TABLE public.vw_cmpl_suppression_list OWNER TO w4;

--
-- Name: vw_compliance_report; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_compliance_report AS
 SELECT clk.publisher_id,
    COALESCE(max((pup.company_name)::text), ((max((pup.first_name)::text) || ' '::text) || max((pup.last_name)::text)), ''::text) AS publisher_name,
    clk.campaign_id,
    max((cmp.name)::text) AS campaign_name,
    COALESCE(max(cd.downloaded_ts)) AS last_downloaded,
    max(v7dtl.total_clk_trend) AS trending,
    max(mcct.total_clicks) AS today_clicks,
    mcct.doy
   FROM ((((((engine_clicks clk
   LEFT JOIN cmpl_downloaded cd ON (((clk.publisher_id = cd.publisher_id) AND (clk.campaign_id = cd.campaign_id))))
   LEFT JOIN campaigns cmp ON ((cmp.id = clk.campaign_id)))
   LEFT JOIN users pusr ON ((clk.publisher_id = pusr.id)))
   LEFT JOIN user_profiles pup ON ((pusr.uuid = pup.user_uuid)))
   LEFT JOIN tvw_7_day_trend_line v7dtl ON ((v7dtl.campaign_id = clk.campaign_id)))
   LEFT JOIN reporting.reports_daily mcct ON (((mcct.campaign_id = clk.campaign_id) AND (mcct.doy = (to_char(now(), 'YYYYmmdd'::text))::integer))))
  WHERE ((clk.campaign_id IN ( SELECT DISTINCT c.campaign_id
   FROM (creative_emails ce
   LEFT JOIN creatives c ON ((ce.creative_id = c.id))))) AND (w4_application_functions.make_doy(clk.created_date) > (to_char((now() - '10 days'::interval), 'YYYYmmdd'::text))::integer))
  GROUP BY clk.publisher_id, clk.campaign_id, mcct.doy;


ALTER TABLE public.vw_compliance_report OWNER TO w4;

--
-- Name: vw_contacts; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_contacts AS
 SELECT c.id,
    c.first_name,
    c.last_name,
    c.address_1,
    c.address_2,
    c.country_id,
    c.region_id,
    c.city_id,
    co.country AS country_name,
    re.ascii_name AS region_name,
    ci.place_name AS city_name,
    c.postal_code,
    c.messenger_name,
    im.description AS messenger_type,
    c.primary_phone,
    c.secondary_phone,
    c.fax,
    c.email_address
   FROM ((((contacts c
   LEFT JOIN geo_typeahead_countries co ON ((co.id = c.country_id)))
   LEFT JOIN geo_typeahead_region re ON ((re.id = c.region_id)))
   LEFT JOIN geo_typeahead_cities ci ON ((ci.id = c.city_id)))
   LEFT JOIN im_types im ON ((c.messenger_type = im.id)));


ALTER TABLE public.vw_contacts OWNER TO w4;

--
-- Name: vw_conversion_geo; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_conversion_geo AS
 SELECT cgo.conversion_db_id,
    cgo.loc_id,
    cgo.continent,
    cgo.country_id,
    cntr.country AS country_code,
    cntr.name AS country_name,
    cgo.region_id,
    rgn.region AS region_code,
    rgn.name AS region_name,
    cgo.city_id,
    cty.name AS city_name,
    cgo.postal_code,
    cgo.latitude,
    cgo.longitude,
    cgo.metro_code,
    cgo.area_code
   FROM (((conversion_geo cgo
   LEFT JOIN countries cntr ON ((cgo.country_id = cntr.id)))
   LEFT JOIN regions rgn ON ((cgo.region_id = rgn.id)))
   LEFT JOIN cities cty ON ((cgo.city_id = cty.id)));


ALTER TABLE public.vw_conversion_geo OWNER TO w4;

--
-- Name: vw_creative_banner_images; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_creative_banner_images AS
 SELECT c.campaign_id,
    c.is_active,
    f.folder,
    f.file_name
   FROM ((creatives c
   LEFT JOIN creative_banners cb ON ((c.id = cb.creative_id)))
   LEFT JOIN files f ON ((cb.image_id = f.id)))
  WHERE (c.type = 1);


ALTER TABLE public.vw_creative_banner_images OWNER TO w4;

--
-- Name: vw_creative_banners; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_creative_banners AS
 SELECT c.campaign_id,
    cb.creative_id AS asset_id,
    cb.image_id AS asset_image_id,
    c.is_active AS asset_status_id,
    c.name AS asset_name,
    c.description AS asset_description,
    cb.width AS asset_dimensions_width,
    cb.height AS asset_dimensions_height,
    cb.html AS asset_source_html,
    c.redirect_url AS asset_redirect_url,
    cb.alt_text AS asset_image_al_text,
    cb.redirect_screenshot_id
   FROM (creative_banners cb
   LEFT JOIN creatives c ON ((c.id = cb.creative_id)));


ALTER TABLE public.vw_creative_banners OWNER TO w4;

--
-- Name: vw_creative_email_images; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_creative_email_images AS
 SELECT ceil.asset_id,
    cei.image_id,
    cei.image_token,
    cei.image_width,
    cei.image_height,
    cei.image_status
   FROM (creative_email_image_lookup ceil
   LEFT JOIN creative_email_images cei ON (((ceil.image_id)::text = (cei.image_id)::text)));


ALTER TABLE public.vw_creative_email_images OWNER TO w4;

--
-- Name: vw_creative_emails; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_creative_emails AS
 SELECT c.campaign_id,
    ce.creative_id AS asset_id,
    c.is_active AS asset_status_id,
    c.name AS asset_name,
    ce.screenshot_id AS asset_screenshot_id,
    ce.email_from_address AS asset_email_from_address,
    ce.email_from_name AS asset_email_from_name,
    ce.email_subject AS asset_email_subject,
    ce.content AS asset_email_content
   FROM (creative_emails ce
   LEFT JOIN creatives c ON ((c.id = ce.creative_id)));


ALTER TABLE public.vw_creative_emails OWNER TO w4;

--
-- Name: vw_creative_text_links; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_creative_text_links AS
 SELECT c.campaign_id,
    ct.creative_id AS asset_id,
    c.is_active AS asset_status_id,
    c.name AS asset_name,
    c.description AS asset_description,
    ct.text AS asset_link_text,
    c.redirect_url AS asset_redirect_url,
    ct.redirect_screenshot_id
   FROM (creative_textlinks ct
   LEFT JOIN creatives c ON ((c.id = ct.creative_id)));


ALTER TABLE public.vw_creative_text_links OWNER TO w4;

--
-- Name: vw_dashboard_leaderboard; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_dashboard_leaderboard AS
 SELECT xxx.unique_clicks,
    xxx.total_clicks,
    xxx.total_conversions AS num_conversions,
    xxx.advertiser_id,
    COALESCE(adv.name, adv.contact_name) AS advertiser_name,
    xxx.publisher_id,
    COALESCE(pup.company_name, (concat(pup.first_name, ' ', pup.last_name))::character varying(255)) AS publisher_name,
    xxx.campaign_id,
    cmp.name AS campaign_name,
    xxx.doy,
    xxx.total_pay_in AS pay_in_amount,
    xxx.total_pay_out AS pay_out_amount,
    COALESCE((xxx.pay_in_amount / (NULLIF(xxx.unique_clicks, 0))::numeric), (0)::numeric) AS advertiser_ppc,
    COALESCE((xxx.pay_out_amount / (NULLIF(xxx.unique_clicks, 0))::numeric), (0)::numeric) AS publisher_epc,
    aeg.ids AS ae_group_ids,
    amg.ids AS am_group_id
   FROM ((((((reporting.reports_daily xxx
   RIGHT JOIN campaigns cmp ON ((xxx.campaign_id = cmp.id)))
   LEFT JOIN advertisers adv ON ((xxx.advertiser_id = adv.id)))
   LEFT JOIN users pusr ON ((xxx.publisher_id = pusr.id)))
   LEFT JOIN user_profiles pup ON ((pusr.uuid = pup.user_uuid)))
   LEFT JOIN ( SELECT acl_user_groups.user_id AS uid,
    string_agg(((acl_user_groups.group_id)::character(1))::text, ','::text) AS ids
   FROM "ACL".acl_user_groups
  GROUP BY acl_user_groups.user_id) aeg ON ((adv.manager_id = aeg.uid)))
   LEFT JOIN ( SELECT acl_user_groups.user_id AS uid,
    string_agg(((acl_user_groups.group_id)::character(1))::text, ','::text) AS ids
   FROM "ACL".acl_user_groups
  GROUP BY acl_user_groups.user_id) amg ON ((pusr.manager_id = amg.uid)))
  ORDER BY xxx.profit, xxx.doy;


ALTER TABLE public.vw_dashboard_leaderboard OWNER TO w4;

--
-- Name: vw_dashboard_summary; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_dashboard_summary AS
 SELECT xxx.unique_clicks,
    xxx.total_clicks,
    xxx.total_conversions AS num_conversions,
    xxx.advertiser_id,
    adv.name AS advertiser_name,
    xxx.publisher_id,
    pup.company_name AS publisher_name,
    xxx.doy,
    xxx.pay_in_amount,
    xxx.pay_out_amount,
    COALESCE((xxx.pay_in_amount / (NULLIF(xxx.unique_clicks, 0))::numeric), (0)::numeric) AS advertiser_ppc,
    COALESCE((xxx.pay_out_amount / (NULLIF(xxx.unique_clicks, 0))::numeric), (0)::numeric) AS publisher_epc,
    aeg.ids AS ae_group_ids,
    amg.ids AS am_group_ids
   FROM (((((reporting.reports_daily xxx
   LEFT JOIN advertisers adv ON ((xxx.advertiser_id = adv.id)))
   LEFT JOIN users pusr ON ((xxx.publisher_id = pusr.id)))
   LEFT JOIN user_profiles pup ON ((pusr.id = pup.user_id)))
   LEFT JOIN ( SELECT acl_user_groups.user_id AS uid,
    string_agg(((acl_user_groups.group_id)::character(1))::text, ','::text) AS ids
   FROM "ACL".acl_user_groups
  GROUP BY acl_user_groups.user_id) aeg ON ((adv.manager_id = aeg.uid)))
   LEFT JOIN ( SELECT acl_user_groups.user_id AS uid,
    string_agg(((acl_user_groups.group_id)::character(1))::text, ','::text) AS ids
   FROM "ACL".acl_user_groups
  GROUP BY acl_user_groups.user_id) amg ON ((pusr.manager_id = amg.uid)))
  ORDER BY xxx.doy;


ALTER TABLE public.vw_dashboard_summary OWNER TO w4;

--
-- Name: vw_engine_campaign; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_engine_campaign AS
 SELECT c.id,
    c.status,
    c.start_date,
    c.is_expiration,
    c.expiry_date,
    c.advertiser_id,
    c.default_redirect_url,
    c.failure_redirect_type,
    c.failure_redirect_campaign_id,
    c.failure_redirect_url,
    c.landing_pages,
    c.cookie_duration_time,
    c.cookie_duration_unit,
    c.outgeo_redirect_type,
    c.outgeo_redirect_url,
    c.outgeo_redirect_campaign_id,
    c.outgeo_redirect_screenshot_id,
    c.mobile_redirect_url,
    c.tracking_type,
    c.do_redirect_mobile,
    c.mobile_screenshot_id,
    c.default_payout,
    c.payout_type,
    c.default_payin,
    c.payin_type,
    c.payin_model_id,
    c.payout_model_id,
    cca.alias_type AS payout_model_alias_type,
    c.access_type,
    c.tracking_secure
   FROM (campaigns c
   LEFT JOIN campaign_conversion_aliases cca ON ((c.payout_model_id = cca.id)));


ALTER TABLE public.vw_engine_campaign OWNER TO w4;

--
-- Name: vw_engine_publisher; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_engine_publisher AS
 SELECT u.id,
    u.access,
    u.active,
    u.parent_id,
    up.tier_id
   FROM (users u
   LEFT JOIN user_profiles up ON ((u.uuid = up.user_uuid)));


ALTER TABLE public.vw_engine_publisher OWNER TO w4;

--
-- Name: vw_entity_search_advertisers; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_entity_search_advertisers AS
 SELECT concat(' ', COALESCE(ad.name, ad.contact_name), ' ', ad.id, ' ') AS search_field,
    COALESCE(ad.name, ad.contact_name) AS entity_name,
    ad.id AS entity_id
   FROM advertisers ad
  ORDER BY concat(' ', COALESCE(ad.name, ad.contact_name), ' ', ad.id, ' ');


ALTER TABLE public.vw_entity_search_advertisers OWNER TO w4;

--
-- Name: vw_entity_search_campaigns; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_entity_search_campaigns AS
 SELECT concat(' ', cmp.name, ' ', cmp.id, ' ') AS search_field,
    cmp.name AS entity_name,
    cmp.id AS entity_id,
    cmp.currency_id
   FROM campaigns cmp
  ORDER BY concat(' ', cmp.name, ' ', cmp.id, ' ');


ALTER TABLE public.vw_entity_search_campaigns OWNER TO w4;

--
-- Name: vw_entity_search_publishers; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_entity_search_publishers AS
 SELECT ((lower((COALESCE(up.company_name, (concat(up.first_name, ' ', up.last_name))::character varying))::text) || ' '::text) || (u.id)::text) AS search_field,
    (COALESCE(up.company_name, (concat(up.first_name, ' ', up.last_name))::character varying))::text AS entity_name,
    u.id AS entity_id
   FROM (user_profiles up
   LEFT JOIN users u ON ((u.id = up.user_id)))
  WHERE ((u.access)::text = 'publisher'::text)
  ORDER BY concat(' ', COALESCE(up.company_name, (concat(up.first_name, ' ', up.last_name))::character varying), ' ', u.id, ' ');


ALTER TABLE public.vw_entity_search_publishers OWNER TO w4;

--
-- Name: vw_entity_search_users; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_entity_search_users AS
 SELECT concat(' ', COALESCE(usp.company_name, (concat(usp.first_name, ' ', usp.last_name))::character varying), ' ', usr.id, ' ') AS search_field,
    COALESCE(usp.company_name, (concat(usp.first_name, ' ', usp.last_name))::character varying) AS entity_name,
    usr.id AS entity_id
   FROM (users usr
   LEFT JOIN user_profiles usp ON ((usr.uuid = usp.user_uuid)))
  WHERE ((usr.access)::text = 'admin'::text)
  ORDER BY concat(' ', COALESCE(usp.company_name, (concat(usp.first_name, ' ', usp.last_name))::character varying), ' ', usr.id, ' ');


ALTER TABLE public.vw_entity_search_users OWNER TO w4;

--
-- Name: vw_pending_campaign_requests; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pending_campaign_requests AS
 SELECT pusr.id AS publisher_user_id,
    COALESCE(pup.company_name, (concat(pup.first_name, ' ', pup.last_name))::character varying(255)) AS publisher_name,
    adv.id AS advertiser_id,
    COALESCE(adv.name, adv.contact_name) AS advertiser_name,
    cap.campaign_id,
    cmp.name AS campaign_name,
    cap.created_at AS created_date,
    aeg.ids AS ae_group_ids,
    amg.ids AS am_group_ids
   FROM ((((((campaign_assigned_publishers cap
   RIGHT JOIN campaigns cmp ON ((cap.campaign_id = cmp.id)))
   LEFT JOIN advertisers adv ON ((cmp.advertiser_id = adv.id)))
   LEFT JOIN users pusr ON ((cap.publisher_id = pusr.id)))
   LEFT JOIN user_profiles pup ON ((pusr.uuid = pup.user_uuid)))
   LEFT JOIN ( SELECT acl_user_groups.user_id AS uid,
    string_agg(((acl_user_groups.group_id)::character(1))::text, ','::text) AS ids
   FROM "ACL".acl_user_groups
  GROUP BY acl_user_groups.user_id) aeg ON ((adv.manager_id = aeg.uid)))
   LEFT JOIN ( SELECT acl_user_groups.user_id AS uid,
    string_agg(((acl_user_groups.group_id)::character(1))::text, ','::text) AS ids
   FROM "ACL".acl_user_groups
  GROUP BY acl_user_groups.user_id) amg ON ((pusr.manager_id = amg.uid)))
  WHERE (((cap.status)::text = 'pending'::text) AND (cmp.id IS NOT NULL))
  ORDER BY cap.campaign_id, cap.publisher_id, cap.created_at DESC;


ALTER TABLE public.vw_pending_campaign_requests OWNER TO w4;

--
-- Name: vw_pending_publishers; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pending_publishers AS
 SELECT usr.id AS publisher_user_id,
    COALESCE(up.company_name, (concat(up.first_name, ' ', up.last_name))::character varying) AS publisher_name,
    usr.created AS created_date
   FROM (users usr
   LEFT JOIN user_profiles up ON ((usr.uuid = up.user_uuid)))
  WHERE (((usr.access)::text = 'publisher'::text) AND ((usr.active)::text = 'unconfirmed'::text))
  ORDER BY usr.created DESC;


ALTER TABLE public.vw_pending_publishers OWNER TO w4;

--
-- Name: vw_pub_campaign_details_summary; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_details_summary AS
 SELECT cmp.id AS campaign_id,
    cmp.name AS campaign_name,
    cmp.description AS campaign_description,
    cmp.restrictions AS campaign_restrictions,
    cmp.advertiser_id,
    adv.name AS advertiser_name,
    cmp.default_payin AS campaign_default_payin,
    cmp.default_payout AS campaign_default_payout,
    cmp.failure_redirect_type AS campaign_failure_redirect_type,
    cmp.failure_redirect_url AS campaign_failure_redirect_url,
    cmp.failure_redirect_campaign_id AS campaign_failure_redirect_campaign_id,
    cmp_fail.name AS campaign_failure_redirect_campaign_name,
    cmp.start_date AS campaign_start_date,
    cmp.expiry_date AS campaign_expiry_date,
    cmp.status AS campaign_status,
    cmp.access_type AS campaign_access_type,
        CASE cmp.access_type
            WHEN 1 THEN 'Public'::text
            WHEN 2 THEN 'Private'::text
            WHEN 3 THEN 'By Approval'::text
            ELSE NULL::text
        END AS access_type_description,
        CASE cmp.failure_redirect_type
            WHEN 1 THEN 'URL'::text
            WHEN 2 THEN 'Campaign'::text
            ELSE NULL::text
        END AS failure_redirect_type_description,
    cmp.cookie_duration_time AS campaign_cookie_duration_time,
    cmp.cookie_duration_unit AS campaign_cookie_duration_unit,
        CASE cmp.cookie_duration_unit
            WHEN 1 THEN 'Seconds'::text
            WHEN 2 THEN 'Minutes'::text
            WHEN 3 THEN 'Hours'::text
            WHEN 4 THEN 'Days'::text
            WHEN 4 THEN 'Weeks'::text
            WHEN 5 THEN 'Months'::text
            WHEN 6 THEN 'Years'::text
            ELSE NULL::text
        END AS cookie_duration_unit_description,
    cmp.tracking_type AS campaign_tracking_type,
    concat('per ', picca.alias) AS campaign_pay_in_model_description,
    concat('per ', pocca.alias) AS campaign_pay_out_model_description,
        CASE
            WHEN ((cmp.tracking_secure)::text = 'no'::text) THEN false
            ELSE true
        END AS is_secure
   FROM ((((campaigns cmp
   LEFT JOIN advertisers adv ON ((cmp.advertiser_id = adv.id)))
   LEFT JOIN campaigns cmp_fail ON ((cmp.failure_redirect_campaign_id = cmp_fail.id)))
   LEFT JOIN campaign_conversion_aliases picca ON ((cmp.payin_model_id = picca.id)))
   LEFT JOIN campaign_conversion_aliases pocca ON ((cmp.payout_model_id = pocca.id)))
  ORDER BY cmp.id;


ALTER TABLE public.vw_pub_campaign_details_summary OWNER TO w4;

SET search_path = reporting, pg_catalog;

--
-- Name: reports_clicks_wide_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_wide_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    browser_name character varying(255),
    platform_name character varying(255),
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    base_uri character varying(255),
    hoy bigint NOT NULL,
    creative_id bigint DEFAULT 0
);


ALTER TABLE reporting.reports_clicks_wide_rollup_hourly OWNER TO w4;

--
-- Name: reports_conversions_wide_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_wide_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    browser_name character varying(255),
    platform_name character varying(255),
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    base_uri character varying(255),
    hoy bigint NOT NULL,
    creative_id bigint DEFAULT 0
);


ALTER TABLE reporting.reports_conversions_wide_rollup_hourly OWNER TO w4;

--
-- Name: reports_wide_daily; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_wide_daily AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    NULL::character varying(255) AS country,
    NULL::character varying(255) AS region_name,
    NULL::character varying(255) AS city_name,
    NULL::character varying(255) AS browser_name,
    NULL::character varying(255) AS platform_name,
    NULL::text AS sub_id_1,
    NULL::text AS sub_id_2,
    NULL::text AS sub_id_3,
    NULL::text AS sub_id_4,
    NULL::character varying(255) AS base_uri,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.doy,
    ag_and_new.creative_id
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    (clk_con_roll.doy)::bigint AS doy,
                    clk_con_roll.creative_id
                   FROM (         SELECT reports_clicks_wide_rollup_hourly.publisher_id,
                                    reports_clicks_wide_rollup_hourly.publisher_pid,
                                    reports_clicks_wide_rollup_hourly.campaign_id,
                                    reports_clicks_wide_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_wide_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_wide_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    ("substring"((reports_clicks_wide_rollup_hourly.hoy)::text, 1, 8))::integer AS doy,
                                    reports_clicks_wide_rollup_hourly.creative_id
                                   FROM reports_clicks_wide_rollup_hourly
                                  GROUP BY reports_clicks_wide_rollup_hourly.advertiser_id, reports_clicks_wide_rollup_hourly.publisher_id, reports_clicks_wide_rollup_hourly.publisher_pid, reports_clicks_wide_rollup_hourly.campaign_id, "substring"((reports_clicks_wide_rollup_hourly.hoy)::text, 1, 8), reports_clicks_wide_rollup_hourly.creative_id
                        UNION
                                 SELECT reports_conversions_wide_rollup_hourly.publisher_id,
                                    reports_conversions_wide_rollup_hourly.publisher_pid,
                                    reports_conversions_wide_rollup_hourly.campaign_id,
                                    reports_conversions_wide_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    (sum(reports_conversions_wide_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_wide_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_wide_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_wide_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_wide_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_wide_rollup_hourly.profit)::numeric) AS profit,
                                    ("substring"((reports_conversions_wide_rollup_hourly.hoy)::text, 1, 8))::integer AS doy,
                                    reports_conversions_wide_rollup_hourly.creative_id
                                   FROM reports_conversions_wide_rollup_hourly
                                  GROUP BY reports_conversions_wide_rollup_hourly.advertiser_id, reports_conversions_wide_rollup_hourly.publisher_id, reports_conversions_wide_rollup_hourly.publisher_pid, reports_conversions_wide_rollup_hourly.campaign_id, "substring"((reports_conversions_wide_rollup_hourly.hoy)::text, 1, 8), reports_conversions_wide_rollup_hourly.creative_id) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.doy, clk_con_roll.creative_id
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.doy,
                    clk_and_con.creative_id
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_doy(engine_clicks_rollup_queue.created_date) AS doy,
                                    engine_clicks_rollup_queue.creative_id
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_doy(engine_clicks_rollup_queue.created_date), engine_clicks_rollup_queue.creative_id
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_doy(engine_conversions_rollup_queue.created_date) AS doy,
                                    engine_conversions_rollup_queue.creative_id
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_doy(engine_conversions_rollup_queue.created_date), engine_conversions_rollup_queue.creative_id) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.doy, clk_and_con.creative_id) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.doy, NULL::character varying(255), NULL::character varying(255), NULL::character varying(255), NULL::character varying(255), NULL::character varying(255), NULL::text, NULL::text, NULL::text, NULL::text, NULL::character varying(255), ag_and_new.creative_id;


ALTER TABLE reporting.reports_wide_daily OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: vw_pub_campaign_report_details_browser; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_report_details_browser AS
 SELECT rd.publisher_id,
    rd.campaign_id,
    rd.browser_name AS browser,
    sum(rd.total_clicks) AS total_clicks,
    sum(rd.unique_clicks) AS unique_clicks,
    sum(rd.total_conversions) AS total_conversions,
    sum(rd.total_pay_out) AS payout,
    rd.doy
   FROM reporting.reports_wide_daily rd
  GROUP BY rd.publisher_id, rd.campaign_id, rd.browser_name, rd.doy;


ALTER TABLE public.vw_pub_campaign_report_details_browser OWNER TO w4;

--
-- Name: vw_pub_campaign_report_details_clicks_overview; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_report_details_clicks_overview AS
 SELECT sq1.publisher_id,
    sq1.campaign_id,
    sum(sq1.total_clicks) AS total_clicks,
    sum(sq1.unique_clicks) AS unique_clicks,
    sum(sq1.foreign_clicks) AS foreign_clicks,
    sum(sq1.banned_clicks) AS banned_clicks,
    sq1.doy
   FROM (        (         SELECT al.publisher_id,
                            al.campaign_id,
                            0 AS total_clicks,
                            0 AS unique_clicks,
                            sum(al.id) AS foreign_clicks,
                            0 AS banned_clicks,
                            make_doy(al.created_date) AS doy
                           FROM engine_audit_log al
                          WHERE (al.audit_reason_ordinal = (-21))
                          GROUP BY al.publisher_id, al.campaign_id, make_doy(al.created_date)
                UNION
                         SELECT al.publisher_id,
                            al.campaign_id,
                            0 AS total_clicks,
                            0 AS unique_clicks,
                            0 AS foreign_clicks,
                            sum(al.id) AS banned_clicks,
                            make_doy(al.created_date) AS doy
                           FROM engine_audit_log al
                          WHERE ((al.audit_reason_ordinal = (-15)) OR (al.audit_reason_ordinal = (-20)))
                          GROUP BY al.publisher_id, al.campaign_id, make_doy(al.created_date))
        UNION
                 SELECT rd.publisher_id,
                    rd.campaign_id,
                    sum(rd.total_clicks) AS total_clicks,
                    sum(rd.unique_clicks) AS unique_clicks,
                    0 AS foreign_clicks,
                    0 AS banned_clicks,
                    rd.doy
                   FROM reporting.reports_daily rd
                  GROUP BY rd.publisher_id, rd.campaign_id, rd.doy) sq1
  GROUP BY sq1.publisher_id, sq1.campaign_id, sq1.doy;


ALTER TABLE public.vw_pub_campaign_report_details_clicks_overview OWNER TO w4;

--
-- Name: VIEW vw_pub_campaign_report_details_clicks_overview; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON VIEW vw_pub_campaign_report_details_clicks_overview IS 'View exists per WAMA-995 - Provides all of the data required for the clicks overview.';


--
-- Name: vw_pub_campaign_report_details_creatives; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_report_details_creatives AS
 SELECT x.publisher_id,
    x.campaign_id,
    x.creative_id,
    x.creative_name,
    x.creative_description,
    x.creative_image_id,
    sum(x.total_clicks) AS total_clicks,
    sum(x.unique_clicks) AS unique_clicks,
    sum(x.total_conversions) AS total_conversions,
    sum(x.payout) AS payout,
    x.doy,
    x.campaign_name
   FROM ( SELECT rd.publisher_id,
            rd.campaign_id,
            cmp.name AS campaign_name,
            rd.creative_id,
            cr.name AS creative_name,
            cr.description AS creative_description,
            cb.image_id AS creative_image_id,
            rd.total_clicks,
            rd.unique_clicks,
            rd.total_conversions,
            rd.total_pay_out AS payout,
            rd.doy
           FROM (((reporting.reports_wide_daily rd
      RIGHT JOIN campaigns cmp ON ((rd.campaign_id = cmp.id)))
   LEFT JOIN creatives cr ON ((rd.creative_id = cr.id)))
   LEFT JOIN creative_banners cb ON ((rd.creative_id = cb.creative_id)))
  WHERE ((rd.publisher_id > 0) AND (rd.campaign_id > 0))
  GROUP BY cr.name, cr.description, cb.image_id, cmp.name, rd.publisher_id, rd.publisher_pid, rd.creative_id, rd.pay_out_amount, rd.total_pay_in, rd.total_pay_out, rd.profit, rd.advertiser_id, rd.sub_id_1, rd.sub_id_2, rd.sub_id_3, rd.sub_id_4, rd.country, rd.region_name, rd.city_name, rd.browser_name, rd.platform_name, rd.campaign_id, rd.base_uri, rd.total_clicks, rd.total_conversions, rd.unique_clicks, rd.doy, rd.pay_in_amount) x
  GROUP BY x.publisher_id, x.campaign_id, x.campaign_name, x.creative_id, x.creative_name, x.creative_description, x.creative_image_id, x.doy
  ORDER BY x.doy DESC, x.campaign_id, x.publisher_id;


ALTER TABLE public.vw_pub_campaign_report_details_creatives OWNER TO w4;

--
-- Name: vw_pub_campaign_report_details_daily; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_report_details_daily AS
 SELECT rd.publisher_id,
    rd.campaign_id,
    sum(rd.total_clicks) AS total_clicks,
    sum(rd.unique_clicks) AS unique_clicks,
    sum(rd.total_conversions) AS total_conversions,
    sum(rd.total_pay_out) AS payout,
    rd.doy
   FROM reporting.reports_daily rd
  GROUP BY rd.publisher_id, rd.campaign_id, rd.doy;


ALTER TABLE public.vw_pub_campaign_report_details_daily OWNER TO w4;

--
-- Name: VIEW vw_pub_campaign_report_details_daily; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON VIEW vw_pub_campaign_report_details_daily IS 'View exists per WAMA-1001 - Provides all of the data required for the daily subreport.';


--
-- Name: vw_pub_campaign_report_details_geos; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_report_details_geos AS
 SELECT rd.publisher_id,
    rd.campaign_id,
    (((((rd.country)::text || ' '::text) || (rd.region_name)::text) || ' '::text) || (rd.city_name)::text) AS geo_location,
    sum(rd.total_clicks) AS total_clicks,
    sum(rd.unique_clicks) AS unique_clicks,
    sum(rd.total_conversions) AS total_conversions,
    sum(rd.total_pay_out) AS payout,
    rd.doy
   FROM reporting.reports_geo_daily rd
  GROUP BY rd.publisher_id, rd.campaign_id, rd.country, rd.region_name, rd.city_name, rd.doy;


ALTER TABLE public.vw_pub_campaign_report_details_geos OWNER TO w4;

--
-- Name: VIEW vw_pub_campaign_report_details_geos; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON VIEW vw_pub_campaign_report_details_geos IS 'View exists per WAMA-997 - Provides all of the data required for the geos.';


--
-- Name: vw_pub_campaign_report_details_platform; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_report_details_platform AS
 SELECT rd.publisher_id,
    rd.campaign_id,
    rd.platform_name AS platform,
    sum(rd.total_clicks) AS total_clicks,
    sum(rd.unique_clicks) AS unique_clicks,
    sum(rd.total_conversions) AS total_conversions,
    sum(rd.total_pay_out) AS payout,
    rd.doy
   FROM reporting.reports_wide_daily rd
  GROUP BY rd.publisher_id, rd.campaign_id, rd.platform_name, rd.doy;


ALTER TABLE public.vw_pub_campaign_report_details_platform OWNER TO w4;

--
-- Name: vw_pub_campaign_report_details_referrer; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_report_details_referrer AS
 SELECT x.publisher_id,
    x.campaign_id,
    x.referrer,
    sum(x.total_clicks) AS total_clicks,
    sum(x.unique_clicks) AS unique_clicks,
    sum(x.total_conversions) AS total_conversions,
    sum(x.payout) AS payout,
    x.doy
   FROM ( SELECT rd.publisher_id,
            rd.campaign_id,
            rd.base_uri AS referrer,
            rd.total_clicks,
            rd.unique_clicks,
            rd.total_conversions,
            rd.total_pay_out AS payout,
            rd.doy
           FROM reporting.reports_wide_daily rd
          GROUP BY rd.publisher_id, rd.publisher_pid, rd.creative_id, rd.pay_out_amount, rd.total_pay_in, rd.total_pay_out, rd.profit, rd.advertiser_id, rd.sub_id_1, rd.sub_id_2, rd.sub_id_3, rd.sub_id_4, rd.country, rd.region_name, rd.city_name, rd.browser_name, rd.platform_name, rd.campaign_id, rd.base_uri, rd.total_clicks, rd.total_conversions, rd.unique_clicks, rd.doy, rd.pay_in_amount) x
  GROUP BY x.publisher_id, x.campaign_id, x.referrer, x.doy;


ALTER TABLE public.vw_pub_campaign_report_details_referrer OWNER TO w4;

SET search_path = reporting, pg_catalog;

--
-- Name: reports_clicks_subid_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_subid_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_subid_rollup_hourly OWNER TO w4;

--
-- Name: reports_conversions_subid_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_subid_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_conversions_subid_rollup_hourly OWNER TO w4;

--
-- Name: reports_subid_daily; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_subid_daily AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    ag_and_new.sub_id_1,
    NULL::text AS sub_id_2,
    NULL::text AS sub_id_3,
    NULL::text AS sub_id_4,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.doy
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    clk_con_roll.sub_id_1,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    (clk_con_roll.doy)::bigint AS doy
                   FROM (         SELECT reports_clicks_subid_rollup_hourly.publisher_id,
                                    reports_clicks_subid_rollup_hourly.publisher_pid,
                                    reports_clicks_subid_rollup_hourly.campaign_id,
                                    reports_clicks_subid_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_subid_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_subid_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    reports_clicks_subid_rollup_hourly.sub_id_1,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    ("substring"((reports_clicks_subid_rollup_hourly.hoy)::text, 1, 8))::integer AS doy
                                   FROM reports_clicks_subid_rollup_hourly
                                  GROUP BY reports_clicks_subid_rollup_hourly.advertiser_id, reports_clicks_subid_rollup_hourly.publisher_id, reports_clicks_subid_rollup_hourly.publisher_pid, reports_clicks_subid_rollup_hourly.campaign_id, "substring"((reports_clicks_subid_rollup_hourly.hoy)::text, 1, 8), reports_clicks_subid_rollup_hourly.sub_id_1
                        UNION
                                 SELECT reports_conversions_subid_rollup_hourly.publisher_id,
                                    reports_conversions_subid_rollup_hourly.publisher_pid,
                                    reports_conversions_subid_rollup_hourly.campaign_id,
                                    reports_conversions_subid_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    reports_conversions_subid_rollup_hourly.sub_id_1,
                                    (sum(reports_conversions_subid_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_subid_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_subid_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_subid_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_subid_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_subid_rollup_hourly.profit)::numeric) AS profit,
                                    ("substring"((reports_conversions_subid_rollup_hourly.hoy)::text, 1, 8))::integer AS doy
                                   FROM reports_conversions_subid_rollup_hourly
                                  GROUP BY reports_conversions_subid_rollup_hourly.advertiser_id, reports_conversions_subid_rollup_hourly.publisher_id, reports_conversions_subid_rollup_hourly.publisher_pid, reports_conversions_subid_rollup_hourly.campaign_id, "substring"((reports_conversions_subid_rollup_hourly.hoy)::text, 1, 8), reports_conversions_subid_rollup_hourly.sub_id_1) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.doy, clk_con_roll.sub_id_1
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    clk_and_con.sub_id_1,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.doy
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    engine_clicks_rollup_queue.sub_id_1,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_doy(engine_clicks_rollup_queue.created_date) AS doy
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_doy(engine_clicks_rollup_queue.created_date), engine_clicks_rollup_queue.sub_id_1
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    engine_conversions_rollup_queue.sub_id_1,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_doy(engine_conversions_rollup_queue.created_date) AS doy
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_doy(engine_conversions_rollup_queue.created_date), engine_conversions_rollup_queue.sub_id_1) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.doy, clk_and_con.sub_id_1) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.doy, ag_and_new.sub_id_1, NULL::text, NULL::text, NULL::text;


ALTER TABLE reporting.reports_subid_daily OWNER TO w4;

SET search_path = public, pg_catalog;

--
-- Name: vw_pub_campaign_report_details_subid; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pub_campaign_report_details_subid AS
 SELECT rd.publisher_id,
    rd.campaign_id,
    rd.sub_id_1,
    rd.sub_id_2,
    rd.sub_id_3,
    rd.sub_id_4,
    sum(rd.total_clicks) AS total_clicks,
    sum(rd.unique_clicks) AS unique_clicks,
    sum(rd.total_conversions) AS total_conversions,
    sum(rd.total_pay_out) AS payout,
    rd.doy
   FROM reporting.reports_subid_daily rd
  GROUP BY rd.publisher_id, rd.campaign_id, rd.sub_id_1, rd.sub_id_2, rd.sub_id_3, rd.sub_id_4, rd.doy;


ALTER TABLE public.vw_pub_campaign_report_details_subid OWNER TO w4;

--
-- Name: VIEW vw_pub_campaign_report_details_subid; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON VIEW vw_pub_campaign_report_details_subid IS 'View exists per WAMA-996 - Provides all of the data required for the subid.';


--
-- Name: vw_publisher_debit_balance; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_debit_balance AS
 SELECT acl.publisher_id,
    COALESCE(sum(acl.pay_out_amt), (0)::numeric) AS debit_balance
   FROM "Accounting".acct_conversion_ledger acl
  WHERE ((acl.transaction_type = 70) AND (acl.status < 20))
  GROUP BY acl.publisher_id;


ALTER TABLE public.vw_publisher_debit_balance OWNER TO w4;

--
-- Name: vw_publisher_detail_information_panel; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_detail_information_panel AS
 SELECT pusr.id AS publisher_id,
    pup.company_name AS publisher_name,
    pusr.manager_id,
    (((mup.first_name)::text || ' '::text) || (mup.last_name)::text) AS manager_name,
    pusr.active AS publisher_status,
    COALESCE(vpdb.debit_balance, (0)::numeric) AS debit_balance,
    pup.payment_threshold,
    pup.payment_schedule AS payment_terms,
    (((pc.first_name)::text || ' '::text) || (pc.last_name)::text) AS contact_name,
    pc.primary_phone AS publisher_phone,
    pc.secondary_phone AS publisher_mobile,
    pc.fax AS publisher_fax,
    pup.payment_to,
    pup.payment_by,
    pup.payment_schedule,
    bc.address_1 AS payment_address_1,
    bc.address_2 AS payment_address_2,
    bcy.place_name_ascii AS payment_city,
    bcr.ascii_name AS payment_state,
    bc.postal_code AS payment_zip,
    bcc.country AS payment_country,
    ac.address_1,
    ac.address_2,
    acy.place_name_ascii AS city,
    acr.ascii_name AS state,
    ac.postal_code AS zip,
    acc.country,
    pusr.email,
    pup.website_url
   FROM (((((((((((((users pusr
   LEFT JOIN users musr ON ((pusr.manager_id = musr.id)))
   LEFT JOIN user_profiles pup ON ((pusr.id = pup.user_id)))
   LEFT JOIN user_profiles mup ON ((musr.id = mup.user_id)))
   LEFT JOIN vw_publisher_debit_balance vpdb ON ((pusr.id = vpdb.publisher_id)))
   LEFT JOIN contacts bc ON ((pusr.billing_contact_id = bc.id)))
   LEFT JOIN contacts ac ON ((pusr.account_contact_id = ac.id)))
   LEFT JOIN contacts pc ON ((pusr.primary_contact_id = pc.id)))
   LEFT JOIN geo_typeahead_countries bcc ON ((bc.country_id = bcc.id)))
   LEFT JOIN geo_typeahead_region bcr ON ((bc.region_id = bcr.id)))
   LEFT JOIN geo_typeahead_cities bcy ON ((bc.city_id = bcy.id)))
   LEFT JOIN geo_typeahead_countries acc ON ((ac.country_id = acc.id)))
   LEFT JOIN geo_typeahead_region acr ON ((ac.region_id = acr.id)))
   LEFT JOIN geo_typeahead_cities acy ON ((ac.city_id = acy.id)))
  WHERE ((pusr.access)::text = 'publisher'::text);


ALTER TABLE public.vw_publisher_detail_information_panel OWNER TO w4;

--
-- Name: vw_publisher_detail_referrer; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_detail_referrer AS
 SELECT rd.publisher_id,
    rd.base_uri,
    max((cmp.name)::text) AS campaign_name,
    rd.campaign_id,
    sum(rd.total_clicks) AS clicks,
    sum(rd.total_conversions) AS conversions,
    rd.doy
   FROM (reporting.reports_wide_daily rd
   LEFT JOIN campaigns cmp ON ((rd.campaign_id = cmp.id)))
  GROUP BY rd.publisher_id, rd.campaign_id, rd.base_uri, rd.doy;


ALTER TABLE public.vw_publisher_detail_referrer OWNER TO w4;

--
-- Name: vw_publisher_detail_subid_report; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_detail_subid_report AS
 SELECT mvsr.campaign_id,
    camp.name AS campaign_name,
    mvsr.publisher_id,
    COALESCE(up.company_name, (concat(up.first_name, ' ', up.last_name))::character varying) AS publisher_name,
    mvsr.advertiser_id,
    adv.name AS advertiser_name,
    mvsr.doy,
    mvsr.sub_id_1,
    mvsr.sub_id_2,
    mvsr.sub_id_3,
    mvsr.sub_id_4,
    mvsr.total_clicks AS clicks,
    mvsr.total_conversions AS conversions,
    mvsr.total_pay_in AS total_in,
    mvsr.total_pay_out AS total_out,
    mvsr.pay_in_amount,
    mvsr.pay_out_amount,
    camp.status AS campaign_status
   FROM ((((reporting.reports_subid_daily mvsr
   LEFT JOIN users usr ON ((mvsr.publisher_id = usr.id)))
   LEFT JOIN user_profiles up ON ((usr.id = up.user_id)))
   LEFT JOIN advertisers adv ON ((mvsr.advertiser_id = adv.id)))
   LEFT JOIN campaigns camp ON ((mvsr.campaign_id = camp.id)));


ALTER TABLE public.vw_publisher_detail_subid_report OWNER TO w4;

--
-- Name: vw_publisher_detail_traffic; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_detail_traffic AS
 SELECT clk.publisher_id,
    clk.campaign_id,
    max((cmp.name)::text) AS campaign_name,
    max(clk.advertiser_id) AS advertiser_id,
    max((cmp.status)::text) AS campaign_status,
    COALESCE(max(v7dtl.unique_clk_trend), '0+0+0+0+0+0+0'::text) AS trending,
    sum(clk.total_clicks) AS clicks,
    sum(clk.total_conversions) AS conversions,
    COALESCE(((sum(clk.total_clicks) / NULLIF(sum(clk.total_conversions), (0)::numeric)) * (100)::numeric), ((0)::bigint)::numeric) AS conversion_pct,
    COALESCE((sum(clk.total_pay_in) / NULLIF(sum(clk.total_clicks), (0)::numeric)), (0)::numeric) AS epc,
    sum(clk.total_pay_in) AS total_in,
    sum(clk.total_pay_out) AS total_out,
    (sum(clk.total_pay_in) / NULLIF(sum(clk.total_conversions), (0)::numeric)) AS average_in,
    (sum(clk.total_pay_out) / NULLIF(sum(clk.total_conversions), (0)::numeric)) AS average_out,
    sum(clk.profit) AS total_profit,
    clk.doy
   FROM ((reporting.reports_daily clk
   LEFT JOIN campaigns cmp ON ((clk.campaign_id = cmp.id)))
   LEFT JOIN tvw_7_day_trend_line v7dtl ON (((cmp.id = v7dtl.campaign_id) AND (v7dtl.publisher_id = clk.publisher_id))))
  GROUP BY clk.publisher_id, clk.campaign_id, clk.doy;


ALTER TABLE public.vw_publisher_detail_traffic OWNER TO w4;

--
-- Name: vw_publisher_edit; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_edit AS
 SELECT pu.id AS publisher_id,
    COALESCE(NULLIF((pup.company_name)::text, ''::text), ((concat(pup.first_name, ' ', pup.last_name))::character varying)::text) AS publisher_name,
    COALESCE(NULLIF((pup.first_name)::text, ''::text), NULLIF((cp.first_name)::text, ''::text)) AS first_name,
    COALESCE(NULLIF((pup.last_name)::text, ''::text), NULLIF((cp.last_name)::text, ''::text)) AS last_name,
    COALESCE(NULLIF((pup.address_1)::text, ''::text), NULLIF((ca.address_1)::text, ''::text)) AS address_1,
    COALESCE(NULLIF((pup.address_2)::text, ''::text), NULLIF((ca.address_2)::text, ''::text)) AS address_2,
    COALESCE(pp.id, ca.country_id) AS country_id,
    COALESCE(NULLIF((pp.country)::text, ''::text), NULLIF((bc.country)::text, ''::text)) AS country,
    COALESCE(NULLIF(((pup.state)::character varying)::text, ''::text), NULLIF((br.ascii_name)::text, ''::text)) AS region,
    COALESCE(NULLIF((pup.city)::text, ''::text), NULLIF((ca.city_name)::text, ''::text)) AS city,
    COALESCE(NULLIF((pup.zip)::text, ''::text), NULLIF((ca.postal_code)::text, ''::text)) AS postal_code,
    COALESCE(NULLIF(pup.phone, ''::text), NULLIF(cp.primary_phone, ''::text)) AS phone,
    COALESCE(NULLIF((pup.cell)::text, ''::text), NULLIF((cp.secondary_phone)::text, ''::text)) AS mobile_phone,
    COALESCE(NULLIF((pup.messenger_id)::text, ''::text), NULLIF((cp.messenger_name)::text, ''::text)) AS messenger_id,
    COALESCE(NULLIF((pup.messenger_type)::text, ''::text), NULLIF((cp.messenger_type)::text, ''::text)) AS messenger_type,
    COALESCE(NULLIF((pup.website_url)::text, ''::text), (''::character varying)::text) AS website_url,
    COALESCE(NULLIF(concat(pup.first_name, ' ', pup.last_name), ' '::text), NULLIF(concat(cp.first_name, ' ', cp.last_name), ' '::text)) AS full_name,
    pup.company_name,
    COALESCE(NULLIF((pup.payment_address_1)::text, ''::text), NULLIF((ca.address_1)::text, ''::text)) AS payment_address_1,
    COALESCE(NULLIF((pup.payment_address_2)::text, ''::text), NULLIF((ca.address_2)::text, ''::text)) AS payment_address_2,
    COALESCE(pa.id, ca.country_id) AS payment_country_id,
    COALESCE(NULLIF((pa.country)::text, ''::text), NULLIF((bc.country)::text, ''::text)) AS payment_country,
    COALESCE(NULLIF((pup.payment_region)::text, ''::text), NULLIF((br.ascii_name)::text, ''::text)) AS payment_region,
    COALESCE(NULLIF((pup.payment_city)::text, ''::text), NULLIF((ca.city_name)::text, ''::text)) AS payment_city,
    COALESCE(NULLIF((pup.payment_postal_code)::text, ''::text), NULLIF((ca.postal_code)::text, ''::text)) AS payment_postal_code,
    pup.tax_id,
    pup.payment_to,
    pup.payment_by AS payment_method_id,
    pup.payment_threshold,
    pup.payment_schedule,
    pu.email,
    pu.manager_id,
    pu.active AS status
   FROM (((((((((users pu
   LEFT JOIN user_profiles pup ON ((pu.id = pup.user_id)))
   LEFT JOIN contacts cp ON ((pu.primary_contact_id = cp.id)))
   LEFT JOIN contacts cb ON ((pu.billing_contact_id = cb.id)))
   LEFT JOIN contacts ca ON ((pu.account_contact_id = ca.id)))
   LEFT JOIN geo_typeahead_countries bc ON ((ca.country_id = bc.id)))
   LEFT JOIN geo_typeahead_region br ON ((ca.region_id = br.id)))
   LEFT JOIN geo_typeahead_cities bi ON ((ca.city_id = bi.id)))
   LEFT JOIN geo_typeahead_countries pp ON (((pup.country)::text = (pp.country)::text)))
   LEFT JOIN geo_typeahead_countries pa ON (((pup.payment_country)::text = (pa.country)::text)))
  WHERE ((pu.access)::text = 'publisher'::text);


ALTER TABLE public.vw_publisher_edit OWNER TO w4;

--
-- Name: vw_publisher_groups; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_groups AS
 SELECT publisher_groups_assoc.publisher_id,
    string_agg(((publisher_groups_assoc.group_id)::character(1))::text, ','::text) AS groups
   FROM publisher_groups_assoc
  GROUP BY publisher_groups_assoc.publisher_id;


ALTER TABLE public.vw_publisher_groups OWNER TO w4;

--
-- Name: vw_publisher_groups_assoc; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_groups_assoc AS
 SELECT pga.publisher_id,
    array_agg((pga.group_id)::bigint) AS groups,
    max(pg.status) AS status
   FROM (publisher_groups_assoc pga
   LEFT JOIN publisher_groups pg ON ((pg.id = pga.group_id)))
  GROUP BY pga.publisher_id;


ALTER TABLE public.vw_publisher_groups_assoc OWNER TO w4;

--
-- Name: vw_publisher_groups_list; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_groups_list AS
 SELECT pga.publisher_id,
    pga.group_id,
    pg.name
   FROM (publisher_groups_assoc pga
   LEFT JOIN publisher_groups pg ON ((pga.group_id = pg.id)));


ALTER TABLE public.vw_publisher_groups_list OWNER TO w4;

--
-- Name: vw_publisher_list_hourly; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_list_hourly AS
 SELECT clk.publisher_id,
    (clk.hoy)::integer AS hour_range,
    clk.campaign_id,
    max((cmp.name)::text) AS campaign_name,
    clk.advertiser_id,
    max((adv.name)::text) AS advertiser_name,
    max((cmp.status)::text) AS campaign_status,
    (sum(clk.total_clicks))::bigint AS clicks,
    (sum(clk.total_conversions))::bigint AS conversions,
    COALESCE(((sum(clk.total_clicks) / NULLIF(sum(clk.total_conversions), (0)::numeric)) * (100)::numeric), ((0)::bigint)::numeric) AS conversion_pct,
    COALESCE((sum(clk.total_pay_in) / NULLIF(sum(clk.total_clicks), (0)::numeric)), (0)::numeric) AS epc,
    sum(clk.total_pay_in) AS total_in,
    sum(clk.total_pay_out) AS total_out,
    sum(clk.profit) AS total_profit,
    (COALESCE((((sum(clk.total_pay_in) - sum(clk.total_pay_out)) * (100)::numeric) / NULLIF(sum(clk.total_pay_in), (0)::numeric)), (0)::numeric))::bigint AS profit_pct
   FROM ((reporting.reports_hourly clk
   LEFT JOIN campaigns cmp ON ((clk.campaign_id = cmp.id)))
   LEFT JOIN advertisers adv ON ((clk.advertiser_id = adv.id)))
  GROUP BY clk.campaign_id, clk.advertiser_id, clk.publisher_id, clk.hoy;


ALTER TABLE public.vw_publisher_list_hourly OWNER TO w4;

--
-- Name: vw_publisher_list_traffic; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_list_traffic AS
 SELECT clk.campaign_id,
    clk.publisher_id,
    clk.advertiser_id,
    cmp.name AS campaign_name,
    COALESCE((up.company_name)::text, concat(up.first_name, ' ', up.last_name)) AS publisher_name,
    clk.total_clicks AS clicks,
    clk.total_conversions AS conversions,
    clk.total_pay_in AS total_in,
    clk.total_pay_out AS total_out,
    clk.profit AS total_profit,
    clk.pay_in_amount AS avg_payin_per_conversion,
    clk.pay_out_amount AS avg_payout_per_conversion,
    (cmp.status)::text AS campaign_status,
    clk.doy
   FROM (((reporting.reports_daily clk
   LEFT JOIN campaigns cmp ON ((clk.campaign_id = cmp.id)))
   LEFT JOIN users usr ON ((clk.publisher_id = usr.id)))
   LEFT JOIN user_profiles up ON ((usr.uuid = up.user_uuid)));


ALTER TABLE public.vw_publisher_list_traffic OWNER TO w4;

--
-- Name: vw_publisher_main_listing; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_main_listing AS
         SELECT pusr.id AS publisher_id,
            rcrd.campaign_id,
            max((cmp.name)::text) AS campaign_name,
            COALESCE(max((pup.company_name)::text), concat(max((pup.first_name)::text), ' ', max((pup.last_name)::text))) AS publisher_name,
            pusr.active AS status,
            pusr.manager_id AS manager,
            max(vpg.groups) AS publisher_groups,
            rcrd.doy,
            sum(rcrd.total_conversions) AS conversions,
            sum(rcrd.total_clicks) AS total_clicks,
            sum(rcrd.unique_clicks) AS unique_clicks,
            sum(rcrd.total_pay_in) AS total_in,
            sum(rcrd.total_pay_out) AS total_out,
            sum(rcrd.profit) AS total_profit
           FROM ((((users pusr
      LEFT JOIN user_profiles pup ON ((pusr.uuid = pup.user_uuid)))
   LEFT JOIN reporting.reports_daily rcrd ON (((pusr.id = rcrd.publisher_id) AND (rcrd.doy < 0))))
   LEFT JOIN campaigns cmp ON ((rcrd.campaign_id = cmp.id)))
   LEFT JOIN vw_publisher_groups vpg ON ((pusr.id = vpg.publisher_id)))
  WHERE ((pusr.access)::text = 'publisher'::text)
  GROUP BY pusr.id, pusr.active, pusr.manager_id, rcrd.campaign_id, rcrd.doy
UNION
         SELECT pusr.id AS publisher_id,
            rcrd.campaign_id,
            max((cmp.name)::text) AS campaign_name,
            COALESCE(max((pup.company_name)::text), concat(max((pup.first_name)::text), ' ', max((pup.last_name)::text))) AS publisher_name,
            pusr.active AS status,
            pusr.manager_id AS manager,
            max(vpg.groups) AS publisher_groups,
            rcrd.doy,
            sum(rcrd.total_conversions) AS conversions,
            sum(rcrd.total_clicks) AS total_clicks,
            sum(rcrd.unique_clicks) AS unique_clicks,
            sum(rcrd.total_pay_in) AS total_in,
            sum(rcrd.total_pay_out) AS total_out,
            sum(rcrd.profit) AS total_profit
           FROM ((((users pusr
      LEFT JOIN user_profiles pup ON ((pusr.uuid = pup.user_uuid)))
   LEFT JOIN reporting.reports_daily rcrd ON ((pusr.id = rcrd.publisher_id)))
   LEFT JOIN campaigns cmp ON ((rcrd.campaign_id = cmp.id)))
   LEFT JOIN vw_publisher_groups vpg ON ((pusr.id = vpg.publisher_id)))
  WHERE ((pusr.access)::text = 'publisher'::text)
  GROUP BY pusr.id, pusr.active, pusr.manager_id, rcrd.campaign_id, rcrd.doy;


ALTER TABLE public.vw_publisher_main_listing OWNER TO w4;

--
-- Name: vw_publisher_main_listing_cpa; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_main_listing_cpa AS
         SELECT pusr.id AS publisher_id,
            rcrd.campaign_id,
            max((cmp.name)::text) AS campaign_name,
            COALESCE(max((pup.company_name)::text), concat(max((pup.first_name)::text), ' ', max((pup.last_name)::text))) AS publisher_name,
            pusr.active AS status,
            pusr.manager_id AS manager,
            max(vpg.groups) AS publisher_groups,
            rcrd.doy,
            sum(rcrd.total_conversions) AS conversions,
            sum(rcrd.total_clicks) AS total_clicks,
            sum(rcrd.unique_clicks) AS unique_clicks,
            sum(rcrd.total_pay_in) AS total_in,
            sum(rcrd.total_pay_out) AS total_out,
            sum(rcrd.profit) AS total_profit,
            rcrd.pay_in_amount AS pay_in,
            rcrd.pay_out_amount AS pay_out
           FROM ((((users pusr
      LEFT JOIN user_profiles pup ON ((pusr.uuid = pup.user_uuid)))
   LEFT JOIN reporting.reports_daily rcrd ON (((pusr.id = rcrd.publisher_id) AND (rcrd.doy < 0))))
   LEFT JOIN campaigns cmp ON ((rcrd.campaign_id = cmp.id)))
   LEFT JOIN vw_publisher_groups vpg ON ((pusr.id = vpg.publisher_id)))
  WHERE ((pusr.access)::text = 'publisher'::text)
  GROUP BY pusr.id, pusr.active, pusr.manager_id, rcrd.campaign_id, rcrd.doy, rcrd.pay_in_amount, rcrd.pay_out_amount
UNION
         SELECT pusr.id AS publisher_id,
            rcrd.campaign_id,
            max((cmp.name)::text) AS campaign_name,
            COALESCE(max((pup.company_name)::text), concat(max((pup.first_name)::text), ' ', max((pup.last_name)::text))) AS publisher_name,
            pusr.active AS status,
            pusr.manager_id AS manager,
            max(vpg.groups) AS publisher_groups,
            rcrd.doy,
            sum(rcrd.total_conversions) AS conversions,
            sum(rcrd.total_clicks) AS total_clicks,
            sum(rcrd.unique_clicks) AS unique_clicks,
            sum(rcrd.total_pay_in) AS total_in,
            sum(rcrd.total_pay_out) AS total_out,
            sum(rcrd.profit) AS total_profit,
            rcrd.pay_in_amount AS pay_in,
            rcrd.pay_out_amount AS pay_out
           FROM ((((users pusr
      LEFT JOIN user_profiles pup ON ((pusr.uuid = pup.user_uuid)))
   LEFT JOIN reporting.reports_daily rcrd ON ((pusr.id = rcrd.publisher_id)))
   LEFT JOIN campaigns cmp ON ((rcrd.campaign_id = cmp.id)))
   LEFT JOIN vw_publisher_groups vpg ON ((pusr.id = vpg.publisher_id)))
  WHERE ((pusr.access)::text = 'publisher'::text)
  GROUP BY pusr.id, pusr.active, pusr.manager_id, rcrd.campaign_id, rcrd.doy, rcrd.pay_in_amount, rcrd.pay_out_amount;


ALTER TABLE public.vw_publisher_main_listing_cpa OWNER TO w4;

--
-- Name: vw_publisher_overrides; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_publisher_overrides AS
 SELECT po.id,
    po.publisher_id,
    COALESCE(up.company_name, (concat(up.first_name, ' ', up.last_name))::character varying) AS publisher_name,
    po.campaign_id,
    c.name AS campaign_name,
    po.override_payout AS payout,
    c.default_payout,
    po.override_payin AS payin,
    c.default_payin,
    (((((((('["'::text || po.sub_id_1) || '","'::text) || po.sub_id_2) || '","'::text) || po.sub_id_3) || '","'::text) || po.sub_id_4) || '"]'::text) AS sub_ids_json,
    po.override_advertiser_landing_page AS advertiser_landing_page,
    to_char(po.effective_date, 'mm/dd/YYYY'::text) AS effective_date,
    to_char(po.expiration_date, 'mm/dd/YYYY'::text) AS expiration_date
   FROM (((publisher_overrides po
   LEFT JOIN users u ON ((po.publisher_id = u.id)))
   LEFT JOIN user_profiles up ON ((u.id = up.user_id)))
   LEFT JOIN campaigns c ON ((po.campaign_id = c.id)));


ALTER TABLE public.vw_publisher_overrides OWNER TO w4;

--
-- Name: vw_pubs_campaign_report_graph_aggregates; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pubs_campaign_report_graph_aggregates AS
 SELECT rd.publisher_id,
    COALESCE(sum(rd.total_clicks), (0)::numeric) AS total_clicks,
    COALESCE(sum(rd.unique_clicks), (0)::numeric) AS unique_clicks,
    COALESCE(sum(rd.total_conversions), (0)::numeric) AS conversions,
    COALESCE(sum(rd.total_pay_out), (0)::numeric) AS revenue
   FROM reporting.reports_daily rd
  GROUP BY rd.publisher_id, rd.doy;


ALTER TABLE public.vw_pubs_campaign_report_graph_aggregates OWNER TO w4;

--
-- Name: VIEW vw_pubs_campaign_report_graph_aggregates; Type: COMMENT; Schema: public; Owner: w4
--

COMMENT ON VIEW vw_pubs_campaign_report_graph_aggregates IS 'View exists per WAMA-994 - Provides all of the data required for the graph view. Since the calculated aggregates change on each query, and you can not add them, you will have to declare those fields using the Fomulae in the spreadsheet';


--
-- Name: vw_pubs_campaign_report_list_items; Type: TABLE; Schema: public; Owner: w4; Tablespace: 
--

CREATE TABLE vw_pubs_campaign_report_list_items (
    campaign_id bigint,
    campaign_name character varying(255),
    publisher_id bigint,
    total_clicks numeric,
    unique_clicks numeric,
    conversions numeric,
    revenue numeric,
    expiration_date timestamp with time zone,
    payout double precision,
    pays_on character varying,
    geos_json json,
    categories_json json,
    channels_json json,
    campaign_description text,
    doy bigint,
    is_new boolean
);


ALTER TABLE public.vw_pubs_campaign_report_list_items OWNER TO w4;

--
-- Name: vw_pubs_campaigns_listing; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_pubs_campaigns_listing AS
 SELECT cmp.name AS campaign_name,
    cmp.id AS campaign_id,
    cmp.default_payout AS pay_out,
    (((cca.alias)::text || ' '::text) || (cca.alias_type)::text) AS pays_on,
    cg.city AS geos,
        CASE cmp.access_type
            WHEN 1 THEN ''::text
            WHEN 3 THEN 'Request Access'::text
            ELSE NULL::text
        END AS pub_access,
        CASE
            WHEN ((cmp.new_until)::timestamp with time zone > (now() + '1 day'::interval)) THEN true
            ELSE false
        END AS is_new
   FROM ((campaigns cmp
   LEFT JOIN campaign_conversion_aliases cca ON ((cmp.payout_model_id = cca.id)))
   LEFT JOIN campaign_geotargeting cg ON ((cmp.id = cg.campaign_id)))
  WHERE (cmp.access_type <> 2);


ALTER TABLE public.vw_pubs_campaigns_listing OWNER TO w4;

--
-- Name: vw_subid_report; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_subid_report AS
 SELECT clk.campaign_id,
    cmp.name,
    clk.publisher_id,
    clk.advertiser_id,
    clk.doy,
    clk.sub_id_1,
    clk.sub_id_2,
    clk.sub_id_3,
    clk.sub_id_4,
    COALESCE(clk.total_clicks, (0)::bigint) AS total_clicks,
    COALESCE(clk.unique_clicks, (0)::bigint) AS unique_clicks,
    COALESCE(clk.total_conversions, (0)::bigint) AS conversions,
    COALESCE(clk.total_pay_in, (0)::numeric) AS total_in,
    COALESCE(clk.total_pay_out, (0)::numeric) AS total_out,
    COALESCE(clk.pay_in_amount, (0)::numeric) AS average_in,
    COALESCE(clk.pay_out_amount, (0)::numeric) AS average_out
   FROM (reporting.reports_subid_daily clk
   LEFT JOIN campaigns cmp ON ((clk.campaign_id = cmp.id)));


ALTER TABLE public.vw_subid_report OWNER TO w4;

--
-- Name: vw_used_acl_admin_groups; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_used_acl_admin_groups AS
 SELECT acl_groups.id,
    acl_groups.name
   FROM "ACL".acl_groups
  WHERE (acl_groups.id IN ( SELECT DISTINCT acl_user_groups.group_id
           FROM "ACL".acl_user_groups
          WHERE (acl_user_groups.group_id <> 8)));


ALTER TABLE public.vw_used_acl_admin_groups OWNER TO w4;

--
-- Name: vw_used_campaign_categories; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_used_campaign_categories AS
 SELECT categories.id,
    categories.parent_id,
    categories.name,
    categories.description
   FROM categories
  WHERE (categories.id IN ( SELECT DISTINCT campaign_categories.category_id
           FROM campaign_categories));


ALTER TABLE public.vw_used_campaign_categories OWNER TO w4;

--
-- Name: vw_used_channels; Type: VIEW; Schema: public; Owner: w4
--

CREATE VIEW vw_used_channels AS
 SELECT traffic_types.id,
    traffic_types.name
   FROM channels traffic_types
  WHERE (traffic_types.id IN ( SELECT DISTINCT campaign_traffic_types.channel_id AS traffic_type_id
           FROM campaign_channels campaign_traffic_types));


ALTER TABLE public.vw_used_channels OWNER TO w4;

SET search_path = reporting, pg_catalog;

--
-- Name: heatmap_data_by_campaign_id; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE heatmap_data_by_campaign_id (
    id bigint NOT NULL,
    campaign_id bigint,
    frequency text,
    return_type text,
    geo_json text,
    y integer
);


ALTER TABLE reporting.heatmap_data_by_campaign_id OWNER TO w4;

--
-- Name: heatmap_data_by_campaign_id_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE heatmap_data_by_campaign_id_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.heatmap_data_by_campaign_id_id_seq OWNER TO w4;

--
-- Name: heatmap_data_by_campaign_id_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE heatmap_data_by_campaign_id_id_seq OWNED BY heatmap_data_by_campaign_id.id;


--
-- Name: heatmap_data_by_publisher_id; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE heatmap_data_by_publisher_id (
    id bigint NOT NULL,
    publisher_id bigint,
    frequency text,
    return_type text,
    geo_json text,
    y integer
);


ALTER TABLE reporting.heatmap_data_by_publisher_id OWNER TO w4;

--
-- Name: heatmap_data_by_publisher_id_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE heatmap_data_by_publisher_id_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.heatmap_data_by_publisher_id_id_seq OWNER TO w4;

--
-- Name: heatmap_data_by_publisher_id_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE heatmap_data_by_publisher_id_id_seq OWNED BY heatmap_data_by_publisher_id.id;


--
-- Name: reports_clicks_geo_country_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_geo_country_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    country character varying(255),
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_geo_country_rollup_hourly OWNER TO w4;

--
-- Name: reports_clicks_geo_country_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_geo_country_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_geo_country_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_geo_country_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_geo_country_rollup_hourly_id_seq OWNED BY reports_clicks_geo_country_rollup_hourly.id;


--
-- Name: reports_clicks_geo_region_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_geo_region_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    country character varying(255),
    region_name character varying(255),
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_geo_region_rollup_hourly OWNER TO w4;

--
-- Name: reports_clicks_geo_region_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_geo_region_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_geo_region_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_geo_region_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_geo_region_rollup_hourly_id_seq OWNED BY reports_clicks_geo_region_rollup_hourly.id;


--
-- Name: reports_clicks_geo_rollup_daily; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_geo_rollup_daily (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    doy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_geo_rollup_daily OWNER TO w4;

--
-- Name: reports_clicks_geo_rollup_daily_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_geo_rollup_daily_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_geo_rollup_daily_id_seq OWNER TO w4;

--
-- Name: reports_clicks_geo_rollup_daily_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_geo_rollup_daily_id_seq OWNED BY reports_clicks_geo_rollup_daily.id;


--
-- Name: reports_clicks_geo_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_geo_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_geo_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_geo_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_geo_rollup_hourly_id_seq OWNED BY reports_clicks_geo_rollup_hourly.id;


--
-- Name: reports_clicks_rollup_daily; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_rollup_daily (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    doy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_rollup_daily OWNER TO w4;

--
-- Name: reports_clicks_rollup_daily_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_rollup_daily_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_rollup_daily_id_seq OWNER TO w4;

--
-- Name: reports_clicks_rollup_daily_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_rollup_daily_id_seq OWNED BY reports_clicks_rollup_daily.id;


--
-- Name: reports_clicks_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_rollup_hourly_id_seq OWNED BY reports_clicks_rollup_hourly.id;


--
-- Name: reports_clicks_rollup_monthly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_rollup_monthly_id_seq
    START WITH 104034
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_rollup_monthly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_rollup_monthly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_rollup_monthly (
    id bigint DEFAULT nextval('reports_clicks_rollup_monthly_id_seq'::regclass) NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    moy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_rollup_monthly OWNER TO w4;

--
-- Name: reports_clicks_rollup_yearly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_rollup_yearly_id_seq
    START WITH 103781
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_rollup_yearly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_rollup_yearly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_rollup_yearly (
    id bigint DEFAULT nextval('reports_clicks_rollup_yearly_id_seq'::regclass) NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    y integer NOT NULL
);


ALTER TABLE reporting.reports_clicks_rollup_yearly OWNER TO w4;

--
-- Name: reports_clicks_subid_rollup_daily; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_subid_rollup_daily (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    doy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_subid_rollup_daily OWNER TO w4;

--
-- Name: reports_clicks_subid_rollup_daily_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_subid_rollup_daily_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_subid_rollup_daily_id_seq OWNER TO w4;

--
-- Name: reports_clicks_subid_rollup_daily_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_subid_rollup_daily_id_seq OWNED BY reports_clicks_subid_rollup_daily.id;


--
-- Name: reports_clicks_subid_rollup_daily_temp; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_subid_rollup_daily_temp (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    doy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_subid_rollup_daily_temp OWNER TO w4;

--
-- Name: reports_clicks_subid_rollup_daily_temp_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_subid_rollup_daily_temp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_subid_rollup_daily_temp_id_seq OWNER TO w4;

--
-- Name: reports_clicks_subid_rollup_daily_temp_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_subid_rollup_daily_temp_id_seq OWNED BY reports_clicks_subid_rollup_daily_temp.id;


--
-- Name: reports_clicks_subid_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_subid_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_subid_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_subid_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_subid_rollup_hourly_id_seq OWNED BY reports_clicks_subid_rollup_hourly.id;


--
-- Name: reports_clicks_subid_rollup_hourly_temp; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_subid_rollup_hourly_temp (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_subid_rollup_hourly_temp OWNER TO w4;

--
-- Name: reports_clicks_subid_rollup_hourly_temp_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_subid_rollup_hourly_temp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_subid_rollup_hourly_temp_id_seq OWNER TO w4;

--
-- Name: reports_clicks_subid_rollup_hourly_temp_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_subid_rollup_hourly_temp_id_seq OWNED BY reports_clicks_subid_rollup_hourly_temp.id;


--
-- Name: reports_clicks_ua_rollup_hourly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_ua_rollup_hourly (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    browser_name character varying(255),
    platform_name character varying(255),
    hoy bigint NOT NULL
);


ALTER TABLE reporting.reports_clicks_ua_rollup_hourly OWNER TO w4;

--
-- Name: reports_clicks_ua_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_ua_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_ua_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_ua_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_ua_rollup_hourly_id_seq OWNED BY reports_clicks_ua_rollup_hourly.id;


--
-- Name: reports_clicks_wide_rollup_daily; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_wide_rollup_daily (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    browser_name character varying(255),
    platform_name character varying(255),
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    base_uri character varying(255),
    doy bigint NOT NULL,
    creative_id bigint DEFAULT 0
);


ALTER TABLE reporting.reports_clicks_wide_rollup_daily OWNER TO w4;

--
-- Name: reports_clicks_wide_rollup_daily_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_wide_rollup_daily_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_wide_rollup_daily_id_seq OWNER TO w4;

--
-- Name: reports_clicks_wide_rollup_daily_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_wide_rollup_daily_id_seq OWNED BY reports_clicks_wide_rollup_daily.id;


--
-- Name: reports_clicks_wide_rollup_daily_temp; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_wide_rollup_daily_temp (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    browser_name character varying(255),
    platform_name character varying(255),
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    base_uri character varying(255),
    doy bigint NOT NULL,
    creative_id bigint DEFAULT 0
);


ALTER TABLE reporting.reports_clicks_wide_rollup_daily_temp OWNER TO w4;

--
-- Name: reports_clicks_wide_rollup_daily_temp_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_wide_rollup_daily_temp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_wide_rollup_daily_temp_id_seq OWNER TO w4;

--
-- Name: reports_clicks_wide_rollup_daily_temp_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_wide_rollup_daily_temp_id_seq OWNED BY reports_clicks_wide_rollup_daily_temp.id;


--
-- Name: reports_clicks_wide_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_wide_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_wide_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_clicks_wide_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_wide_rollup_hourly_id_seq OWNED BY reports_clicks_wide_rollup_hourly.id;


--
-- Name: reports_clicks_wide_rollup_hourly_temp; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_clicks_wide_rollup_hourly_temp (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_clicks bigint DEFAULT (0)::bigint NOT NULL,
    unique_clicks bigint DEFAULT (0)::bigint NOT NULL,
    browser_name character varying(255),
    platform_name character varying(255),
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    base_uri character varying(255),
    hoy bigint NOT NULL,
    creative_id bigint DEFAULT 0
);


ALTER TABLE reporting.reports_clicks_wide_rollup_hourly_temp OWNER TO w4;

--
-- Name: reports_clicks_wide_rollup_hourly_temp_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_clicks_wide_rollup_hourly_temp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_clicks_wide_rollup_hourly_temp_id_seq OWNER TO w4;

--
-- Name: reports_clicks_wide_rollup_hourly_temp_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_clicks_wide_rollup_hourly_temp_id_seq OWNED BY reports_clicks_wide_rollup_hourly_temp.id;


--
-- Name: reports_conversions_geo_rollup_daily; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_geo_rollup_daily (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    doy bigint NOT NULL
);


ALTER TABLE reporting.reports_conversions_geo_rollup_daily OWNER TO w4;

--
-- Name: reports_conversions_geo_rollup_daily_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_geo_rollup_daily_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_geo_rollup_daily_id_seq OWNER TO w4;

--
-- Name: reports_conversions_geo_rollup_daily_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_conversions_geo_rollup_daily_id_seq OWNED BY reports_conversions_geo_rollup_daily.id;


--
-- Name: reports_conversions_geo_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_geo_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_geo_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_conversions_geo_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_conversions_geo_rollup_hourly_id_seq OWNED BY reports_conversions_geo_rollup_hourly.id;


--
-- Name: reports_conversions_rollup_daily_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_rollup_daily_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_rollup_daily_id_seq OWNER TO w4;

--
-- Name: reports_conversions_rollup_daily_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_conversions_rollup_daily_id_seq OWNED BY reports_conversions_rollup_daily.id;


--
-- Name: reports_conversions_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_conversions_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_conversions_rollup_hourly_id_seq OWNED BY reports_conversions_rollup_hourly.id;


--
-- Name: reports_conversions_rollup_monthly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_rollup_monthly_id_seq
    START WITH 13219
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_rollup_monthly_id_seq OWNER TO w4;

--
-- Name: reports_conversions_rollup_monthly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_rollup_monthly (
    id bigint DEFAULT nextval('reports_conversions_rollup_monthly_id_seq'::regclass) NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    moy bigint NOT NULL
);


ALTER TABLE reporting.reports_conversions_rollup_monthly OWNER TO w4;

--
-- Name: reports_conversions_rollup_yearly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_rollup_yearly_id_seq
    START WITH 13123
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_rollup_yearly_id_seq OWNER TO w4;

--
-- Name: reports_conversions_rollup_yearly; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_rollup_yearly (
    id bigint DEFAULT nextval('reports_conversions_rollup_yearly_id_seq'::regclass) NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    y bigint NOT NULL
);


ALTER TABLE reporting.reports_conversions_rollup_yearly OWNER TO w4;

--
-- Name: reports_conversions_subid_rollup_daily; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_subid_rollup_daily (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    doy bigint NOT NULL
);


ALTER TABLE reporting.reports_conversions_subid_rollup_daily OWNER TO w4;

--
-- Name: reports_conversions_subid_rollup_daily_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_subid_rollup_daily_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_subid_rollup_daily_id_seq OWNER TO w4;

--
-- Name: reports_conversions_subid_rollup_daily_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_conversions_subid_rollup_daily_id_seq OWNED BY reports_conversions_subid_rollup_daily.id;


--
-- Name: reports_conversions_subid_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_subid_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_subid_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_conversions_subid_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_conversions_subid_rollup_hourly_id_seq OWNED BY reports_conversions_subid_rollup_hourly.id;


--
-- Name: reports_conversions_wide_rollup_daily; Type: TABLE; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE TABLE reports_conversions_wide_rollup_daily (
    id bigint NOT NULL,
    publisher_id bigint NOT NULL,
    publisher_pid bigint,
    campaign_id bigint NOT NULL,
    advertiser_id bigint NOT NULL,
    total_conversions bigint DEFAULT (0)::bigint NOT NULL,
    payin_amount money,
    payout_amount money,
    total_pay_in money,
    total_pay_out money,
    profit money,
    browser_name character varying(255),
    platform_name character varying(255),
    country character varying(255),
    region_name character varying(255),
    city_name character varying(255),
    sub_id_1 text,
    sub_id_2 text,
    sub_id_3 text,
    sub_id_4 text,
    base_uri character varying(255),
    doy bigint NOT NULL,
    creative_id bigint DEFAULT 0
);


ALTER TABLE reporting.reports_conversions_wide_rollup_daily OWNER TO w4;

--
-- Name: reports_conversions_wide_rollup_daily_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_wide_rollup_daily_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_wide_rollup_daily_id_seq OWNER TO w4;

--
-- Name: reports_conversions_wide_rollup_daily_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_conversions_wide_rollup_daily_id_seq OWNED BY reports_conversions_wide_rollup_daily.id;


--
-- Name: reports_conversions_wide_rollup_hourly_id_seq; Type: SEQUENCE; Schema: reporting; Owner: w4
--

CREATE SEQUENCE reports_conversions_wide_rollup_hourly_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporting.reports_conversions_wide_rollup_hourly_id_seq OWNER TO w4;

--
-- Name: reports_conversions_wide_rollup_hourly_id_seq; Type: SEQUENCE OWNED BY; Schema: reporting; Owner: w4
--

ALTER SEQUENCE reports_conversions_wide_rollup_hourly_id_seq OWNED BY reports_conversions_wide_rollup_hourly.id;


--
-- Name: reports_geo_hourly; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_geo_hourly AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    ag_and_new.country,
    ag_and_new.region_name,
    ag_and_new.city_name,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.hoy
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    clk_con_roll.country,
                    clk_con_roll.region_name,
                    clk_con_roll.city_name,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    clk_con_roll.hoy
                   FROM (         SELECT reports_clicks_geo_rollup_hourly.publisher_id,
                                    reports_clicks_geo_rollup_hourly.publisher_pid,
                                    reports_clicks_geo_rollup_hourly.campaign_id,
                                    reports_clicks_geo_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_geo_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_geo_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    reports_clicks_geo_rollup_hourly.country,
                                    reports_clicks_geo_rollup_hourly.region_name,
                                    reports_clicks_geo_rollup_hourly.city_name,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    reports_clicks_geo_rollup_hourly.hoy
                                   FROM reports_clicks_geo_rollup_hourly
                                  GROUP BY reports_clicks_geo_rollup_hourly.advertiser_id, reports_clicks_geo_rollup_hourly.publisher_id, reports_clicks_geo_rollup_hourly.publisher_pid, reports_clicks_geo_rollup_hourly.campaign_id, reports_clicks_geo_rollup_hourly.hoy, reports_clicks_geo_rollup_hourly.country, reports_clicks_geo_rollup_hourly.region_name, reports_clicks_geo_rollup_hourly.city_name
                        UNION
                                 SELECT reports_conversions_geo_rollup_hourly.publisher_id,
                                    reports_conversions_geo_rollup_hourly.publisher_pid,
                                    reports_conversions_geo_rollup_hourly.campaign_id,
                                    reports_conversions_geo_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    reports_conversions_geo_rollup_hourly.country,
                                    reports_conversions_geo_rollup_hourly.region_name,
                                    reports_conversions_geo_rollup_hourly.city_name,
                                    (sum(reports_conversions_geo_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_geo_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_geo_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_geo_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_geo_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_geo_rollup_hourly.profit)::numeric) AS profit,
                                    reports_conversions_geo_rollup_hourly.hoy
                                   FROM reports_conversions_geo_rollup_hourly
                                  GROUP BY reports_conversions_geo_rollup_hourly.advertiser_id, reports_conversions_geo_rollup_hourly.publisher_id, reports_conversions_geo_rollup_hourly.publisher_pid, reports_conversions_geo_rollup_hourly.campaign_id, reports_conversions_geo_rollup_hourly.hoy, reports_conversions_geo_rollup_hourly.country, reports_conversions_geo_rollup_hourly.region_name, reports_conversions_geo_rollup_hourly.city_name) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.hoy, clk_con_roll.country, clk_con_roll.region_name, clk_con_roll.city_name
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    clk_and_con.country,
                    clk_and_con.region_name,
                    clk_and_con.city_name,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.hoy
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    engine_clicks_rollup_queue.country,
                                    engine_clicks_rollup_queue.region_name,
                                    engine_clicks_rollup_queue.city AS city_name,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_hoy(engine_clicks_rollup_queue.created_date) AS hoy
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_hoy(engine_clicks_rollup_queue.created_date), engine_clicks_rollup_queue.country, engine_clicks_rollup_queue.region_name, engine_clicks_rollup_queue.city
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    engine_conversions_rollup_queue.country,
                                    engine_conversions_rollup_queue.region_name,
                                    engine_conversions_rollup_queue.city AS city_name,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_hoy(engine_conversions_rollup_queue.created_date) AS hoy
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_hoy(engine_conversions_rollup_queue.created_date), engine_conversions_rollup_queue.country, engine_conversions_rollup_queue.region_name, engine_conversions_rollup_queue.city) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.hoy, clk_and_con.country, clk_and_con.region_name, clk_and_con.city_name) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.hoy, ag_and_new.country, ag_and_new.region_name, ag_and_new.city_name;


ALTER TABLE reporting.reports_geo_hourly OWNER TO w4;

--
-- Name: reports_monthly; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_monthly AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.moy
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    (clk_con_roll.moy)::bigint AS moy
                   FROM (         SELECT reports_clicks_rollup_hourly.publisher_id,
                                    reports_clicks_rollup_hourly.publisher_pid,
                                    reports_clicks_rollup_hourly.campaign_id,
                                    reports_clicks_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    ("substring"((reports_clicks_rollup_hourly.hoy)::text, 1, 6))::integer AS moy
                                   FROM reports_clicks_rollup_hourly
                                  GROUP BY reports_clicks_rollup_hourly.advertiser_id, reports_clicks_rollup_hourly.publisher_id, reports_clicks_rollup_hourly.publisher_pid, reports_clicks_rollup_hourly.campaign_id, "substring"((reports_clicks_rollup_hourly.hoy)::text, 1, 6)
                        UNION
                                 SELECT reports_conversions_rollup_hourly.publisher_id,
                                    reports_conversions_rollup_hourly.publisher_pid,
                                    reports_conversions_rollup_hourly.campaign_id,
                                    reports_conversions_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    (sum(reports_conversions_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_rollup_hourly.profit)::numeric) AS profit,
                                    ("substring"((reports_conversions_rollup_hourly.hoy)::text, 1, 6))::integer AS moy
                                   FROM reports_conversions_rollup_hourly
                                  GROUP BY reports_conversions_rollup_hourly.advertiser_id, reports_conversions_rollup_hourly.publisher_id, reports_conversions_rollup_hourly.publisher_pid, reports_conversions_rollup_hourly.campaign_id, "substring"((reports_conversions_rollup_hourly.hoy)::text, 1, 6)) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.moy
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.moy
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_moy(engine_clicks_rollup_queue.created_date) AS moy
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_moy(engine_clicks_rollup_queue.created_date)
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_moy(engine_conversions_rollup_queue.created_date) AS moy
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_moy(engine_conversions_rollup_queue.created_date)) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.moy) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.moy;


ALTER TABLE reporting.reports_monthly OWNER TO w4;

--
-- Name: reports_subid_hourly; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_subid_hourly AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    ag_and_new.sub_id_1,
    NULL::text AS sub_id_2,
    NULL::text AS sub_id_3,
    NULL::text AS sub_id_4,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.hoy
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    clk_con_roll.sub_id_1,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    clk_con_roll.hoy
                   FROM (         SELECT reports_clicks_subid_rollup_hourly.publisher_id,
                                    reports_clicks_subid_rollup_hourly.publisher_pid,
                                    reports_clicks_subid_rollup_hourly.campaign_id,
                                    reports_clicks_subid_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_subid_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_subid_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    reports_clicks_subid_rollup_hourly.sub_id_1,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    reports_clicks_subid_rollup_hourly.hoy
                                   FROM reports_clicks_subid_rollup_hourly
                                  GROUP BY reports_clicks_subid_rollup_hourly.advertiser_id, reports_clicks_subid_rollup_hourly.publisher_id, reports_clicks_subid_rollup_hourly.publisher_pid, reports_clicks_subid_rollup_hourly.campaign_id, reports_clicks_subid_rollup_hourly.hoy, reports_clicks_subid_rollup_hourly.sub_id_1
                        UNION
                                 SELECT reports_conversions_subid_rollup_hourly.publisher_id,
                                    reports_conversions_subid_rollup_hourly.publisher_pid,
                                    reports_conversions_subid_rollup_hourly.campaign_id,
                                    reports_conversions_subid_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    reports_conversions_subid_rollup_hourly.sub_id_1,
                                    (sum(reports_conversions_subid_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_subid_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_subid_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_subid_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_subid_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_subid_rollup_hourly.profit)::numeric) AS profit,
                                    reports_conversions_subid_rollup_hourly.hoy
                                   FROM reports_conversions_subid_rollup_hourly
                                  GROUP BY reports_conversions_subid_rollup_hourly.advertiser_id, reports_conversions_subid_rollup_hourly.publisher_id, reports_conversions_subid_rollup_hourly.publisher_pid, reports_conversions_subid_rollup_hourly.campaign_id, reports_conversions_subid_rollup_hourly.hoy, reports_conversions_subid_rollup_hourly.sub_id_1) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.hoy, clk_con_roll.sub_id_1
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    clk_and_con.sub_id_1,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.hoy
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    engine_clicks_rollup_queue.sub_id_1,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_hoy(engine_clicks_rollup_queue.created_date) AS hoy
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_hoy(engine_clicks_rollup_queue.created_date), engine_clicks_rollup_queue.sub_id_1
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    engine_conversions_rollup_queue.sub_id_1,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_hoy(engine_conversions_rollup_queue.created_date) AS hoy
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_hoy(engine_conversions_rollup_queue.created_date), engine_conversions_rollup_queue.sub_id_1) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.hoy, clk_and_con.sub_id_1) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.hoy, ag_and_new.sub_id_1, NULL::text, NULL::text, NULL::text;


ALTER TABLE reporting.reports_subid_hourly OWNER TO w4;

--
-- Name: reports_wide_hourly; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_wide_hourly AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    NULL::character varying(255) AS country,
    NULL::character varying(255) AS region_name,
    NULL::character varying(255) AS city_name,
    NULL::character varying(255) AS browser_name,
    NULL::character varying(255) AS platform_name,
    NULL::text AS sub_id_1,
    NULL::text AS sub_id_2,
    NULL::text AS sub_id_3,
    NULL::text AS sub_id_4,
    NULL::character varying(255) AS base_uri,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.hoy,
    ag_and_new.creative_id
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    clk_con_roll.hoy,
                    clk_con_roll.creative_id
                   FROM (         SELECT reports_clicks_wide_rollup_hourly.publisher_id,
                                    reports_clicks_wide_rollup_hourly.publisher_pid,
                                    reports_clicks_wide_rollup_hourly.campaign_id,
                                    reports_clicks_wide_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_wide_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_wide_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    reports_clicks_wide_rollup_hourly.hoy,
                                    reports_clicks_wide_rollup_hourly.creative_id
                                   FROM reports_clicks_wide_rollup_hourly
                                  GROUP BY reports_clicks_wide_rollup_hourly.advertiser_id, reports_clicks_wide_rollup_hourly.publisher_id, reports_clicks_wide_rollup_hourly.publisher_pid, reports_clicks_wide_rollup_hourly.campaign_id, reports_clicks_wide_rollup_hourly.hoy, reports_clicks_wide_rollup_hourly.creative_id
                        UNION
                                 SELECT reports_conversions_wide_rollup_hourly.publisher_id,
                                    reports_conversions_wide_rollup_hourly.publisher_pid,
                                    reports_conversions_wide_rollup_hourly.campaign_id,
                                    reports_conversions_wide_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    (sum(reports_conversions_wide_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_wide_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_wide_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_wide_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_wide_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_wide_rollup_hourly.profit)::numeric) AS profit,
                                    reports_conversions_wide_rollup_hourly.hoy,
                                    reports_conversions_wide_rollup_hourly.creative_id
                                   FROM reports_conversions_wide_rollup_hourly
                                  GROUP BY reports_conversions_wide_rollup_hourly.advertiser_id, reports_conversions_wide_rollup_hourly.publisher_id, reports_conversions_wide_rollup_hourly.publisher_pid, reports_conversions_wide_rollup_hourly.campaign_id, reports_conversions_wide_rollup_hourly.hoy, reports_conversions_wide_rollup_hourly.creative_id) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.hoy, clk_con_roll.creative_id
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.hoy,
                    clk_and_con.creative_id
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_hoy(engine_clicks_rollup_queue.created_date) AS hoy,
                                    engine_clicks_rollup_queue.creative_id
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_hoy(engine_clicks_rollup_queue.created_date), engine_clicks_rollup_queue.creative_id
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_hoy(engine_conversions_rollup_queue.created_date) AS hoy,
                                    engine_conversions_rollup_queue.creative_id
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_hoy(engine_conversions_rollup_queue.created_date), engine_conversions_rollup_queue.creative_id) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.hoy, clk_and_con.creative_id) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.hoy, NULL::character varying(255), NULL::text, ag_and_new.creative_id;


ALTER TABLE reporting.reports_wide_hourly OWNER TO w4;

--
-- Name: reports_yearly; Type: VIEW; Schema: reporting; Owner: w4
--

CREATE VIEW reports_yearly AS
 SELECT ag_and_new.publisher_id,
    ag_and_new.publisher_pid,
    ag_and_new.campaign_id,
    ag_and_new.advertiser_id,
    (sum(ag_and_new.total_clicks))::bigint AS total_clicks,
    (sum(ag_and_new.unique_clicks))::bigint AS unique_clicks,
    (sum(ag_and_new.total_conversions))::bigint AS total_conversions,
    avg(ag_and_new.pay_in_amount) AS pay_in_amount,
    avg(ag_and_new.pay_out_amount) AS pay_out_amount,
    sum(ag_and_new.total_pay_in) AS total_pay_in,
    sum(ag_and_new.total_pay_out) AS total_pay_out,
    sum(ag_and_new.profit) AS profit,
    ag_and_new.y
   FROM (         SELECT clk_con_roll.publisher_id,
                    clk_con_roll.publisher_pid,
                    clk_con_roll.campaign_id,
                    clk_con_roll.advertiser_id,
                    (sum(clk_con_roll.total_clicks))::bigint AS total_clicks,
                    (sum(clk_con_roll.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_con_roll.total_conversions))::bigint AS total_conversions,
                    avg(clk_con_roll.pay_in_amount) AS pay_in_amount,
                    avg(clk_con_roll.pay_out_amount) AS pay_out_amount,
                    sum(clk_con_roll.total_pay_in) AS total_pay_in,
                    sum(clk_con_roll.total_pay_out) AS total_pay_out,
                    sum(clk_con_roll.profit) AS profit,
                    (clk_con_roll.y)::bigint AS y
                   FROM (         SELECT reports_clicks_rollup_hourly.publisher_id,
                                    reports_clicks_rollup_hourly.publisher_pid,
                                    reports_clicks_rollup_hourly.campaign_id,
                                    reports_clicks_rollup_hourly.advertiser_id,
                                    (sum(reports_clicks_rollup_hourly.total_clicks))::bigint AS total_clicks,
                                    (sum(reports_clicks_rollup_hourly.unique_clicks))::bigint AS unique_clicks,
                                    0 AS total_conversions,
                                    0 AS pay_in_amount,
                                    0 AS pay_out_amount,
                                    0 AS total_pay_in,
                                    0 AS total_pay_out,
                                    0 AS profit,
                                    ("substring"((reports_clicks_rollup_hourly.hoy)::text, 1, 4))::integer AS y
                                   FROM reports_clicks_rollup_hourly
                                  GROUP BY reports_clicks_rollup_hourly.advertiser_id, reports_clicks_rollup_hourly.publisher_id, reports_clicks_rollup_hourly.publisher_pid, reports_clicks_rollup_hourly.campaign_id, "substring"((reports_clicks_rollup_hourly.hoy)::text, 1, 4)
                        UNION
                                 SELECT reports_conversions_rollup_hourly.publisher_id,
                                    reports_conversions_rollup_hourly.publisher_pid,
                                    reports_conversions_rollup_hourly.campaign_id,
                                    reports_conversions_rollup_hourly.advertiser_id,
                                    (0)::bigint AS total_clicks,
                                    (0)::bigint AS unique_clicks,
                                    (sum(reports_conversions_rollup_hourly.total_conversions))::bigint AS total_conversions,
                                    avg((reports_conversions_rollup_hourly.payin_amount)::numeric) AS pay_in_amount,
                                    avg((reports_conversions_rollup_hourly.payout_amount)::numeric) AS pay_out_amount,
                                    sum((reports_conversions_rollup_hourly.total_pay_in)::numeric) AS total_pay_in,
                                    sum((reports_conversions_rollup_hourly.total_pay_out)::numeric) AS total_pay_out,
                                    sum((reports_conversions_rollup_hourly.profit)::numeric) AS profit,
                                    ("substring"((reports_conversions_rollup_hourly.hoy)::text, 1, 4))::integer AS y
                                   FROM reports_conversions_rollup_hourly
                                  GROUP BY reports_conversions_rollup_hourly.advertiser_id, reports_conversions_rollup_hourly.publisher_id, reports_conversions_rollup_hourly.publisher_pid, reports_conversions_rollup_hourly.campaign_id, "substring"((reports_conversions_rollup_hourly.hoy)::text, 1, 4)) clk_con_roll
                  GROUP BY clk_con_roll.advertiser_id, clk_con_roll.publisher_id, clk_con_roll.publisher_pid, clk_con_roll.campaign_id, clk_con_roll.y
        UNION
                 SELECT clk_and_con.publisher_id,
                    clk_and_con.publisher_pid,
                    clk_and_con.campaign_id,
                    clk_and_con.advertiser_id,
                    (sum(clk_and_con.total_clicks))::bigint AS total_clicks,
                    (sum(clk_and_con.unique_clicks))::bigint AS unique_clicks,
                    (sum(clk_and_con.total_conversions))::bigint AS total_conversions,
                    avg(clk_and_con.pay_in_amount) AS pay_in_amount,
                    avg(clk_and_con.pay_out_amount) AS pay_out_amount,
                    sum(clk_and_con.total_pay_in) AS total_pay_in,
                    sum(clk_and_con.total_pay_out) AS total_pay_out,
                    sum(clk_and_con.profit) AS profit,
                    clk_and_con.y
                   FROM (         SELECT engine_clicks_rollup_queue.publisher_id,
                                    engine_clicks_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_clicks_rollup_queue.campaign_id,
                                    engine_clicks_rollup_queue.advertiser_id,
                                    sum((engine_clicks_rollup_queue.nb_dupes + 1)) AS total_clicks,
                                    sum(
                                        CASE
                                            WHEN engine_clicks_rollup_queue.unique_click THEN 1
                                            ELSE 0
                                        END) AS unique_clicks,
                                    NULL::bigint AS total_conversions,
                                    NULL::numeric AS pay_in_amount,
                                    NULL::numeric AS pay_out_amount,
                                    NULL::numeric AS total_pay_in,
                                    NULL::numeric AS total_pay_out,
                                    NULL::numeric AS profit,
                                    public.make_y(engine_clicks_rollup_queue.created_date) AS y
                                   FROM public.engine_clicks_rollup_queue
                                  GROUP BY engine_clicks_rollup_queue.advertiser_id, engine_clicks_rollup_queue.publisher_id, engine_clicks_rollup_queue.parent_publisher_id, engine_clicks_rollup_queue.campaign_id, public.make_y(engine_clicks_rollup_queue.created_date)
                        UNION
                                 SELECT engine_conversions_rollup_queue.publisher_id,
                                    engine_conversions_rollup_queue.parent_publisher_id AS publisher_pid,
                                    engine_conversions_rollup_queue.campaign_id,
                                    engine_conversions_rollup_queue.advertiser_id,
                                    NULL::bigint AS total_clicks,
                                    NULL::bigint AS unique_clicks,
                                    count(engine_conversions_rollup_queue.campaign_id) AS total_conversions,
                                    avg((engine_conversions_rollup_queue.payin)::numeric) AS pay_in_amount,
                                    avg((engine_conversions_rollup_queue.payout)::numeric) AS pay_out_amount,
                                    sum((engine_conversions_rollup_queue.payin)::numeric) AS total_pay_in,
                                    sum((engine_conversions_rollup_queue.payout)::numeric) AS total_pay_out,
                                    (sum((engine_conversions_rollup_queue.payin)::numeric) - sum((engine_conversions_rollup_queue.payout)::numeric)) AS profit,
                                    public.make_y(engine_conversions_rollup_queue.created_date) AS y
                                   FROM public.engine_conversions_rollup_queue
                                  GROUP BY engine_conversions_rollup_queue.advertiser_id, engine_conversions_rollup_queue.publisher_id, engine_conversions_rollup_queue.parent_publisher_id, engine_conversions_rollup_queue.campaign_id, public.make_y(engine_conversions_rollup_queue.created_date)) clk_and_con
                  GROUP BY clk_and_con.advertiser_id, clk_and_con.publisher_id, clk_and_con.publisher_pid, clk_and_con.campaign_id, clk_and_con.y) ag_and_new
  GROUP BY ag_and_new.advertiser_id, ag_and_new.publisher_id, ag_and_new.publisher_pid, ag_and_new.campaign_id, ag_and_new.y;


ALTER TABLE reporting.reports_yearly OWNER TO w4;

SET search_path = topology, pg_catalog;

--
-- Name: layer; Type: TABLE; Schema: topology; Owner: w4; Tablespace: 
--

CREATE TABLE layer (
    topology_id integer NOT NULL,
    layer_id integer NOT NULL,
    schema_name character varying NOT NULL,
    table_name character varying NOT NULL,
    feature_column character varying NOT NULL,
    feature_type integer NOT NULL,
    level integer DEFAULT 0 NOT NULL,
    child_id integer
);


ALTER TABLE topology.layer OWNER TO w4;

--
-- Name: topology; Type: TABLE; Schema: topology; Owner: w4; Tablespace: 
--

CREATE TABLE topology (
    id integer NOT NULL,
    name character varying NOT NULL,
    srid integer NOT NULL,
    "precision" double precision NOT NULL,
    hasz boolean DEFAULT false NOT NULL
);


ALTER TABLE topology.topology OWNER TO w4;

--
-- Name: topology_id_seq; Type: SEQUENCE; Schema: topology; Owner: w4
--

CREATE SEQUENCE topology_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE topology.topology_id_seq OWNER TO w4;

--
-- Name: topology_id_seq; Type: SEQUENCE OWNED BY; Schema: topology; Owner: w4
--

ALTER SEQUENCE topology_id_seq OWNED BY topology.id;


SET search_path = "ACL", pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: ACL; Owner: w4
--

ALTER TABLE ONLY acl_group_management ALTER COLUMN id SET DEFAULT nextval('acl_group_management_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: ACL; Owner: w4
--

ALTER TABLE ONLY acl_groups ALTER COLUMN id SET DEFAULT nextval('acl_groups_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: ACL; Owner: w4
--

ALTER TABLE ONLY acl_resources ALTER COLUMN id SET DEFAULT nextval('acl_resources_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: ACL; Owner: w4
--

ALTER TABLE ONLY controller_group_privileges ALTER COLUMN id SET DEFAULT nextval('controller_group_privileges_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: ACL; Owner: w4
--

ALTER TABLE ONLY file_group_privileges ALTER COLUMN id SET DEFAULT nextval('file_group_privileges_id_seq'::regclass);


SET search_path = "Accounting", pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: Accounting; Owner: w4
--

ALTER TABLE ONLY acct_invoices_publisher ALTER COLUMN id SET DEFAULT nextval('acct_invoices_publisher_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: Accounting; Owner: w4
--

ALTER TABLE ONLY acct_invoices_publisher_adjustments ALTER COLUMN id SET DEFAULT nextval('acct_invoices_publisher_adjustments_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: Accounting; Owner: w4
--

ALTER TABLE ONLY acct_invoices_publisher_line_items ALTER COLUMN id SET DEFAULT nextval('acct_invoices_publisher_line_items_id_seq'::regclass);


SET search_path = ftp, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: ftp; Owner: w4
--

ALTER TABLE ONLY "user" ALTER COLUMN id SET DEFAULT nextval('user_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: ftp; Owner: w4
--

ALTER TABLE ONLY user_salt ALTER COLUMN id SET DEFAULT nextval('user_salt_id_seq'::regclass);


SET search_path = public, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY admin_alert_settings ALTER COLUMN id SET DEFAULT nextval('admin_alert_settings_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY admin_pubs_terms ALTER COLUMN id SET DEFAULT nextval('admin_pubs_terms_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY advertiser_banned_publishers ALTER COLUMN id SET DEFAULT nextval('advertiser_banned_publishers_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY advertiser_banned_sub_publishers ALTER COLUMN id SET DEFAULT nextval('advertiser_banned_sub_publishers_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY advertiser_contacts ALTER COLUMN id SET DEFAULT nextval('advertiser_contacts_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY advertiser_payment_terms ALTER COLUMN id SET DEFAULT nextval('advertiser_payment_terms_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY advertiser_uploads ALTER COLUMN id SET DEFAULT nextval('advertiser_uploads_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY advertisers ALTER COLUMN id SET DEFAULT nextval('advertisers_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY assets ALTER COLUMN id SET DEFAULT nextval('assets_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY audit_log ALTER COLUMN id SET DEFAULT nextval('audit_log_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY audit_log_types ALTER COLUMN id SET DEFAULT nextval('audit_log_types_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY cache_invalidation ALTER COLUMN id SET DEFAULT nextval('cache_invalidation_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_banned_sub_publishers ALTER COLUMN id SET DEFAULT nextval('campaign_banned_sub_publishers_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_caps ALTER COLUMN id SET DEFAULT nextval('campaign_caps_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_conversion_aliases ALTER COLUMN id SET DEFAULT nextval('campaign_conversion_aliases_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_geotargeting ALTER COLUMN id SET DEFAULT nextval('campaign_geotargeting_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_group_items ALTER COLUMN id SET DEFAULT nextval('campaign_group_items_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_groups ALTER COLUMN id SET DEFAULT nextval('campaign_groups_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_payout_changes ALTER COLUMN id SET DEFAULT nextval('campaign_payout_changes_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_piggyback_pixels ALTER COLUMN id SET DEFAULT nextval('campaign_piggyback_pixels_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_pixels_legacy ALTER COLUMN id SET DEFAULT nextval('campaign_pixels_legacy_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_suppression_lists ALTER COLUMN id SET DEFAULT nextval('campaign_suppression_lists_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaign_tracking_type_lookup ALTER COLUMN id SET DEFAULT nextval('campaign_tracking_type_lookup_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY campaigns ALTER COLUMN id SET DEFAULT nextval('campaigns_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY categories ALTER COLUMN id SET DEFAULT nextval('categories_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY channels ALTER COLUMN id SET DEFAULT nextval('channels_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY cities ALTER COLUMN id SET DEFAULT nextval('cities_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY click_geo ALTER COLUMN id SET DEFAULT nextval('click_geo_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY click_user_agent ALTER COLUMN id SET DEFAULT nextval('click_user_agent_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY clicks ALTER COLUMN id SET DEFAULT nextval('clicks_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY cmpl_alert_template ALTER COLUMN id SET DEFAULT nextval('cmpl_alert_template_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY cmpl_downloaded ALTER COLUMN id SET DEFAULT nextval('cmpl_downloaded_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY cmpl_email_template ALTER COLUMN id SET DEFAULT nextval('cmpl_email_template_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY cmpl_exceptions ALTER COLUMN id SET DEFAULT nextval('cmpl_exceptions_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY cmpl_notifications ALTER COLUMN id SET DEFAULT nextval('cmpl_notifications_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY cmpl_suppression_file ALTER COLUMN id SET DEFAULT nextval('cmpl_suppression_file_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY code_locations ALTER COLUMN id SET DEFAULT nextval('code_locations_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY contact_type_lookup ALTER COLUMN id SET DEFAULT nextval('contact_type_lookup_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY contacts ALTER COLUMN id SET DEFAULT nextval('contacts_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY conversion_geo ALTER COLUMN id SET DEFAULT nextval('conversion_geo_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY countries ALTER COLUMN id SET DEFAULT nextval('countries_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY creative_banners ALTER COLUMN id SET DEFAULT nextval('creative_banners_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY creative_email_images ALTER COLUMN id SET DEFAULT nextval('creative_email_images_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY creative_email_links ALTER COLUMN id SET DEFAULT nextval('creative_email_links_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY creative_emails ALTER COLUMN id SET DEFAULT nextval('creative_emails_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY creative_swfs ALTER COLUMN id SET DEFAULT nextval('creative_swfs_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY creatives ALTER COLUMN id SET DEFAULT nextval('creatives_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY dashboard_messages ALTER COLUMN id SET DEFAULT nextval('dashboard_messages_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY data_anomaly_log ALTER COLUMN id SET DEFAULT nextval('data_anomaly_log_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY email_batches ALTER COLUMN id SET DEFAULT nextval('email_batches_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY email_from_lines ALTER COLUMN id SET DEFAULT nextval('email_from_lines_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY email_queue ALTER COLUMN id SET DEFAULT nextval('email_queue_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY email_subject_lines ALTER COLUMN id SET DEFAULT nextval('email_subject_lines_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_audit_log ALTER COLUMN id SET DEFAULT nextval('engine_audit_log_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_click_tests ALTER COLUMN id SET DEFAULT nextval('engine_click_tests_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_clicks ALTER COLUMN id SET DEFAULT nextval('engine_clicks_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_clicks_calls ALTER COLUMN id SET DEFAULT nextval('engine_clicks_calls_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_clicks_calls_success ALTER COLUMN id SET DEFAULT nextval('engine_clicks_calls_success_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_clicks_dupes ALTER COLUMN id SET DEFAULT nextval('engine_clicks_dupes_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_clicks_rollup ALTER COLUMN id SET DEFAULT nextval('engine_clicks_rollup_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_clicks_rollup_queue ALTER COLUMN id SET DEFAULT nextval('engine_clicks_rollup_queue_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_clicks_tmp ALTER COLUMN id SET DEFAULT nextval('engine_clicks_tmp_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_consumers ALTER COLUMN id SET DEFAULT nextval('engine_consumers_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions ALTER COLUMN id SET DEFAULT nextval('engine_conversions_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions_calls ALTER COLUMN id SET DEFAULT nextval('engine_conversions_calls_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions_calls_success ALTER COLUMN id SET DEFAULT nextval('engine_conversions_calls_success_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions_manual ALTER COLUMN id SET DEFAULT nextval('engine_conversions_manual_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions_rollup ALTER COLUMN id SET DEFAULT nextval('engine_conversions_rollup_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions_rollup_queue ALTER COLUMN id SET DEFAULT nextval('engine_conversions_rollup_queue_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions_staging ALTER COLUMN id SET DEFAULT nextval('engine_conversions_staging_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions_tmp ALTER COLUMN id SET DEFAULT nextval('engine_conversions_tmp_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions_waiting ALTER COLUMN id SET DEFAULT nextval('engine_conversions_waiting_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_error_log ALTER COLUMN id SET DEFAULT nextval('engine_error_log_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_pixel_tests ALTER COLUMN id SET DEFAULT nextval('engine_pixel_tests_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_redirect_decisions ALTER COLUMN id SET DEFAULT nextval('engine_redirect_decisions_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_tests ALTER COLUMN id SET DEFAULT nextval('engine_tests_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY files ALTER COLUMN id SET DEFAULT nextval('files_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY gearman_jobs ALTER COLUMN id SET DEFAULT nextval('gearman_jobs_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY geo_target_cities ALTER COLUMN id SET DEFAULT nextval('geo_target_cities_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY geo_target_countries ALTER COLUMN id SET DEFAULT nextval('geo_target_countries_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY geo_target_region ALTER COLUMN id SET DEFAULT nextval('geo_target_region_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY geo_typeahead_countries ALTER COLUMN id SET DEFAULT nextval('geo_typeahead_countries_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY geo_typeahead_region ALTER COLUMN id SET DEFAULT nextval('geo_typeahead_region_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY global_settings ALTER COLUMN id SET DEFAULT nextval('global_settings_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY hosted_creative_assets ALTER COLUMN id SET DEFAULT nextval('hosted_creative_assets_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY im_types ALTER COLUMN id SET DEFAULT nextval('im_types_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY image_url_batches ALTER COLUMN id SET DEFAULT nextval('image_url_batches_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY image_url_queue ALTER COLUMN id SET DEFAULT nextval('image_url_queue_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY message_delivery_setting_types ALTER COLUMN id SET DEFAULT nextval('message_delivery_setting_types_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY message_delivery_settings ALTER COLUMN id SET DEFAULT nextval('message_delivery_settings_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY message_delivery_types ALTER COLUMN id SET DEFAULT nextval('message_delivery_types_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY message_status ALTER COLUMN id SET DEFAULT nextval('message_status_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY message_types ALTER COLUMN id SET DEFAULT nextval('message_types_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY messages ALTER COLUMN id SET DEFAULT nextval('messages_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_account_changes ALTER COLUMN id SET DEFAULT nextval('publisher_account_changes_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_account_changes_import ALTER COLUMN id SET DEFAULT nextval('publisher_account_changes_import_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_blocked_subids_import ALTER COLUMN id SET DEFAULT nextval('publisher_blocked_subids_import_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_campaign_recommendations ALTER COLUMN id SET DEFAULT nextval('publisher_campaign_recommendations_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_campaign_searches ALTER COLUMN id SET DEFAULT nextval('publisher_campaign_searches_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_change_requests ALTER COLUMN id SET DEFAULT nextval('publisher_change_requests_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_contact ALTER COLUMN id SET DEFAULT nextval('publisher_contact_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_groups ALTER COLUMN id SET DEFAULT nextval('publisher_groups_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_interface_settings ALTER COLUMN id SET DEFAULT nextval('publisher_interface_settings_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_notes ALTER COLUMN id SET DEFAULT nextval('publisher_notes_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_overrides ALTER COLUMN id SET DEFAULT nextval('publisher_overrides_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_signup ALTER COLUMN id SET DEFAULT nextval('publisher_signup_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_support_contact ALTER COLUMN id SET DEFAULT nextval('publisher_support_contact_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_suppression_internal_requests ALTER COLUMN id SET DEFAULT nextval('publisher_suppression_internal_requests_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_suppression_optizmo_requests ALTER COLUMN id SET DEFAULT nextval('publisher_suppression_optizmo_requests_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_tiers ALTER COLUMN id SET DEFAULT nextval('publisher_tiers_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY publisher_uploads ALTER COLUMN id SET DEFAULT nextval('publisher_uploads_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY regions ALTER COLUMN id SET DEFAULT nextval('regions_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY reports_clicks ALTER COLUMN id SET DEFAULT nextval('reports_clicks_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY rewards_program ALTER COLUMN id SET DEFAULT nextval('rewards_program_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY rewards_types ALTER COLUMN id SET DEFAULT nextval('rewards_types_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY screenshot_batches ALTER COLUMN id SET DEFAULT nextval('screenshot_batches_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY screenshot_queue ALTER COLUMN id SET DEFAULT nextval('screenshot_queue_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY suppression_lists ALTER COLUMN id SET DEFAULT nextval('suppression_lists_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY suppression_unsubscribe_batches ALTER COLUMN id SET DEFAULT nextval('suppression_unsubscribe_batches_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY suppression_unsubscribe_files ALTER COLUMN id SET DEFAULT nextval('suppression_unsubscribe_files_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY suppression_unsubscribe_queue ALTER COLUMN id SET DEFAULT nextval('suppression_unsubscribe_queue_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY suppression_upload_batches ALTER COLUMN id SET DEFAULT nextval('suppression_upload_batches_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY suppression_upload_files ALTER COLUMN id SET DEFAULT nextval('suppression_upload_files_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY tracking_domains ALTER COLUMN id SET DEFAULT nextval('tracking_domains_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_access_logs ALTER COLUMN id SET DEFAULT nextval('user_access_logs_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_agent_browser_lookup ALTER COLUMN id SET DEFAULT nextval('user_agent_browser_lookup_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_agent_feature ALTER COLUMN id SET DEFAULT nextval('user_agent_feature_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_agent_platform_lookup ALTER COLUMN id SET DEFAULT nextval('user_agent_platform_lookup_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_impersonation ALTER COLUMN id SET DEFAULT nextval('user_impersonation_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_profiles ALTER COLUMN id SET DEFAULT nextval('user_profiles_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_tokens ALTER COLUMN id SET DEFAULT nextval('user_tokens_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: w4
--

ALTER TABLE ONLY users ALTER COLUMN id SET DEFAULT nextval('users_id_seq'::regclass);


SET search_path = reporting, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY heatmap_data_by_campaign_id ALTER COLUMN id SET DEFAULT nextval('heatmap_data_by_campaign_id_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY heatmap_data_by_publisher_id ALTER COLUMN id SET DEFAULT nextval('heatmap_data_by_publisher_id_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_geo_country_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_clicks_geo_country_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_geo_region_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_clicks_geo_region_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_geo_rollup_daily ALTER COLUMN id SET DEFAULT nextval('reports_clicks_geo_rollup_daily_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_geo_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_clicks_geo_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_rollup_daily ALTER COLUMN id SET DEFAULT nextval('reports_clicks_rollup_daily_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_clicks_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_subid_rollup_daily ALTER COLUMN id SET DEFAULT nextval('reports_clicks_subid_rollup_daily_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_subid_rollup_daily_temp ALTER COLUMN id SET DEFAULT nextval('reports_clicks_subid_rollup_daily_temp_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_subid_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_clicks_subid_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_subid_rollup_hourly_temp ALTER COLUMN id SET DEFAULT nextval('reports_clicks_subid_rollup_hourly_temp_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_ua_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_clicks_ua_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_wide_rollup_daily ALTER COLUMN id SET DEFAULT nextval('reports_clicks_wide_rollup_daily_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_wide_rollup_daily_temp ALTER COLUMN id SET DEFAULT nextval('reports_clicks_wide_rollup_daily_temp_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_wide_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_clicks_wide_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_clicks_wide_rollup_hourly_temp ALTER COLUMN id SET DEFAULT nextval('reports_clicks_wide_rollup_hourly_temp_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_conversions_geo_rollup_daily ALTER COLUMN id SET DEFAULT nextval('reports_conversions_geo_rollup_daily_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_conversions_geo_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_conversions_geo_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_conversions_rollup_daily ALTER COLUMN id SET DEFAULT nextval('reports_conversions_rollup_daily_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_conversions_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_conversions_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_conversions_subid_rollup_daily ALTER COLUMN id SET DEFAULT nextval('reports_conversions_subid_rollup_daily_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_conversions_subid_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_conversions_subid_rollup_hourly_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_conversions_wide_rollup_daily ALTER COLUMN id SET DEFAULT nextval('reports_conversions_wide_rollup_daily_id_seq'::regclass);


--
-- Name: id; Type: DEFAULT; Schema: reporting; Owner: w4
--

ALTER TABLE ONLY reports_conversions_wide_rollup_hourly ALTER COLUMN id SET DEFAULT nextval('reports_conversions_wide_rollup_hourly_id_seq'::regclass);


SET search_path = topology, pg_catalog;

--
-- Name: id; Type: DEFAULT; Schema: topology; Owner: w4
--

ALTER TABLE ONLY topology ALTER COLUMN id SET DEFAULT nextval('topology_id_seq'::regclass);


SET search_path = "ACL", pg_catalog;

--
-- Name: acl_group_management_pkey; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acl_group_management
    ADD CONSTRAINT acl_group_management_pkey PRIMARY KEY (id);


--
-- Name: acl_group_privileges_pkey; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acl_group_privileges
    ADD CONSTRAINT acl_group_privileges_pkey PRIMARY KEY (group_id, resource_id);


--
-- Name: acl_groups_pkey; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acl_groups
    ADD CONSTRAINT acl_groups_pkey PRIMARY KEY (id);


--
-- Name: acl_resources_pkey; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acl_resources
    ADD CONSTRAINT acl_resources_pkey PRIMARY KEY (id);


--
-- Name: acl_resources_resource_key; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acl_resources
    ADD CONSTRAINT acl_resources_resource_key UNIQUE (resource);


--
-- Name: acl_user_groups_pkey; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acl_user_groups
    ADD CONSTRAINT acl_user_groups_pkey PRIMARY KEY (user_id, group_id);


--
-- Name: acl_user_privileges_pkey; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acl_user_privileges
    ADD CONSTRAINT acl_user_privileges_pkey PRIMARY KEY (resource_id, user_id);


--
-- Name: controller_resources_name_action_key; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY controller_resources
    ADD CONSTRAINT controller_resources_name_action_key UNIQUE (name, action);


--
-- Name: file_group_privileges_group_resorce_key; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY file_group_privileges
    ADD CONSTRAINT file_group_privileges_group_resorce_key UNIQUE (group_id, resource_id);


--
-- Name: file_resources_name_crud_key; Type: CONSTRAINT; Schema: ACL; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY file_resources
    ADD CONSTRAINT file_resources_name_crud_key UNIQUE (name, crud);


SET search_path = "Accounting", pg_catalog;

--
-- Name: acct_conversion_ledger_pkey; Type: CONSTRAINT; Schema: Accounting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acct_conversion_ledger
    ADD CONSTRAINT acct_conversion_ledger_pkey PRIMARY KEY (id);


--
-- Name: invoice_adjustments_pkey; Type: CONSTRAINT; Schema: Accounting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY acct_invoices_publisher_adjustments
    ADD CONSTRAINT invoice_adjustments_pkey PRIMARY KEY (id);


SET search_path = ftp, pg_catalog;

--
-- Name: user_advertiser_id_key; Type: CONSTRAINT; Schema: ftp; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY "user"
    ADD CONSTRAINT user_advertiser_id_key UNIQUE (advertiser_id);


--
-- Name: user_folder_key; Type: CONSTRAINT; Schema: ftp; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY "user"
    ADD CONSTRAINT user_folder_key UNIQUE (folder);


--
-- Name: user_salt_username_key; Type: CONSTRAINT; Schema: ftp; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_salt
    ADD CONSTRAINT user_salt_username_key UNIQUE (username);


--
-- Name: user_username_key; Type: CONSTRAINT; Schema: ftp; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY "user"
    ADD CONSTRAINT user_username_key UNIQUE (username);


SET search_path = public, pg_catalog;

--
-- Name: action_areas_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY action_areas
    ADD CONSTRAINT action_areas_pkey PRIMARY KEY (id);


--
-- Name: action_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY action_types
    ADD CONSTRAINT action_types_pkey PRIMARY KEY (id);


--
-- Name: admin_alert_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY admin_alert_settings
    ADD CONSTRAINT admin_alert_settings_pkey PRIMARY KEY (id);


--
-- Name: advertiser_banned_publishers_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY advertiser_banned_publishers
    ADD CONSTRAINT advertiser_banned_publishers_pkey PRIMARY KEY (id);


--
-- Name: advertiser_banned_sub_publishers_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY advertiser_banned_sub_publishers
    ADD CONSTRAINT advertiser_banned_sub_publishers_pkey PRIMARY KEY (id);


--
-- Name: advertiser_contact_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY contacts
    ADD CONSTRAINT advertiser_contact_pkey PRIMARY KEY (id);


--
-- Name: advertiser_contacts_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY advertiser_contacts
    ADD CONSTRAINT advertiser_contacts_pkey PRIMARY KEY (id);


--
-- Name: advertiser_payment_terms_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY advertiser_payment_terms
    ADD CONSTRAINT advertiser_payment_terms_pkey PRIMARY KEY (id);


--
-- Name: advertiser_uploads_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY advertiser_uploads
    ADD CONSTRAINT advertiser_uploads_pkey PRIMARY KEY (id);


--
-- Name: advertisers_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY advertisers
    ADD CONSTRAINT advertisers_pkey PRIMARY KEY (id);


--
-- Name: assets_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY assets
    ADD CONSTRAINT assets_pkey PRIMARY KEY (id);


--
-- Name: audit_log_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY audit_log_types
    ADD CONSTRAINT audit_log_types_pkey PRIMARY KEY (id);


--
-- Name: banned_ips_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY banned_ips
    ADD CONSTRAINT banned_ips_pkey PRIMARY KEY (ip);


--
-- Name: cache_invalidation_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cache_invalidation
    ADD CONSTRAINT cache_invalidation_pkey PRIMARY KEY (id);


--
-- Name: campaign_assigned_publishers_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_assigned_publishers
    ADD CONSTRAINT campaign_assigned_publishers_pkey PRIMARY KEY (campaign_id, publisher_id);


--
-- Name: campaign_banned_sub_publishers_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_banned_sub_publishers
    ADD CONSTRAINT campaign_banned_sub_publishers_pkey PRIMARY KEY (id);


--
-- Name: campaign_caps_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_caps
    ADD CONSTRAINT campaign_caps_pkey PRIMARY KEY (id);


--
-- Name: campaign_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_categories
    ADD CONSTRAINT campaign_categories_pkey PRIMARY KEY (campaign_id, category_id);


--
-- Name: campaign_conversion_aliases_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_conversion_aliases
    ADD CONSTRAINT campaign_conversion_aliases_pkey PRIMARY KEY (id);


--
-- Name: campaign_geotargeting_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_geotargeting
    ADD CONSTRAINT campaign_geotargeting_pkey PRIMARY KEY (id);


--
-- Name: campaign_geotargeting_postal_codes_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_geotargeting_postal_codes
    ADD CONSTRAINT campaign_geotargeting_postal_codes_pkey PRIMARY KEY (campaign_id, postal_code);


--
-- Name: campaign_group_items_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_group_items
    ADD CONSTRAINT campaign_group_items_pkey PRIMARY KEY (id);


--
-- Name: campaign_groups_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_groups
    ADD CONSTRAINT campaign_groups_pkey PRIMARY KEY (id);


--
-- Name: campaign_piggyback_pixels_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_piggyback_pixels
    ADD CONSTRAINT campaign_piggyback_pixels_pkey PRIMARY KEY (id);


--
-- Name: campaign_tracking_type_lookup_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_tracking_type_lookup
    ADD CONSTRAINT campaign_tracking_type_lookup_pkey PRIMARY KEY (id);


--
-- Name: campaign_traffic_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_channels
    ADD CONSTRAINT campaign_traffic_types_pkey PRIMARY KEY (campaign_id, channel_id);


--
-- Name: campaign_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaign_versions
    ADD CONSTRAINT campaign_versions_pkey PRIMARY KEY (id, version_id);


--
-- Name: campaigns_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY campaigns
    ADD CONSTRAINT campaigns_pkey PRIMARY KEY (id);


--
-- Name: categories_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY categories
    ADD CONSTRAINT categories_pkey PRIMARY KEY (id);


--
-- Name: check_name_parent_id_uniq; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY categories
    ADD CONSTRAINT check_name_parent_id_uniq UNIQUE (parent_id, name);


--
-- Name: cities_country_region_name_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cities
    ADD CONSTRAINT cities_country_region_name_key UNIQUE (country, region, name);


--
-- Name: cities_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cities
    ADD CONSTRAINT cities_pkey PRIMARY KEY (id);


--
-- Name: click_geo_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY click_geo
    ADD CONSTRAINT click_geo_pkey PRIMARY KEY (id);


--
-- Name: click_user_agent_features_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY click_user_agent_features
    ADD CONSTRAINT click_user_agent_features_pkey PRIMARY KEY (click_user_agent_id, user_agent_feature_id);


--
-- Name: click_user_agent_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY click_user_agent
    ADD CONSTRAINT click_user_agent_pkey PRIMARY KEY (id);


--
-- Name: clicks_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY clicks
    ADD CONSTRAINT clicks_pkey PRIMARY KEY (id);


--
-- Name: cmpl_alert_template_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cmpl_alert_template
    ADD CONSTRAINT cmpl_alert_template_pkey PRIMARY KEY (id);


--
-- Name: cmpl_downloaded_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cmpl_downloaded
    ADD CONSTRAINT cmpl_downloaded_pkey PRIMARY KEY (id);


--
-- Name: cmpl_email_template_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cmpl_email_template
    ADD CONSTRAINT cmpl_email_template_pkey PRIMARY KEY (id);


--
-- Name: cmpl_exceptions_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cmpl_exceptions
    ADD CONSTRAINT cmpl_exceptions_pkey PRIMARY KEY (id);


--
-- Name: cmpl_notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cmpl_notifications
    ADD CONSTRAINT cmpl_notifications_pkey PRIMARY KEY (id);


--
-- Name: cmpl_suppression_file_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY cmpl_suppression_file
    ADD CONSTRAINT cmpl_suppression_file_pkey PRIMARY KEY (id);


--
-- Name: code_locations_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY code_locations
    ADD CONSTRAINT code_locations_pkey PRIMARY KEY (id);


--
-- Name: contact_type_lookup_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY contact_type_lookup
    ADD CONSTRAINT contact_type_lookup_pkey PRIMARY KEY (id);


--
-- Name: conversion_geo_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY conversion_geo
    ADD CONSTRAINT conversion_geo_pkey PRIMARY KEY (id);


--
-- Name: conversion_user_agent_features_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY conversion_user_agent_features
    ADD CONSTRAINT conversion_user_agent_features_pkey PRIMARY KEY (conv_user_agent_id, user_agent_feature_id);


--
-- Name: countries_country_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY countries
    ADD CONSTRAINT countries_country_key UNIQUE (country);


--
-- Name: countries_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY countries
    ADD CONSTRAINT countries_pkey PRIMARY KEY (id);


--
-- Name: creative_banners_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY creative_banners
    ADD CONSTRAINT creative_banners_pkey PRIMARY KEY (creative_id);


--
-- Name: creative_email_images_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY creative_email_images
    ADD CONSTRAINT creative_email_images_pkey PRIMARY KEY (id);


--
-- Name: creative_email_links_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY creative_email_links
    ADD CONSTRAINT creative_email_links_pkey PRIMARY KEY (id);


--
-- Name: creative_emails_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY creative_emails
    ADD CONSTRAINT creative_emails_pkey PRIMARY KEY (creative_id);


--
-- Name: creative_status_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY creative_status_types
    ADD CONSTRAINT creative_status_types_pkey PRIMARY KEY (id);


--
-- Name: creative_swfs_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY creative_swfs
    ADD CONSTRAINT creative_swfs_pkey PRIMARY KEY (creative_id);


--
-- Name: creative_textlinks_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY creative_textlinks
    ADD CONSTRAINT creative_textlinks_pkey PRIMARY KEY (creative_id);


--
-- Name: creatives_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY creatives
    ADD CONSTRAINT creatives_pkey PRIMARY KEY (id);


--
-- Name: currency_lookup_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY currency_lookup
    ADD CONSTRAINT currency_lookup_pkey PRIMARY KEY (id);


--
-- Name: dashboard_message_groups_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY dashboard_message_groups
    ADD CONSTRAINT dashboard_message_groups_pkey PRIMARY KEY (message_id, group_id);


--
-- Name: dashboard_message_users_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY dashboard_message_users
    ADD CONSTRAINT dashboard_message_users_pkey PRIMARY KEY (message_id, publisher_id);


--
-- Name: dashboard_messages_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY dashboard_messages
    ADD CONSTRAINT dashboard_messages_pkey PRIMARY KEY (id);


--
-- Name: data_anomaly_log_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY data_anomaly_log
    ADD CONSTRAINT data_anomaly_log_pkey PRIMARY KEY (id);


--
-- Name: email_from_lines_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY email_from_lines
    ADD CONSTRAINT email_from_lines_pkey PRIMARY KEY (id);


--
-- Name: email_subject_lines_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY email_subject_lines
    ADD CONSTRAINT email_subject_lines_pkey PRIMARY KEY (id);


--
-- Name: engine_audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_audit_log
    ADD CONSTRAINT engine_audit_log_pkey PRIMARY KEY (id);


--
-- Name: engine_clicks_dupes_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_clicks_dupes
    ADD CONSTRAINT engine_clicks_dupes_pkey PRIMARY KEY (id);


--
-- Name: engine_clicks_hitpath_ref_id; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_clicks
    ADD CONSTRAINT engine_clicks_hitpath_ref_id UNIQUE (hitpath_ref_id);


--
-- Name: engine_clicks_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_clicks
    ADD CONSTRAINT engine_clicks_pkey PRIMARY KEY (id);


--
-- Name: engine_consumers_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_consumers
    ADD CONSTRAINT engine_consumers_pkey PRIMARY KEY (id);


--
-- Name: engine_conversions_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_conversions
    ADD CONSTRAINT engine_conversions_pkey PRIMARY KEY (id);


--
-- Name: engine_conversions_staging_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_conversions_staging
    ADD CONSTRAINT engine_conversions_staging_pkey PRIMARY KEY (id);


--
-- Name: engine_conversions_tmp_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_conversions_tmp
    ADD CONSTRAINT engine_conversions_tmp_pkey PRIMARY KEY (id);


--
-- Name: engine_conversions_waiting_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_conversions_waiting
    ADD CONSTRAINT engine_conversions_waiting_pkey PRIMARY KEY (id);


--
-- Name: engine_error_log_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY engine_error_log
    ADD CONSTRAINT engine_error_log_pkey PRIMARY KEY (id);


--
-- Name: entries_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY entries
    ADD CONSTRAINT entries_pkey PRIMARY KEY (id);


--
-- Name: files_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY files
    ADD CONSTRAINT files_pkey PRIMARY KEY (id);


--
-- Name: gearman_jobs_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY gearman_jobs
    ADD CONSTRAINT gearman_jobs_pkey PRIMARY KEY (id);


--
-- Name: geo_target_cities_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY geo_target_cities
    ADD CONSTRAINT geo_target_cities_pkey PRIMARY KEY (id);


--
-- Name: geo_target_countries_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY geo_target_countries
    ADD CONSTRAINT geo_target_countries_pkey PRIMARY KEY (id);


--
-- Name: geo_target_region_import_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY geo_target_region
    ADD CONSTRAINT geo_target_region_import_pkey PRIMARY KEY (country, admin1_code);


--
-- Name: geo_typeahead_countries_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY geo_typeahead_countries
    ADD CONSTRAINT geo_typeahead_countries_pkey PRIMARY KEY (id);


--
-- Name: geo_typeahead_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY geo_typeahead_cities
    ADD CONSTRAINT geo_typeahead_pkey PRIMARY KEY (id);


--
-- Name: geocoding_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY geocoding
    ADD CONSTRAINT geocoding_pkey PRIMARY KEY (address);


--
-- Name: global_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY global_settings
    ADD CONSTRAINT global_settings_pkey PRIMARY KEY (id);


--
-- Name: hosted_creative_assets_creative_id_sequence_id_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY hosted_creative_assets
    ADD CONSTRAINT hosted_creative_assets_creative_id_sequence_id_key UNIQUE (creative_id, sequence_id);


--
-- Name: hosted_creative_assets_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY hosted_creative_assets
    ADD CONSTRAINT hosted_creative_assets_pkey PRIMARY KEY (id);


--
-- Name: idx_advertiser_publisher_campaign; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY advertiser_banned_publishers
    ADD CONSTRAINT idx_advertiser_publisher_campaign UNIQUE (advertiser_id, publisher_id, campaign_id);


--
-- Name: im_types_name_short_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY im_types
    ADD CONSTRAINT im_types_name_short_key UNIQUE (name_short);


--
-- Name: im_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY im_types
    ADD CONSTRAINT im_types_pkey PRIMARY KEY (id);


--
-- Name: interfaces_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY interfaces
    ADD CONSTRAINT interfaces_pkey PRIMARY KEY (id);


--
-- Name: message_delivery_setting_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY message_delivery_setting_types
    ADD CONSTRAINT message_delivery_setting_types_pkey PRIMARY KEY (id);


--
-- Name: message_delivery_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY message_delivery_settings
    ADD CONSTRAINT message_delivery_settings_pkey PRIMARY KEY (id);


--
-- Name: message_delivery_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY message_delivery_types
    ADD CONSTRAINT message_delivery_types_pkey PRIMARY KEY (id);


--
-- Name: message_status_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY message_status
    ADD CONSTRAINT message_status_pkey PRIMARY KEY (id);


--
-- Name: message_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY message_types
    ADD CONSTRAINT message_types_pkey PRIMARY KEY (id);


--
-- Name: messages_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY messages
    ADD CONSTRAINT messages_pkey PRIMARY KEY (id);


--
-- Name: payment_methods_name_short_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY payment_methods
    ADD CONSTRAINT payment_methods_name_short_key UNIQUE (name_short);


--
-- Name: payment_methods_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY payment_methods
    ADD CONSTRAINT payment_methods_pkey PRIMARY KEY (id);


--
-- Name: pgbench_accounts_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY pgbench_accounts
    ADD CONSTRAINT pgbench_accounts_pkey PRIMARY KEY (aid);


--
-- Name: pgbench_branches_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY pgbench_branches
    ADD CONSTRAINT pgbench_branches_pkey PRIMARY KEY (bid);


--
-- Name: pgbench_tellers_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY pgbench_tellers
    ADD CONSTRAINT pgbench_tellers_pkey PRIMARY KEY (tid);


--
-- Name: publisher_account_changes_import_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_account_changes_import
    ADD CONSTRAINT publisher_account_changes_import_pkey PRIMARY KEY (id);


--
-- Name: publisher_account_changes_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_account_changes
    ADD CONSTRAINT publisher_account_changes_pkey PRIMARY KEY (id);


--
-- Name: publisher_application_scores_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_application_scores
    ADD CONSTRAINT publisher_application_scores_pkey PRIMARY KEY (publisher_id);


--
-- Name: publisher_auth_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_auth_tokens
    ADD CONSTRAINT publisher_auth_tokens_pkey PRIMARY KEY (publisher_id);


--
-- Name: publisher_auth_tokens_token_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_auth_tokens
    ADD CONSTRAINT publisher_auth_tokens_token_key UNIQUE (token);


--
-- Name: publisher_campaign_recommendations_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_campaign_recommendations
    ADD CONSTRAINT publisher_campaign_recommendations_pkey PRIMARY KEY (id);


--
-- Name: publisher_campaign_recommendations_publisher_id_campaign_id_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_campaign_recommendations
    ADD CONSTRAINT publisher_campaign_recommendations_publisher_id_campaign_id_key UNIQUE (publisher_id, campaign_id);


--
-- Name: publisher_campaign_searches_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_campaign_searches
    ADD CONSTRAINT publisher_campaign_searches_pkey PRIMARY KEY (id);


--
-- Name: publisher_change_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_change_requests
    ADD CONSTRAINT publisher_change_requests_pkey PRIMARY KEY (id);


--
-- Name: publisher_contact_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_contact
    ADD CONSTRAINT publisher_contact_pkey PRIMARY KEY (id);


--
-- Name: publisher_groups_assoc_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_groups_assoc
    ADD CONSTRAINT publisher_groups_assoc_pkey PRIMARY KEY (publisher_id, group_id);


--
-- Name: publisher_groups_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_groups
    ADD CONSTRAINT publisher_groups_pkey PRIMARY KEY (id);


--
-- Name: publisher_notes_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_notes
    ADD CONSTRAINT publisher_notes_pkey PRIMARY KEY (id);


--
-- Name: publisher_overrides_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_overrides
    ADD CONSTRAINT publisher_overrides_pkey PRIMARY KEY (id);


--
-- Name: publisher_password_recovery_keys_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_password_recovery_keys
    ADD CONSTRAINT publisher_password_recovery_keys_pkey PRIMARY KEY (publisher_id);


--
-- Name: publisher_password_recovery_keys_recovery_key_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_password_recovery_keys
    ADD CONSTRAINT publisher_password_recovery_keys_recovery_key_key UNIQUE (recovery_key);


--
-- Name: publisher_support_contact_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_support_contact
    ADD CONSTRAINT publisher_support_contact_pkey PRIMARY KEY (id);


--
-- Name: publisher_suppression_internal_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_suppression_internal_requests
    ADD CONSTRAINT publisher_suppression_internal_requests_pkey PRIMARY KEY (id);


--
-- Name: publisher_suppression_optizmo_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_suppression_optizmo_requests
    ADD CONSTRAINT publisher_suppression_optizmo_requests_pkey PRIMARY KEY (id);


--
-- Name: publisher_tiers_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_tiers
    ADD CONSTRAINT publisher_tiers_pkey PRIMARY KEY (id);


--
-- Name: publisher_uploads_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY publisher_uploads
    ADD CONSTRAINT publisher_uploads_pkey PRIMARY KEY (id);


--
-- Name: regions_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY regions
    ADD CONSTRAINT regions_pkey PRIMARY KEY (id);


--
-- Name: regions_region_country_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY regions
    ADD CONSTRAINT regions_region_country_key UNIQUE (region, country);


--
-- Name: reports_clicks_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks
    ADD CONSTRAINT reports_clicks_pkey PRIMARY KEY (id);


--
-- Name: rewards_program_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY rewards_program
    ADD CONSTRAINT rewards_program_pkey PRIMARY KEY (id);


--
-- Name: rewards_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY rewards_types
    ADD CONSTRAINT rewards_types_pkey PRIMARY KEY (id);


--
-- Name: spatial_ref_sys_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY spatial_ref_sys
    ADD CONSTRAINT spatial_ref_sys_pkey PRIMARY KEY (srid);


--
-- Name: traffic_type_creative_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY channel_creative_types
    ADD CONSTRAINT traffic_type_creative_types_pkey PRIMARY KEY (channel_id, creative_type);


--
-- Name: traffic_types_name_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY channels
    ADD CONSTRAINT traffic_types_name_key UNIQUE (name);


--
-- Name: traffic_types_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY channels
    ADD CONSTRAINT traffic_types_pkey PRIMARY KEY (id);


--
-- Name: user_access_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_access_logs
    ADD CONSTRAINT user_access_logs_pkey PRIMARY KEY (id);


--
-- Name: user_agent_browser_lookup_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_agent_browser_lookup
    ADD CONSTRAINT user_agent_browser_lookup_pkey PRIMARY KEY (id);


--
-- Name: user_agent_feature_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_agent_feature
    ADD CONSTRAINT user_agent_feature_pkey PRIMARY KEY (id);


--
-- Name: user_agent_platform_lookup_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_agent_platform_lookup
    ADD CONSTRAINT user_agent_platform_lookup_pkey PRIMARY KEY (id);


--
-- Name: user_impersonation_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_impersonation
    ADD CONSTRAINT user_impersonation_pkey PRIMARY KEY (id);


--
-- Name: user_profile_pics_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_profile_pics
    ADD CONSTRAINT user_profile_pics_pkey PRIMARY KEY (user_id);


--
-- Name: user_profile_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_profile_versions
    ADD CONSTRAINT user_profile_versions_pkey PRIMARY KEY (id, version_id);


--
-- Name: user_profiles_user_id_uniq; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_profiles
    ADD CONSTRAINT user_profiles_user_id_uniq UNIQUE (user_id);


--
-- Name: user_profiles_user_uuid_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_profiles
    ADD CONSTRAINT user_profiles_user_uuid_key UNIQUE (user_uuid);


--
-- Name: user_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY user_tokens
    ADD CONSTRAINT user_tokens_pkey PRIMARY KEY (id);


--
-- Name: users_pkey; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: users_uuid_key; Type: CONSTRAINT; Schema: public; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_uuid_key UNIQUE (uuid);


SET search_path = reporting, pg_catalog;

--
-- Name: heatmap_data_by_campaign_id_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY heatmap_data_by_campaign_id
    ADD CONSTRAINT heatmap_data_by_campaign_id_pkey PRIMARY KEY (id);


--
-- Name: heatmap_data_by_publisher_id_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY heatmap_data_by_publisher_id
    ADD CONSTRAINT heatmap_data_by_publisher_id_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_geo_rollup_daily_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_geo_rollup_daily
    ADD CONSTRAINT reports_clicks_geo_rollup_daily_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_geo_rollup_hourly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_geo_rollup_hourly
    ADD CONSTRAINT reports_clicks_geo_rollup_hourly_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_rollup_daily_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_rollup_daily
    ADD CONSTRAINT reports_clicks_rollup_daily_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_rollup_hourly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_rollup_hourly
    ADD CONSTRAINT reports_clicks_rollup_hourly_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_rollup_monthly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_rollup_monthly
    ADD CONSTRAINT reports_clicks_rollup_monthly_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_rollup_yearly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_rollup_yearly
    ADD CONSTRAINT reports_clicks_rollup_yearly_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_subid_rollup_daily_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_subid_rollup_daily
    ADD CONSTRAINT reports_clicks_subid_rollup_daily_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_subid_rollup_daily_temp_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_subid_rollup_daily_temp
    ADD CONSTRAINT reports_clicks_subid_rollup_daily_temp_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_subid_rollup_hourly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_subid_rollup_hourly
    ADD CONSTRAINT reports_clicks_subid_rollup_hourly_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_subid_rollup_hourly_temp_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_subid_rollup_hourly_temp
    ADD CONSTRAINT reports_clicks_subid_rollup_hourly_temp_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_wide_rollup_daily_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_wide_rollup_daily
    ADD CONSTRAINT reports_clicks_wide_rollup_daily_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_wide_rollup_daily_temp_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_wide_rollup_daily_temp
    ADD CONSTRAINT reports_clicks_wide_rollup_daily_temp_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_wide_rollup_hourly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_wide_rollup_hourly
    ADD CONSTRAINT reports_clicks_wide_rollup_hourly_pkey PRIMARY KEY (id);


--
-- Name: reports_clicks_wide_rollup_hourly_temp_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_clicks_wide_rollup_hourly_temp
    ADD CONSTRAINT reports_clicks_wide_rollup_hourly_temp_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_geo_rollup_daily_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_geo_rollup_daily
    ADD CONSTRAINT reports_conversions_geo_rollup_daily_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_geo_rollup_hourly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_geo_rollup_hourly
    ADD CONSTRAINT reports_conversions_geo_rollup_hourly_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_rollup_daily_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_rollup_daily
    ADD CONSTRAINT reports_conversions_rollup_daily_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_rollup_hourly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_rollup_hourly
    ADD CONSTRAINT reports_conversions_rollup_hourly_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_rollup_monthly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_rollup_monthly
    ADD CONSTRAINT reports_conversions_rollup_monthly_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_rollup_yearly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_rollup_yearly
    ADD CONSTRAINT reports_conversions_rollup_yearly_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_subid_rollup_daily_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_subid_rollup_daily
    ADD CONSTRAINT reports_conversions_subid_rollup_daily_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_subid_rollup_hourly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_subid_rollup_hourly
    ADD CONSTRAINT reports_conversions_subid_rollup_hourly_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_wide_rollup_daily_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_wide_rollup_daily
    ADD CONSTRAINT reports_conversions_wide_rollup_daily_pkey PRIMARY KEY (id);


--
-- Name: reports_conversions_wide_rollup_hourly_pkey; Type: CONSTRAINT; Schema: reporting; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY reports_conversions_wide_rollup_hourly
    ADD CONSTRAINT reports_conversions_wide_rollup_hourly_pkey PRIMARY KEY (id);


SET search_path = topology, pg_catalog;

--
-- Name: layer_pkey; Type: CONSTRAINT; Schema: topology; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY layer
    ADD CONSTRAINT layer_pkey PRIMARY KEY (topology_id, layer_id);


--
-- Name: layer_schema_name_table_name_feature_column_key; Type: CONSTRAINT; Schema: topology; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY layer
    ADD CONSTRAINT layer_schema_name_table_name_feature_column_key UNIQUE (schema_name, table_name, feature_column);


--
-- Name: topology_name_key; Type: CONSTRAINT; Schema: topology; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY topology
    ADD CONSTRAINT topology_name_key UNIQUE (name);


--
-- Name: topology_pkey; Type: CONSTRAINT; Schema: topology; Owner: w4; Tablespace: 
--

ALTER TABLE ONLY topology
    ADD CONSTRAINT topology_pkey PRIMARY KEY (id);


SET search_path = "ACL", pg_catalog;

--
-- Name: acl_group_management_managed_group_id_idx; Type: INDEX; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE INDEX acl_group_management_managed_group_id_idx ON acl_group_management USING btree (managed_group_id);


--
-- Name: acl_group_management_manager_group_id_idx; Type: INDEX; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE INDEX acl_group_management_manager_group_id_idx ON acl_group_management USING btree (manager_group_id);


--
-- Name: acl_group_privileges_resource_id_idx; Type: INDEX; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE INDEX acl_group_privileges_resource_id_idx ON acl_group_privileges USING btree (resource_id);


--
-- Name: acl_resources_parent_id_idx; Type: INDEX; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE INDEX acl_resources_parent_id_idx ON acl_resources USING btree (parent_id);


--
-- Name: acl_user_groups_group_id_idx; Type: INDEX; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE INDEX acl_user_groups_group_id_idx ON acl_user_groups USING btree (group_id);


--
-- Name: acl_user_privileges_user_id_idx; Type: INDEX; Schema: ACL; Owner: w4; Tablespace: 
--

CREATE INDEX acl_user_privileges_user_id_idx ON acl_user_privileges USING btree (user_id);


SET search_path = "Accounting", pg_catalog;

--
-- Name: acct_conversion_ledger_1_idx; Type: INDEX; Schema: Accounting; Owner: w4; Tablespace: 
--

CREATE INDEX acct_conversion_ledger_1_idx ON acct_conversion_ledger USING btree (conversion_id, i_doy, i_woy, i_moy, i_qoy, i_y);


SET search_path = public, pg_catalog;

--
-- Name: advertiser_banned_publishers_publisher_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX advertiser_banned_publishers_publisher_id_idx ON advertiser_banned_publishers USING btree (publisher_id);


--
-- Name: advertiser_banned_sub_publishers_advertiser_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX advertiser_banned_sub_publishers_advertiser_id_idx ON advertiser_banned_sub_publishers USING btree (advertiser_id);


--
-- Name: advertiser_uploads_advertiser_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX advertiser_uploads_advertiser_id_idx ON advertiser_uploads USING btree (advertiser_id);


--
-- Name: advertisers_manager_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX advertisers_manager_id_idx ON advertisers USING btree (manager_id);


--
-- Name: advertisers_payment_terms_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX advertisers_payment_terms_id_idx ON advertisers USING btree (payment_terms_id);


--
-- Name: assets_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX assets_campaign_id_idx ON assets USING btree (campaign_id);


--
-- Name: assets_file_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX assets_file_id_idx ON assets USING btree (file_id);


--
-- Name: assets_owner_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX assets_owner_id_idx ON assets USING btree (owner_id);


--
-- Name: audit_log_enitity_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX audit_log_enitity_idx ON audit_log USING btree (entity_id);


--
-- Name: audit_log_enitity_type_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX audit_log_enitity_type_idx ON audit_log USING btree (entity_type_id);


--
-- Name: audit_log_user_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX audit_log_user_idx ON audit_log USING btree (user_id);


--
-- Name: campaign_assigned_publishers_publisher_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaign_assigned_publishers_publisher_id_idx ON campaign_assigned_publishers USING btree (publisher_id);


--
-- Name: campaign_assigned_publishers_status_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaign_assigned_publishers_status_idx ON campaign_assigned_publishers USING btree (status);


--
-- Name: campaign_banned_sub_publishers_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaign_banned_sub_publishers_campaign_id_idx ON campaign_banned_sub_publishers USING btree (campaign_id);


--
-- Name: campaign_categories_category_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaign_categories_category_id_idx ON campaign_categories USING btree (campaign_id, category_id);


--
-- Name: campaign_payout_changes_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaign_payout_changes_campaign_id_idx ON campaign_payout_changes USING btree (campaign_id);


--
-- Name: campaign_pixels_legacy_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaign_pixels_legacy_campaign_id_idx ON campaign_pixels_legacy USING btree (campaign_id);


--
-- Name: campaign_traffic_types_traffic_type_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaign_traffic_types_traffic_type_id_idx ON campaign_channels USING btree (campaign_id, channel_id);


--
-- Name: campaign_versions_search_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaign_versions_search_id_idx ON campaign_versions USING btree (id, version_id, advertiser_id, user_id, version_start_date);


--
-- Name: campaigns_advertiser_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaigns_advertiser_id_idx ON campaigns USING btree (advertiser_id);


--
-- Name: campaigns_failure_redirect_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaigns_failure_redirect_campaign_id_idx ON campaigns USING btree (failure_redirect_campaign_id);


--
-- Name: campaigns_name_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaigns_name_idx ON campaigns USING btree (name);


--
-- Name: campaigns_outgeo_redirect_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaigns_outgeo_redirect_campaign_id_idx ON campaigns USING btree (outgeo_redirect_campaign_id);


--
-- Name: campaigns_payin_model_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaigns_payin_model_id_idx ON campaigns USING btree (payin_model_id);


--
-- Name: campaigns_payout_model_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaigns_payout_model_id_idx ON campaigns USING btree (payout_model_id);


--
-- Name: campaigns_user_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX campaigns_user_id_idx ON campaigns USING btree (user_id);


--
-- Name: cities_name_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX cities_name_idx ON cities USING btree (name);


--
-- Name: clicks_1_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX clicks_1_idx ON clicks USING btree (publisher_id, sub_publisher_id, creative_id, campaign_id, traffic_type, r_hoy, r_doy, r_woy, r_moy, r_qoy, r_y);


--
-- Name: creative_email_image_lookup_asset_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX creative_email_image_lookup_asset_id_idx ON creative_email_image_lookup USING btree (asset_id);


--
-- Name: creative_email_image_lookup_image_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX creative_email_image_lookup_image_id_idx ON creative_email_image_lookup USING btree (image_id);


--
-- Name: creatives_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX creatives_campaign_id_idx ON creatives USING btree (campaign_id);


--
-- Name: creatives_name_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX creatives_name_idx ON creatives USING btree (name);


--
-- Name: creatives_type_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX creatives_type_idx ON creatives USING btree (type);


--
-- Name: dashboard_message_groups_group_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX dashboard_message_groups_group_id_idx ON dashboard_message_groups USING btree (group_id);


--
-- Name: dashboard_message_users_publisher_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX dashboard_message_users_publisher_id_idx ON dashboard_message_users USING btree (publisher_id);


--
-- Name: email_from_lines_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX email_from_lines_campaign_id_idx ON email_from_lines USING btree (campaign_id);


--
-- Name: email_subject_lines_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX email_subject_lines_campaign_id_idx ON email_subject_lines USING btree (campaign_id);


--
-- Name: engine_audit_log_1_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX engine_audit_log_1_idx ON engine_audit_log USING btree (failed_step);


--
-- Name: engine_clicks_dupes_click_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX engine_clicks_dupes_click_id_idx ON engine_clicks_dupes USING btree (click_id);


--
-- Name: engine_error_log_1_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX engine_error_log_1_idx ON engine_error_log USING btree (short_error, url, campaign_id, pub_id, status, last_occurrence);


--
-- Name: engine_tests_campaign_publisher_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX engine_tests_campaign_publisher_idx ON engine_tests USING btree (campaign_id, publisher_id);


--
-- Name: fk_campaigns_conversions; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fk_campaigns_conversions ON engine_conversions USING btree (campaign_id);


--
-- Name: fk_engine_conversions_waiting_click_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fk_engine_conversions_waiting_click_id ON engine_conversions_waiting USING btree (click_id);


--
-- Name: fk_user_profiles_type; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE UNIQUE INDEX fk_user_profiles_type ON users USING btree (id, access, active);


--
-- Name: fk_users_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fk_users_idx ON user_profiles USING btree (user_id DESC);


--
-- Name: fki_clicks_conversions; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_clicks_conversions ON engine_conversions USING btree (click_id);


--
-- Name: fki_conv_platfrm; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_conv_platfrm ON engine_conversions USING btree (platform_id);


--
-- Name: fki_conv_ubrows; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_conv_ubrows ON engine_conversions USING btree (browser_id);


--
-- Name: fki_engine_clicks_rollup_queue_campaigns_clicks; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_clicks_rollup_queue_campaigns_clicks ON engine_clicks_rollup_queue USING btree (campaign_id);


--
-- Name: fki_engine_clicks_rollup_queue_clk_brows; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_clicks_rollup_queue_clk_brows ON engine_clicks_rollup_queue USING btree (browser_id);


--
-- Name: fki_engine_clicks_rollup_queue_clk_platrfm; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_clicks_rollup_queue_clk_platrfm ON engine_clicks_rollup_queue USING btree (platform_id);


--
-- Name: fki_engine_clicks_rollup_queue_publishers_clicks; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_clicks_rollup_queue_publishers_clicks ON engine_clicks_rollup_queue USING btree (publisher_id);


--
-- Name: fki_engine_clicks_rollup_queue_rollup_id_clicks; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_clicks_rollup_queue_rollup_id_clicks ON engine_clicks_rollup_queue USING btree (rollup_id);


--
-- Name: fki_engine_conversions_rollup_queue_campaigns_clicks; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_conversions_rollup_queue_campaigns_clicks ON engine_conversions_rollup_queue USING btree (campaign_id);


--
-- Name: fki_engine_conversions_rollup_queue_clk_brows; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_conversions_rollup_queue_clk_brows ON engine_conversions_rollup_queue USING btree (browser_id);


--
-- Name: fki_engine_conversions_rollup_queue_clk_platrfm; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_conversions_rollup_queue_clk_platrfm ON engine_conversions_rollup_queue USING btree (platform_id);


--
-- Name: fki_engine_conversions_rollup_queue_publishers_clicks; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_conversions_rollup_queue_publishers_clicks ON engine_conversions_rollup_queue USING btree (publisher_id);


--
-- Name: fki_engine_conversions_rollup_queue_rollup_id_clicks; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_engine_conversions_rollup_queue_rollup_id_clicks ON engine_conversions_rollup_queue USING btree (rollup_id);


--
-- Name: fki_iu_u_id_fk; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_iu_u_id_fk ON user_impersonation USING btree (impersonated_user_id);


--
-- Name: fki_mgr_id_fk; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_mgr_id_fk ON users USING btree (manager_id);


--
-- Name: fki_pc_id_fk; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_pc_id_fk ON users USING btree (primary_contact_id);


--
-- Name: fki_pnt_id_fk; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_pnt_id_fk ON users USING btree (parent_id);


--
-- Name: fki_publishers_conversions; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_publishers_conversions ON engine_conversions USING btree (publisher_id);


--
-- Name: fki_rollup_id_clicks; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_rollup_id_clicks ON engine_clicks USING btree (rollup_id);


--
-- Name: fki_u_u_id_fk; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX fki_u_u_id_fk ON user_impersonation USING btree (user_id);


--
-- Name: gearman_jobs_unique_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX gearman_jobs_unique_id_idx ON gearman_jobs USING btree (unique_id);


--
-- Name: idc_usrs_id_hash; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idc_usrs_id_hash ON users USING hash (id);


--
-- Name: idx_active_user_type; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_active_user_type ON users USING btree (active, access DESC NULLS LAST);


--
-- Name: idx_contacts_pk; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE UNIQUE INDEX idx_contacts_pk ON contacts USING btree (id DESC NULLS LAST);


--
-- Name: idx_conv_date; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_conv_date ON engine_conversions USING btree (created_date DESC NULLS LAST);


--
-- Name: idx_convs_basic_search; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_convs_basic_search ON engine_conversions USING btree (click_id, campaign_id, publisher_id, parent_publisher_id, status);


--
-- Name: idx_convs_id_desc; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_convs_id_desc ON engine_conversions USING btree (id DESC NULLS LAST);


--
-- Name: idx_cty_search_faster; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_cty_search_faster ON geo_typeahead_countries USING btree (country_search);


--
-- Name: idx_email_queue_batch_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_email_queue_batch_id ON email_queue USING btree (batch_id);


--
-- Name: idx_engine_clicks_rollup_queue_click_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE UNIQUE INDEX idx_engine_clicks_rollup_queue_click_id ON engine_clicks_rollup_queue USING btree (click_id);


--
-- Name: idx_engine_clicks_rollup_queue_cpg_date; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_engine_clicks_rollup_queue_cpg_date ON engine_clicks_rollup_queue USING btree (campaign_id, created_date DESC NULLS LAST);


--
-- Name: idx_engine_clicks_rollup_queue_date; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_engine_clicks_rollup_queue_date ON engine_clicks_rollup_queue USING btree (created_date DESC NULLS LAST);


--
-- Name: idx_engine_clicks_rollup_queue_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE UNIQUE INDEX idx_engine_clicks_rollup_queue_id ON engine_clicks_rollup_queue USING btree (id);


--
-- Name: idx_engine_clicks_rollup_queue_search; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_engine_clicks_rollup_queue_search ON engine_clicks_rollup_queue USING btree (campaign_id, advertiser_id, publisher_id, parent_publisher_id, created_date);


--
-- Name: idx_engine_conversions_click_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_engine_conversions_click_id ON engine_conversions USING btree (click_id);


--
-- Name: idx_engine_conversions_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE UNIQUE INDEX idx_engine_conversions_id ON engine_conversions USING btree (id);


--
-- Name: idx_engine_conversions_rollup_queue_conversion_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE UNIQUE INDEX idx_engine_conversions_rollup_queue_conversion_id ON engine_conversions_rollup_queue USING btree (conversion_id);


--
-- Name: idx_engine_conversions_rollup_queue_cpg_date; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_engine_conversions_rollup_queue_cpg_date ON engine_conversions_rollup_queue USING btree (campaign_id, created_date DESC NULLS LAST);


--
-- Name: idx_engine_conversions_rollup_queue_date; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_engine_conversions_rollup_queue_date ON engine_conversions_rollup_queue USING btree (created_date DESC NULLS LAST);


--
-- Name: idx_engine_conversions_rollup_queue_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE UNIQUE INDEX idx_engine_conversions_rollup_queue_id ON engine_conversions_rollup_queue USING btree (id);


--
-- Name: idx_engine_conversions_rollup_queue_search; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_engine_conversions_rollup_queue_search ON engine_conversions_rollup_queue USING btree (campaign_id, advertiser_id, publisher_id, parent_publisher_id, created_date);


--
-- Name: idx_geo_target_cities; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_geo_target_cities ON geo_target_cities USING btree (search_string, country_code, admin1_code);


--
-- Name: idx_geo_target_countries; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_geo_target_countries ON geo_target_countries USING btree (country_search);


--
-- Name: idx_geo_target_region; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_geo_target_region ON geo_target_region USING btree (region_search, country);


--
-- Name: idx_image_url_queue_batch_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_image_url_queue_batch_id ON image_url_queue USING btree (batch_id);


--
-- Name: idx_rgn_search_faster; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rgn_search_faster ON geo_typeahead_region USING btree (region_search, country);


--
-- Name: idx_screenshot_queue_batch_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_screenshot_queue_batch_id ON screenshot_queue USING btree (batch_id);


--
-- Name: idx_search_faster; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_search_faster ON geo_typeahead_cities USING btree (search_string, country_code, admin1_code, admin2_code);


--
-- Name: idx_suppression_unsubscribe_queue_batch_id; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_suppression_unsubscribe_queue_batch_id ON suppression_unsubscribe_queue USING btree (batch_id);


--
-- Name: idx_usrs_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX idx_usrs_id_idx ON users USING btree (id);


--
-- Name: publisher_campaign_recommendations_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_campaign_recommendations_campaign_id_idx ON publisher_campaign_recommendations USING btree (campaign_id);


--
-- Name: publisher_campaign_recommendations_user_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_campaign_recommendations_user_id_idx ON publisher_campaign_recommendations USING btree (user_id);


--
-- Name: publisher_campaign_searches_1_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_campaign_searches_1_idx ON publisher_campaign_searches USING btree (publisher_id, query);


--
-- Name: publisher_groups_assoc_group_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_groups_assoc_group_id_idx ON publisher_groups_assoc USING btree (group_id);


--
-- Name: publisher_notes_publisher_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_notes_publisher_id_idx ON publisher_notes USING btree (publisher_id);


--
-- Name: publisher_overrides_campaign_publisher_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_overrides_campaign_publisher_idx ON publisher_overrides USING btree (campaign_id, publisher_id);


--
-- Name: publisher_suppression_internal_requests_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_suppression_internal_requests_idx ON publisher_suppression_internal_requests USING btree (publisher_id, campaign_id, advertiser_id);


--
-- Name: publisher_suppression_internal_requests_list_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_suppression_internal_requests_list_id_idx ON publisher_suppression_internal_requests USING btree (list_id);


--
-- Name: publisher_suppression_optizmo_requests_1_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_suppression_optizmo_requests_1_idx ON publisher_suppression_optizmo_requests USING btree (publisher_id, campaign_id, advertiser_id);


--
-- Name: publisher_uploads_publisher_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX publisher_uploads_publisher_id_idx ON publisher_uploads USING btree (publisher_id);


--
-- Name: reports_clicks_advertiser_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_advertiser_id_idx ON reports_clicks USING btree (advertiser_id);


--
-- Name: reports_clicks_browser_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_browser_id_idx ON reports_clicks USING btree (browser_id);


--
-- Name: reports_clicks_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_campaign_id_idx ON reports_clicks USING btree (campaign_id);


--
-- Name: reports_clicks_city_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_city_idx ON reports_clicks USING btree (city);


--
-- Name: reports_clicks_creative_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_creative_id_idx ON reports_clicks USING btree (creative_id);


--
-- Name: reports_clicks_entities_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_entities_idx ON reports_clicks USING btree (campaign_id, advertiser_id, publisher_id, parent_publisher_id, hoy);


--
-- Name: reports_clicks_hoy_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_hoy_idx ON reports_clicks USING btree (hoy);


--
-- Name: reports_clicks_parent_publisher_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_parent_publisher_id_idx ON reports_clicks USING btree (parent_publisher_id);


--
-- Name: reports_clicks_platorm_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_platorm_id_idx ON reports_clicks USING btree (platform_id);


--
-- Name: reports_clicks_publisher_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_publisher_id_idx ON reports_clicks USING btree (publisher_id);


--
-- Name: reports_clicks_sub_id_1_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_sub_id_1_idx ON reports_clicks USING btree (sub_id_1);


--
-- Name: suppression_unsubscribe_files_suppression_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX suppression_unsubscribe_files_suppression_id_idx ON suppression_unsubscribe_files USING btree (suppression_id);


--
-- Name: suppression_upload_files_advertiser_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX suppression_upload_files_advertiser_id_idx ON suppression_upload_files USING btree (advertiser_id);


--
-- Name: suppression_upload_files_campaign_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX suppression_upload_files_campaign_id_idx ON suppression_upload_files USING btree (campaign_id);


--
-- Name: suppression_upload_files_file_path_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX suppression_upload_files_file_path_idx ON suppression_upload_files USING btree (file_path);


--
-- Name: tracking_domains_publisher_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX tracking_domains_publisher_id_idx ON tracking_domains USING btree (publisher_id);


--
-- Name: traffic_type_creative_types_creative_type_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX traffic_type_creative_types_creative_type_idx ON channel_creative_types USING btree (creative_type);


--
-- Name: user_agent_browser_lookup_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX user_agent_browser_lookup_idx ON user_agent_browser_lookup USING btree (browser_name, browser_version, browser_special);


--
-- Name: user_agent_platform_lookup_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX user_agent_platform_lookup_idx ON user_agent_platform_lookup USING btree (platform_name, platform_version, platform_special);


--
-- Name: user_profile_versions_search_id_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX user_profile_versions_search_id_idx ON user_profile_versions USING btree (id, user_uuid, version_id, version_start_date);


--
-- Name: user_tokens_1_idx; Type: INDEX; Schema: public; Owner: w4; Tablespace: 
--

CREATE INDEX user_tokens_1_idx ON user_tokens USING btree (user_id, token);


SET search_path = reporting, pg_catalog;

--
-- Name: idx_rclghd_lookup_by_core_entities; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rclghd_lookup_by_core_entities ON reports_clicks_geo_rollup_daily USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, country, region_name, city_name, doy);


--
-- Name: idx_rclghr_lookup_by_core_entities; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rclghr_lookup_by_core_entities ON reports_clicks_geo_rollup_hourly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, country, region_name, city_name, hoy);


--
-- Name: idx_rclhd_lookup_by_core_entities; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rclhd_lookup_by_core_entities ON reports_clicks_rollup_daily USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, doy);


--
-- Name: idx_rclhr_lookup_by_core_entities; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rclhr_lookup_by_core_entities ON reports_clicks_rollup_hourly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, hoy);


--
-- Name: idx_reports_clicks_subid_rollup_daily_entities; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_reports_clicks_subid_rollup_daily_entities ON reports_clicks_subid_rollup_daily_temp USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, sub_id_1, doy);


--
-- Name: idx_reports_clicks_subid_rollup_hourly_entities; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_reports_clicks_subid_rollup_hourly_entities ON reports_clicks_subid_rollup_hourly_temp USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, sub_id_1, hoy);


--
-- Name: idx_reports_clicks_wide_rollup_daily_entities; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_reports_clicks_wide_rollup_daily_entities ON reports_clicks_wide_rollup_daily_temp USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, browser_name, platform_name, country, region_name, city_name, sub_id_1, creative_id, doy);


--
-- Name: idx_reports_clicks_wide_rollup_hourly_entities; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_reports_clicks_wide_rollup_hourly_entities ON reports_clicks_wide_rollup_hourly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, browser_name, platform_name, country, region_name, city_name, sub_id_1, creative_id, hoy);


--
-- Name: idx_rpt_cgrd; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_cgrd ON reports_conversions_geo_rollup_daily USING btree (publisher_id, campaign_id, advertiser_id, payin_amount, payout_amount, country, region_name, city_name, doy, publisher_pid);


--
-- Name: idx_rpt_cgrh; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_cgrh ON reports_conversions_geo_rollup_hourly USING btree (publisher_id, campaign_id, advertiser_id, payin_amount, payout_amount, country, region_name, city_name, hoy, publisher_pid);


--
-- Name: idx_rpt_clk_ru_m; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_clk_ru_m ON reports_clicks_rollup_monthly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, moy);


--
-- Name: idx_rpt_clk_ru_y; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_clk_ru_y ON reports_clicks_rollup_yearly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, y);


--
-- Name: idx_rpt_cnv_ru_m; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_cnv_ru_m ON reports_conversions_rollup_monthly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, payin_amount, payout_amount, moy);


--
-- Name: idx_rpt_cnv_ru_y; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_cnv_ru_y ON reports_conversions_rollup_yearly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, payin_amount, payout_amount, y);


--
-- Name: idx_rpt_crd; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_crd ON reports_conversions_rollup_daily USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, payin_amount, payout_amount, doy);


--
-- Name: idx_rpt_crh; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_crh ON reports_conversions_rollup_hourly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, payin_amount, payout_amount, hoy);


--
-- Name: idx_rpt_csrd; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_csrd ON reports_conversions_subid_rollup_daily USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, payin_amount, payout_amount, sub_id_1, sub_id_2, sub_id_3, sub_id_4, doy);


--
-- Name: idx_rpt_csrh; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_csrh ON reports_conversions_subid_rollup_hourly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, payin_amount, payout_amount, sub_id_1, sub_id_2, sub_id_3, sub_id_4, hoy);


--
-- Name: idx_rpt_cwrd; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_cwrd ON reports_conversions_wide_rollup_daily USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, payin_amount, payout_amount, browser_name, platform_name, country, region_name, city_name, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, creative_id, doy);


--
-- Name: idx_rpt_cwrh; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX idx_rpt_cwrh ON reports_conversions_wide_rollup_hourly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, payin_amount, payout_amount, browser_name, platform_name, country, region_name, city_name, sub_id_1, sub_id_2, sub_id_3, sub_id_4, base_uri, creative_id, hoy);


--
-- Name: reports_clicks_geo_rollup_hou_publisher_id_publisher_pid_ca_idx; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_geo_rollup_hou_publisher_id_publisher_pid_ca_idx ON reports_clicks_geo_rollup_hourly USING btree (publisher_id, publisher_pid, campaign_id);


--
-- Name: reports_clicks_rollup_daily_campaign_id_advertiser_id_publi_idx; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_rollup_daily_campaign_id_advertiser_id_publi_idx ON reports_clicks_rollup_daily USING btree (campaign_id, advertiser_id, publisher_id, publisher_pid, doy);


--
-- Name: reports_clicks_rollup_daily_total_clicks_unique_clicks_idx; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_rollup_daily_total_clicks_unique_clicks_idx ON reports_clicks_rollup_daily USING btree (total_clicks, unique_clicks);


--
-- Name: reports_clicks_ua_rollup_hourly_idx; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX reports_clicks_ua_rollup_hourly_idx ON reports_clicks_ua_rollup_hourly USING btree (publisher_id, publisher_pid, campaign_id, advertiser_id, browser_name, platform_name, hoy);


--
-- Name: reports_conversions_rollup_da_advertiser_id_campaign_id_pub_idx; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX reports_conversions_rollup_da_advertiser_id_campaign_id_pub_idx ON reports_conversions_rollup_daily USING btree (advertiser_id, campaign_id, publisher_pid, publisher_id, doy);


--
-- Name: reports_conversions_rollup_da_payin_amount_payout_amount_to_idx; Type: INDEX; Schema: reporting; Owner: w4; Tablespace: 
--

CREATE INDEX reports_conversions_rollup_da_payin_amount_payout_amount_to_idx ON reports_conversions_rollup_daily USING btree (payin_amount, payout_amount, total_pay_in, total_pay_out, total_conversions);


SET search_path = public, pg_catalog;

--
-- Name: _RETURN; Type: RULE; Schema: public; Owner: w4
--

CREATE RULE "_RETURN" AS
    ON SELECT TO vw_pubs_campaign_report_list_items DO INSTEAD  SELECT cmp.id AS campaign_id,
    cmp.name AS campaign_name,
    rd.publisher_id,
    COALESCE(sum(rd.total_clicks), (0)::numeric) AS total_clicks,
    COALESCE(sum(rd.unique_clicks), (0)::numeric) AS unique_clicks,
    COALESCE(sum(rd.total_conversions), (0)::numeric) AS conversions,
    COALESCE(sum(rd.total_pay_out), (0)::numeric) AS revenue,
    max(cmp.expiry_date) AS expiration_date,
    COALESCE(po.override_payout, (cmp.default_payout)::double precision) AS payout,
    w4_application_functions.pays_on_friendly_name(max(cmp.payout_model_id)) AS pays_on,
    w4_application_functions.geos_json(cmp.id) AS geos_json,
    w4_application_functions.categories_json(cmp.id) AS categories_json,
    w4_application_functions.channels_json(cmp.id) AS channels_json,
    max(cmp.description) AS campaign_description,
    rd.doy,
        CASE
            WHEN ((cmp.new_until)::timestamp with time zone > (now() + '1 day'::interval)) THEN true
            ELSE false
        END AS is_new
   FROM ((campaigns cmp
   LEFT JOIN reporting.reports_daily rd ON ((cmp.id = rd.campaign_id)))
   LEFT JOIN publisher_overrides po ON (((((po.publisher_id = rd.publisher_id) AND (po.campaign_id = cmp.id)) AND (po.effective_date <= now())) AND (po.expiration_date >= now()))))
  GROUP BY cmp.id, cmp.name, rd.publisher_id, rd.doy, po.override_payout, cmp.default_payout;


--
-- Name: _RETURN; Type: RULE; Schema: public; Owner: w4
--

CREATE RULE "_RETURN" AS
    ON SELECT TO vw_campaigns_traffic_list_view DO INSTEAD          SELECT cmp.id AS campaign_id,
            max((cmp.name)::text) AS campaign_name,
            max((cmp.status)::text) AS campaign_status,
            max((adv.name)::text) AS advertiser_name,
            max(adv.id) AS advertiser_id,
            vcct.doy,
            COALESCE(concat(',', max(mcccl.category_ids), ','), ',,'::text) AS category_ids,
            COALESCE(max(mcccl.categories), ''::text) AS categories,
            COALESCE(concat(',', max(mcccl.channel_ids), ','), ',,'::text) AS channel_ids,
            COALESCE(max(mcccl.channels), ''::text) AS channels,
            COALESCE(sum(vcct.total_clicks), (0)::numeric) AS total_clicks,
            COALESCE(sum(vcct.unique_clicks), (0)::numeric) AS unique_clicks,
            COALESCE(sum(vcct.total_conversions), (0)::numeric) AS total_conversions,
            COALESCE(sum(vcct.total_pay_in), (0)::numeric) AS total_in,
            COALESCE(sum(vcct.total_pay_out), (0)::numeric) AS total_out,
            COALESCE((max(cc.value))::numeric, ((-1))::numeric) AS campaign_cap,
            COALESCE((max(cmp.currency_id))::numeric, (1)::numeric) AS currency_id,
            COALESCE(
                CASE
                    WHEN (max(cmp.new_until) > now()) THEN 'Yes'::text
                    ELSE 'No'::text
                END, 'No'::text) AS is_new,
            cmp.expiry_date AS expires
           FROM ((((reporting.reports_daily vcct
      LEFT JOIN campaigns cmp ON ((vcct.campaign_id = cmp.id)))
   LEFT JOIN ( SELECT max(campaign_caps.value) AS value,
               campaign_caps.campaign_id
              FROM campaign_caps
             GROUP BY campaign_caps.campaign_id) cc ON ((cmp.id = cc.campaign_id)))
   LEFT JOIN advertisers adv ON ((cmp.advertiser_id = adv.id)))
   LEFT JOIN ( SELECT vccl.campaign_id,
     vccal.category_ids,
     vccal.categories,
     vccl.channel_ids,
     vccl.channels
    FROM (( SELECT ctt.campaign_id,
             concat(',', COALESCE(string_agg(((tt.id)::character varying)::text, ','::text)), ',') AS channel_ids,
             concat(',', (string_agg((tt.name)::text, (''::text || ','::text)) || chr(32)), ',') AS channels
            FROM (campaign_channels ctt
       LEFT JOIN channels tt ON ((ctt.channel_id = tt.id)))
      GROUP BY ctt.campaign_id) vccl
   LEFT JOIN vw_campaign_category_labels vccal ON ((vccl.campaign_id = vccal.campaign_id)))) mcccl ON ((cmp.id = mcccl.campaign_id)))
  GROUP BY cmp.id, adv.id, vcct.doy
UNION
         SELECT cmp.id AS campaign_id,
            cmp.name AS campaign_name,
            cmp.status AS campaign_status,
            max((adv.name)::text) AS advertiser_name,
            max(adv.id) AS advertiser_id,
            vcct.doy,
            COALESCE(concat(',', max(mcccl.category_ids), ','), ',,'::text) AS category_ids,
            COALESCE(max(mcccl.categories), ''::text) AS categories,
            COALESCE(concat(',', max(mcccl.channel_ids), ','), ',,'::text) AS channel_ids,
            COALESCE(max(mcccl.channels), ''::text) AS channels,
            0 AS total_clicks,
            0 AS unique_clicks,
            0 AS total_conversions,
            0 AS total_in,
            0 AS total_out,
            COALESCE((max(cc.value))::numeric, ((-1))::numeric) AS campaign_cap,
            COALESCE((max(cmp.currency_id))::numeric, (1)::numeric) AS currency_id,
            COALESCE(
                CASE
                    WHEN (max(cmp.new_until) > now()) THEN 'Yes'::text
                    ELSE 'No'::text
                END, 'No'::text) AS is_new,
            cmp.expiry_date AS expires
           FROM ((((campaigns cmp
      LEFT JOIN reporting.reports_daily vcct ON (((vcct.campaign_id = cmp.id) AND (vcct.doy IS NULL))))
   LEFT JOIN ( SELECT max(campaign_caps.value) AS value,
               campaign_caps.campaign_id
              FROM campaign_caps
             GROUP BY campaign_caps.campaign_id) cc ON ((cmp.id = cc.campaign_id)))
   LEFT JOIN advertisers adv ON ((cmp.advertiser_id = adv.id)))
   LEFT JOIN ( SELECT vccl.campaign_id,
     vccal.category_ids,
     vccal.categories,
     vccl.channel_ids,
     vccl.channels
    FROM (( SELECT ctt.campaign_id,
             concat(',', COALESCE(string_agg(((tt.id)::character varying)::text, ','::text)), ',') AS channel_ids,
             concat(',', (string_agg((tt.name)::text, (''::text || ','::text)) || chr(32)), ',') AS channels
            FROM (campaign_channels ctt
       LEFT JOIN channels tt ON ((ctt.channel_id = tt.id)))
      GROUP BY ctt.campaign_id) vccl
   LEFT JOIN vw_campaign_category_labels vccal ON ((vccl.campaign_id = vccal.campaign_id)))) mcccl ON ((cmp.id = mcccl.campaign_id)))
  GROUP BY cmp.id, vcct.doy
  ORDER BY 1 DESC;


--
-- Name: add_current_date_to_cmpl_downloaded; Type: TRIGGER; Schema: public; Owner: w4
--

CREATE TRIGGER add_current_date_to_cmpl_downloaded BEFORE UPDATE ON cmpl_downloaded FOR EACH ROW EXECUTE PROCEDURE w4_application_functions.update_cmpl_downloaded();


--
-- Name: add_current_date_to_cmpl_exceptions; Type: TRIGGER; Schema: public; Owner: w4
--

CREATE TRIGGER add_current_date_to_cmpl_exceptions BEFORE UPDATE ON cmpl_exceptions FOR EACH ROW EXECUTE PROCEDURE w4_application_functions.update_cmpl_exceptions();


--
-- Name: add_current_date_to_cmpl_notifications; Type: TRIGGER; Schema: public; Owner: w4
--

CREATE TRIGGER add_current_date_to_cmpl_notifications BEFORE UPDATE ON cmpl_notifications FOR EACH ROW EXECUTE PROCEDURE w4_application_functions.update_cmpl_notifications();


--
-- Name: add_current_date_to_cmpl_suppression_file; Type: TRIGGER; Schema: public; Owner: w4
--

CREATE TRIGGER add_current_date_to_cmpl_suppression_file BEFORE UPDATE ON cmpl_suppression_file FOR EACH ROW EXECUTE PROCEDURE w4_application_functions.update_cmpl_suppression_file();


--
-- Name: campaigns_versioning; Type: TRIGGER; Schema: public; Owner: w4
--

CREATE TRIGGER campaigns_versioning AFTER INSERT OR UPDATE ON campaigns FOR EACH ROW EXECUTE PROCEDURE version_campaign_record();


--
-- Name: users_validation; Type: TRIGGER; Schema: public; Owner: w4
--

CREATE TRIGGER users_validation BEFORE INSERT OR UPDATE ON users FOR EACH ROW EXECUTE PROCEDURE w4_application_functions.create_or_update_users();


SET search_path = topology, pg_catalog;

--
-- Name: layer_integrity_checks; Type: TRIGGER; Schema: topology; Owner: w4
--

CREATE TRIGGER layer_integrity_checks BEFORE DELETE OR UPDATE ON layer FOR EACH ROW EXECUTE PROCEDURE layertrigger();


SET search_path = "ACL", pg_catalog;

--
-- Name: acl_user_groups_group_id_fkey; Type: FK CONSTRAINT; Schema: ACL; Owner: w4
--

ALTER TABLE ONLY acl_user_groups
    ADD CONSTRAINT acl_user_groups_group_id_fkey FOREIGN KEY (group_id) REFERENCES acl_groups(id);


SET search_path = public, pg_catalog;

--
-- Name: fk_campaigns_conversions; Type: FK CONSTRAINT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions
    ADD CONSTRAINT fk_campaigns_conversions FOREIGN KEY (campaign_id) REFERENCES campaigns(id) MATCH FULL NOT VALID;


--
-- Name: fk_conv_platfrm; Type: FK CONSTRAINT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions
    ADD CONSTRAINT fk_conv_platfrm FOREIGN KEY (platform_id) REFERENCES user_agent_platform_lookup(id) NOT VALID;


--
-- Name: fk_conv_ubrows; Type: FK CONSTRAINT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions
    ADD CONSTRAINT fk_conv_ubrows FOREIGN KEY (browser_id) REFERENCES user_agent_browser_lookup(id) NOT VALID;


--
-- Name: fk_publishers_conversions; Type: FK CONSTRAINT; Schema: public; Owner: w4
--

ALTER TABLE ONLY engine_conversions
    ADD CONSTRAINT fk_publishers_conversions FOREIGN KEY (publisher_id) REFERENCES users(id) MATCH FULL NOT VALID;


--
-- Name: fk_user_profiles_users; Type: FK CONSTRAINT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_profiles
    ADD CONSTRAINT fk_user_profiles_users FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: iu_u_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_impersonation
    ADD CONSTRAINT iu_u_id_fk FOREIGN KEY (impersonated_user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: u_u_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: w4
--

ALTER TABLE ONLY user_impersonation
    ADD CONSTRAINT u_u_id_fk FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE RESTRICT ON DELETE CASCADE;


SET search_path = topology, pg_catalog;

--
-- Name: layer_topology_id_fkey; Type: FK CONSTRAINT; Schema: topology; Owner: w4
--

ALTER TABLE ONLY layer
    ADD CONSTRAINT layer_topology_id_fkey FOREIGN KEY (topology_id) REFERENCES topology(id);


--
-- Name: ftp; Type: ACL; Schema: -; Owner: w4admin
--

REVOKE ALL ON SCHEMA ftp FROM PUBLIC;
REVOKE ALL ON SCHEMA ftp FROM w4admin;
GRANT ALL ON SCHEMA ftp TO w4admin;
GRANT ALL ON SCHEMA ftp TO w4;
GRANT USAGE ON SCHEMA ftp TO proftp;


--
-- Name: public; Type: ACL; Schema: -; Owner: w4admin
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM w4admin;
GRANT ALL ON SCHEMA public TO w4admin;
GRANT ALL ON SCHEMA public TO PUBLIC;


SET search_path = ftp, pg_catalog;

--
-- Name: user; Type: ACL; Schema: ftp; Owner: w4
--

REVOKE ALL ON TABLE "user" FROM PUBLIC;
REVOKE ALL ON TABLE "user" FROM w4;
GRANT ALL ON TABLE "user" TO w4;
GRANT SELECT ON TABLE "user" TO proftp;


--
-- Name: user_salt; Type: ACL; Schema: ftp; Owner: w4
--

REVOKE ALL ON TABLE user_salt FROM PUBLIC;
REVOKE ALL ON TABLE user_salt FROM w4;
GRANT ALL ON TABLE user_salt TO w4;
GRANT SELECT ON TABLE user_salt TO proftp;


SET search_path = public, pg_catalog;

--
-- Name: raster_overviews; Type: ACL; Schema: public; Owner: w4
--

REVOKE ALL ON TABLE raster_overviews FROM PUBLIC;
REVOKE ALL ON TABLE raster_overviews FROM w4;
GRANT ALL ON TABLE raster_overviews TO w4;
GRANT SELECT ON TABLE raster_overviews TO PUBLIC;


--
-- Name: spatial_ref_sys; Type: ACL; Schema: public; Owner: w4
--

REVOKE ALL ON TABLE spatial_ref_sys FROM PUBLIC;
REVOKE ALL ON TABLE spatial_ref_sys FROM w4;
GRANT ALL ON TABLE spatial_ref_sys TO w4;


--
-- PostgreSQL database dump complete
--

